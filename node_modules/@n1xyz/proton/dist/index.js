export * from "./client";
/** Low-level API for interacting with the bridge contract. */
export * as bridge from "./bridge";
/** Methods for interacting with the app as an app owner. */
export * as appOwner from "./owner";
import { assert } from "./assert";
/**
 * Convert a `number` to a `bigint` with the specified number of decimals,
 * scaled with the number of decimals. If there is loss of precision, the
 * fractional part will be lost.
 *
 * @param amount amount in denomination units
 * @param decimals number of decimal places
 * @returns amount in quantum units for the given decimals
 */
export function floatToScaledBigIntLossy(amount, decimals) {
    if (!Number.isFinite(amount) || Number.isNaN(amount)) {
        throw new RangeError(`amount ${amount} is not a finite number`);
    }
    if (!Number.isInteger(decimals) || decimals < 0) {
        throw new RangeError(`decimals ${decimals} is not a positive integer`);
    }
    if (Number.isInteger(amount)) {
        return BigInt(amount) * 10n ** BigInt(decimals);
    }
    const sgn = amount >= 0 ? 1n : -1n;
    const amt = Math.abs(amount).toString();
    let [mant, exp_] = amt.split("e");
    assert(mant !== undefined, `mantissa should be defined; inputs were (${amount}, ${decimals})`);
    let exp = exp_ ? parseInt(exp_) : 0;
    const dot = mant.indexOf(".");
    if (dot !== -1) {
        exp -= mant.length - dot - 1;
        mant = mant.replace(".", "");
    }
    exp += decimals;
    if (exp >= 0) {
        return sgn * BigInt(mant + "0".repeat(exp));
    }
    else {
        if (mant.length <= -exp) {
            return sgn * BigInt(0);
        }
        else {
            return sgn * BigInt(mant.slice(0, mant.length + exp));
        }
    }
}
