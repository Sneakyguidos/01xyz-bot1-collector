import { BN } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { createAssociatedTokenAccountIdempotentInstructionWithDerivation } from "@solana/spl-token";
import { createAnchorProgram } from "./bridge";
import { bridge } from ".";
import { assertHasOwn, assertInstanceOf } from "./assert";
// Anchor doesn't generate code for unit structs. We validate it manually.
function commitmentToHex(x) {
    assertInstanceOf(x, Object);
    assertHasOwn(x, "0");
    assertInstanceOf(x["0"], (Array));
    return Buffer.from(x["0"]).toString("hex");
}
/** Fetch the app account, possibly unapproved.
 *
 * The difference with this function is that it supports fetching
 * an app that has not been approved yet. See the `status` field of
 * the return value.
 *
 */
export async function fetchApp({ app, conn, }) {
    const accInfo = await conn.getAccountInfo(app);
    if (accInfo === null)
        return null;
    if (accInfo.data.length < 8)
        throw new Error("account data too small, no discriminator");
    const discriminator = accInfo.data.subarray(0, 8);
    if (bridge.discriminator("appConfig").equals(discriminator)) {
        const appConfig = bridge.decode("appConfig", accInfo.data);
        assertHasOwn(appConfig, "initialAppStateCommitment");
        return {
            status: "unapproved",
            value: {
                ...appConfig,
                initialAppStateCommitment: commitmentToHex(appConfig.initialAppStateCommitment),
            },
        };
    }
    if (bridge.discriminator("app").equals(discriminator)) {
        const app = bridge.decode("app", accInfo.data);
        assertHasOwn(app, "allowedAppVersions");
        assertHasOwn(app, "finaStateFactsPrevCmtmt");
        assertHasOwn(app, "finaStateFacts");
        return {
            status: "approved", //.
            value: {
                ...app,
                allowedAppVersions: app.allowedAppVersions.map(commitmentToHex),
                finaStateFactsPrevCmtmt: commitmentToHex(app.finaStateFactsPrevCmtmt),
            },
        };
    }
    throw new Error(`unknown account discriminator: ${discriminator.toHex()}`);
}
/** Approve the creation of a new app on the bridge.
 *
 * @param app - The app account to create
 * @param appOwner - The owner of the app
 * @param programId - The program ID of the bridge
 * @returns An instruction that approves the creation of an app; must be signed by the app owner
 */
export async function appCreateApproveIx({ programId, app, appOwner, }) {
    return createAnchorProgram(programId, {})
        .methods.appCreateApprove()
        .accounts({
        app,
        appOwner,
        program: programId,
    })
        .instruction();
}
/**
 * Whitelist a new mint for use with the app and configure its limits.
 *
 * This function returns two instructions in order to also create the token account for
 * storing tokens of the mint in the bridge contract's escrow.
 *
 * @param programId - The bridge program ID
 * @param app - The app account to update
 * @param appOwner - The owner of the app; must sign the transaction
 * @param payer - The account paying rent for the newly created PDAs; must sign the transaction
 * @param mint - The mint being whitelisted
 * @param minDeposit - The minimum deposit amount in token quanta
 * @param limiterConfig - The withdrawal limiter configuration for the mint
 * @returns An instruction that whitelists the mint; must be signed by the app owner
 */
export async function whitelistAssetIx({ programId, app, appOwner, payer, mint, quantMinDeposit, limiterConfig: { quantMaxBurst, quantRatePerSlot }, }) {
    const [tokenAuthority, _] = PublicKey.findProgramAddressSync([bridge.TOKEN_AUTHORITY_SEED, app.toBuffer()], programId);
    return [
        await createAnchorProgram(programId, {})
            .methods.whitelistAsset(new BN(quantMinDeposit.toString(16), 16), {
            maxBurst: new BN(quantMaxBurst.toString(16), 16),
            ratePerSlot: new BN(quantRatePerSlot.toString(16), 16),
        })
            .accounts({
            payer,
            app,
            appOwner,
            mint,
            program: programId,
        })
            .instruction(),
        createAssociatedTokenAccountIdempotentInstructionWithDerivation(appOwner, tokenAuthority, mint, true),
    ];
}
/**
 * Allow a specific application version for an app instance.
 *
 * Used to add a new version of the app in preparation for an upgrade. Once
 * the upgrade is done and a proposal with the new version is created, use
 * `denyAppVersionIx` to remove the old version.
 *
 * @param programId - The bridge program ID
 * @param app - The app account to update
 * @param appOwner - The owner of the app; must sign the transaction
 * @param appVersion - The 32-byte identifier of the app version
 * @returns An instruction that updates the version allowlist; must be signed by the app owner
 */
export async function allowAppVersionIx(x) {
    return await allowAppVersionIx_({ ...x, allow: true });
}
/**
 * Deny a specific application version for an app instance.
 *
 * Used after an app upgrade is done to remove the old version.
 *
 * @param programId - The bridge program ID
 * @param app - The app account to update
 * @param appOwner - The owner of the app; must sign the transaction
 * @param appVersion - The 32-byte identifier of the app version
 * @returns An instruction that updates the version allowlist; must be signed by the app owner
 */
export async function denyAppVersionIx(x) {
    return await allowAppVersionIx_({ ...x, allow: false });
}
async function allowAppVersionIx_({ programId, app, appOwner, appVersion, allow, }) {
    if (appVersion.length !== 32) {
        throw new RangeError(`appVersion must have exactly 32 bytes; received ${appVersion.length}`);
    }
    return createAnchorProgram(programId, {})
        .methods.allowAppVersion(Array.from(appVersion), allow)
        .accounts({
        app,
        appOwner,
        program: programId,
    })
        .instruction();
}
/**
 * Update the minimum deposit amount for a given mint.
 *
 * @param programId - The bridge program ID
 * @param app - The app account to update
 * @param appOwner - The owner of the app; must sign the transaction
 * @param mint - The mint whose deposit requirements are being updated
 * @param minDeposit - The new minimum deposit in token quanta
 * @returns An instruction that updates the minimum deposit; must be signed by the app owner
 */
export async function setMinDepositIx({ programId, app, appOwner, mint, quantMinDeposit, }) {
    return createAnchorProgram(programId, {})
        .methods.setMinDeposit(new BN(quantMinDeposit.toString(16), 16))
        .accounts({
        app,
        appOwner,
        mint,
        program: programId,
    })
        .instruction();
}
/**
 * Configure the withdrawal rate limiter for a given mint.
 *
 * @param programId - The bridge program ID
 * @param app - The app account to update
 * @param appOwner - The owner of the app; must sign the transaction
 * @param mint - The mint whose rate limiter is being configured
 * @param quantMaxBurst - Maximum burst size of the rate limiter, in quanta
 * @param quantRatePerSlot - Maximum amount of tokens withdrawn per slot, in quanta
 * @returns An instruction that updates the withdrawal limiter; must be signed by the app owner
 */
export async function setWithdrawalRateLimitIx({ programId, app, appOwner, mint, limiterConfig: { quantMaxBurst, quantRatePerSlot }, }) {
    return createAnchorProgram(programId, {})
        .methods.setWithdrawalRateLimit({
        maxBurst: new BN(quantMaxBurst.toString(16), 16),
        ratePerSlot: new BN(quantRatePerSlot.toString(16), 16),
    })
        .accounts({
        app,
        appOwner,
        mint,
        program: programId,
    })
        .instruction();
}
