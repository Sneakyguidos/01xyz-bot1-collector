import { PublicKey, } from "@solana/web3.js";
import createClient from "openapi-fetch";
import { createAnchorProgram } from "./bridge";
import * as bridge from "./bridge";
import { assert } from "./assert";
export class ProtonClient {
    programId;
    app;
    client;
    conn;
    anchor;
    mintInfo = new Map();
    constructor({ client, config, programVk, solConn: connection, }) {
        this.client = client;
        this.app = new PublicKey(config.app);
        this.programId = programVk;
        this.conn = connection;
        this.anchor = createAnchorProgram(programVk, { connection });
    }
    static async init({ protonUrl, app, solConn, }) {
        const client = createClient({ baseUrl: protonUrl });
        let [config, appAcc, genesisHash] = await Promise.all([
            client.GET("/proton/v0/config", {}),
            solConn.getAccountInfo(app, "finalized"),
            solConn.getGenesisHash(),
        ]);
        if (!config.data) {
            throw new Error(`failed to fetch indexer info: ${config.error}`);
        }
        if (config.data.app !== app.toString()) {
            throw new Error(`app mismatch: server reports ${config.data.app}, but expected ${app.toString()}; check the url and app parameters`);
        }
        if (genesisHash !== config.data.chainGenesis) {
            throw new Error(`genesis hash mismatch: server reports ${genesisHash.toString()}, but expected ${config.data.chainGenesis.toString()}; check the chain for your rpc!`);
        }
        if (appAcc === null) {
            throw new Error(`app account ${app.toString()} not found; this is our fault, please report`);
        }
        try {
            bridge.decode("app", appAcc.data);
        }
        catch (e) {
            throw new Error(`failed to decode app account at ${app}: ${e}; ensure your versions match up`);
        }
        const proton = new ProtonClient({
            config: config.data,
            client,
            programVk: appAcc.owner,
            solConn,
        });
        for (const mint of config.data.mints) {
            proton.mintInfo.set(mint.mint, {
                minDeposit: BigInt(mint.minDeposit),
                tokenProgramId: new PublicKey(mint.tokenProgram),
                withdrawalRateLimit: {
                    ratePerSlot: BigInt(mint.withdrawalRateLimit.ratePerSlot),
                    maxBurst: BigInt(mint.withdrawalRateLimit.maxBurst),
                },
            });
        }
        return proton;
    }
    async config() {
        const response = await this.client.GET("/proton/v0/config", {});
        return response.data;
    }
    async blocksByRange({ start, end }) {
        const response = await this.client.GET("/proton/v0/blocks/by-range", {
            params: {
                query: {
                    start,
                    end,
                },
            },
        });
        return response.data;
    }
    async blocksByActionId(actionId) {
        const response = await this.client.GET("/proton/v0/blocks/by-action-id/{action_id}", {
            params: {
                path: {
                    action_id: actionId,
                },
            },
        });
        return response.data;
    }
    async withdrawalsForUser(pubkey, params) {
        const response = await this.client.GET("/proton/v0/withdrawals/by-user/{pubkey}", {
            params: {
                path: {
                    pubkey: pubkey.toString(),
                },
                query: {
                    order: "desc",
                    status: "all",
                    ...params,
                },
            },
        });
        return response.data;
    }
    async withdrawalForActionId(actionId) {
        const response = await this.client.GET("/proton/v0/withdrawals/by-action-id/{action_id}", {
            params: {
                path: {
                    action_id: actionId,
                },
            },
        });
        return response.data;
    }
    async depositsForRecipient(recipient, { 
    // slot to use for pagination as a starting point.
    // currently the deposits are returned in descending order by slot.
    startSlot, order, }) {
        const response = await this.client.GET("/proton/v0/deposits/by-recipient/{pubkey}", {
            params: {
                path: {
                    pubkey: recipient.toString(),
                },
                query: {
                    order,
                    status: "all",
                    slot: startSlot,
                },
            },
        });
        return response.data;
    }
    async fetchApp() {
        const data = await this.anchor.account.app.fetchNullable(this.app);
        assert(data !== null, `app account ${this.app} is null`);
        return data;
    }
    /** Returns the capacity of the rate limiter for the given mint.
     *
     * Returns null if the mint is not in mintInfo.
     */
    async fetchRateLimiterCapacity({ mint, }) {
        let mintInfo = this.mintInfo.get(mint.toString());
        if (mintInfo === undefined)
            return null;
        let addr = PublicKey.findProgramAddressSync([bridge.WITHDRAWAL_LIMITER_SEED, this.app.toBytes(), mint.toBytes()], this.programId)[0];
        let { data, context: { slot }, } = await this.anchor.account.tokenBucket.fetchNullableAndContext(addr);
        assert(data !== null, `rate limiter for ${mint} at ${addr} is null`);
        const { cfg: _, lastUpdate, tokens } = data;
        const maxBurst = mintInfo.withdrawalRateLimit.maxBurst;
        const totalTokens = BigInt(tokens.toString()) +
            mintInfo.withdrawalRateLimit.ratePerSlot *
                (BigInt(slot) - BigInt(lastUpdate.toString()));
        return maxBurst < totalTokens ? maxBurst : totalTokens;
    }
    /** Builds an instruction to deposit tokens.
     *
     * Make sure to sign the transaction with the `extraSigner`. This is for an intermediate account
     * created to store the deposit info on-chain.
     *
     * @param params - Parameters for the deposit
     * @param params.quantAmount - Amount to deposit in quantum units, e.g. lamports for SOL
     * @param params.sourceTokenAccount - Source token account. Must be for the `mint` token. Owner must sign.
     * @param params.recipient - Recipient of the deposit; defaults to the same public key as the wallet
     *
     * @returns Transaction instruction and extra signer
     */
    async buildDepositIx({ quantAmount, sourceTokenAccount, recipient, payer, mint, }) {
        const mintInfo = this.mintInfo.get(mint.toString());
        if (mintInfo === undefined) {
            throw new Error(`mint ${mint.toString()} not found; invalid mint`);
        }
        if (quantAmount < mintInfo.minDeposit) {
            throw new Error(`amount ${quantAmount} is less than the minimum deposit of ${mintInfo.minDeposit} for mint ${mint.toString()}`);
        }
        return await bridge.depositIx({
            programId: this.programId,
            app: this.app,
            payer,
            sourceTokenAccount,
            quantAmount,
            recipient,
            mint,
            tokenProgramId: mintInfo.tokenProgramId,
        });
    }
}
