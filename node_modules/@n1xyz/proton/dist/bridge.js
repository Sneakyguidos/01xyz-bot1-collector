import { PublicKey, Keypair } from "@solana/web3.js";
import { Program, BN } from "@coral-xyz/anchor";
import BRIDGE_IDL from "./generated/bridge-idl.json";
import { getAssociatedTokenAddressSync } from "@solana/spl-token";
import { BorshAccountsCoder } from "@coral-xyz/anchor";
import { assert } from "./assert";
// anchor-lang canonically exports an `idl.json` file and a corresponding `idl.ts`
// file. however, the `idl.json` file is in Rust-style snake_case and PascalCase,
// while the `idl.ts`, presumably to honour typescript conventions, is in camelCase.
// to deal with this discrepancy, what anchor suggests is to fucking _cast_ the type[0]:
//
// ```
// import idl from "./idl.json";
// import type { Idl } from "./idlType";
// export const program = new Program(idl as Idl, { ...});
// ```
//
// of course, this wouldn't really work, so what they do is they internally
// convert the idl to camelCase[1]
//
// the issue we're dealing with is that we need a way to decode an accountinfo
// directly, knowing the type of the account. this requries us to also know the
// discriminator of the account so we can have proper control flow on it. however,
// anchor only provides this api from the non-camelCase idl, so we end up actually
// bypassing the layer where the conversion happens.
//
// the purpose of these tests is to ensure that passing in `"appConfig"` as the
// account name does not break our shit.
//
// note: i am slightly worried that this breaks cjs, but if you are still
// somehow using cjs you deserve to have your shit broken.
//
// [0]: https://www.anchor-lang.com/docs/clients/typescript
// [1]: https://github.com/solana-foundation/anchor/blob/292b095f91eb2888a0dd034d408395a9379ed5c4/ts/packages/anchor/src/program/index.ts#L290
import { convertIdlToCamelCase } from "@coral-xyz/anchor/dist/esm/idl";
import { Buffer } from "buffer";
export const GLOBAL_SEED = Buffer.from("global");
export const EVENT_SEED = Buffer.from("queued_event");
export const CHILD_BLOCKS_STORAGE_SEED = Buffer.from("child_blocks");
export const EFFECT_NULLIFIER_SEED = Buffer.from("effect_nullifier");
export const CHALLENGE_NULLIFIER_SEED = Buffer.from("challenge_nullifier");
export const ASSET_CONFIG_SEED = Buffer.from("asset_config");
export const TOKEN_AUTHORITY_SEED = Buffer.from("token_authority");
export const CRUMB_AUTHORITY_SEED = Buffer.from("crumb_authority");
export const WITHDRAWAL_LIMITER_SEED = Buffer.from("withdrawal_limiter");
export const ACL_SEED = Buffer.from("acl");
export function createAnchorProgram(programId, provider) {
    return new Program({ ...BRIDGE_IDL, address: programId.toString() }, provider);
}
/** The 8 byte discriminator for the given account. */
export function discriminator(name) {
    const coder = new BorshAccountsCoder(
    // HACK: see the comment above. yeah i hate myself, how did you know?
    convertIdlToCamelCase(BRIDGE_IDL));
    const disc = coder.accountDiscriminator(name);
    assert(disc.length === 8, `account discriminator ${disc.toHex} for ${name} is not 8 bytes`);
    return disc;
}
/** Decodes the given account data given the type. Checks the discriminator. */
export function decode(name, data) {
    const program = createAnchorProgram(PublicKey.default, {});
    const buffer = Buffer.from(data);
    return program.coder.accounts.decode(name, buffer);
}
export async function depositIx({ programId, app, quantAmount, recipient, payer, sourceTokenAccount, mint, tokenProgramId, }) {
    const buffer = Keypair.generate();
    const [tokenAuthority] = PublicKey.findProgramAddressSync([TOKEN_AUTHORITY_SEED, app.toBytes()], programId);
    const [assetConfig] = PublicKey.findProgramAddressSync([ASSET_CONFIG_SEED, app.toBytes(), mint.toBytes()], programId);
    const tokenAccount = getAssociatedTokenAddressSync(mint, tokenAuthority, true, tokenProgramId);
    const ix = await createAnchorProgram(programId, {})
        .methods.depositCreate(recipient, new BN(quantAmount.toString(16), 16))
        .accounts({
        payer,
        app,
        event: buffer.publicKey,
        fromAccount: sourceTokenAccount,
        program: programId,
        tokenProgram: tokenProgramId,
        // HACK: resolving 'fromAccount.mint' (obviously) doesn't work.
        //       we override the accounts that need it. this can be "fixed"
        //       by adding a `mint` field to the instruction, albeit that
        //       requires 32 extra bytes in the transaction.
        ...{
            assetConfig,
            tokenAccount,
        },
    })
        .instruction();
    return { ix, extraSigner: buffer };
}
