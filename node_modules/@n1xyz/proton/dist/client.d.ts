import { PublicKey, Connection, Keypair, TransactionInstruction } from "@solana/web3.js";
import type { components } from "./generated/hansel-openapi.ts";
export declare class ProtonClient {
    readonly programId: PublicKey;
    readonly app: PublicKey;
    private client;
    private conn;
    private anchor;
    private mintInfo;
    private constructor();
    static init({ protonUrl, app, solConn, }: Readonly<{
        protonUrl: string;
        app: PublicKey;
        solConn: Connection;
    }>): Promise<ProtonClient>;
    config(): Promise<{
        maxBlocksByRange: number;
        maxBlocksUncranked: number;
        maxWithdrawalsByUser: number;
        maxDepositsUnqueued: number;
        maxDepositsByRecipientSlots: number;
        maxPrunableBlocks: number;
        chainGenesis: string;
        app: string;
        mints: components["schemas"]["Mint"][];
    } | undefined>;
    blocksByRange({ start, end }: {
        start: number;
        end: number;
    }): Promise<{
        blockId: number;
        proposer: string;
        blockFacts: components["schemas"]["BlockFacts"];
        effectsExecutedCount: number;
        proposedSlot: number;
        finalizedSlot?: number | null;
        proposedAt: string;
        finalizedAt: string;
    }[] | undefined>;
    blocksByActionId(actionId: number): Promise<{
        blockId: number;
        proposer: string;
        blockFacts: components["schemas"]["BlockFacts"];
        effectsExecutedCount: number;
        proposedSlot: number;
        finalizedSlot?: number | null;
        proposedAt: string;
        finalizedAt: string;
    }[] | undefined>;
    withdrawalsForUser(pubkey: PublicKey, params?: {
        order?: "desc";
        status?: "all";
        blockId?: number;
        leafIndex?: number;
    }): Promise<{
        blockId: number;
        leafIndex: number;
        mint: string;
        amount: number;
        wallet: string;
        fulfillmentInfo?: components["schemas"]["WithdrawalFulfillment"] | null;
    }[] | undefined>;
    withdrawalForActionId(actionId: number): Promise<import("openapi-typescript-helpers").SuccessResponse<{
        200: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Withdrawal"] | null;
            };
        };
        400: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ClientError_for_GenericErrorKind"];
            };
        };
    }, `${string}/${string}`> | undefined>;
    depositsForRecipient(recipient: PublicKey, { startSlot, order, }: Readonly<{
        startSlot: number | null;
        order: "desc";
    }>): Promise<{
        eventIndex?: number | null;
        createdAtSlot: number;
        amount: number;
        depositorTokenAccount: string;
        bufferAccount: string;
        recipient: string;
        mint: string;
    }[] | undefined>;
    fetchApp(): Promise<{
        owner: PublicKey;
        frozen: boolean;
        operator: PublicKey;
        challengeConsensusThreshold: number;
        challengePeriodSlots: BN;
        lastBlockId: BN;
        lastEventIndex: BN;
        finaStateFactsPrevCmtmt: any;
        finaStateFacts: any;
        targetFinaStateFacts: any;
        blockLifetime: BN;
        allowedAppVersions: any[];
    }>;
    /** Returns the capacity of the rate limiter for the given mint.
     *
     * Returns null if the mint is not in mintInfo.
     */
    fetchRateLimiterCapacity({ mint, }: {
        mint: PublicKey;
    }): Promise<bigint | null>;
    /** Builds an instruction to deposit tokens.
     *
     * Make sure to sign the transaction with the `extraSigner`. This is for an intermediate account
     * created to store the deposit info on-chain.
     *
     * @param params - Parameters for the deposit
     * @param params.quantAmount - Amount to deposit in quantum units, e.g. lamports for SOL
     * @param params.sourceTokenAccount - Source token account. Must be for the `mint` token. Owner must sign.
     * @param params.recipient - Recipient of the deposit; defaults to the same public key as the wallet
     *
     * @returns Transaction instruction and extra signer
     */
    buildDepositIx({ quantAmount, sourceTokenAccount, recipient, payer, mint, }: Readonly<{
        payer: PublicKey;
        quantAmount: bigint;
        mint: PublicKey;
        sourceTokenAccount: PublicKey;
        recipient: PublicKey;
    }>): Promise<{
        ix: TransactionInstruction;
        extraSigner: Keypair;
    }>;
}
