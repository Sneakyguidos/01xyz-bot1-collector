import { Keypair } from "@solana/web3.js";
import { discriminator, depositIx } from "./bridge";
import { expect, test } from "bun:test";
// test to ensure that our shitty hack works as intended.
test("discriminator", () => {
    expect(() => discriminator("----invalid--type----")).toThrow();
    expect(() => discriminator("app")).toBeTruthy();
    expect(() => discriminator("appConfig")).toBeTruthy();
    expect(() => discriminator("queuedEvent")).toBeTruthy();
    expect(() => discriminator("permissionSet")).toBeTruthy();
    expect(() => discriminator("App")).toThrow();
    expect(() => discriminator("AppConfig")).toThrow();
    expect(() => discriminator("QueuedEvent")).toThrow();
    expect(() => discriminator("PermissionSet")).toThrow();
});
test("depositIx", async () => {
    // test that this function does not throw. when a given signer is not provided,
    // the anchor program assumes that it must be the provider's wallet. in our
    // case, the buffer account is the signer, so this function was throwing. just
    // regression testing that case.
    const ix = await depositIx({
        programId: Keypair.generate().publicKey,
        app: Keypair.generate().publicKey,
        payer: Keypair.generate().publicKey,
        sourceTokenAccount: Keypair.generate().publicKey,
        quantAmount: 10000n,
        recipient: Keypair.generate().publicKey,
        mint: Keypair.generate().publicKey,
        tokenProgramId: Keypair.generate().publicKey,
    });
    expect(ix).toBeObject();
});
