import * as proto from "./gen/nord_pb";
import type { components } from "./gen/openapi.ts";
import Decimal from "decimal.js";
import { Connection } from "@solana/web3.js";
/**
 * Nord subscription type for trades or deltas
 */
export type SubscriptionType = "trades" | "deltas" | "account" | "candle";
/**
 * Pattern for a valid Nord subscription
 * Format should be: "<type>@<parameter>"
 * Examples: "trades@BTCUSDC", "deltas@ETHUSDC", "account@42"
 */
export type SubscriptionPattern = `${SubscriptionType}@${string}` | string;
/**
 * Configuration options for the Nord client
 */
export interface NordConfig {
    /** Base URL for the Nord web server */
    webServerUrl: string;
    /** App address */
    app: string;
    /** Solana connection */
    solanaConnection: Connection;
    /** Proton URL, defaults to webServerUrl */
    protonUrl?: string;
    /**
     * Whether to initialize WebSockets on creation, defaults to true
     * @deprecated this is a funky api we're gonna be removing it
     */
    initWebSockets?: boolean;
}
export type MarketsInfo = components["schemas"]["MarketsInfo"];
export type Market = MarketsInfo["markets"][number];
export type Token = MarketsInfo["tokens"][number];
export type Account = components["schemas"]["Account"];
export type TradesResponse = components["schemas"]["PageResult_for_uint64_and_Trade"];
export type User = components["schemas"]["User"];
export type OrderbookResponse = components["schemas"]["OrderbookInfo"];
export type MarketStats = components["schemas"]["MarketStats"];
export type OrderbookInfo = components["schemas"]["OrderbookInfo"];
export type MarketStatsFromApi = components["schemas"]["MarketStats"];
export type TradeFromApi = components["schemas"]["Trade"];
export type PageResult<K extends string, V extends string> = K extends "String" ? V extends "OrderInfo" ? components["schemas"]["PageResult_for_uint64_and_OrderInfo"] : V extends "Trade" ? components["schemas"]["PageResult_for_uint64_and_Trade"] : never : never;
export type PageResultStringOrderInfo = components["schemas"]["PageResult_for_uint64_and_OrderInfo"];
export type PageResultStringTrade = components["schemas"]["PageResult_for_uint64_and_Trade"];
export type OrderInfoFromApi = components["schemas"]["OrderInfo"];
export type OpenOrder = components["schemas"]["OpenOrder"];
export type Balance = components["schemas"]["Balance"];
export type PositionSummary = components["schemas"]["PositionSummary"];
export type PerpPosition = components["schemas"]["PerpPosition"];
export type AccountMarginsView = components["schemas"]["AccountMarginsView"];
export type SideSummary = components["schemas"]["SideSummary"];
export type UserSession = components["schemas"]["UserSession"];
export type ActionsItem = components["schemas"]["ActionsItem"];
export type FillRole = components["schemas"]["FillRole"];
export type PerpMarketStatsFromApi = components["schemas"]["PerpMarketStats"];
export type SideFromApi = components["schemas"]["Side"];
export type FillModeFromApi = components["schemas"]["FillMode"];
export type PlacementOrigin = components["schemas"]["PlacementOrigin"];
export type FinalizationReason = components["schemas"]["FinalizationReason"];
export type PagedQuery = components["schemas"]["PagedQuery"];
export type AccountPnlInfo = components["schemas"]["AccountPnlInfo"];
export type AccountPnlInfoPage = components["schemas"]["PageResult_for_uint64_and_AccountPnlInfo"];
export type AccountTriggerInfo = components["schemas"]["TriggerInfo"];
export type TriggerHistoryPage = components["schemas"]["PageResult_for_uint64_and_Trigger"];
export type WithdrawalHistoryPage = components["schemas"]["PageResult_for_uint64_and_WithdrawalInfo"];
export type FeeTierConfig = components["schemas"]["FeeTierConfig"];
export type FeeTierId = components["schemas"]["FeeTierId"];
export type TokenStats = components["schemas"]["TokenStats"];
export type AccountFeeTier = components["schemas"]["AccountFeeTier"];
export type AccountFeeTierPage = components["schemas"]["PageResult_for_uint32_and_AccountFeeTier"];
export type AdminInfo = components["schemas"]["AdminInfo"];
export type GetAccountVolumeQuery = components["schemas"]["GetAccountVolumeQuery"];
export type AccountVolumeInfo = components["schemas"]["AccountVolumeInfo"];
export type WithdrawalInfo = components["schemas"]["WithdrawalInfo"];
/**
 * Configuration options for the Nord client
 */
export interface TokenInfo {
    address: string;
    precision: number;
    tokenId: number;
    name: string;
}
export interface Order {
    orderId: number;
    isLong: boolean;
    size: number;
    price: number;
    marketId: number;
}
export declare enum Side {
    Ask = "ask",
    Bid = "bid"
}
export declare enum FillMode {
    Limit = 0,
    PostOnly = 1,
    ImmediateOrCancel = 2,
    FillOrKill = 3
}
export declare enum TriggerKind {
    StopLoss = 0,
    TakeProfit = 1
}
export declare enum TriggerStatus {
    Active = 0,
    Success = 1,
    Cancel = 2,
    Remove = 4
}
export interface SubscriberConfig {
    streamURL: string;
    maxBufferLen?: number;
}
export interface DeltaEvent {
    last_update_id: number;
    update_id: number;
    market_symbol: string;
    asks: OrderbookEntry[];
    bids: OrderbookEntry[];
}
export interface StreamTrade {
    side: Side;
    price: number;
    size: number;
    order_id: string;
}
export interface Trades {
    last_update_id: number;
    update_id: number;
    market_symbol: string;
    trades: StreamTrade[];
}
export interface LocalOrderInfo {
    id: number;
    reduce_only: boolean;
    limit_price: number;
    size: number;
    account_id: number;
    sender_tracking_id?: number;
}
export interface HashMap<T> {
    [key: number]: T;
}
export interface ActionResponse {
    actionId: number;
    action: proto.Action;
    physicalExecTime: Date;
}
/**
 * Converts a `FillMode` enum to its corresponding protobuf representation.
 *
 * @param x - The fill mode to convert.
 * @returns The corresponding protobuf fill mode.
 * @throws Will throw an error if provided with an invalid fill mode.
 */
export declare function fillModeToProtoFillMode(x: FillMode): proto.FillMode;
/**
 * Orderbook entry representing price and size
 */
export interface OrderbookEntry {
    price: number;
    size: number;
}
/**
 * Query parameters for orderbook
 *
 * Note: While you can provide either symbol or market_id, the API endpoint only accepts market_id.
 * If you provide a symbol, it will be converted to a market_id internally.
 */
export interface OrderbookQuery {
    symbol?: string;
    marketId?: number;
}
/**
 * Response for timestamp query
 */
export interface TimestampResponse {
    timestamp: number;
}
/**
 * Response for action nonce query
 */
export interface ActionNonceResponse {
    nonce: number;
}
/**
 * WebSocket message types
 */
export declare enum WebSocketMessageType {
    TradeUpdate = "trades",
    DeltaUpdate = "delta",
    AccountUpdate = "account"
}
export type CandleResolution = "1" | "5" | "15" | "30" | "60" | "1D" | "1W" | "1M";
/**
 * WebSocket trade update message
 */
export type WebSocketTradeUpdate = Trades;
/**
 * WebSocket delta update message
 */
export interface WebSocketDeltaUpdate {
    e: WebSocketMessageType.DeltaUpdate;
    last_update_id: number;
    update_id: number;
    market_symbol: string;
    asks: OrderbookEntry[];
    bids: OrderbookEntry[];
    timestamp: number;
}
export type OrderId = string;
export interface WebSocketAccountUpdate {
    last_update_id: number;
    update_id: number;
    account_id: number;
    fills: Record<OrderId, {
        side: "bid" | "ask";
        quantity: number;
        remaining: number;
        price: number;
        order_id: string;
        market_id: number;
        maker_id: number;
        taker_id: number;
        sender_tracking_id: number | null;
    }>;
    places: Record<OrderId, {
        side: "bid" | "ask";
        current_size: number;
        price: number;
        market_id: number;
    }>;
    cancels: Record<OrderId, {
        side: "bid" | "ask";
        current_size: number;
        price: number;
        market_id: number;
    }>;
    balances: Record<string, number>;
}
export interface WebSocketCandleUpdate {
    res: CandleResolution;
    mid: number;
    t: number;
    o: number;
    h: number;
    l: number;
    c: number;
    v: number;
}
export type WebSocketMessage = {
    trades: WebSocketTradeUpdate;
} | {
    delta: WebSocketDeltaUpdate;
} | {
    account: WebSocketAccountUpdate;
} | WebSocketCandleUpdate;
export interface SPLTokenInfo {
    mint: string;
    precision: number;
    tokenId: number;
    name: string;
}
export declare class QuoteSize {
    price: Decimal;
    size: Decimal;
    constructor(quotePrice: Decimal.Value, quoteSize: Decimal.Value);
    value(): Decimal;
    toWire(marketPriceDecimals: number, marketSizeDecimals: number): {
        price: bigint;
        size: bigint;
    };
}
