import { PublicKey, Transaction, SendOptions } from "@solana/web3.js";
import Decimal from "decimal.js";
import { FillMode, Side, SPLTokenInfo, QuoteSize, TriggerKind } from "../types";
import * as proto from "../gen/nord_pb";
import { BigIntValue } from "../utils";
import { Nord } from "./Nord";
/**
 * Parameters for individual atomic subactions (user-friendly version)
 */
export interface UserAtomicSubaction {
    /** The type of action to perform. */
    kind: "place" | "cancel";
    /** The market ID to place the order in. */
    marketId?: number;
    /** The order ID to cancel. */
    orderId?: BigIntValue;
    /** Order side (bid or ask) */
    side?: Side;
    /** Fill mode (limit, market, etc.) */
    fillMode?: FillMode;
    /** Whether the order is reduce-only. */
    isReduceOnly?: boolean;
    /** The size of the order. */
    size?: Decimal.Value;
    /** Order price */
    price?: Decimal.Value;
    /** Quote size object (for market-style placement) */
    quoteSize?: QuoteSize;
    /** The client order ID of the order. */
    clientOrderId?: BigIntValue;
}
/**
 * User class for interacting with the Nord protocol
 */
export declare class NordUser {
    private readonly signSessionMessage;
    private readonly signMessage;
    private readonly signTransaction;
    /** If set, will use signTransaction instead of signMessage for session creation.
     * Because ledgers don't support signMessage, we have an escape hatch for them.
     * However, the escape hatch is brittle and we recommend avoiditing as much as
     * possible. Thus, _only_ use this if you are forced to use ledgers.
     * To use this, just set it to true in your NordUser instance.
     */
    __use_solana_transaction_framing__: boolean;
    readonly nord: Nord;
    sessionId?: bigint;
    sessionPubKey: PublicKey;
    publicKey: PublicKey;
    lastTs: number;
    private nonce;
    /** User balances by token symbol */
    balances: {
        [key: string]: {
            accountId: number;
            balance: number;
            symbol: string;
        }[];
    };
    orders: {
        [key: string]: {
            orderId: number;
            marketId: number;
            side: "ask" | "bid";
            size: number;
            price: number;
            originalOrderSize: number;
            clientOrderId: number | null;
        }[];
    };
    /** User positions by account ID */
    positions: {
        [key: string]: {
            marketId: number;
            openOrders: number;
            perp?: {
                baseSize: number;
                price: number;
                updatedFundingRateIndex: number;
                fundingPaymentPnl: number;
                sizePricePnl: number;
                isLong: boolean;
            };
            actionId: number;
        }[];
    };
    /** User margins by account ID */
    margins: {
        [key: string]: {
            omf: number;
            mf: number;
            imf: number;
            cmf: number;
            mmf: number;
            pon: number;
            pn: number;
            bankruptcy: boolean;
        };
    };
    /** User's account IDs */
    accountIds?: number[];
    /** SPL token information */
    splTokenInfos: SPLTokenInfo[];
    private constructor();
    /**
     * Create a new NordUser instance
     *
     * @param nord - Nord client instance
     * @param walletPubkey - Wallet public key
     * @param sessionPubKey - Session public key
     * @param sessionId - Existing session identifier, if known. Otherwise, pass nothing and call `refreshSession` to fetch a new session.
     * @param signMessageFn - Function to sign the given UTF-8 string with the user's wallet. Typically just your wallet's `signMessage` method.
     * @param signTransactionFn - Function to sign transactions with the user's wallet. Typically just your wallet's `signTransaction` method.
     * @param signSessionFn - Function to sign messages with the provided `sessionPubKey`
     * @throws {NordError} If required parameters are missing
     */
    static new({ nord, walletPubkey, sessionPubkey, sessionId, signMessageFn, signTransactionFn, signSessionFn, }: Readonly<{
        nord: Nord;
        signSessionFn: (rawMessage: Uint8Array) => Promise<Uint8Array>;
        signMessageFn: (utf8Message: Uint8Array) => Promise<Uint8Array>;
        signTransactionFn: (tx: Transaction) => Promise<Transaction>;
        sessionId?: bigint;
        sessionPubkey: Uint8Array;
        walletPubkey: PublicKey;
    }>): Promise<NordUser>;
    /**
     * Create a NordUser from a private key
     *
     * @param nord - Nord instance
     * @param privateKey - Private key as string or Uint8Array
     * @returns NordUser instance
     * @throws {NordError} If the private key is invalid
     */
    static fromPrivateKey(nord: Nord, privateKey: string | Uint8Array): NordUser;
    /**
     * Get the associated token account for a token mint
     *
     * @param mint - Token mint address
     * @returns Associated token account address
     * @throws {NordError} If required parameters are missing or operation fails
     */
    getAssociatedTokenAccount(mint: PublicKey): Promise<PublicKey>;
    /**
     * Deposit SPL tokens to the app
     *
     * @param amount - Amount to deposit
     * @param tokenId - Token ID
     * @param recipient - Recipient address; defaults to the user's address
     * @returns Transaction signature
     * @deprecated Use deposit instead
     * @throws {NordError} If required parameters are missing or operation fails
     */
    depositSpl(amount: number, tokenId: number, recipient?: PublicKey): Promise<string>;
    /**
     * Deposit SPL tokens to the app
     *
     * @param amount - Amount to deposit
     * @param tokenId - Token ID
     * @param recipient - Recipient address; defaults to the user's address
     * @param sendOptions - Send options for .sendTransaction
     * @returns Transaction signature and buffer account
     * @throws {NordError} If required parameters are missing or operation fails
     *
     * The buffer account is used to correlate the deposit for when it gets queued.
     * Note that even though there may technically be multiple deposits with the same
     * buffer account, in the case of this method, there will only be one as it discards
     * the buffer after performing the deposit.
     */
    deposit({ amount, tokenId, recipient, sendOptions, }: Readonly<{
        amount: number;
        tokenId: number;
        recipient?: PublicKey;
        sendOptions?: SendOptions;
    }>): Promise<{
        signature: string;
        buffer: PublicKey;
    }>;
    /**
     * Get a new nonce for actions
     *
     * @returns Nonce as number
     */
    getNonce(): number;
    private submitSessionAction;
    /**
     * Update account IDs for this user
     *
     * @throws {NordError} If the operation fails
     */
    updateAccountId(): Promise<void>;
    /**
     * Fetch user information including balances and orders
     *
     * @throws {NordError} If the operation fails
     */
    fetchInfo(): Promise<void>;
    /**
     * Refresh the user's session
     *
     * @throws {NordError} If the operation fails
     */
    refreshSession(): Promise<void>;
    /**
     * Revoke a session
     *
     * @param sessionId - Session ID to revoke
     * @throws {NordError} If the operation fails
     */
    revokeSession(sessionId: BigIntValue): Promise<void>;
    /**
     * Checks if the session is valid
     * @private
     * @throws {NordError} If the session is not valid
     */
    private checkSessionValidity;
    /**
     * Withdraw tokens from the exchange
     *
     * @param tokenId - Token ID to withdraw
     * @param amount - Amount to withdraw
     * @param destPubkey - Optional destination registration pubkey (base58); defaults to session owner
     * @throws {NordError} If the operation fails
     */
    withdraw({ amount, tokenId, destPubkey, }: Readonly<{
        tokenId: number;
        amount: number;
        destPubkey?: string;
    }>): Promise<{
        actionId: bigint;
    }>;
    /**
     * Place an order on the exchange
     *
     * @param marketId - Target market identifier
     * @param side - Order side
     * @param fillMode - Fill mode (limit, market, etc.)
     * @param isReduceOnly - Reduce-only flag
     * @param size - Base size to place
     * @param price - Limit price
     * @param quoteSize - Quote-sized order representation
     * @param accountId - Account executing the order
     * @param clientOrderId - Optional client-specified identifier
     * @returns Object containing actionId, orderId (if posted), fills, and clientOrderId
     * @throws {NordError} If the operation fails
     */
    placeOrder({ marketId, side, fillMode, isReduceOnly, size, price, quoteSize, accountId, clientOrderId, }: Readonly<{
        marketId: number;
        side: Side;
        fillMode: FillMode;
        isReduceOnly: boolean;
        size?: Decimal.Value;
        price?: Decimal.Value;
        quoteSize?: QuoteSize;
        accountId?: number;
        clientOrderId?: BigIntValue;
    }>): Promise<{
        actionId: bigint;
        orderId?: bigint;
        fills: proto.Receipt_Trade[];
    }>;
    /**
     * Cancel an order
     *
     * @param orderId - Order ID to cancel
     * @param providedAccountId - Account ID that placed the order
     * @returns Object containing actionId, cancelled orderId, and accountId
     * @throws {NordError} If the operation fails
     */
    cancelOrder(orderId: BigIntValue, accountId?: number): Promise<{
        actionId: bigint;
        orderId: bigint;
        accountId: number;
    }>;
    /**
     * Cancel an order by client_order_id.
     *
     * @param clientOrderId - Client order ID to cancel
     * @param providedAccountId - Account ID that placed the order (defaults to the first account)
     * @returns Object containing actionId, cancelled orderId, and accountId
     * @throws {NordError} If the operation fails
     */
    cancelOrderByClientId(clientOrderId: BigIntValue, accountId?: number): Promise<{
        actionId: bigint;
        orderId: bigint;
        accountId: number;
    }>;
    /**
     * Add a trigger for the current session
     *
     * @param marketId - Market to watch
     * @param side - Order side for the trigger
     * @param kind - Stop-loss or take-profit trigger type
     * @param triggerPrice - Price that activates the trigger
     * @param limitPrice - Limit price placed once the trigger fires
     * @param accountId - Account executing the trigger
     * @returns Object containing the actionId of the submitted trigger
     * @throws {NordError} If the operation fails
     *
     * NOTE: You can upsert a trigger by providing the same trigger data
     * with specifically identifiaction by (marketId, accountId,side,kind).
     */
    addTrigger({ marketId, side, kind, triggerPrice, limitPrice, accountId, }: Readonly<{
        marketId: number;
        side: Side;
        kind: TriggerKind;
        triggerPrice: Decimal.Value;
        limitPrice?: Decimal.Value;
        accountId?: number;
    }>): Promise<{
        actionId: bigint;
    }>;
    /**
     * Remove a trigger for the current session
     *
     * @param marketId - Market the trigger belongs to
     * @param side - Order side for the trigger
     * @param kind - Stop-loss or take-profit trigger type
     * @param accountId - Account executing the trigger
     * @returns Object containing the actionId of the removal action
     * @throws {NordError} If the operation fails
     */
    removeTrigger({ marketId, side, kind, accountId, }: Readonly<{
        marketId: number;
        side: Side;
        kind: TriggerKind;
        accountId?: number;
    }>): Promise<{
        actionId: bigint;
    }>;
    /**
     * Transfer tokens to another account
     *
     * @param tokenId - Token identifier to move
     * @param amount - Amount to transfer
     * @param fromAccountId - Source account id
     * @param toAccountId - Destination account id
     * @throws {NordError} If the operation fails
     */
    transferToAccount({ tokenId, amount, fromAccountId, toAccountId, }: Readonly<{
        tokenId: number;
        amount: Decimal.Value;
        fromAccountId?: number;
        toAccountId?: number;
    }>): Promise<{
        actionId: bigint;
        newAccountId?: number;
    }>;
    /**
     * Execute up to four place/cancel operations atomically.
     * Per Market:
     * 1. cancels can only be in the start (one cannot predict future order ids)
     * 2. intermediate trades can trade only
     * 3. placements go last
     *
     * Across Markets, order action can be any
     *
     * @param userActions array of user-friendly subactions
     * @param providedAccountId optional account performing the action (defaults to first account)
     */
    atomic(userActions: UserAtomicSubaction[], providedAccountId?: number): Promise<{
        actionId: bigint;
        results: proto.Receipt_AtomicSubactionResultKind[];
    }>;
    /**
     * Helper function to retry a promise with exponential backoff
     *
     * @param fn - Function to retry
     * @param maxRetries - Maximum number of retries
     * @param initialDelay - Initial delay in milliseconds
     * @returns Promise result
     */
    private retryWithBackoff;
    /**
     * Get user's token balances on Solana chain using mintAddr
     *
     * @param options - Optional parameters
     * @param options.includeZeroBalances - Whether to include tokens with zero balance (default: true)
     * @param options.includeTokenAccounts - Whether to include token account addresses in the result (default: false)
     * @param options.maxConcurrent - Maximum number of concurrent requests (default: 5)
     * @param options.maxRetries - Maximum number of retries for rate-limited requests (default: 3)
     * @returns Object with token balances and optional token account addresses
     * @throws {NordError} If required parameters are missing or operation fails
     */
    getSolanaBalances(options?: {
        includeZeroBalances?: boolean;
        includeTokenAccounts?: boolean;
        maxConcurrent?: number;
        maxRetries?: number;
    }): Promise<{
        balances: {
            [symbol: string]: number;
        };
        tokenAccounts?: {
            [symbol: string]: string;
        };
    }>;
    protected submitSignedAction(kind: proto.Action["kind"], makeSignedMessage: (message: Uint8Array) => Promise<Uint8Array>): Promise<proto.Receipt>;
}
