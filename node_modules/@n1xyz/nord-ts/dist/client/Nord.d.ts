import { ProtonClient } from "@n1xyz/proton";
import { Connection, PublicKey } from "@solana/web3.js";
import { EventEmitter } from "events";
import { Client } from "openapi-fetch";
import type { paths } from "../gen/openapi.ts";
import { Account, AccountPnlInfoPage, PagedQuery, ActionResponse, MarketsInfo, Market, MarketStats, NordConfig, OrderbookQuery, OrderbookResponse, FeeTierConfig, Token, TradesResponse, User, AccountTriggerInfo, TriggerHistoryPage, WithdrawalHistoryPage, FeeTierId, AccountFeeTierPage, PageResultStringOrderInfo, PageResultStringTrade, OrderInfoFromApi, TokenStats, FillRole, AdminInfo, AccountVolumeInfo, GetAccountVolumeQuery, CandleResolution } from "../types";
import { NordWebSocketClient } from "../websocket/index";
import { OrderbookSubscription, TradeSubscription, CandleSubscription } from "../websocket/Subscriber";
/**
 * User subscription interface
 */
export interface UserSubscription extends EventEmitter {
    close: () => void;
}
/**
 * Main Nord client class for interacting with the Nord API
 */
export declare class Nord {
    /** Base URL for the Nord web server */
    readonly webServerUrl: string;
    /** Solana RPC URL */
    readonly solanaConnection: Connection;
    /** Available markets */
    markets: Market[];
    /** Available tokens */
    tokens: Token[];
    /** Map of symbol to market_id */
    private symbolToMarketId;
    /** Proton client for proton related operations */
    protonClient: ProtonClient;
    /** HTTP client for Nord operations */
    readonly httpClient: Client<paths>;
    /**
     * Create a new Nord client
     *
     * @param config - Configuration options for the Nord client
     * @param config.webServerUrl - Base URL for the Nord web server
     * @param config.solanaUrl - Solana cluster URL
     * @throws {Error} If required configuration is missing
     */
    private constructor();
    /**
     * Create a WebSocket client with specific subscriptions
     *
     * @param trades - Market symbols to subscribe to for trade updates
     * @param deltas - Market symbols to subscribe to for orderbook delta updates
     * @param accounts - Account IDs to subscribe to for account updates
     * @param candles - Candle subscriptions with symbol and resolution
     * @returns A new WebSocket client with the requested subscriptions
     * @throws {NordError} If invalid subscription options are provided
     *
     * @example
     * // Create a client for trades and deltas from one market and an account
     * const wsClient = nord.createWebSocketClient({
     *   trades: ["BTCUSDC"],
     *   deltas: ["BTCUSDC"],
     *   accounts: [123]
     * });
     *
     * @example
     * // Create a client for trades from multiple markets
     * const tradesClient = nord.createWebSocketClient({
     *   trades: ["BTCUSDC", "ETHUSDC"]
     * });
     */
    createWebSocketClient({ trades, deltas, accounts, candles, }: Readonly<{
        trades?: string[];
        deltas?: string[];
        accounts?: number[];
        candles?: Array<{
            symbol: string;
            resolution: CandleResolution;
        }>;
    }>): NordWebSocketClient;
    private GET;
    /**
     * Get the current timestamp from the Nord server
     *
     * @returns Current timestamp as a bigint
     * @throws {NordError} If the request fails
     */
    getTimestamp(): Promise<bigint>;
    /**
     * Get the last event nonce from the Nord server
     *
     * @returns Next action nonce
     * @throws {NordError} If the request fails
     */
    getActionNonce(): Promise<number>;
    /**
     * Get the admin list from the Nord server
     *
     * @returns List of admin registration keys paired with their ACL role mask
     * @throws {NordError} If the request fails
     */
    getAdminList(): Promise<Array<AdminInfo>>;
    /**
     * Get account volume across all markets, optionally for a specific market.
     *
     * @param accountId - Account identifier
     * @param since - RFC3339 timestamp marking the inclusive start of the window
     * @param until - RFC3339 timestamp marking the exclusive end of the window
     * @param marketId - Optional market identifier to scope the volume
     * @returns Array of market volumes (single entry when `marketId` is provided)
     * @throws {NordError} If the request fails
     */
    getAccountVolume({ accountId, since, until, marketId, }: Readonly<GetAccountVolumeQuery>): Promise<Array<AccountVolumeInfo>>;
    /**
     * Fetch information about Nord markets and tokens
     *
     * @throws {NordError} If the request fails
     */
    fetchNordInfo(): Promise<void>;
    /** @deprecated use Nord.new */
    static initNord(x: Readonly<NordConfig>): Promise<Nord>;
    /**
     * Initialize a new Nord client
     *
     * @param nordConfig - Configuration options for the Nord client
     * @param nordConfig.webServerUrl - Base URL for the Nord web server
     * @param nordConfig.app - App address
     * @param nordConfig.solanaUrl - Solana cluster URL
     * @returns Initialized Nord client
     * @throws {NordError} If initialization fails
     */
    static new({ app, solanaConnection, webServerUrl, protonUrl, }: Readonly<NordConfig>): Promise<Nord>;
    /**
     * Initialize the Nord client
     * @private
     */
    private init;
    /**
     * Query a specific action
     *
     * @param actionId - Action identifier to fetch
     * @returns Action response
     * @throws {NordError} If the request fails
     */
    queryAction({ actionId, }: Readonly<{
        actionId: number;
    }>): Promise<ActionResponse | null>;
    /**
     * Query recent actions
     *
     * @param from - Starting action index (inclusive)
     * @param to - Ending action index (inclusive)
     * @returns Actions response
     * @throws {NordError} If the request fails
     */
    queryRecentActions({ from, to, }: Readonly<{
        from: number;
        to: number;
    }>): Promise<ActionResponse[]>;
    /**
     * Get the last action ID
     *
     * @returns Last action ID
     * @throws {NordError} If the request fails
     */
    getLastActionId(): Promise<number>;
    /**
     * Subscribe to orderbook updates for a market
     *
     * @param symbol - Market symbol
     * @returns Orderbook subscription
     * @throws {NordError} If symbol is invalid
     */
    subscribeOrderbook(symbol: string): OrderbookSubscription;
    subscribeBars(symbol: string, resolution: CandleResolution): CandleSubscription;
    /**
     * Subscribe to trade updates for a market
     *
     * @param symbol - Market symbol
     * @returns Trade subscription
     * @throws {NordError} If symbol is invalid
     */
    subscribeTrades(symbol: string): TradeSubscription;
    /**
     * Subscribe to account updates
     *
     * @param accountId - Account ID to subscribe to
     * @returns User subscription
     * @throws {NordError} If accountId is invalid
     */
    subscribeAccount(accountId: number): UserSubscription;
    /**
     * Get trades for a market
     *
     * @param marketId - Market identifier to filter by
     * @param takerId - Taker account identifier
     * @param makerId - Maker account identifier
     * @param takerSide - Side executed by the taker
     * @param pageSize - Maximum number of trades to return
     * @param since - RFC3339 timestamp to start from (inclusive)
     * @param until - RFC3339 timestamp to end at (exclusive)
     * @param pageId - Pagination cursor returned from a prior call
     * @returns Trades response
     * @throws {NordError} If the request fails
     */
    getTrades({ marketId, takerId, makerId, takerSide, pageSize, since, until, startInclusive, }: Readonly<{
        marketId?: number;
        takerId?: number;
        makerId?: number;
        takerSide?: "bid" | "ask";
        pageSize?: number;
        since?: string;
        until?: string;
        startInclusive?: number;
    }>): Promise<TradesResponse>;
    /**
     * Get user account IDs
     *
     * @param pubkey - User public key to query
     * @returns User account IDs response
     * @throws {NordError} If the request fails
     */
    getUser({ pubkey, }: Readonly<{
        pubkey: string | PublicKey;
    }>): Promise<User | null>;
    /**
     * Get orderbook for a market
     *
     * @param symbol - Market symbol to resolve into an id
     * @param marketId - Market identifier
     * @returns Orderbook response
     * @throws {NordError} If the request fails or if the market symbol is unknown
     * @remarks It's recommended to initialize the Nord client using the static `initNord` method
     * to ensure market information is properly loaded before calling this method.
     */
    getOrderbook({ symbol, marketId, }: OrderbookQuery): Promise<OrderbookResponse>;
    /**
     * Get information about the Nord server
     *
     * @returns Information about markets and tokens
     * @throws {NordError} If the request fails
     */
    getInfo(): Promise<MarketsInfo>;
    /**
     * Fetch the current fee tier brackets configured on Nord.
     *
     * @returns Array of fee tier identifiers paired with their configuration
     * @throws {NordError} If the request fails
     */
    getFeeBrackets(): Promise<Array<[FeeTierId, FeeTierConfig]>>;
    /**
     * Retrieve the fee tier assigned to a specific account.
     *
     * @param accountId - Account identifier to query
     * @returns Fee tier details for the requested account
     * @throws {NordError} If the request fails
     */
    getAccountFeeTier(accountId: number): Promise<FeeTierId>;
    /**
     * Get account information
     *
     * @param accountId - Account ID to get information for
     * @returns Account information
     * @throws {NordError} If the request fails
     */
    getAccount(accountId: number): Promise<Account>;
    /**
     * Get the public key associated with an account id.
     *
     * @param accountId - Account id to query
     * @returns Base58-encoded account public key
     * @throws {NordError} If the request fails
     */
    getAccountPubkey(accountId: number): Promise<string>;
    /**
     * Get the withdrawal fee charged for an account.
     *
     * @param accountId - Account id to query
     * @returns Withdrawal fee quoted in quote token units
     * @throws {NordError} If the request fails
     */
    getAccountWithdrawalFee(accountId: number): Promise<number>;
    /**
     * Get open orders for an account.
     *
     * @param accountId - Account id to query
     * @param startInclusive - Pagination cursor (client order id) to resume from
     * @param pageSize - Maximum number of orders to return
     * @returns Page of orders keyed by client order id
     * @throws {NordError} If the request fails
     */
    getAccountOrders(accountId: number, { startInclusive, pageSize, }?: Readonly<{
        startInclusive?: number;
        pageSize?: number;
    }>): Promise<PageResultStringOrderInfo>;
    /**
     * List account fee tiers with pagination support.
     *
     * @param startInclusive - Account id cursor to resume from
     * @param pageSize - Maximum number of entries to return
     * @param tier - Optional fee tier filter
     */
    getAccountsFeeTiers({ startInclusive, pageSize, tier, }?: Readonly<{
        startInclusive?: number;
        pageSize?: number;
        tier?: FeeTierId;
    }>): Promise<AccountFeeTierPage>;
    /**
     * Get profit and loss history for an account
     *
     * @param accountId - Account ID to query
     * @param since - RFC3339 timestamp to start from (inclusive)
     * @param until - RFC3339 timestamp to end at (exclusive)
     * @param startInclusive - Pagination cursor to resume from
     * @param pageSize - Maximum number of entries to return
     * @returns Page of PnL entries ordered from latest to oldest
     * @throws {NordError} If the request fails
     */
    getAccountPnl(accountId: number, { since, until, startInclusive, pageSize, }?: Readonly<Partial<PagedQuery>>): Promise<AccountPnlInfoPage>;
    /**
     * Get market statistics (alias for marketsStats for backward compatibility)
     *
     *
     * @param marketId - Market identifier
     *
     * @returns Market statistics response
     */
    getMarketStats({ marketId, }: Readonly<{
        marketId: number;
    }>): Promise<MarketStats>;
    /**
     * Fetch the per-market fee quote for an account.
     *
     * @param marketId - Market identifier
     * @param feeKind - Fill role (maker/taker) to quote
     * @param accountId - Account identifier to quote
     * @returns Fee in quote token units (negative means fee is charged)
     * @throws {NordError} If the request fails
     */
    getMarketFee({ marketId, feeKind, accountId, }: Readonly<{
        marketId: number;
        feeKind: FillRole;
        accountId: number;
    }>): Promise<number>;
    /**
     * Fetch token statistics such as index price and oracle metadata.
     *
     * @param tokenId - Token identifier
     * @returns Token stats
     * @throws {NordError} If the request fails
     */
    getTokenStats(tokenId: number): Promise<TokenStats>;
    /**
     * Get order summary by order id.
     *
     * @param orderId - Order identifier
     * @returns Order information
     * @throws {NordError} If the request fails
     */
    getOrder(orderId: number): Promise<OrderInfoFromApi>;
    /**
     * Get trade history for a specific order.
     *
     * @param orderId - Order identifier
     * @param startInclusive - Trade pagination cursor
     * @param pageSize - Maximum number of trades to return
     * @returns Page of trades associated with the order
     * @throws {NordError} If the request fails
     */
    getOrderTrades(orderId: number, { startInclusive, pageSize, }?: Readonly<{
        startInclusive?: number;
        pageSize?: number;
    }>): Promise<PageResultStringTrade>;
    /**
     * Check if an account exists for the given address
     *
     * @param address - The public key address to check
     * @returns True if the account exists, false otherwise
     * @deprecated use getUser instead
     */
    accountExists(pubkey: string | PublicKey): Promise<boolean>;
    /**
     * Fetch active triggers for an account.
     *
     * @param accountId - Account identifier owning the triggers
     * @throws {NordError} If no account can be resolved or the request fails.
     */
    getAccountTriggers({ accountId, }?: Readonly<{
        accountId?: number;
    }>): Promise<AccountTriggerInfo[]>;
    /**
     * Fetch trigger history for an account.
     *
     * @param accountId - Account identifier owning the triggers
     * @param since - RFC3339 timestamp to start from (inclusive)
     * @param until - RFC3339 timestamp to end at (exclusive)
     * @param pageSize - Maximum number of entries to return
     * @param startInclusive - Pagination cursor to resume from
     * @throws {NordError} If no account can be resolved or the request fails.
     */
    getAccountTriggerHistory({ accountId, since, until, pageSize, startInclusive, }: Readonly<PagedQuery & {
        accountId?: number;
    }>): Promise<TriggerHistoryPage>;
    /**
     * Fetch withdrawal history for an account.
     *
     * @param accountId - Account identifier owning the withdrawals
     * @param since - RFC3339 timestamp to start from (inclusive)
     * @param until - RFC3339 timestamp to end at (exclusive)
     * @param pageSize - Maximum number of entries to return
     * @param startInclusive - Pagination cursor to resume from
     * @throws {NordError} If no account can be resolved or the request fails.
     */
    getAccountWithdrawalHistory({ accountId, since, until, pageSize, startInclusive, }: Readonly<PagedQuery & {
        accountId?: number;
    }>): Promise<WithdrawalHistoryPage>;
}
