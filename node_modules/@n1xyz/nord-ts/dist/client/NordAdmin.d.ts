import { PublicKey, Transaction } from "@solana/web3.js";
import * as proto from "../gen/nord_pb";
import { Nord } from "./Nord";
import { FeeTierConfig } from "../gen/nord_pb";
import Decimal from "decimal.js";
export declare enum AclRole {
    FEE_MANAGER = 1,
    MARKET_MANAGER = 2,
    ADMIN = 2147483648
}
/**
 * Administrative client capable of submitting privileged configuration actions.
 */
export declare class NordAdmin {
    private readonly nord;
    private readonly admin;
    private readonly signFn;
    private constructor();
    /** Create a new admin client.
     *
     * @param nord - Nord instance
     * @param admin - The user that will be signing actions.
     * @param signFn - Function to sign messages with the admin's wallet.
     */
    static new({ nord, admin, signFn, }: Readonly<{
        nord: Nord;
        admin: PublicKey;
        signFn: (m: Transaction) => Promise<Transaction>;
    }>): Promise<NordAdmin>;
    /**
     * Submit an action and append the admin signature before sending it to Nord.
     *
     * @param kind - Action payload describing the admin request
     * @throws {NordError} If signing or submission fails
     */
    private submitAction;
    /** Set acl permissions for a given user.
     *
     * If all roles are removed, the user is removed from the acl.
     *
     * @param target - User to update.
     * @param addRoles - Roles to add to the user.
     * @param removeRoles - Reles to remove from the user.
     */
    updateAcl({ target, addRoles, removeRoles, }: Readonly<{
        target: PublicKey;
        addRoles: AclRole[];
        removeRoles: AclRole[];
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_AclUpdated>;
    /**
     * Register a new token that can be listed on Nord.
     *
     * @param tokenDecimals - Decimal shift used when parsing deposits/withdrawals
     * @param weightBps - Risk weight in basis points applied in account value calculations
     * @param viewSymbol - Symbol surfaced to Nord clients
     * @param oracleSymbol - Symbol resolved by the oracle adapter
     * @param mintAddr - Solana mint backing this token
     * @returns Action identifier and resulting token metadata
     * @throws {NordError} If the action submission fails
     */
    createToken({ tokenDecimals, weightBps, viewSymbol, oracleSymbol, mintAddr, }: Readonly<{
        tokenDecimals: number;
        weightBps: number;
        viewSymbol: string;
        oracleSymbol: string;
        mintAddr: PublicKey;
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_InsertTokenResult>;
    /**
     * Open a new market with the provided trading parameters.
     *
     * @param sizeDecimals - Decimal shift for contract sizes
     * @param priceDecimals - Decimal shift for price ticks
     * @param imfBps - Base initial margin fraction (IMF) in basis points, see docs/MARKETS.md
     * @param cmfBps - Cancel margin fraction (CMF) in basis points, see docs/MARKETS.md
     * @param mmfBps - Maintenance margin fraction (MMF) in basis points, see docs/MARKETS.md
     * @param marketType - Spot or perpetual market type
     * @param viewSymbol - Symbol exposed to Nord clients
     * @param oracleSymbol - Symbol resolved by the oracle adapter
     * @param baseTokenId - Registered base token backing this market
     * @returns Action identifier and resulting market metadata
     * @throws {NordError} If the action submission fails
     */
    createMarket({ sizeDecimals, priceDecimals, imfBps, cmfBps, mmfBps, marketType, viewSymbol, oracleSymbol, baseTokenId, }: Readonly<{
        sizeDecimals: number;
        priceDecimals: number;
        imfBps: number;
        cmfBps: number;
        mmfBps: number;
        marketType: proto.MarketType;
        viewSymbol: string;
        oracleSymbol: string;
        baseTokenId: number;
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_InsertMarketResult>;
    /**
     * Update the Pyth guardian set used for verifying Wormhole messages.
     *
     * Each address must decode from a 20-byte hex string (with or without a
     * leading `0x` prefix). The engine validates the supplied guardian set index
     * before applying the update.
     *
     * @param guardianSetIndex - Wormhole guardian set index that must already exist
     * @param addresses - 20-byte hex-encoded guardian addresses
     * @returns Action identifier and guardian update receipt
     * @throws {NordError} If the action submission fails
     */
    pythSetWormholeGuardians({ guardianSetIndex, addresses, }: Readonly<{
        guardianSetIndex: number;
        addresses: readonly string[];
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_UpdateGuardianSetResult>;
    /**
     * Link an oracle symbol to a specific Pyth price feed.
     *
     * The price feed identifier must decode to 32 bytes (with or without a
     * leading `0x` prefix). Use this call to create or update the mapping used
     * by the oracle integration.
     *
     * @param oracleSymbol - Symbol resolved by the oracle adapter
     * @param priceFeedId - 32-byte hex-encoded Pyth price feed identifier
     * @returns Action identifier and symbol feed receipt
     * @throws {NordError} If the action submission fails
     */
    pythSetSymbolFeed({ oracleSymbol, priceFeedId: priceFeedIdHex, }: Readonly<{
        oracleSymbol: string;
        priceFeedId: string;
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_OracleSymbolFeedResult>;
    /**
     * Pause all trading activity on the exchange.
     *
     * @returns Action identifier confirming the pause
     * @throws {NordError} If the action submission fails
     */
    pause(): Promise<{
        actionId: bigint;
    }>;
    /**
     * Resume trading activity after a pause.
     *
     * @returns Action identifier confirming the unpause
     * @throws {NordError} If the action submission fails
     */
    unpause(): Promise<{
        actionId: bigint;
    }>;
    /**
     * Freeze an individual market, preventing new trades and orders.
     *
     * @param marketId - Target market identifier
     * @returns Action identifier and freeze receipt
     * @throws {NordError} If the action submission fails
     */
    freezeMarket({ marketId, }: Readonly<{
        marketId: number;
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_MarketFreezeUpdated>;
    /**
     * Unfreeze a market that was previously halted.
     *
     * @param marketId - Target market identifier
     * @returns Action identifier and freeze receipt
     * @throws {NordError} If the action submission fails
     */
    unfreezeMarket({ marketId, }: Readonly<{
        marketId: number;
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_MarketFreezeUpdated>;
    /**
     * Append a new fee tier to the account bracket configuration.
     *
     * - The engine supports at most 16 tiers (ids 0–15). Tier 0 is reserved for
     *   the default Nord fees; use `updateFeeTier` if you need to change it.
     * - The first appended tier receives id 1, and subsequent tiers increment the id.
     *
     * @param config - Fee tier configuration to insert
     *
     * Use 1/1_000_000 granularity (ppm)
     * | ppm  | decimal  | percent |
     * |------|----------|---------|
     * | 1    | 0.000001 | 0.0001% |
     * | 5    | 0.000005 | 0.0005% |
     * | 10   | 0.00001  | 0.001%  |
     * | 50   | 0.00005  | 0.005%  |
     * | 100  | 0.0001   | 0.01%   |
     * | 500  | 0.0005   | 0.05%   |
     * | 1000 | 0.001    | 0.10%   |
     * | 5000 | 0.005    | 0.50%   |
     * | 10000| 0.01     | 1.00%   |
     *
     * @returns Action identifier and fee tier addition receipt
     * @throws {NordError} If the action submission fails or the new tier exceeds the maximum range (0-15).
     */
    addFeeTier({ config, }: Readonly<{
        config: FeeTierConfig;
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_FeeTierAdded>;
    /**
     * Update an existing fee tier with new maker/taker rates.
     *
     * Tier identifiers must already exist; attempting to update a missing tier
     * causes the action to fail.
     *
     * @param tierId - Existing fee tier identifier to update
     * @param config - Replacement configuration for the tier
     * @returns Action identifier and fee tier update receipt
     * @throws {NordError} If the action submission fails or the tier ID exceeds the configured range.
     */
    updateFeeTier({ tierId, config, }: Readonly<{
        tierId: number;
        config: FeeTierConfig;
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_FeeTierUpdated>;
    /**
     * Assign a fee tier to one or more accounts.
     *
     * The tier id must be within the configured range (0–15). Every account starts
     * on tier 0; assigning it to another tier requires that tier to exist already.
     * Invalid account ids or tier ids cause the action to fail.
     *
     * @param accounts - Account IDs to update
     * @param tierId - Target fee tier identifier
     * @returns Action identifier and accounts-tier receipt
     * @throws {NordError} If the tier id exceeds the configured range or an account id is invalid.
     */
    updateAccountsTier(accounts: number[], tierId: number): Promise<{
        actionId: bigint;
    } & proto.Receipt_AccountsTierUpdated>;
    feeVaultTransfer({ recipient, tokenId, amount, }: Readonly<{
        recipient: number;
        tokenId: number;
        amount: Decimal.Value;
    }>): Promise<{
        actionId: bigint;
    } & proto.Receipt_FeeVaultTransferred>;
}
