import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
/**
 * Describes the file nord.proto.
 */
export declare const file_nord: GenFile;
/**
 * @generated from message nord.FeeTierConfig
 */
export type FeeTierConfig = Message<"nord.FeeTierConfig"> & {
    /**
     * @generated from field: uint32 maker_fee_ppm = 1;
     */
    makerFeePpm: number;
    /**
     * @generated from field: uint32 taker_fee_ppm = 2;
     */
    takerFeePpm: number;
};
/**
 * @generated from message nord.FeeTierConfig
 */
export type FeeTierConfigJson = {
    /**
     * @generated from field: uint32 maker_fee_ppm = 1;
     */
    makerFeePpm?: number;
    /**
     * @generated from field: uint32 taker_fee_ppm = 2;
     */
    takerFeePpm?: number;
};
/**
 * Describes the message nord.FeeTierConfig.
 * Use `create(FeeTierConfigSchema)` to create a new message.
 */
export declare const FeeTierConfigSchema: GenMessage<FeeTierConfig, {
    jsonType: FeeTierConfigJson;
}>;
/**
 * @generated from message nord.Market
 */
export type Market = Message<"nord.Market"> & {
    /**
     * @generated from field: uint32 market_id = 1;
     */
    marketId: number;
    /**
     * @generated from field: uint32 price_decimals = 2;
     */
    priceDecimals: number;
    /**
     * @generated from field: uint32 size_decimals = 3;
     */
    sizeDecimals: number;
    /**
     * @generated from field: uint32 base_token_id = 4;
     */
    baseTokenId: number;
    /**
     * @generated from field: nord.MarketType market_type = 5;
     */
    marketType: MarketType;
    /**
     * @generated from field: uint32 imf_bps = 6;
     */
    imfBps: number;
    /**
     * @generated from field: uint32 cmf_bps = 7;
     */
    cmfBps: number;
    /**
     * @generated from field: uint32 mmf_bps = 8;
     */
    mmfBps: number;
    /**
     * @generated from field: string view_symbol = 10;
     */
    viewSymbol: string;
};
/**
 * @generated from message nord.Market
 */
export type MarketJson = {
    /**
     * @generated from field: uint32 market_id = 1;
     */
    marketId?: number;
    /**
     * @generated from field: uint32 price_decimals = 2;
     */
    priceDecimals?: number;
    /**
     * @generated from field: uint32 size_decimals = 3;
     */
    sizeDecimals?: number;
    /**
     * @generated from field: uint32 base_token_id = 4;
     */
    baseTokenId?: number;
    /**
     * @generated from field: nord.MarketType market_type = 5;
     */
    marketType?: MarketTypeJson;
    /**
     * @generated from field: uint32 imf_bps = 6;
     */
    imfBps?: number;
    /**
     * @generated from field: uint32 cmf_bps = 7;
     */
    cmfBps?: number;
    /**
     * @generated from field: uint32 mmf_bps = 8;
     */
    mmfBps?: number;
    /**
     * @generated from field: string view_symbol = 10;
     */
    viewSymbol?: string;
};
/**
 * Describes the message nord.Market.
 * Use `create(MarketSchema)` to create a new message.
 */
export declare const MarketSchema: GenMessage<Market, {
    jsonType: MarketJson;
}>;
/**
 * @generated from message nord.Token
 */
export type Token = Message<"nord.Token"> & {
    /**
     * @generated from field: uint32 token_id = 1;
     */
    tokenId: number;
    /**
     * / See CreateToken for details.
     *
     * @generated from field: uint32 token_decimals = 2;
     */
    tokenDecimals: number;
    /**
     * @generated from field: uint32 weight_bps = 4;
     */
    weightBps: number;
    /**
     * @generated from field: string view_symbol = 5;
     */
    viewSymbol: string;
};
/**
 * @generated from message nord.Token
 */
export type TokenJson = {
    /**
     * @generated from field: uint32 token_id = 1;
     */
    tokenId?: number;
    /**
     * / See CreateToken for details.
     *
     * @generated from field: uint32 token_decimals = 2;
     */
    tokenDecimals?: number;
    /**
     * @generated from field: uint32 weight_bps = 4;
     */
    weightBps?: number;
    /**
     * @generated from field: string view_symbol = 5;
     */
    viewSymbol?: string;
};
/**
 * Describes the message nord.Token.
 * Use `create(TokenSchema)` to create a new message.
 */
export declare const TokenSchema: GenMessage<Token, {
    jsonType: TokenJson;
}>;
/**
 * quote_size = size * price, in decimals for specific market
 * Use current market if you want realistic tick step exisitng on market.
 * Use smaller prices for more granular quote size control,
 * but beware it will be neared to possible value in engine.
 *
 * @generated from message nord.QuoteSize
 */
export type QuoteSize = Message<"nord.QuoteSize"> & {
    /**
     * In `Market.size_decimals` decimals. 63 bit positive integer.
     *
     * @generated from field: uint64 size = 1;
     */
    size: bigint;
    /**
     * In `Market.price_decimals` decimals. 64 bit positive integer.
     *
     * @generated from field: uint64 price = 2;
     */
    price: bigint;
};
/**
 * quote_size = size * price, in decimals for specific market
 * Use current market if you want realistic tick step exisitng on market.
 * Use smaller prices for more granular quote size control,
 * but beware it will be neared to possible value in engine.
 *
 * @generated from message nord.QuoteSize
 */
export type QuoteSizeJson = {
    /**
     * In `Market.size_decimals` decimals. 63 bit positive integer.
     *
     * @generated from field: uint64 size = 1;
     */
    size?: string;
    /**
     * In `Market.price_decimals` decimals. 64 bit positive integer.
     *
     * @generated from field: uint64 price = 2;
     */
    price?: string;
};
/**
 * Describes the message nord.QuoteSize.
 * Use `create(QuoteSizeSchema)` to create a new message.
 */
export declare const QuoteSizeSchema: GenMessage<QuoteSize, {
    jsonType: QuoteSizeJson;
}>;
/**
 * @generated from message nord.OrderLimit
 */
export type OrderLimit = Message<"nord.OrderLimit"> & {
    /**
     * @generated from field: uint64 price = 6;
     */
    price: bigint;
    /**
     * @generated from field: uint64 size = 7;
     */
    size: bigint;
    /**
     * Optional.
     *
     * @generated from field: nord.QuoteSize quote_size = 8;
     */
    quoteSize?: QuoteSize;
};
/**
 * @generated from message nord.OrderLimit
 */
export type OrderLimitJson = {
    /**
     * @generated from field: uint64 price = 6;
     */
    price?: string;
    /**
     * @generated from field: uint64 size = 7;
     */
    size?: string;
    /**
     * Optional.
     *
     * @generated from field: nord.QuoteSize quote_size = 8;
     */
    quoteSize?: QuoteSizeJson;
};
/**
 * Describes the message nord.OrderLimit.
 * Use `create(OrderLimitSchema)` to create a new message.
 */
export declare const OrderLimitSchema: GenMessage<OrderLimit, {
    jsonType: OrderLimitJson;
}>;
/**
 * @generated from message nord.OrderType
 */
export type OrderType = Message<"nord.OrderType"> & {
    /**
     * @generated from field: nord.Side side = 3;
     */
    side: Side;
    /**
     * @generated from field: nord.FillMode fill_mode = 4;
     */
    fillMode: FillMode;
    /**
     * @generated from field: bool is_reduce_only = 5;
     */
    isReduceOnly: boolean;
};
/**
 * @generated from message nord.OrderType
 */
export type OrderTypeJson = {
    /**
     * @generated from field: nord.Side side = 3;
     */
    side?: SideJson;
    /**
     * @generated from field: nord.FillMode fill_mode = 4;
     */
    fillMode?: FillModeJson;
    /**
     * @generated from field: bool is_reduce_only = 5;
     */
    isReduceOnly?: boolean;
};
/**
 * Describes the message nord.OrderType.
 * Use `create(OrderTypeSchema)` to create a new message.
 */
export declare const OrderTypeSchema: GenMessage<OrderType, {
    jsonType: OrderTypeJson;
}>;
/**
 * @generated from message nord.TradeOrPlace
 */
export type TradeOrPlace = Message<"nord.TradeOrPlace"> & {
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId: number;
    /**
     * @generated from field: nord.OrderType order_type = 3;
     */
    orderType?: OrderType;
    /**
     * @generated from field: nord.OrderLimit limit = 6;
     */
    limit?: OrderLimit;
    /**
     * @generated from field: optional uint64 client_order_id = 33;
     */
    clientOrderId?: bigint;
};
/**
 * @generated from message nord.TradeOrPlace
 */
export type TradeOrPlaceJson = {
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId?: number;
    /**
     * @generated from field: nord.OrderType order_type = 3;
     */
    orderType?: OrderTypeJson;
    /**
     * @generated from field: nord.OrderLimit limit = 6;
     */
    limit?: OrderLimitJson;
    /**
     * @generated from field: optional uint64 client_order_id = 33;
     */
    clientOrderId?: string;
};
/**
 * Describes the message nord.TradeOrPlace.
 * Use `create(TradeOrPlaceSchema)` to create a new message.
 */
export declare const TradeOrPlaceSchema: GenMessage<TradeOrPlace, {
    jsonType: TradeOrPlaceJson;
}>;
/**
 * @generated from message nord.CancelOrder
 */
export type CancelOrder = Message<"nord.CancelOrder"> & {
    /**
     * @generated from field: uint64 order_id = 2;
     */
    orderId: bigint;
};
/**
 * @generated from message nord.CancelOrder
 */
export type CancelOrderJson = {
    /**
     * @generated from field: uint64 order_id = 2;
     */
    orderId?: string;
};
/**
 * Describes the message nord.CancelOrder.
 * Use `create(CancelOrderSchema)` to create a new message.
 */
export declare const CancelOrderSchema: GenMessage<CancelOrder, {
    jsonType: CancelOrderJson;
}>;
/**
 * @generated from message nord.TriggerKey
 */
export type TriggerKey = Message<"nord.TriggerKey"> & {
    /**
     * @generated from field: nord.TriggerKind kind = 3;
     */
    kind: TriggerKind;
    /**
     * @generated from field: nord.Side side = 4;
     */
    side: Side;
};
/**
 * @generated from message nord.TriggerKey
 */
export type TriggerKeyJson = {
    /**
     * @generated from field: nord.TriggerKind kind = 3;
     */
    kind?: TriggerKindJson;
    /**
     * @generated from field: nord.Side side = 4;
     */
    side?: SideJson;
};
/**
 * Describes the message nord.TriggerKey.
 * Use `create(TriggerKeySchema)` to create a new message.
 */
export declare const TriggerKeySchema: GenMessage<TriggerKey, {
    jsonType: TriggerKeyJson;
}>;
/**
 * @generated from message nord.AtomicSubactionKind
 */
export type AtomicSubactionKind = Message<"nord.AtomicSubactionKind"> & {
    /**
     * @generated from oneof nord.AtomicSubactionKind.inner
     */
    inner: {
        /**
         * @generated from field: nord.TradeOrPlace trade_or_place = 6;
         */
        value: TradeOrPlace;
        case: "tradeOrPlace";
    } | {
        /**
         * @generated from field: nord.CancelOrder cancel_order = 7;
         */
        value: CancelOrder;
        case: "cancelOrder";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * @generated from message nord.AtomicSubactionKind
 */
export type AtomicSubactionKindJson = {
    /**
     * @generated from field: nord.TradeOrPlace trade_or_place = 6;
     */
    tradeOrPlace?: TradeOrPlaceJson;
    /**
     * @generated from field: nord.CancelOrder cancel_order = 7;
     */
    cancelOrder?: CancelOrderJson;
};
/**
 * Describes the message nord.AtomicSubactionKind.
 * Use `create(AtomicSubactionKindSchema)` to create a new message.
 */
export declare const AtomicSubactionKindSchema: GenMessage<AtomicSubactionKind, {
    jsonType: AtomicSubactionKindJson;
}>;
/**
 * @generated from message nord.Atomic
 */
export type Atomic = Message<"nord.Atomic"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
    /**
     * @generated from field: optional uint32 account_id = 2;
     */
    accountId?: number;
    /**
     * @generated from field: repeated nord.AtomicSubactionKind actions = 6;
     */
    actions: AtomicSubactionKind[];
};
/**
 * @generated from message nord.Atomic
 */
export type AtomicJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
    /**
     * @generated from field: optional uint32 account_id = 2;
     */
    accountId?: number;
    /**
     * @generated from field: repeated nord.AtomicSubactionKind actions = 6;
     */
    actions?: AtomicSubactionKindJson[];
};
/**
 * Describes the message nord.Atomic.
 * Use `create(AtomicSchema)` to create a new message.
 */
export declare const AtomicSchema: GenMessage<Atomic, {
    jsonType: AtomicJson;
}>;
/**
 * An action executed by the engine. This is the main message that is sent to
 * the server.
 *
 * @generated from message nord.Action
 */
export type Action = Message<"nord.Action"> & {
    /**
     * Must be within 60s of the engine's current logical time, which
     * should be within a few seconds of real time.
     *
     * Ignored for the `PythPriceFeedUpdate` action as that action updates
     * the timestamp. Should be set to 0 in that case to omit it.
     *
     * @generated from field: int64 current_timestamp = 1;
     */
    currentTimestamp: bigint;
    /**
     * Optional nonce to handle if user wants several identical transactions to be
     * executed with `current_timestamp`. Sending exactly same transaction twice
     * is rejected. In order to change signature of transaction(execute it once
     * more time), nonce should be changed(incremented).
     *
     * @generated from field: uint32 nonce = 2;
     */
    nonce: number;
    /**
     * @generated from oneof nord.Action.kind
     */
    kind: {
        /**
         * @generated from field: nord.Action.CreateSession create_session = 4;
         */
        value: Action_CreateSession;
        case: "createSession";
    } | {
        /**
         * @generated from field: nord.Action.CreateToken create_token = 5;
         */
        value: Action_CreateToken;
        case: "createToken";
    } | {
        /**
         * @generated from field: nord.Action.CreateMarket create_market = 6;
         */
        value: Action_CreateMarket;
        case: "createMarket";
    } | {
        /**
         * @generated from field: nord.Action.PlaceOrder place_order = 7;
         */
        value: Action_PlaceOrder;
        case: "placeOrder";
    } | {
        /**
         * @generated from field: nord.Action.CancelOrderById cancel_order_by_id = 8;
         */
        value: Action_CancelOrderById;
        case: "cancelOrderById";
    } | {
        /**
         * @generated from field: nord.Action.Deposit deposit = 9;
         */
        value: Action_Deposit;
        case: "deposit";
    } | {
        /**
         * @generated from field: nord.Action.Withdraw withdraw = 10;
         */
        value: Action_Withdraw;
        case: "withdraw";
    } | {
        /**
         * @generated from field: nord.Action.PythSetWormholeGuardians pyth_set_wormhole_guardians = 11;
         */
        value: Action_PythSetWormholeGuardians;
        case: "pythSetWormholeGuardians";
    } | {
        /**
         * @generated from field: nord.Action.PythSetSymbolFeed pyth_set_symbol_feed = 12;
         */
        value: Action_PythSetSymbolFeed;
        case: "pythSetSymbolFeed";
    } | {
        /**
         * @generated from field: nord.Action.PythPriceFeedUpdate pyth_price_feed_update = 13;
         */
        value: Action_PythPriceFeedUpdate;
        case: "pythPriceFeedUpdate";
    } | {
        /**
         * @generated from field: nord.Action.Liquidate liquidate = 14;
         */
        value: Action_Liquidate;
        case: "liquidate";
    } | {
        /**
         * @generated from field: nord.Action.RevokeSession revoke_session = 15;
         */
        value: Action_RevokeSession;
        case: "revokeSession";
    } | {
        /**
         * @generated from field: nord.Action.Pause pause = 16;
         */
        value: Action_Pause;
        case: "pause";
    } | {
        /**
         * @generated from field: nord.Action.Unpause unpause = 17;
         */
        value: Action_Unpause;
        case: "unpause";
    } | {
        /**
         * @generated from field: nord.Action.Transfer transfer = 18;
         */
        value: Action_Transfer;
        case: "transfer";
    } | {
        /**
         * @generated from field: nord.Action.AddTrigger add_trigger = 32;
         */
        value: Action_AddTrigger;
        case: "addTrigger";
    } | {
        /**
         * @generated from field: nord.Action.RemoveTrigger remove_trigger = 33;
         */
        value: Action_RemoveTrigger;
        case: "removeTrigger";
    } | {
        /**
         * @generated from field: nord.Action.TakePosition take_position = 34;
         */
        value: Action_TakePosition;
        case: "takePosition";
    } | {
        /**
         * @generated from field: nord.Atomic atomic = 35;
         */
        value: Atomic;
        case: "atomic";
    } | {
        /**
         * @generated from field: nord.Action.FreezeMarket freeze_market = 36;
         */
        value: Action_FreezeMarket;
        case: "freezeMarket";
    } | {
        /**
         * @generated from field: nord.Action.UnfreezeMarket unfreeze_market = 37;
         */
        value: Action_UnfreezeMarket;
        case: "unfreezeMarket";
    } | {
        /**
         * @generated from field: nord.Action.AddFeeTier add_fee_tier = 38;
         */
        value: Action_AddFeeTier;
        case: "addFeeTier";
    } | {
        /**
         * @generated from field: nord.Action.UpdateFeeTier update_fee_tier = 39;
         */
        value: Action_UpdateFeeTier;
        case: "updateFeeTier";
    } | {
        /**
         * @generated from field: nord.Action.UpdateAccountsTier update_accounts_tier = 40;
         */
        value: Action_UpdateAccountsTier;
        case: "updateAccountsTier";
    } | {
        /**
         * @generated from field: nord.Action.UpdateAcl update_acl = 41;
         */
        value: Action_UpdateAcl;
        case: "updateAcl";
    } | {
        /**
         * @generated from field: nord.Action.FeeVaultTransfer fee_vault_transfer = 42;
         */
        value: Action_FeeVaultTransfer;
        case: "feeVaultTransfer";
    } | {
        /**
         * @generated from field: nord.Action.CancelOrderByClientId cancel_order_by_client_id = 44;
         */
        value: Action_CancelOrderByClientId;
        case: "cancelOrderByClientId";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * An action executed by the engine. This is the main message that is sent to
 * the server.
 *
 * @generated from message nord.Action
 */
export type ActionJson = {
    /**
     * Must be within 60s of the engine's current logical time, which
     * should be within a few seconds of real time.
     *
     * Ignored for the `PythPriceFeedUpdate` action as that action updates
     * the timestamp. Should be set to 0 in that case to omit it.
     *
     * @generated from field: int64 current_timestamp = 1;
     */
    currentTimestamp?: string;
    /**
     * Optional nonce to handle if user wants several identical transactions to be
     * executed with `current_timestamp`. Sending exactly same transaction twice
     * is rejected. In order to change signature of transaction(execute it once
     * more time), nonce should be changed(incremented).
     *
     * @generated from field: uint32 nonce = 2;
     */
    nonce?: number;
    /**
     * @generated from field: nord.Action.CreateSession create_session = 4;
     */
    createSession?: Action_CreateSessionJson;
    /**
     * @generated from field: nord.Action.CreateToken create_token = 5;
     */
    createToken?: Action_CreateTokenJson;
    /**
     * @generated from field: nord.Action.CreateMarket create_market = 6;
     */
    createMarket?: Action_CreateMarketJson;
    /**
     * @generated from field: nord.Action.PlaceOrder place_order = 7;
     */
    placeOrder?: Action_PlaceOrderJson;
    /**
     * @generated from field: nord.Action.CancelOrderById cancel_order_by_id = 8;
     */
    cancelOrderById?: Action_CancelOrderByIdJson;
    /**
     * @generated from field: nord.Action.Deposit deposit = 9;
     */
    deposit?: Action_DepositJson;
    /**
     * @generated from field: nord.Action.Withdraw withdraw = 10;
     */
    withdraw?: Action_WithdrawJson;
    /**
     * @generated from field: nord.Action.PythSetWormholeGuardians pyth_set_wormhole_guardians = 11;
     */
    pythSetWormholeGuardians?: Action_PythSetWormholeGuardiansJson;
    /**
     * @generated from field: nord.Action.PythSetSymbolFeed pyth_set_symbol_feed = 12;
     */
    pythSetSymbolFeed?: Action_PythSetSymbolFeedJson;
    /**
     * @generated from field: nord.Action.PythPriceFeedUpdate pyth_price_feed_update = 13;
     */
    pythPriceFeedUpdate?: Action_PythPriceFeedUpdateJson;
    /**
     * @generated from field: nord.Action.Liquidate liquidate = 14;
     */
    liquidate?: Action_LiquidateJson;
    /**
     * @generated from field: nord.Action.RevokeSession revoke_session = 15;
     */
    revokeSession?: Action_RevokeSessionJson;
    /**
     * @generated from field: nord.Action.Pause pause = 16;
     */
    pause?: Action_PauseJson;
    /**
     * @generated from field: nord.Action.Unpause unpause = 17;
     */
    unpause?: Action_UnpauseJson;
    /**
     * @generated from field: nord.Action.Transfer transfer = 18;
     */
    transfer?: Action_TransferJson;
    /**
     * @generated from field: nord.Action.AddTrigger add_trigger = 32;
     */
    addTrigger?: Action_AddTriggerJson;
    /**
     * @generated from field: nord.Action.RemoveTrigger remove_trigger = 33;
     */
    removeTrigger?: Action_RemoveTriggerJson;
    /**
     * @generated from field: nord.Action.TakePosition take_position = 34;
     */
    takePosition?: Action_TakePositionJson;
    /**
     * @generated from field: nord.Atomic atomic = 35;
     */
    atomic?: AtomicJson;
    /**
     * @generated from field: nord.Action.FreezeMarket freeze_market = 36;
     */
    freezeMarket?: Action_FreezeMarketJson;
    /**
     * @generated from field: nord.Action.UnfreezeMarket unfreeze_market = 37;
     */
    unfreezeMarket?: Action_UnfreezeMarketJson;
    /**
     * @generated from field: nord.Action.AddFeeTier add_fee_tier = 38;
     */
    addFeeTier?: Action_AddFeeTierJson;
    /**
     * @generated from field: nord.Action.UpdateFeeTier update_fee_tier = 39;
     */
    updateFeeTier?: Action_UpdateFeeTierJson;
    /**
     * @generated from field: nord.Action.UpdateAccountsTier update_accounts_tier = 40;
     */
    updateAccountsTier?: Action_UpdateAccountsTierJson;
    /**
     * @generated from field: nord.Action.UpdateAcl update_acl = 41;
     */
    updateAcl?: Action_UpdateAclJson;
    /**
     * @generated from field: nord.Action.FeeVaultTransfer fee_vault_transfer = 42;
     */
    feeVaultTransfer?: Action_FeeVaultTransferJson;
    /**
     * @generated from field: nord.Action.CancelOrderByClientId cancel_order_by_client_id = 44;
     */
    cancelOrderByClientId?: Action_CancelOrderByClientIdJson;
};
/**
 * Describes the message nord.Action.
 * Use `create(ActionSchema)` to create a new message.
 */
export declare const ActionSchema: GenMessage<Action, {
    jsonType: ActionJson;
}>;
/**
 * @generated from message nord.Action.CreateSession
 */
export type Action_CreateSession = Message<"nord.Action.CreateSession"> & {
    /**
     * User's Ed25519 registration key, i.e. the wallet address. Must be 32
     * bytes.
     *
     * @generated from field: bytes user_pubkey = 1;
     */
    userPubkey: Uint8Array;
    /**
     * The session's public key. Must be 32 bytes.
     *
     * @generated from field: bytes session_pubkey = 2;
     */
    sessionPubkey: Uint8Array;
    /**
     * Expiry time of the session, in unix timestamp. Relative to the engine's
     * time.
     *
     * @generated from field: int64 expiry_timestamp = 3;
     */
    expiryTimestamp: bigint;
    /**
     * Alternatively frame the message as a Solana transaction.
     * Defaults to hex if unset, to stay compatible with existing payloads.
     *
     * @generated from field: optional nord.Action.UserSignatureFraming signature_framing = 4;
     */
    signatureFraming?: Action_UserSignatureFraming;
};
/**
 * @generated from message nord.Action.CreateSession
 */
export type Action_CreateSessionJson = {
    /**
     * User's Ed25519 registration key, i.e. the wallet address. Must be 32
     * bytes.
     *
     * @generated from field: bytes user_pubkey = 1;
     */
    userPubkey?: string;
    /**
     * The session's public key. Must be 32 bytes.
     *
     * @generated from field: bytes session_pubkey = 2;
     */
    sessionPubkey?: string;
    /**
     * Expiry time of the session, in unix timestamp. Relative to the engine's
     * time.
     *
     * @generated from field: int64 expiry_timestamp = 3;
     */
    expiryTimestamp?: string;
    /**
     * Alternatively frame the message as a Solana transaction.
     * Defaults to hex if unset, to stay compatible with existing payloads.
     *
     * @generated from field: optional nord.Action.UserSignatureFraming signature_framing = 4;
     */
    signatureFraming?: Action_UserSignatureFramingJson;
};
/**
 * Describes the message nord.Action.CreateSession.
 * Use `create(Action_CreateSessionSchema)` to create a new message.
 */
export declare const Action_CreateSessionSchema: GenMessage<Action_CreateSession, {
    jsonType: Action_CreateSessionJson;
}>;
/**
 * @generated from message nord.Action.CreateToken
 */
export type Action_CreateToken = Message<"nord.Action.CreateToken"> & {
    /**
     * / Example:
     * / Settlement 1 ETH is 10**18 value.
     * / With `token_decimals` of `10`, engine balance will have 1 ETH = 10**10
     * / value. Rollup sends to engine and expects from engine 10**10 as 1 ETH
     * / value. So if user has on balance 10**9 of ETH, it means he has 0.1 ETH
     * / on engine balance and in settlement, but in settlement it will be
     * / represented as 10**17 value. As consequence, if oracle gives index_price
     * / of 1 ETH as it is in Ethereum, we must divide balance by
     * / `10**token_decimals` and multiply by price to get USD value (do not
     * / forget allow for rounding sub USD values). As for market price, to trade
     * / 0.1 ETH,
     * need to 1/10 / 10**token_decimals * 10**Market.size_decimals
     *
     * @generated from field: uint32 token_decimals = 1;
     */
    tokenDecimals: number;
    /**
     * @generated from field: uint32 weight_bps = 3;
     */
    weightBps: number;
    /**
     * @generated from field: string view_symbol = 4;
     */
    viewSymbol: string;
    /**
     * / Used to bind to relevant oracle feed
     *
     * @generated from field: string oracle_symbol = 5;
     */
    oracleSymbol: string;
    /**
     * On chain id for the wrapped asset on the rollup
     *
     * @generated from field: bytes sol_addr = 6;
     */
    solAddr: Uint8Array;
    /**
     * @generated from field: bytes acl_pubkey = 7;
     */
    aclPubkey: Uint8Array;
};
/**
 * @generated from message nord.Action.CreateToken
 */
export type Action_CreateTokenJson = {
    /**
     * / Example:
     * / Settlement 1 ETH is 10**18 value.
     * / With `token_decimals` of `10`, engine balance will have 1 ETH = 10**10
     * / value. Rollup sends to engine and expects from engine 10**10 as 1 ETH
     * / value. So if user has on balance 10**9 of ETH, it means he has 0.1 ETH
     * / on engine balance and in settlement, but in settlement it will be
     * / represented as 10**17 value. As consequence, if oracle gives index_price
     * / of 1 ETH as it is in Ethereum, we must divide balance by
     * / `10**token_decimals` and multiply by price to get USD value (do not
     * / forget allow for rounding sub USD values). As for market price, to trade
     * / 0.1 ETH,
     * need to 1/10 / 10**token_decimals * 10**Market.size_decimals
     *
     * @generated from field: uint32 token_decimals = 1;
     */
    tokenDecimals?: number;
    /**
     * @generated from field: uint32 weight_bps = 3;
     */
    weightBps?: number;
    /**
     * @generated from field: string view_symbol = 4;
     */
    viewSymbol?: string;
    /**
     * / Used to bind to relevant oracle feed
     *
     * @generated from field: string oracle_symbol = 5;
     */
    oracleSymbol?: string;
    /**
     * On chain id for the wrapped asset on the rollup
     *
     * @generated from field: bytes sol_addr = 6;
     */
    solAddr?: string;
    /**
     * @generated from field: bytes acl_pubkey = 7;
     */
    aclPubkey?: string;
};
/**
 * Describes the message nord.Action.CreateToken.
 * Use `create(Action_CreateTokenSchema)` to create a new message.
 */
export declare const Action_CreateTokenSchema: GenMessage<Action_CreateToken, {
    jsonType: Action_CreateTokenJson;
}>;
/**
 * @generated from message nord.Action.CreateMarket
 */
export type Action_CreateMarket = Message<"nord.Action.CreateMarket"> & {
    /**
     * @generated from field: uint32 size_decimals = 1;
     */
    sizeDecimals: number;
    /**
     * @generated from field: uint32 price_decimals = 2;
     */
    priceDecimals: number;
    /**
     * @generated from field: uint32 imf_bps = 3;
     */
    imfBps: number;
    /**
     * @generated from field: uint32 cmf_bps = 4;
     */
    cmfBps: number;
    /**
     * @generated from field: uint32 mmf_bps = 5;
     */
    mmfBps: number;
    /**
     * @generated from field: nord.MarketType market_type = 6;
     */
    marketType: MarketType;
    /**
     * Arbitrary human-readable market symbol, not to be confused with token's
     * symbol
     *
     * @generated from field: string view_symbol = 7;
     */
    viewSymbol: string;
    /**
     * Oracle symbol which references specific price feed. Must be
     * `oracle_symbol` of registered price feed
     *
     * @generated from field: string oracle_symbol = 8;
     */
    oracleSymbol: string;
    /**
     * One of registered `token_id`'s.
     *
     * Base token for `MarketType::Spot`.
     *
     * Same as quote token id for `MarketType::Perpetual`. `oracle_symbol`
     * identifies relevant price feed.
     *
     * @generated from field: uint32 base_token_id = 9;
     */
    baseTokenId: number;
    /**
     * @generated from field: bytes acl_pubkey = 10;
     */
    aclPubkey: Uint8Array;
};
/**
 * @generated from message nord.Action.CreateMarket
 */
export type Action_CreateMarketJson = {
    /**
     * @generated from field: uint32 size_decimals = 1;
     */
    sizeDecimals?: number;
    /**
     * @generated from field: uint32 price_decimals = 2;
     */
    priceDecimals?: number;
    /**
     * @generated from field: uint32 imf_bps = 3;
     */
    imfBps?: number;
    /**
     * @generated from field: uint32 cmf_bps = 4;
     */
    cmfBps?: number;
    /**
     * @generated from field: uint32 mmf_bps = 5;
     */
    mmfBps?: number;
    /**
     * @generated from field: nord.MarketType market_type = 6;
     */
    marketType?: MarketTypeJson;
    /**
     * Arbitrary human-readable market symbol, not to be confused with token's
     * symbol
     *
     * @generated from field: string view_symbol = 7;
     */
    viewSymbol?: string;
    /**
     * Oracle symbol which references specific price feed. Must be
     * `oracle_symbol` of registered price feed
     *
     * @generated from field: string oracle_symbol = 8;
     */
    oracleSymbol?: string;
    /**
     * One of registered `token_id`'s.
     *
     * Base token for `MarketType::Spot`.
     *
     * Same as quote token id for `MarketType::Perpetual`. `oracle_symbol`
     * identifies relevant price feed.
     *
     * @generated from field: uint32 base_token_id = 9;
     */
    baseTokenId?: number;
    /**
     * @generated from field: bytes acl_pubkey = 10;
     */
    aclPubkey?: string;
};
/**
 * Describes the message nord.Action.CreateMarket.
 * Use `create(Action_CreateMarketSchema)` to create a new message.
 */
export declare const Action_CreateMarketSchema: GenMessage<Action_CreateMarket, {
    jsonType: Action_CreateMarketJson;
}>;
/**
 * Note on order size.
 * Any order being placed has absolute maximum size, which is 2^48-1.
 * Although, this limit is applied not to initial order being placed
 * but to final order being added to market's orderbook.
 * This behavior exists because order can be limited by quote size,
 * which converts to order size in a non-linear manner.
 *
 * Some orders can be executed immediately, in this no order will be added to
 * orderbook, no order id created. Consider using `client_order_id` to track
 * execution of such orders.
 *
 * Example: User posts order with size 2^48+100_000. Order fills counter
 * orders and its size is reduced to 2^48-1_000_000 in process. This order
 * will be added to orderbook successfully despite its initial size is above
 * limit.
 *
 * @generated from message nord.Action.PlaceOrder
 */
export type Action_PlaceOrder = Message<"nord.Action.PlaceOrder"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId: number;
    /**
     * @generated from field: nord.Side side = 3;
     */
    side: Side;
    /**
     * @generated from field: nord.FillMode fill_mode = 4;
     */
    fillMode: FillMode;
    /**
     * A reduce-only order only reduces your current position, as opposed to
     * increasing it. It means you can only use it to close a position. In
     * contrast, non-reduce-only orders can reduce or increase your position.
     * Reduce is handled by dynamically reducing or adjusting limit order's
     * contract quantity
     * / to match the contract size of the open position.
     *
     * @generated from field: bool is_reduce_only = 5;
     */
    isReduceOnly: boolean;
    /**
     * Raw integral value of order limit price.
     * `1` here equals to market's `10^-price_decimals`
     * When used in token balances and reward computations, shifted by market's
     * `price_decimals`. Optional, treated as not set if 0.
     *
     * @generated from field: uint64 price = 6;
     */
    price: bigint;
    /**
     * Raw integral value of order size limit.
     * For spot markers measured in base size,
     * for perpetuals in contract token.
     * So using base as default naming in codebase.
     * `1` here equals to market's `10^-size_decimals`
     * When used in token balances and reward computations, shifted by market's
     * `size_decimals`. Optional, treated as not set if 0.
     *
     * @generated from field: uint64 size = 7;
     */
    size: bigint;
    /**
     * Quote size limit.
     * Optional.
     *
     * @generated from field: nord.QuoteSize quote_size = 8;
     */
    quoteSize?: QuoteSize;
    /**
     * Optional account on behalf of whom the order should be placed.
     * Executed only if sender has delegated authority to do so,
     * like admin user or liquidator bot.
     * # Delegation allowed if:
     * - trigger
     * - reduce bad position
     * - sell at good price to reduce if cannot cover bad position
     *
     * @generated from field: optional uint32 delegator_account_id = 32;
     */
    delegatorAccountId?: number;
    /**
     * Caller provided opaque order identifier up to 8 bytes.
     * Not used by engine, but can be used by client to track orders.
     *
     * @generated from field: optional uint64 client_order_id = 33;
     */
    clientOrderId?: bigint;
    /**
     * Account id which performs operation;
     * if not specified, first account of session's owner user is picked
     *
     * @generated from field: optional uint32 sender_account_id = 34;
     */
    senderAccountId?: number;
    /**
     * Opaque identifier chosen by the sender to be able to correlate this
     * place order requests with the corresponding fill and place order events.
     *
     * @generated from field: optional uint64 sender_tracking_id = 35;
     */
    senderTrackingId?: bigint;
};
/**
 * Note on order size.
 * Any order being placed has absolute maximum size, which is 2^48-1.
 * Although, this limit is applied not to initial order being placed
 * but to final order being added to market's orderbook.
 * This behavior exists because order can be limited by quote size,
 * which converts to order size in a non-linear manner.
 *
 * Some orders can be executed immediately, in this no order will be added to
 * orderbook, no order id created. Consider using `client_order_id` to track
 * execution of such orders.
 *
 * Example: User posts order with size 2^48+100_000. Order fills counter
 * orders and its size is reduced to 2^48-1_000_000 in process. This order
 * will be added to orderbook successfully despite its initial size is above
 * limit.
 *
 * @generated from message nord.Action.PlaceOrder
 */
export type Action_PlaceOrderJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId?: number;
    /**
     * @generated from field: nord.Side side = 3;
     */
    side?: SideJson;
    /**
     * @generated from field: nord.FillMode fill_mode = 4;
     */
    fillMode?: FillModeJson;
    /**
     * A reduce-only order only reduces your current position, as opposed to
     * increasing it. It means you can only use it to close a position. In
     * contrast, non-reduce-only orders can reduce or increase your position.
     * Reduce is handled by dynamically reducing or adjusting limit order's
     * contract quantity
     * / to match the contract size of the open position.
     *
     * @generated from field: bool is_reduce_only = 5;
     */
    isReduceOnly?: boolean;
    /**
     * Raw integral value of order limit price.
     * `1` here equals to market's `10^-price_decimals`
     * When used in token balances and reward computations, shifted by market's
     * `price_decimals`. Optional, treated as not set if 0.
     *
     * @generated from field: uint64 price = 6;
     */
    price?: string;
    /**
     * Raw integral value of order size limit.
     * For spot markers measured in base size,
     * for perpetuals in contract token.
     * So using base as default naming in codebase.
     * `1` here equals to market's `10^-size_decimals`
     * When used in token balances and reward computations, shifted by market's
     * `size_decimals`. Optional, treated as not set if 0.
     *
     * @generated from field: uint64 size = 7;
     */
    size?: string;
    /**
     * Quote size limit.
     * Optional.
     *
     * @generated from field: nord.QuoteSize quote_size = 8;
     */
    quoteSize?: QuoteSizeJson;
    /**
     * Optional account on behalf of whom the order should be placed.
     * Executed only if sender has delegated authority to do so,
     * like admin user or liquidator bot.
     * # Delegation allowed if:
     * - trigger
     * - reduce bad position
     * - sell at good price to reduce if cannot cover bad position
     *
     * @generated from field: optional uint32 delegator_account_id = 32;
     */
    delegatorAccountId?: number;
    /**
     * Caller provided opaque order identifier up to 8 bytes.
     * Not used by engine, but can be used by client to track orders.
     *
     * @generated from field: optional uint64 client_order_id = 33;
     */
    clientOrderId?: string;
    /**
     * Account id which performs operation;
     * if not specified, first account of session's owner user is picked
     *
     * @generated from field: optional uint32 sender_account_id = 34;
     */
    senderAccountId?: number;
    /**
     * Opaque identifier chosen by the sender to be able to correlate this
     * place order requests with the corresponding fill and place order events.
     *
     * @generated from field: optional uint64 sender_tracking_id = 35;
     */
    senderTrackingId?: string;
};
/**
 * Describes the message nord.Action.PlaceOrder.
 * Use `create(Action_PlaceOrderSchema)` to create a new message.
 */
export declare const Action_PlaceOrderSchema: GenMessage<Action_PlaceOrder, {
    jsonType: Action_PlaceOrderJson;
}>;
/**
 * @generated from message nord.Action.CancelOrderById
 */
export type Action_CancelOrderById = Message<"nord.Action.CancelOrderById"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
    /**
     * @generated from field: uint64 order_id = 2;
     */
    orderId: bigint;
    /**
     * @generated from field: optional uint32 delegator_account_id = 32;
     */
    delegatorAccountId?: number;
    /**
     * @generated from field: optional uint32 sender_account_id = 33;
     */
    senderAccountId?: number;
};
/**
 * @generated from message nord.Action.CancelOrderById
 */
export type Action_CancelOrderByIdJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
    /**
     * @generated from field: uint64 order_id = 2;
     */
    orderId?: string;
    /**
     * @generated from field: optional uint32 delegator_account_id = 32;
     */
    delegatorAccountId?: number;
    /**
     * @generated from field: optional uint32 sender_account_id = 33;
     */
    senderAccountId?: number;
};
/**
 * Describes the message nord.Action.CancelOrderById.
 * Use `create(Action_CancelOrderByIdSchema)` to create a new message.
 */
export declare const Action_CancelOrderByIdSchema: GenMessage<Action_CancelOrderById, {
    jsonType: Action_CancelOrderByIdJson;
}>;
/**
 * @generated from message nord.Action.CancelOrderByClientId
 */
export type Action_CancelOrderByClientId = Message<"nord.Action.CancelOrderByClientId"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
    /**
     * @generated from field: uint64 client_order_id = 2;
     */
    clientOrderId: bigint;
    /**
     * @generated from field: optional uint32 sender_account_id = 3;
     */
    senderAccountId?: number;
};
/**
 * @generated from message nord.Action.CancelOrderByClientId
 */
export type Action_CancelOrderByClientIdJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
    /**
     * @generated from field: uint64 client_order_id = 2;
     */
    clientOrderId?: string;
    /**
     * @generated from field: optional uint32 sender_account_id = 3;
     */
    senderAccountId?: number;
};
/**
 * Describes the message nord.Action.CancelOrderByClientId.
 * Use `create(Action_CancelOrderByClientIdSchema)` to create a new message.
 */
export declare const Action_CancelOrderByClientIdSchema: GenMessage<Action_CancelOrderByClientId, {
    jsonType: Action_CancelOrderByClientIdJson;
}>;
/**
 * @generated from message nord.Action.Deposit
 */
export type Action_Deposit = Message<"nord.Action.Deposit"> & {
    /**
     * used for integration of rollup with nord app
     *
     * @generated from field: uint64 action_nonce = 1;
     */
    actionNonce: bigint;
    /**
     * @generated from field: bytes token_addr = 2;
     */
    tokenAddr: Uint8Array;
    /**
     * Shifted by the token's decimals.
     *
     * @generated from field: uint64 amount = 3;
     */
    amount: bigint;
    /**
     * Recipient's ed25519 registration public key, 32 bytes long
     *
     * @generated from field: bytes user_pubkey = 4;
     */
    userPubkey: Uint8Array;
    /**
     * Sender's ed25519 public key. Unused in nord, but must be forwarded
     * through the system.
     *
     * @generated from field: bytes sender_pubkey = 5;
     */
    senderPubkey: Uint8Array;
};
/**
 * @generated from message nord.Action.Deposit
 */
export type Action_DepositJson = {
    /**
     * used for integration of rollup with nord app
     *
     * @generated from field: uint64 action_nonce = 1;
     */
    actionNonce?: string;
    /**
     * @generated from field: bytes token_addr = 2;
     */
    tokenAddr?: string;
    /**
     * Shifted by the token's decimals.
     *
     * @generated from field: uint64 amount = 3;
     */
    amount?: string;
    /**
     * Recipient's ed25519 registration public key, 32 bytes long
     *
     * @generated from field: bytes user_pubkey = 4;
     */
    userPubkey?: string;
    /**
     * Sender's ed25519 public key. Unused in nord, but must be forwarded
     * through the system.
     *
     * @generated from field: bytes sender_pubkey = 5;
     */
    senderPubkey?: string;
};
/**
 * Describes the message nord.Action.Deposit.
 * Use `create(Action_DepositSchema)` to create a new message.
 */
export declare const Action_DepositSchema: GenMessage<Action_Deposit, {
    jsonType: Action_DepositJson;
}>;
/**
 * todo(n1): when gate will be here, remove or replace internals with message
 *
 * @generated from message nord.Action.Withdraw
 */
export type Action_Withdraw = Message<"nord.Action.Withdraw"> & {
    /**
     * @generated from field: uint32 token_id = 1;
     */
    tokenId: number;
    /**
     * @generated from field: uint64 session_id = 2;
     */
    sessionId: bigint;
    /**
     * Shifted by the token's decimals.
     *
     * @generated from field: uint64 amount = 3;
     */
    amount: bigint;
    /**
     * @generated from field: optional bytes dest_pubkey = 4;
     */
    destPubkey?: Uint8Array;
};
/**
 * todo(n1): when gate will be here, remove or replace internals with message
 *
 * @generated from message nord.Action.Withdraw
 */
export type Action_WithdrawJson = {
    /**
     * @generated from field: uint32 token_id = 1;
     */
    tokenId?: number;
    /**
     * @generated from field: uint64 session_id = 2;
     */
    sessionId?: string;
    /**
     * Shifted by the token's decimals.
     *
     * @generated from field: uint64 amount = 3;
     */
    amount?: string;
    /**
     * @generated from field: optional bytes dest_pubkey = 4;
     */
    destPubkey?: string;
};
/**
 * Describes the message nord.Action.Withdraw.
 * Use `create(Action_WithdrawSchema)` to create a new message.
 */
export declare const Action_WithdrawSchema: GenMessage<Action_Withdraw, {
    jsonType: Action_WithdrawJson;
}>;
/**
 * @generated from message nord.Action.PythSetWormholeGuardians
 */
export type Action_PythSetWormholeGuardians = Message<"nord.Action.PythSetWormholeGuardians"> & {
    /**
     * See
     * https://docs.wormholescan.io/#/Guardian/guardian-set
     *
     * @generated from field: uint32 guardian_set_index = 1;
     */
    guardianSetIndex: number;
    /**
     * Each address is 20 bytes, consisting of the last 20 bytes
     * of the keccak256 hash of the public key of the guardian.
     *
     * @generated from field: repeated bytes addresses = 2;
     */
    addresses: Uint8Array[];
    /**
     * @generated from field: bytes acl_pubkey = 3;
     */
    aclPubkey: Uint8Array;
};
/**
 * @generated from message nord.Action.PythSetWormholeGuardians
 */
export type Action_PythSetWormholeGuardiansJson = {
    /**
     * See
     * https://docs.wormholescan.io/#/Guardian/guardian-set
     *
     * @generated from field: uint32 guardian_set_index = 1;
     */
    guardianSetIndex?: number;
    /**
     * Each address is 20 bytes, consisting of the last 20 bytes
     * of the keccak256 hash of the public key of the guardian.
     *
     * @generated from field: repeated bytes addresses = 2;
     */
    addresses?: string[];
    /**
     * @generated from field: bytes acl_pubkey = 3;
     */
    aclPubkey?: string;
};
/**
 * Describes the message nord.Action.PythSetWormholeGuardians.
 * Use `create(Action_PythSetWormholeGuardiansSchema)` to create a new message.
 */
export declare const Action_PythSetWormholeGuardiansSchema: GenMessage<Action_PythSetWormholeGuardians, {
    jsonType: Action_PythSetWormholeGuardiansJson;
}>;
/**
 * Associate a oracle symbol to a Pyth Feed ID.
 *
 * @generated from message nord.Action.PythSetSymbolFeed
 */
export type Action_PythSetSymbolFeed = Message<"nord.Action.PythSetSymbolFeed"> & {
    /**
     * @generated from field: string oracle_symbol = 1;
     */
    oracleSymbol: string;
    /**
     * MUST be 32 bytes.
     *
     * @generated from field: bytes price_feed_id = 2;
     */
    priceFeedId: Uint8Array;
    /**
     * @generated from field: bytes acl_pubkey = 3;
     */
    aclPubkey: Uint8Array;
};
/**
 * Associate a oracle symbol to a Pyth Feed ID.
 *
 * @generated from message nord.Action.PythSetSymbolFeed
 */
export type Action_PythSetSymbolFeedJson = {
    /**
     * @generated from field: string oracle_symbol = 1;
     */
    oracleSymbol?: string;
    /**
     * MUST be 32 bytes.
     *
     * @generated from field: bytes price_feed_id = 2;
     */
    priceFeedId?: string;
    /**
     * @generated from field: bytes acl_pubkey = 3;
     */
    aclPubkey?: string;
};
/**
 * Describes the message nord.Action.PythSetSymbolFeed.
 * Use `create(Action_PythSetSymbolFeedSchema)` to create a new message.
 */
export declare const Action_PythSetSymbolFeedSchema: GenMessage<Action_PythSetSymbolFeed, {
    jsonType: Action_PythSetSymbolFeedJson;
}>;
/**
 * @generated from message nord.Action.PythPriceFeedUpdate
 */
export type Action_PythPriceFeedUpdate = Message<"nord.Action.PythPriceFeedUpdate"> & {
    /**
     * See https://hermes.pyth.network/docs/#/rest/latest_price_updates
     *
     * @generated from field: bytes raw_pythnet_data = 1;
     */
    rawPythnetData: Uint8Array;
};
/**
 * @generated from message nord.Action.PythPriceFeedUpdate
 */
export type Action_PythPriceFeedUpdateJson = {
    /**
     * See https://hermes.pyth.network/docs/#/rest/latest_price_updates
     *
     * @generated from field: bytes raw_pythnet_data = 1;
     */
    rawPythnetData?: string;
};
/**
 * Describes the message nord.Action.PythPriceFeedUpdate.
 * Use `create(Action_PythPriceFeedUpdateSchema)` to create a new message.
 */
export declare const Action_PythPriceFeedUpdateSchema: GenMessage<Action_PythPriceFeedUpdate, {
    jsonType: Action_PythPriceFeedUpdateJson;
}>;
/**
 * Perform final account liquidation procedure.
 * Can be executed only accounts with AV < 0 (bankrupt).
 * After execution, `liquidatee_account_id` is removed from state.
 * See MARKETS.md `Bankruptcy` for details.
 *
 * @generated from message nord.Action.Liquidate
 */
export type Action_Liquidate = Message<"nord.Action.Liquidate"> & {
    /**
     * @generated from field: uint64 liquidator_session_id = 1;
     */
    liquidatorSessionId: bigint;
    /**
     * @generated from field: uint32 liquidatee_account_id = 2;
     */
    liquidateeAccountId: number;
    /**
     * @generated from field: optional uint32 liquidator_account_id = 3;
     */
    liquidatorAccountId?: number;
};
/**
 * Perform final account liquidation procedure.
 * Can be executed only accounts with AV < 0 (bankrupt).
 * After execution, `liquidatee_account_id` is removed from state.
 * See MARKETS.md `Bankruptcy` for details.
 *
 * @generated from message nord.Action.Liquidate
 */
export type Action_LiquidateJson = {
    /**
     * @generated from field: uint64 liquidator_session_id = 1;
     */
    liquidatorSessionId?: string;
    /**
     * @generated from field: uint32 liquidatee_account_id = 2;
     */
    liquidateeAccountId?: number;
    /**
     * @generated from field: optional uint32 liquidator_account_id = 3;
     */
    liquidatorAccountId?: number;
};
/**
 * Describes the message nord.Action.Liquidate.
 * Use `create(Action_LiquidateSchema)` to create a new message.
 */
export declare const Action_LiquidateSchema: GenMessage<Action_Liquidate, {
    jsonType: Action_LiquidateJson;
}>;
/**
 * @generated from message nord.Action.RevokeSession
 */
export type Action_RevokeSession = Message<"nord.Action.RevokeSession"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
};
/**
 * @generated from message nord.Action.RevokeSession
 */
export type Action_RevokeSessionJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
};
/**
 * Describes the message nord.Action.RevokeSession.
 * Use `create(Action_RevokeSessionSchema)` to create a new message.
 */
export declare const Action_RevokeSessionSchema: GenMessage<Action_RevokeSession, {
    jsonType: Action_RevokeSessionJson;
}>;
/**
 * The engine fails with a maintenance error while paused.
 *
 * @generated from message nord.Action.Pause
 */
export type Action_Pause = Message<"nord.Action.Pause"> & {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey: Uint8Array;
};
/**
 * The engine fails with a maintenance error while paused.
 *
 * @generated from message nord.Action.Pause
 */
export type Action_PauseJson = {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey?: string;
};
/**
 * Describes the message nord.Action.Pause.
 * Use `create(Action_PauseSchema)` to create a new message.
 */
export declare const Action_PauseSchema: GenMessage<Action_Pause, {
    jsonType: Action_PauseJson;
}>;
/**
 * @generated from message nord.Action.Unpause
 */
export type Action_Unpause = Message<"nord.Action.Unpause"> & {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey: Uint8Array;
};
/**
 * @generated from message nord.Action.Unpause
 */
export type Action_UnpauseJson = {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey?: string;
};
/**
 * Describes the message nord.Action.Unpause.
 * Use `create(Action_UnpauseSchema)` to create a new message.
 */
export declare const Action_UnpauseSchema: GenMessage<Action_Unpause, {
    jsonType: Action_UnpauseJson;
}>;
/**
 * Transfers tokens to specified account.
 *
 * @generated from message nord.Action.Transfer
 */
export type Action_Transfer = Message<"nord.Action.Transfer"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
    /**
     * @generated from field: uint32 from_account_id = 2;
     */
    fromAccountId: number;
    /**
     * @generated from field: uint32 token_id = 3;
     */
    tokenId: number;
    /**
     * @generated from field: uint64 amount = 4;
     */
    amount: bigint;
    /**
     * If target account id isn't specified, new account is created.
     *
     * @generated from field: optional uint32 to_account_id = 8;
     */
    toAccountId?: number;
    /**
     * If specified, than `to_account_id` must be none.
     * Transfer funds to accounts, for example to cover bankruptcies.
     *
     * @generated from field: optional nord.SpecialAccount special_account = 9;
     */
    specialAccount?: SpecialAccount;
};
/**
 * Transfers tokens to specified account.
 *
 * @generated from message nord.Action.Transfer
 */
export type Action_TransferJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
    /**
     * @generated from field: uint32 from_account_id = 2;
     */
    fromAccountId?: number;
    /**
     * @generated from field: uint32 token_id = 3;
     */
    tokenId?: number;
    /**
     * @generated from field: uint64 amount = 4;
     */
    amount?: string;
    /**
     * If target account id isn't specified, new account is created.
     *
     * @generated from field: optional uint32 to_account_id = 8;
     */
    toAccountId?: number;
    /**
     * If specified, than `to_account_id` must be none.
     * Transfer funds to accounts, for example to cover bankruptcies.
     *
     * @generated from field: optional nord.SpecialAccount special_account = 9;
     */
    specialAccount?: SpecialAccountJson;
};
/**
 * Describes the message nord.Action.Transfer.
 * Use `create(Action_TransferSchema)` to create a new message.
 */
export declare const Action_TransferSchema: GenMessage<Action_Transfer, {
    jsonType: Action_TransferJson;
}>;
/**
 * @generated from message nord.Action.FeeVaultTransfer
 */
export type Action_FeeVaultTransfer = Message<"nord.Action.FeeVaultTransfer"> & {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey: Uint8Array;
    /**
     * @generated from field: uint32 recipient = 2;
     */
    recipient: number;
    /**
     * @generated from field: uint32 token_id = 3;
     */
    tokenId: number;
    /**
     * @generated from field: uint64 amount = 4;
     */
    amount: bigint;
};
/**
 * @generated from message nord.Action.FeeVaultTransfer
 */
export type Action_FeeVaultTransferJson = {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey?: string;
    /**
     * @generated from field: uint32 recipient = 2;
     */
    recipient?: number;
    /**
     * @generated from field: uint32 token_id = 3;
     */
    tokenId?: number;
    /**
     * @generated from field: uint64 amount = 4;
     */
    amount?: string;
};
/**
 * Describes the message nord.Action.FeeVaultTransfer.
 * Use `create(Action_FeeVaultTransferSchema)` to create a new message.
 */
export declare const Action_FeeVaultTransferSchema: GenMessage<Action_FeeVaultTransfer, {
    jsonType: Action_FeeVaultTransferJson;
}>;
/**
 * @generated from message nord.Action.TriggerPrices
 */
export type Action_TriggerPrices = Message<"nord.Action.TriggerPrices"> & {
    /**
     * @generated from field: uint64 trigger_price = 5;
     */
    triggerPrice: bigint;
    /**
     * @generated from field: optional uint64 limit_price = 6;
     */
    limitPrice?: bigint;
};
/**
 * @generated from message nord.Action.TriggerPrices
 */
export type Action_TriggerPricesJson = {
    /**
     * @generated from field: uint64 trigger_price = 5;
     */
    triggerPrice?: string;
    /**
     * @generated from field: optional uint64 limit_price = 6;
     */
    limitPrice?: string;
};
/**
 * Describes the message nord.Action.TriggerPrices.
 * Use `create(Action_TriggerPricesSchema)` to create a new message.
 */
export declare const Action_TriggerPricesSchema: GenMessage<Action_TriggerPrices, {
    jsonType: Action_TriggerPricesJson;
}>;
/**
 * @generated from message nord.Action.AddTrigger
 */
export type Action_AddTrigger = Message<"nord.Action.AddTrigger"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId: number;
    /**
     * @generated from field: nord.TriggerKey key = 3;
     */
    key?: TriggerKey;
    /**
     * @generated from field: nord.Action.TriggerPrices prices = 4;
     */
    prices?: Action_TriggerPrices;
    /**
     * @generated from field: optional uint32 account_id = 10;
     */
    accountId?: number;
};
/**
 * @generated from message nord.Action.AddTrigger
 */
export type Action_AddTriggerJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId?: number;
    /**
     * @generated from field: nord.TriggerKey key = 3;
     */
    key?: TriggerKeyJson;
    /**
     * @generated from field: nord.Action.TriggerPrices prices = 4;
     */
    prices?: Action_TriggerPricesJson;
    /**
     * @generated from field: optional uint32 account_id = 10;
     */
    accountId?: number;
};
/**
 * Describes the message nord.Action.AddTrigger.
 * Use `create(Action_AddTriggerSchema)` to create a new message.
 */
export declare const Action_AddTriggerSchema: GenMessage<Action_AddTrigger, {
    jsonType: Action_AddTriggerJson;
}>;
/**
 * @generated from message nord.Action.RemoveTrigger
 */
export type Action_RemoveTrigger = Message<"nord.Action.RemoveTrigger"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId: number;
    /**
     * @generated from field: nord.TriggerKey key = 3;
     */
    key?: TriggerKey;
    /**
     * @generated from field: optional uint32 account_id = 10;
     */
    accountId?: number;
};
/**
 * @generated from message nord.Action.RemoveTrigger
 */
export type Action_RemoveTriggerJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId?: number;
    /**
     * @generated from field: nord.TriggerKey key = 3;
     */
    key?: TriggerKeyJson;
    /**
     * @generated from field: optional uint32 account_id = 10;
     */
    accountId?: number;
};
/**
 * Describes the message nord.Action.RemoveTrigger.
 * Use `create(Action_RemoveTriggerSchema)` to create a new message.
 */
export declare const Action_RemoveTriggerSchema: GenMessage<Action_RemoveTrigger, {
    jsonType: Action_RemoveTriggerJson;
}>;
/**
 * @generated from message nord.Action.AddFeeTier
 */
export type Action_AddFeeTier = Message<"nord.Action.AddFeeTier"> & {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey: Uint8Array;
    /**
     * @generated from field: nord.FeeTierConfig config = 2;
     */
    config?: FeeTierConfig;
};
/**
 * @generated from message nord.Action.AddFeeTier
 */
export type Action_AddFeeTierJson = {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey?: string;
    /**
     * @generated from field: nord.FeeTierConfig config = 2;
     */
    config?: FeeTierConfigJson;
};
/**
 * Describes the message nord.Action.AddFeeTier.
 * Use `create(Action_AddFeeTierSchema)` to create a new message.
 */
export declare const Action_AddFeeTierSchema: GenMessage<Action_AddFeeTier, {
    jsonType: Action_AddFeeTierJson;
}>;
/**
 * @generated from message nord.Action.UpdateFeeTier
 */
export type Action_UpdateFeeTier = Message<"nord.Action.UpdateFeeTier"> & {
    /**
     * @generated from field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from field: nord.FeeTierConfig config = 2;
     */
    config?: FeeTierConfig;
    /**
     * @generated from field: bytes acl_pubkey = 3;
     */
    aclPubkey: Uint8Array;
};
/**
 * @generated from message nord.Action.UpdateFeeTier
 */
export type Action_UpdateFeeTierJson = {
    /**
     * @generated from field: uint32 id = 1;
     */
    id?: number;
    /**
     * @generated from field: nord.FeeTierConfig config = 2;
     */
    config?: FeeTierConfigJson;
    /**
     * @generated from field: bytes acl_pubkey = 3;
     */
    aclPubkey?: string;
};
/**
 * Describes the message nord.Action.UpdateFeeTier.
 * Use `create(Action_UpdateFeeTierSchema)` to create a new message.
 */
export declare const Action_UpdateFeeTierSchema: GenMessage<Action_UpdateFeeTier, {
    jsonType: Action_UpdateFeeTierJson;
}>;
/**
 * @generated from message nord.Action.UpdateAccountsTier
 */
export type Action_UpdateAccountsTier = Message<"nord.Action.UpdateAccountsTier"> & {
    /**
     * @generated from field: uint32 tier_id = 1;
     */
    tierId: number;
    /**
     * @generated from field: repeated uint32 accounts = 2;
     */
    accounts: number[];
    /**
     * @generated from field: bytes acl_pubkey = 3;
     */
    aclPubkey: Uint8Array;
};
/**
 * @generated from message nord.Action.UpdateAccountsTier
 */
export type Action_UpdateAccountsTierJson = {
    /**
     * @generated from field: uint32 tier_id = 1;
     */
    tierId?: number;
    /**
     * @generated from field: repeated uint32 accounts = 2;
     */
    accounts?: number[];
    /**
     * @generated from field: bytes acl_pubkey = 3;
     */
    aclPubkey?: string;
};
/**
 * Describes the message nord.Action.UpdateAccountsTier.
 * Use `create(Action_UpdateAccountsTierSchema)` to create a new message.
 */
export declare const Action_UpdateAccountsTierSchema: GenMessage<Action_UpdateAccountsTier, {
    jsonType: Action_UpdateAccountsTierJson;
}>;
/**
 * @generated from message nord.Action.UpdateAcl
 */
export type Action_UpdateAcl = Message<"nord.Action.UpdateAcl"> & {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey: Uint8Array;
    /**
     * @generated from field: bytes target_pubkey = 2;
     */
    targetPubkey: Uint8Array;
    /**
     * @generated from field: uint32 roles_mask = 3;
     */
    rolesMask: number;
    /**
     * @generated from field: uint32 roles_value = 4;
     */
    rolesValue: number;
};
/**
 * @generated from message nord.Action.UpdateAcl
 */
export type Action_UpdateAclJson = {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey?: string;
    /**
     * @generated from field: bytes target_pubkey = 2;
     */
    targetPubkey?: string;
    /**
     * @generated from field: uint32 roles_mask = 3;
     */
    rolesMask?: number;
    /**
     * @generated from field: uint32 roles_value = 4;
     */
    rolesValue?: number;
};
/**
 * Describes the message nord.Action.UpdateAcl.
 * Use `create(Action_UpdateAclSchema)` to create a new message.
 */
export declare const Action_UpdateAclSchema: GenMessage<Action_UpdateAcl, {
    jsonType: Action_UpdateAclJson;
}>;
/**
 * @generated from message nord.Action.FreezeMarket
 */
export type Action_FreezeMarket = Message<"nord.Action.FreezeMarket"> & {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey: Uint8Array;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId: number;
};
/**
 * @generated from message nord.Action.FreezeMarket
 */
export type Action_FreezeMarketJson = {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey?: string;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId?: number;
};
/**
 * Describes the message nord.Action.FreezeMarket.
 * Use `create(Action_FreezeMarketSchema)` to create a new message.
 */
export declare const Action_FreezeMarketSchema: GenMessage<Action_FreezeMarket, {
    jsonType: Action_FreezeMarketJson;
}>;
/**
 * @generated from message nord.Action.UnfreezeMarket
 */
export type Action_UnfreezeMarket = Message<"nord.Action.UnfreezeMarket"> & {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey: Uint8Array;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId: number;
};
/**
 * @generated from message nord.Action.UnfreezeMarket
 */
export type Action_UnfreezeMarketJson = {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey?: string;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId?: number;
};
/**
 * Describes the message nord.Action.UnfreezeMarket.
 * Use `create(Action_UnfreezeMarketSchema)` to create a new message.
 */
export declare const Action_UnfreezeMarketSchema: GenMessage<Action_UnfreezeMarket, {
    jsonType: Action_UnfreezeMarketJson;
}>;
/**
 * @generated from message nord.Action.TakePosition
 */
export type Action_TakePosition = Message<"nord.Action.TakePosition"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId: number;
    /**
     * Amount to take.
     *
     * @generated from field: int64 size = 3;
     */
    size: bigint;
    /**
     * Account id which performs operation;
     * if not specified, first account of session's owner user is picked
     *
     * @generated from field: optional uint32 sender_account_id = 4;
     */
    senderAccountId?: number;
    /**
     * If set, then it is take action.
     * If price not so good as in field, take will fail.
     *
     * If not set,
     * will do fill-or-kill order as per liquidation trade rule.
     *
     * @generated from field: optional uint64 price = 5;
     */
    price?: bigint;
};
/**
 * @generated from message nord.Action.TakePosition
 */
export type Action_TakePositionJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId?: number;
    /**
     * Amount to take.
     *
     * @generated from field: int64 size = 3;
     */
    size?: string;
    /**
     * Account id which performs operation;
     * if not specified, first account of session's owner user is picked
     *
     * @generated from field: optional uint32 sender_account_id = 4;
     */
    senderAccountId?: number;
    /**
     * If set, then it is take action.
     * If price not so good as in field, take will fail.
     *
     * If not set,
     * will do fill-or-kill order as per liquidation trade rule.
     *
     * @generated from field: optional uint64 price = 5;
     */
    price?: string;
};
/**
 * Describes the message nord.Action.TakePosition.
 * Use `create(Action_TakePositionSchema)` to create a new message.
 */
export declare const Action_TakePositionSchema: GenMessage<Action_TakePosition, {
    jsonType: Action_TakePositionJson;
}>;
/**
 * @generated from enum nord.Action.UserSignatureFraming
 */
export declare enum Action_UserSignatureFraming {
    /**
     * @generated from enum value: HEX = 0;
     */
    HEX = 0,
    /**
     * @generated from enum value: SOLANA_TRANSACTION = 1;
     */
    SOLANA_TRANSACTION = 1
}
/**
 * @generated from enum nord.Action.UserSignatureFraming
 */
export type Action_UserSignatureFramingJson = "HEX" | "SOLANA_TRANSACTION";
/**
 * Describes the enum nord.Action.UserSignatureFraming.
 */
export declare const Action_UserSignatureFramingSchema: GenEnum<Action_UserSignatureFraming, Action_UserSignatureFramingJson>;
/**
 * The response of an action from the engine. Most actions have a corresponding
 * receipt kind, which you can deduce from the naming.
 *
 * @generated from message nord.Receipt
 */
export type Receipt = Message<"nord.Receipt"> & {
    /**
     * Action id which was run to produce this receipt.
     * In case of error it was next action id which did not incremented because of
     * error.
     *
     * @generated from field: uint64 action_id = 1;
     */
    actionId: bigint;
    /**
     * @generated from oneof nord.Receipt.kind
     */
    kind: {
        /**
         * @generated from field: nord.Error err = 32;
         */
        value: Error;
        case: "err";
    } | {
        /**
         * @generated from field: nord.Receipt.CreateSessionResult create_session_result = 33;
         */
        value: Receipt_CreateSessionResult;
        case: "createSessionResult";
    } | {
        /**
         * @generated from field: nord.Receipt.PlaceOrderResult place_order_result = 34;
         */
        value: Receipt_PlaceOrderResult;
        case: "placeOrderResult";
    } | {
        /**
         * @generated from field: nord.Receipt.CancelOrderResult cancel_order_result = 35;
         */
        value: Receipt_CancelOrderResult;
        case: "cancelOrderResult";
    } | {
        /**
         * @generated from field: nord.Receipt.DepositResult deposit_result = 36;
         */
        value: Receipt_DepositResult;
        case: "depositResult";
    } | {
        /**
         * @generated from field: nord.Receipt.InsertTokenResult insert_token_result = 37;
         */
        value: Receipt_InsertTokenResult;
        case: "insertTokenResult";
    } | {
        /**
         * @generated from field: nord.Receipt.InsertMarketResult insert_market_result = 38;
         */
        value: Receipt_InsertMarketResult;
        case: "insertMarketResult";
    } | {
        /**
         * @generated from field: nord.Receipt.WithdrawResult withdraw_result = 39;
         */
        value: Receipt_WithdrawResult;
        case: "withdrawResult";
    } | {
        /**
         * @generated from field: nord.Receipt.OracleSymbolFeedResult oracle_symbol_feed_result = 40;
         */
        value: Receipt_OracleSymbolFeedResult;
        case: "oracleSymbolFeedResult";
    } | {
        /**
         * @generated from field: nord.Receipt.OracleUpdateResult oracle_update_result = 41;
         */
        value: Receipt_OracleUpdateResult;
        case: "oracleUpdateResult";
    } | {
        /**
         * @generated from field: nord.Receipt.UpdateGuardianSetResult update_guardian_set_result = 42;
         */
        value: Receipt_UpdateGuardianSetResult;
        case: "updateGuardianSetResult";
    } | {
        /**
         * @generated from field: nord.Receipt.AccountLiquidated liquidated = 43;
         */
        value: Receipt_AccountLiquidated;
        case: "liquidated";
    } | {
        /**
         * @generated from field: nord.Receipt.SessionRevoked session_revoked = 44;
         */
        value: Receipt_SessionRevoked;
        case: "sessionRevoked";
    } | {
        /**
         * @generated from field: nord.Receipt.Paused paused = 45;
         */
        value: Receipt_Paused;
        case: "paused";
    } | {
        /**
         * @generated from field: nord.Receipt.Unpaused unpaused = 46;
         */
        value: Receipt_Unpaused;
        case: "unpaused";
    } | {
        /**
         * @generated from field: nord.Receipt.Transferred transferred = 47;
         */
        value: Receipt_Transferred;
        case: "transferred";
    } | {
        /**
         * @generated from field: nord.Receipt.TriggerAdded trigger_added = 64;
         */
        value: Receipt_TriggerAdded;
        case: "triggerAdded";
    } | {
        /**
         * @generated from field: nord.Receipt.TriggerRemoved trigger_removed = 65;
         */
        value: Receipt_TriggerRemoved;
        case: "triggerRemoved";
    } | {
        /**
         * @generated from field: nord.Receipt.PositionTakenOrTradedResult position_taken_or_traded = 66;
         */
        value: Receipt_PositionTakenOrTradedResult;
        case: "positionTakenOrTraded";
    } | {
        /**
         * @generated from field: nord.Receipt.AtomicResult atomic = 67;
         */
        value: Receipt_AtomicResult;
        case: "atomic";
    } | {
        /**
         * @generated from field: nord.Receipt.MarketFreezeUpdated market_freeze_updated = 68;
         */
        value: Receipt_MarketFreezeUpdated;
        case: "marketFreezeUpdated";
    } | {
        /**
         * @generated from field: nord.Receipt.FeeTierAdded fee_tier_added = 69;
         */
        value: Receipt_FeeTierAdded;
        case: "feeTierAdded";
    } | {
        /**
         * @generated from field: nord.Receipt.FeeTierUpdated fee_tier_updated = 70;
         */
        value: Receipt_FeeTierUpdated;
        case: "feeTierUpdated";
    } | {
        /**
         * @generated from field: nord.Receipt.AccountsTierUpdated accounts_tier_updated = 71;
         */
        value: Receipt_AccountsTierUpdated;
        case: "accountsTierUpdated";
    } | {
        /**
         * @generated from field: nord.Receipt.AclUpdated acl_updated = 72;
         */
        value: Receipt_AclUpdated;
        case: "aclUpdated";
    } | {
        /**
         * @generated from field: nord.Receipt.FeeVaultTransferred fee_vault_transferred = 73;
         */
        value: Receipt_FeeVaultTransferred;
        case: "feeVaultTransferred";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * The response of an action from the engine. Most actions have a corresponding
 * receipt kind, which you can deduce from the naming.
 *
 * @generated from message nord.Receipt
 */
export type ReceiptJson = {
    /**
     * Action id which was run to produce this receipt.
     * In case of error it was next action id which did not incremented because of
     * error.
     *
     * @generated from field: uint64 action_id = 1;
     */
    actionId?: string;
    /**
     * @generated from field: nord.Error err = 32;
     */
    err?: ErrorJson;
    /**
     * @generated from field: nord.Receipt.CreateSessionResult create_session_result = 33;
     */
    createSessionResult?: Receipt_CreateSessionResultJson;
    /**
     * @generated from field: nord.Receipt.PlaceOrderResult place_order_result = 34;
     */
    placeOrderResult?: Receipt_PlaceOrderResultJson;
    /**
     * @generated from field: nord.Receipt.CancelOrderResult cancel_order_result = 35;
     */
    cancelOrderResult?: Receipt_CancelOrderResultJson;
    /**
     * @generated from field: nord.Receipt.DepositResult deposit_result = 36;
     */
    depositResult?: Receipt_DepositResultJson;
    /**
     * @generated from field: nord.Receipt.InsertTokenResult insert_token_result = 37;
     */
    insertTokenResult?: Receipt_InsertTokenResultJson;
    /**
     * @generated from field: nord.Receipt.InsertMarketResult insert_market_result = 38;
     */
    insertMarketResult?: Receipt_InsertMarketResultJson;
    /**
     * @generated from field: nord.Receipt.WithdrawResult withdraw_result = 39;
     */
    withdrawResult?: Receipt_WithdrawResultJson;
    /**
     * @generated from field: nord.Receipt.OracleSymbolFeedResult oracle_symbol_feed_result = 40;
     */
    oracleSymbolFeedResult?: Receipt_OracleSymbolFeedResultJson;
    /**
     * @generated from field: nord.Receipt.OracleUpdateResult oracle_update_result = 41;
     */
    oracleUpdateResult?: Receipt_OracleUpdateResultJson;
    /**
     * @generated from field: nord.Receipt.UpdateGuardianSetResult update_guardian_set_result = 42;
     */
    updateGuardianSetResult?: Receipt_UpdateGuardianSetResultJson;
    /**
     * @generated from field: nord.Receipt.AccountLiquidated liquidated = 43;
     */
    liquidated?: Receipt_AccountLiquidatedJson;
    /**
     * @generated from field: nord.Receipt.SessionRevoked session_revoked = 44;
     */
    sessionRevoked?: Receipt_SessionRevokedJson;
    /**
     * @generated from field: nord.Receipt.Paused paused = 45;
     */
    paused?: Receipt_PausedJson;
    /**
     * @generated from field: nord.Receipt.Unpaused unpaused = 46;
     */
    unpaused?: Receipt_UnpausedJson;
    /**
     * @generated from field: nord.Receipt.Transferred transferred = 47;
     */
    transferred?: Receipt_TransferredJson;
    /**
     * @generated from field: nord.Receipt.TriggerAdded trigger_added = 64;
     */
    triggerAdded?: Receipt_TriggerAddedJson;
    /**
     * @generated from field: nord.Receipt.TriggerRemoved trigger_removed = 65;
     */
    triggerRemoved?: Receipt_TriggerRemovedJson;
    /**
     * @generated from field: nord.Receipt.PositionTakenOrTradedResult position_taken_or_traded = 66;
     */
    positionTakenOrTraded?: Receipt_PositionTakenOrTradedResultJson;
    /**
     * @generated from field: nord.Receipt.AtomicResult atomic = 67;
     */
    atomic?: Receipt_AtomicResultJson;
    /**
     * @generated from field: nord.Receipt.MarketFreezeUpdated market_freeze_updated = 68;
     */
    marketFreezeUpdated?: Receipt_MarketFreezeUpdatedJson;
    /**
     * @generated from field: nord.Receipt.FeeTierAdded fee_tier_added = 69;
     */
    feeTierAdded?: Receipt_FeeTierAddedJson;
    /**
     * @generated from field: nord.Receipt.FeeTierUpdated fee_tier_updated = 70;
     */
    feeTierUpdated?: Receipt_FeeTierUpdatedJson;
    /**
     * @generated from field: nord.Receipt.AccountsTierUpdated accounts_tier_updated = 71;
     */
    accountsTierUpdated?: Receipt_AccountsTierUpdatedJson;
    /**
     * @generated from field: nord.Receipt.AclUpdated acl_updated = 72;
     */
    aclUpdated?: Receipt_AclUpdatedJson;
    /**
     * @generated from field: nord.Receipt.FeeVaultTransferred fee_vault_transferred = 73;
     */
    feeVaultTransferred?: Receipt_FeeVaultTransferredJson;
};
/**
 * Describes the message nord.Receipt.
 * Use `create(ReceiptSchema)` to create a new message.
 */
export declare const ReceiptSchema: GenMessage<Receipt, {
    jsonType: ReceiptJson;
}>;
/**
 * @generated from message nord.Receipt.Posted
 */
export type Receipt_Posted = Message<"nord.Receipt.Posted"> & {
    /**
     * @generated from field: nord.Side side = 1;
     */
    side: Side;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId: number;
    /**
     * @generated from field: uint64 price = 3;
     */
    price: bigint;
    /**
     * @generated from field: uint64 size = 4;
     */
    size: bigint;
    /**
     * @generated from field: uint64 order_id = 5;
     */
    orderId: bigint;
    /**
     * @generated from field: uint32 account_id = 6;
     */
    accountId: number;
};
/**
 * @generated from message nord.Receipt.Posted
 */
export type Receipt_PostedJson = {
    /**
     * @generated from field: nord.Side side = 1;
     */
    side?: SideJson;
    /**
     * @generated from field: uint32 market_id = 2;
     */
    marketId?: number;
    /**
     * @generated from field: uint64 price = 3;
     */
    price?: string;
    /**
     * @generated from field: uint64 size = 4;
     */
    size?: string;
    /**
     * @generated from field: uint64 order_id = 5;
     */
    orderId?: string;
    /**
     * @generated from field: uint32 account_id = 6;
     */
    accountId?: number;
};
/**
 * Describes the message nord.Receipt.Posted.
 * Use `create(Receipt_PostedSchema)` to create a new message.
 */
export declare const Receipt_PostedSchema: GenMessage<Receipt_Posted, {
    jsonType: Receipt_PostedJson;
}>;
/**
 * @generated from message nord.Receipt.Trade
 */
export type Receipt_Trade = Message<"nord.Receipt.Trade"> & {
    /**
     * @generated from field: uint64 order_id = 2;
     */
    orderId: bigint;
    /**
     * non zero
     *
     * @generated from field: uint64 price = 4;
     */
    price: bigint;
    /**
     * @generated from field: uint64 size = 5;
     */
    size: bigint;
    /**
     * @generated from field: uint32 account_id = 6;
     */
    accountId: number;
};
/**
 * @generated from message nord.Receipt.Trade
 */
export type Receipt_TradeJson = {
    /**
     * @generated from field: uint64 order_id = 2;
     */
    orderId?: string;
    /**
     * non zero
     *
     * @generated from field: uint64 price = 4;
     */
    price?: string;
    /**
     * @generated from field: uint64 size = 5;
     */
    size?: string;
    /**
     * @generated from field: uint32 account_id = 6;
     */
    accountId?: number;
};
/**
 * Describes the message nord.Receipt.Trade.
 * Use `create(Receipt_TradeSchema)` to create a new message.
 */
export declare const Receipt_TradeSchema: GenMessage<Receipt_Trade, {
    jsonType: Receipt_TradeJson;
}>;
/**
 * @generated from message nord.Receipt.CreateSessionResult
 */
export type Receipt_CreateSessionResult = Message<"nord.Receipt.CreateSessionResult"> & {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId: bigint;
};
/**
 * @generated from message nord.Receipt.CreateSessionResult
 */
export type Receipt_CreateSessionResultJson = {
    /**
     * @generated from field: uint64 session_id = 1;
     */
    sessionId?: string;
};
/**
 * Describes the message nord.Receipt.CreateSessionResult.
 * Use `create(Receipt_CreateSessionResultSchema)` to create a new message.
 */
export declare const Receipt_CreateSessionResultSchema: GenMessage<Receipt_CreateSessionResult, {
    jsonType: Receipt_CreateSessionResultJson;
}>;
/**
 * @generated from message nord.Receipt.Triggered
 */
export type Receipt_Triggered = Message<"nord.Receipt.Triggered"> & {
    /**
     * @generated from field: nord.TriggerKind kind = 3;
     */
    kind: TriggerKind;
    /**
     * @generated from field: uint64 trigger_price = 4;
     */
    triggerPrice: bigint;
};
/**
 * @generated from message nord.Receipt.Triggered
 */
export type Receipt_TriggeredJson = {
    /**
     * @generated from field: nord.TriggerKind kind = 3;
     */
    kind?: TriggerKindJson;
    /**
     * @generated from field: uint64 trigger_price = 4;
     */
    triggerPrice?: string;
};
/**
 * Describes the message nord.Receipt.Triggered.
 * Use `create(Receipt_TriggeredSchema)` to create a new message.
 */
export declare const Receipt_TriggeredSchema: GenMessage<Receipt_Triggered, {
    jsonType: Receipt_TriggeredJson;
}>;
/**
 * @generated from message nord.Receipt.PlaceOrderResult
 */
export type Receipt_PlaceOrderResult = Message<"nord.Receipt.PlaceOrderResult"> & {
    /**
     * @generated from field: optional nord.Receipt.Posted posted = 1;
     */
    posted?: Receipt_Posted;
    /**
     * @generated from field: repeated nord.Receipt.Trade fills = 2;
     */
    fills: Receipt_Trade[];
    /**
     * @generated from field: optional uint64 client_order_id = 3;
     */
    clientOrderId?: bigint;
    /**
     * @generated from field: optional uint64 sender_tracking_id = 4;
     */
    senderTrackingId?: bigint;
    /**
     * @generated from field: optional nord.Receipt.Triggered triggered = 5;
     */
    triggered?: Receipt_Triggered;
};
/**
 * @generated from message nord.Receipt.PlaceOrderResult
 */
export type Receipt_PlaceOrderResultJson = {
    /**
     * @generated from field: optional nord.Receipt.Posted posted = 1;
     */
    posted?: Receipt_PostedJson;
    /**
     * @generated from field: repeated nord.Receipt.Trade fills = 2;
     */
    fills?: Receipt_TradeJson[];
    /**
     * @generated from field: optional uint64 client_order_id = 3;
     */
    clientOrderId?: string;
    /**
     * @generated from field: optional uint64 sender_tracking_id = 4;
     */
    senderTrackingId?: string;
    /**
     * @generated from field: optional nord.Receipt.Triggered triggered = 5;
     */
    triggered?: Receipt_TriggeredJson;
};
/**
 * Describes the message nord.Receipt.PlaceOrderResult.
 * Use `create(Receipt_PlaceOrderResultSchema)` to create a new message.
 */
export declare const Receipt_PlaceOrderResultSchema: GenMessage<Receipt_PlaceOrderResult, {
    jsonType: Receipt_PlaceOrderResultJson;
}>;
/**
 * @generated from message nord.Receipt.TakenResult
 */
export type Receipt_TakenResult = Message<"nord.Receipt.TakenResult"> & {
    /**
     * @generated from field: int64 pnl = 1;
     */
    pnl: bigint;
    /**
     * @generated from field: int64 size = 2;
     */
    size: bigint;
    /**
     * @generated from field: uint32 taker_account_id = 3;
     */
    takerAccountId: number;
};
/**
 * @generated from message nord.Receipt.TakenResult
 */
export type Receipt_TakenResultJson = {
    /**
     * @generated from field: int64 pnl = 1;
     */
    pnl?: string;
    /**
     * @generated from field: int64 size = 2;
     */
    size?: string;
    /**
     * @generated from field: uint32 taker_account_id = 3;
     */
    takerAccountId?: number;
};
/**
 * Describes the message nord.Receipt.TakenResult.
 * Use `create(Receipt_TakenResultSchema)` to create a new message.
 */
export declare const Receipt_TakenResultSchema: GenMessage<Receipt_TakenResult, {
    jsonType: Receipt_TakenResultJson;
}>;
/**
 * @generated from message nord.Receipt.PositionTakenOrTradedResult
 */
export type Receipt_PositionTakenOrTradedResult = Message<"nord.Receipt.PositionTakenOrTradedResult"> & {
    /**
     * @generated from field: uint32 market_id = 1;
     */
    marketId: number;
    /**
     * @generated from oneof nord.Receipt.PositionTakenOrTradedResult.PositionTakenOrTradedKind
     */
    PositionTakenOrTradedKind: {
        /**
         * @generated from field: nord.Receipt.TakenResult taken = 2;
         */
        value: Receipt_TakenResult;
        case: "taken";
    } | {
        /**
         * non empty if trade immediately
         *
         * @generated from field: nord.Receipt.PlaceOrderResult traded = 3;
         */
        value: Receipt_PlaceOrderResult;
        case: "traded";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * @generated from message nord.Receipt.PositionTakenOrTradedResult
 */
export type Receipt_PositionTakenOrTradedResultJson = {
    /**
     * @generated from field: uint32 market_id = 1;
     */
    marketId?: number;
    /**
     * @generated from field: nord.Receipt.TakenResult taken = 2;
     */
    taken?: Receipt_TakenResultJson;
    /**
     * non empty if trade immediately
     *
     * @generated from field: nord.Receipt.PlaceOrderResult traded = 3;
     */
    traded?: Receipt_PlaceOrderResultJson;
};
/**
 * Describes the message nord.Receipt.PositionTakenOrTradedResult.
 * Use `create(Receipt_PositionTakenOrTradedResultSchema)` to create a new message.
 */
export declare const Receipt_PositionTakenOrTradedResultSchema: GenMessage<Receipt_PositionTakenOrTradedResult, {
    jsonType: Receipt_PositionTakenOrTradedResultJson;
}>;
/**
 * @generated from message nord.Receipt.CancelOrderResult
 */
export type Receipt_CancelOrderResult = Message<"nord.Receipt.CancelOrderResult"> & {
    /**
     * @generated from field: uint64 order_id = 1;
     */
    orderId: bigint;
    /**
     * Account from which order was cancelled
     *
     * @generated from field: uint32 account_id = 2;
     */
    accountId: number;
};
/**
 * @generated from message nord.Receipt.CancelOrderResult
 */
export type Receipt_CancelOrderResultJson = {
    /**
     * @generated from field: uint64 order_id = 1;
     */
    orderId?: string;
    /**
     * Account from which order was cancelled
     *
     * @generated from field: uint32 account_id = 2;
     */
    accountId?: number;
};
/**
 * Describes the message nord.Receipt.CancelOrderResult.
 * Use `create(Receipt_CancelOrderResultSchema)` to create a new message.
 */
export declare const Receipt_CancelOrderResultSchema: GenMessage<Receipt_CancelOrderResult, {
    jsonType: Receipt_CancelOrderResultJson;
}>;
/**
 * @generated from message nord.Receipt.DepositResult
 */
export type Receipt_DepositResult = Message<"nord.Receipt.DepositResult"> & {
    /**
     * @generated from field: uint32 token_id = 1;
     */
    tokenId: number;
    /**
     * @generated from field: uint64 amount = 2;
     */
    amount: bigint;
    /**
     * Default account of newly created or existing user
     *
     * @generated from field: uint32 account_id = 3;
     */
    accountId: number;
    /**
     * @generated from field: bool user_created = 4;
     */
    userCreated: boolean;
    /**
     * @generated from field: bytes user_pubkey = 5;
     */
    userPubkey: Uint8Array;
};
/**
 * @generated from message nord.Receipt.DepositResult
 */
export type Receipt_DepositResultJson = {
    /**
     * @generated from field: uint32 token_id = 1;
     */
    tokenId?: number;
    /**
     * @generated from field: uint64 amount = 2;
     */
    amount?: string;
    /**
     * Default account of newly created or existing user
     *
     * @generated from field: uint32 account_id = 3;
     */
    accountId?: number;
    /**
     * @generated from field: bool user_created = 4;
     */
    userCreated?: boolean;
    /**
     * @generated from field: bytes user_pubkey = 5;
     */
    userPubkey?: string;
};
/**
 * Describes the message nord.Receipt.DepositResult.
 * Use `create(Receipt_DepositResultSchema)` to create a new message.
 */
export declare const Receipt_DepositResultSchema: GenMessage<Receipt_DepositResult, {
    jsonType: Receipt_DepositResultJson;
}>;
/**
 * @generated from message nord.Receipt.InsertTokenResult
 */
export type Receipt_InsertTokenResult = Message<"nord.Receipt.InsertTokenResult"> & {
    /**
     * @generated from field: bytes chain_addr = 1;
     */
    chainAddr: Uint8Array;
    /**
     * @generated from field: nord.Token token = 2;
     */
    token?: Token;
};
/**
 * @generated from message nord.Receipt.InsertTokenResult
 */
export type Receipt_InsertTokenResultJson = {
    /**
     * @generated from field: bytes chain_addr = 1;
     */
    chainAddr?: string;
    /**
     * @generated from field: nord.Token token = 2;
     */
    token?: TokenJson;
};
/**
 * Describes the message nord.Receipt.InsertTokenResult.
 * Use `create(Receipt_InsertTokenResultSchema)` to create a new message.
 */
export declare const Receipt_InsertTokenResultSchema: GenMessage<Receipt_InsertTokenResult, {
    jsonType: Receipt_InsertTokenResultJson;
}>;
/**
 * @generated from message nord.Receipt.InsertMarketResult
 */
export type Receipt_InsertMarketResult = Message<"nord.Receipt.InsertMarketResult"> & {
    /**
     * @generated from field: nord.Market market = 1;
     */
    market?: Market;
};
/**
 * @generated from message nord.Receipt.InsertMarketResult
 */
export type Receipt_InsertMarketResultJson = {
    /**
     * @generated from field: nord.Market market = 1;
     */
    market?: MarketJson;
};
/**
 * Describes the message nord.Receipt.InsertMarketResult.
 * Use `create(Receipt_InsertMarketResultSchema)` to create a new message.
 */
export declare const Receipt_InsertMarketResultSchema: GenMessage<Receipt_InsertMarketResult, {
    jsonType: Receipt_InsertMarketResultJson;
}>;
/**
 * @generated from message nord.Receipt.WithdrawResult
 */
export type Receipt_WithdrawResult = Message<"nord.Receipt.WithdrawResult"> & {
    /**
     * @generated from field: uint32 token_id = 1;
     */
    tokenId: number;
    /**
     * @generated from field: uint64 amount = 2;
     */
    amount: bigint;
    /**
     * @generated from field: uint64 balance = 3;
     */
    balance: bigint;
    /**
     * @generated from field: uint32 account_id = 4;
     */
    accountId: number;
    /**
     * @generated from field: uint64 fee = 5;
     */
    fee: bigint;
    /**
     * @generated from field: bytes user_pubkey = 6;
     */
    userPubkey: Uint8Array;
};
/**
 * @generated from message nord.Receipt.WithdrawResult
 */
export type Receipt_WithdrawResultJson = {
    /**
     * @generated from field: uint32 token_id = 1;
     */
    tokenId?: number;
    /**
     * @generated from field: uint64 amount = 2;
     */
    amount?: string;
    /**
     * @generated from field: uint64 balance = 3;
     */
    balance?: string;
    /**
     * @generated from field: uint32 account_id = 4;
     */
    accountId?: number;
    /**
     * @generated from field: uint64 fee = 5;
     */
    fee?: string;
    /**
     * @generated from field: bytes user_pubkey = 6;
     */
    userPubkey?: string;
};
/**
 * Describes the message nord.Receipt.WithdrawResult.
 * Use `create(Receipt_WithdrawResultSchema)` to create a new message.
 */
export declare const Receipt_WithdrawResultSchema: GenMessage<Receipt_WithdrawResult, {
    jsonType: Receipt_WithdrawResultJson;
}>;
/**
 * pyth receipts are not user facing, so they can be terse and optional
 *
 * @generated from message nord.Receipt.OracleSymbolFeedResult
 */
export type Receipt_OracleSymbolFeedResult = Message<"nord.Receipt.OracleSymbolFeedResult"> & {
    /**
     * @generated from field: string oracle_symbol = 1;
     */
    oracleSymbol: string;
    /**
     * @generated from field: bytes feed_id = 2;
     */
    feedId: Uint8Array;
};
/**
 * pyth receipts are not user facing, so they can be terse and optional
 *
 * @generated from message nord.Receipt.OracleSymbolFeedResult
 */
export type Receipt_OracleSymbolFeedResultJson = {
    /**
     * @generated from field: string oracle_symbol = 1;
     */
    oracleSymbol?: string;
    /**
     * @generated from field: bytes feed_id = 2;
     */
    feedId?: string;
};
/**
 * Describes the message nord.Receipt.OracleSymbolFeedResult.
 * Use `create(Receipt_OracleSymbolFeedResultSchema)` to create a new message.
 */
export declare const Receipt_OracleSymbolFeedResultSchema: GenMessage<Receipt_OracleSymbolFeedResult, {
    jsonType: Receipt_OracleSymbolFeedResultJson;
}>;
/**
 * @generated from message nord.Receipt.OracleUpdateResult
 */
export type Receipt_OracleUpdateResult = Message<"nord.Receipt.OracleUpdateResult"> & {
    /**
     * @generated from field: int64 timestamp = 1;
     */
    timestamp: bigint;
};
/**
 * @generated from message nord.Receipt.OracleUpdateResult
 */
export type Receipt_OracleUpdateResultJson = {
    /**
     * @generated from field: int64 timestamp = 1;
     */
    timestamp?: string;
};
/**
 * Describes the message nord.Receipt.OracleUpdateResult.
 * Use `create(Receipt_OracleUpdateResultSchema)` to create a new message.
 */
export declare const Receipt_OracleUpdateResultSchema: GenMessage<Receipt_OracleUpdateResult, {
    jsonType: Receipt_OracleUpdateResultJson;
}>;
/**
 * @generated from message nord.Receipt.UpdateGuardianSetResult
 */
export type Receipt_UpdateGuardianSetResult = Message<"nord.Receipt.UpdateGuardianSetResult"> & {
    /**
     * @generated from field: uint32 guardian_set_index = 1;
     */
    guardianSetIndex: number;
    /**
     * @generated from field: repeated bytes addresses = 2;
     */
    addresses: Uint8Array[];
};
/**
 * @generated from message nord.Receipt.UpdateGuardianSetResult
 */
export type Receipt_UpdateGuardianSetResultJson = {
    /**
     * @generated from field: uint32 guardian_set_index = 1;
     */
    guardianSetIndex?: number;
    /**
     * @generated from field: repeated bytes addresses = 2;
     */
    addresses?: string[];
};
/**
 * Describes the message nord.Receipt.UpdateGuardianSetResult.
 * Use `create(Receipt_UpdateGuardianSetResultSchema)` to create a new message.
 */
export declare const Receipt_UpdateGuardianSetResultSchema: GenMessage<Receipt_UpdateGuardianSetResult, {
    jsonType: Receipt_UpdateGuardianSetResultJson;
}>;
/**
 * @generated from message nord.Receipt.PerpPosition
 */
export type Receipt_PerpPosition = Message<"nord.Receipt.PerpPosition"> & {
    /**
     * @generated from field: uint32 market_id = 1;
     */
    marketId: number;
    /**
     * @generated from field: int64 base_size = 2;
     */
    baseSize: bigint;
    /**
     * @generated from field: uint64 price = 3;
     */
    price: bigint;
};
/**
 * @generated from message nord.Receipt.PerpPosition
 */
export type Receipt_PerpPositionJson = {
    /**
     * @generated from field: uint32 market_id = 1;
     */
    marketId?: number;
    /**
     * @generated from field: int64 base_size = 2;
     */
    baseSize?: string;
    /**
     * @generated from field: uint64 price = 3;
     */
    price?: string;
};
/**
 * Describes the message nord.Receipt.PerpPosition.
 * Use `create(Receipt_PerpPositionSchema)` to create a new message.
 */
export declare const Receipt_PerpPositionSchema: GenMessage<Receipt_PerpPosition, {
    jsonType: Receipt_PerpPositionJson;
}>;
/**
 * / Result of bankruptcy liquidation.
 *
 * @generated from message nord.Receipt.AccountLiquidated
 */
export type Receipt_AccountLiquidated = Message<"nord.Receipt.AccountLiquidated"> & {
    /**
     * @generated from field: uint32 liquidator_account_id = 1;
     */
    liquidatorAccountId: number;
    /**
     * @generated from field: uint32 liquidatee_account_id = 2;
     */
    liquidateeAccountId: number;
    /**
     * @generated from field: repeated uint64 cancelled_orders = 3;
     */
    cancelledOrders: bigint[];
    /**
     * @generated from field: repeated nord.Receipt.PerpPosition removed_perps = 4;
     */
    removedPerps: Receipt_PerpPosition[];
};
/**
 * / Result of bankruptcy liquidation.
 *
 * @generated from message nord.Receipt.AccountLiquidated
 */
export type Receipt_AccountLiquidatedJson = {
    /**
     * @generated from field: uint32 liquidator_account_id = 1;
     */
    liquidatorAccountId?: number;
    /**
     * @generated from field: uint32 liquidatee_account_id = 2;
     */
    liquidateeAccountId?: number;
    /**
     * @generated from field: repeated uint64 cancelled_orders = 3;
     */
    cancelledOrders?: string[];
    /**
     * @generated from field: repeated nord.Receipt.PerpPosition removed_perps = 4;
     */
    removedPerps?: Receipt_PerpPositionJson[];
};
/**
 * Describes the message nord.Receipt.AccountLiquidated.
 * Use `create(Receipt_AccountLiquidatedSchema)` to create a new message.
 */
export declare const Receipt_AccountLiquidatedSchema: GenMessage<Receipt_AccountLiquidated, {
    jsonType: Receipt_AccountLiquidatedJson;
}>;
/**
 * @generated from message nord.Receipt.SessionRevoked
 */
export type Receipt_SessionRevoked = Message<"nord.Receipt.SessionRevoked"> & {};
/**
 * @generated from message nord.Receipt.SessionRevoked
 */
export type Receipt_SessionRevokedJson = {};
/**
 * Describes the message nord.Receipt.SessionRevoked.
 * Use `create(Receipt_SessionRevokedSchema)` to create a new message.
 */
export declare const Receipt_SessionRevokedSchema: GenMessage<Receipt_SessionRevoked, {
    jsonType: Receipt_SessionRevokedJson;
}>;
/**
 * @generated from message nord.Receipt.Paused
 */
export type Receipt_Paused = Message<"nord.Receipt.Paused"> & {};
/**
 * @generated from message nord.Receipt.Paused
 */
export type Receipt_PausedJson = {};
/**
 * Describes the message nord.Receipt.Paused.
 * Use `create(Receipt_PausedSchema)` to create a new message.
 */
export declare const Receipt_PausedSchema: GenMessage<Receipt_Paused, {
    jsonType: Receipt_PausedJson;
}>;
/**
 * @generated from message nord.Receipt.Unpaused
 */
export type Receipt_Unpaused = Message<"nord.Receipt.Unpaused"> & {};
/**
 * @generated from message nord.Receipt.Unpaused
 */
export type Receipt_UnpausedJson = {};
/**
 * Describes the message nord.Receipt.Unpaused.
 * Use `create(Receipt_UnpausedSchema)` to create a new message.
 */
export declare const Receipt_UnpausedSchema: GenMessage<Receipt_Unpaused, {
    jsonType: Receipt_UnpausedJson;
}>;
/**
 * @generated from message nord.Receipt.Transferred
 */
export type Receipt_Transferred = Message<"nord.Receipt.Transferred"> & {
    /**
     * @generated from field: uint32 from_account_id = 1;
     */
    fromAccountId: number;
    /**
     * @generated from field: optional uint32 to_user_account = 2;
     */
    toUserAccount?: number;
    /**
     * @generated from field: uint32 token_id = 3;
     */
    tokenId: number;
    /**
     * @generated from field: uint64 amount = 4;
     */
    amount: bigint;
    /**
     * @generated from field: bool account_created = 5;
     */
    accountCreated: boolean;
    /**
     * @generated from field: optional nord.SpecialAccount to_special_account = 6;
     */
    toSpecialAccount?: SpecialAccount;
};
/**
 * @generated from message nord.Receipt.Transferred
 */
export type Receipt_TransferredJson = {
    /**
     * @generated from field: uint32 from_account_id = 1;
     */
    fromAccountId?: number;
    /**
     * @generated from field: optional uint32 to_user_account = 2;
     */
    toUserAccount?: number;
    /**
     * @generated from field: uint32 token_id = 3;
     */
    tokenId?: number;
    /**
     * @generated from field: uint64 amount = 4;
     */
    amount?: string;
    /**
     * @generated from field: bool account_created = 5;
     */
    accountCreated?: boolean;
    /**
     * @generated from field: optional nord.SpecialAccount to_special_account = 6;
     */
    toSpecialAccount?: SpecialAccountJson;
};
/**
 * Describes the message nord.Receipt.Transferred.
 * Use `create(Receipt_TransferredSchema)` to create a new message.
 */
export declare const Receipt_TransferredSchema: GenMessage<Receipt_Transferred, {
    jsonType: Receipt_TransferredJson;
}>;
/**
 * @generated from message nord.Receipt.FeeVaultTransferred
 */
export type Receipt_FeeVaultTransferred = Message<"nord.Receipt.FeeVaultTransferred"> & {
    /**
     * @generated from field: uint32 recipient = 1;
     */
    recipient: number;
    /**
     * @generated from field: uint32 token_id = 2;
     */
    tokenId: number;
    /**
     * @generated from field: uint64 amount = 3;
     */
    amount: bigint;
};
/**
 * @generated from message nord.Receipt.FeeVaultTransferred
 */
export type Receipt_FeeVaultTransferredJson = {
    /**
     * @generated from field: uint32 recipient = 1;
     */
    recipient?: number;
    /**
     * @generated from field: uint32 token_id = 2;
     */
    tokenId?: number;
    /**
     * @generated from field: uint64 amount = 3;
     */
    amount?: string;
};
/**
 * Describes the message nord.Receipt.FeeVaultTransferred.
 * Use `create(Receipt_FeeVaultTransferredSchema)` to create a new message.
 */
export declare const Receipt_FeeVaultTransferredSchema: GenMessage<Receipt_FeeVaultTransferred, {
    jsonType: Receipt_FeeVaultTransferredJson;
}>;
/**
 * @generated from message nord.Receipt.TriggerAdded
 */
export type Receipt_TriggerAdded = Message<"nord.Receipt.TriggerAdded"> & {};
/**
 * @generated from message nord.Receipt.TriggerAdded
 */
export type Receipt_TriggerAddedJson = {};
/**
 * Describes the message nord.Receipt.TriggerAdded.
 * Use `create(Receipt_TriggerAddedSchema)` to create a new message.
 */
export declare const Receipt_TriggerAddedSchema: GenMessage<Receipt_TriggerAdded, {
    jsonType: Receipt_TriggerAddedJson;
}>;
/**
 * @generated from message nord.Receipt.TriggerRemoved
 */
export type Receipt_TriggerRemoved = Message<"nord.Receipt.TriggerRemoved"> & {};
/**
 * @generated from message nord.Receipt.TriggerRemoved
 */
export type Receipt_TriggerRemovedJson = {};
/**
 * Describes the message nord.Receipt.TriggerRemoved.
 * Use `create(Receipt_TriggerRemovedSchema)` to create a new message.
 */
export declare const Receipt_TriggerRemovedSchema: GenMessage<Receipt_TriggerRemoved, {
    jsonType: Receipt_TriggerRemovedJson;
}>;
/**
 * @generated from message nord.Receipt.MarketFreezeUpdated
 */
export type Receipt_MarketFreezeUpdated = Message<"nord.Receipt.MarketFreezeUpdated"> & {
    /**
     * @generated from field: uint32 market_id = 1;
     */
    marketId: number;
    /**
     * @generated from field: bool frozen = 2;
     */
    frozen: boolean;
};
/**
 * @generated from message nord.Receipt.MarketFreezeUpdated
 */
export type Receipt_MarketFreezeUpdatedJson = {
    /**
     * @generated from field: uint32 market_id = 1;
     */
    marketId?: number;
    /**
     * @generated from field: bool frozen = 2;
     */
    frozen?: boolean;
};
/**
 * Describes the message nord.Receipt.MarketFreezeUpdated.
 * Use `create(Receipt_MarketFreezeUpdatedSchema)` to create a new message.
 */
export declare const Receipt_MarketFreezeUpdatedSchema: GenMessage<Receipt_MarketFreezeUpdated, {
    jsonType: Receipt_MarketFreezeUpdatedJson;
}>;
/**
 * @generated from message nord.Receipt.FeeTierAdded
 */
export type Receipt_FeeTierAdded = Message<"nord.Receipt.FeeTierAdded"> & {
    /**
     * @generated from field: nord.FeeTierConfig config = 1;
     */
    config?: FeeTierConfig;
};
/**
 * @generated from message nord.Receipt.FeeTierAdded
 */
export type Receipt_FeeTierAddedJson = {
    /**
     * @generated from field: nord.FeeTierConfig config = 1;
     */
    config?: FeeTierConfigJson;
};
/**
 * Describes the message nord.Receipt.FeeTierAdded.
 * Use `create(Receipt_FeeTierAddedSchema)` to create a new message.
 */
export declare const Receipt_FeeTierAddedSchema: GenMessage<Receipt_FeeTierAdded, {
    jsonType: Receipt_FeeTierAddedJson;
}>;
/**
 * @generated from message nord.Receipt.FeeTierUpdated
 */
export type Receipt_FeeTierUpdated = Message<"nord.Receipt.FeeTierUpdated"> & {
    /**
     * @generated from field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from field: nord.FeeTierConfig config = 2;
     */
    config?: FeeTierConfig;
};
/**
 * @generated from message nord.Receipt.FeeTierUpdated
 */
export type Receipt_FeeTierUpdatedJson = {
    /**
     * @generated from field: uint32 id = 1;
     */
    id?: number;
    /**
     * @generated from field: nord.FeeTierConfig config = 2;
     */
    config?: FeeTierConfigJson;
};
/**
 * Describes the message nord.Receipt.FeeTierUpdated.
 * Use `create(Receipt_FeeTierUpdatedSchema)` to create a new message.
 */
export declare const Receipt_FeeTierUpdatedSchema: GenMessage<Receipt_FeeTierUpdated, {
    jsonType: Receipt_FeeTierUpdatedJson;
}>;
/**
 * @generated from message nord.Receipt.AccountsTierUpdated
 */
export type Receipt_AccountsTierUpdated = Message<"nord.Receipt.AccountsTierUpdated"> & {
    /**
     * @generated from field: uint32 tier_id = 1;
     */
    tierId: number;
    /**
     * @generated from field: repeated uint32 accounts = 2;
     */
    accounts: number[];
};
/**
 * @generated from message nord.Receipt.AccountsTierUpdated
 */
export type Receipt_AccountsTierUpdatedJson = {
    /**
     * @generated from field: uint32 tier_id = 1;
     */
    tierId?: number;
    /**
     * @generated from field: repeated uint32 accounts = 2;
     */
    accounts?: number[];
};
/**
 * Describes the message nord.Receipt.AccountsTierUpdated.
 * Use `create(Receipt_AccountsTierUpdatedSchema)` to create a new message.
 */
export declare const Receipt_AccountsTierUpdatedSchema: GenMessage<Receipt_AccountsTierUpdated, {
    jsonType: Receipt_AccountsTierUpdatedJson;
}>;
/**
 * @generated from message nord.Receipt.AclUpdated
 */
export type Receipt_AclUpdated = Message<"nord.Receipt.AclUpdated"> & {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey: Uint8Array;
    /**
     * @generated from field: uint64 roles_mask = 2;
     */
    rolesMask: bigint;
    /**
     * @generated from field: bytes target_pubkey = 3;
     */
    targetPubkey: Uint8Array;
    /**
     * @generated from field: uint64 roles_value = 4;
     */
    rolesValue: bigint;
};
/**
 * @generated from message nord.Receipt.AclUpdated
 */
export type Receipt_AclUpdatedJson = {
    /**
     * @generated from field: bytes acl_pubkey = 1;
     */
    aclPubkey?: string;
    /**
     * @generated from field: uint64 roles_mask = 2;
     */
    rolesMask?: string;
    /**
     * @generated from field: bytes target_pubkey = 3;
     */
    targetPubkey?: string;
    /**
     * @generated from field: uint64 roles_value = 4;
     */
    rolesValue?: string;
};
/**
 * Describes the message nord.Receipt.AclUpdated.
 * Use `create(Receipt_AclUpdatedSchema)` to create a new message.
 */
export declare const Receipt_AclUpdatedSchema: GenMessage<Receipt_AclUpdated, {
    jsonType: Receipt_AclUpdatedJson;
}>;
/**
 * @generated from message nord.Receipt.AtomicSubactionResultKind
 */
export type Receipt_AtomicSubactionResultKind = Message<"nord.Receipt.AtomicSubactionResultKind"> & {
    /**
     * @generated from oneof nord.Receipt.AtomicSubactionResultKind.inner
     */
    inner: {
        /**
         * reusing existing messages -> way less code to change in nord, with some
         * duplication of data unlike input, which is required to be very specific
         * to be correct, receipts can be same to easy ingested into view and hist
         *
         * @generated from field: nord.Receipt.PlaceOrderResult place_order_result = 1;
         */
        value: Receipt_PlaceOrderResult;
        case: "placeOrderResult";
    } | {
        /**
         * @generated from field: nord.Receipt.CancelOrderResult cancel_order = 2;
         */
        value: Receipt_CancelOrderResult;
        case: "cancelOrder";
    } | {
        case: undefined;
        value?: undefined;
    };
};
/**
 * @generated from message nord.Receipt.AtomicSubactionResultKind
 */
export type Receipt_AtomicSubactionResultKindJson = {
    /**
     * reusing existing messages -> way less code to change in nord, with some
     * duplication of data unlike input, which is required to be very specific
     * to be correct, receipts can be same to easy ingested into view and hist
     *
     * @generated from field: nord.Receipt.PlaceOrderResult place_order_result = 1;
     */
    placeOrderResult?: Receipt_PlaceOrderResultJson;
    /**
     * @generated from field: nord.Receipt.CancelOrderResult cancel_order = 2;
     */
    cancelOrder?: Receipt_CancelOrderResultJson;
};
/**
 * Describes the message nord.Receipt.AtomicSubactionResultKind.
 * Use `create(Receipt_AtomicSubactionResultKindSchema)` to create a new message.
 */
export declare const Receipt_AtomicSubactionResultKindSchema: GenMessage<Receipt_AtomicSubactionResultKind, {
    jsonType: Receipt_AtomicSubactionResultKindJson;
}>;
/**
 * @generated from message nord.Receipt.AtomicResult
 */
export type Receipt_AtomicResult = Message<"nord.Receipt.AtomicResult"> & {
    /**
     * @generated from field: repeated nord.Receipt.AtomicSubactionResultKind results = 1;
     */
    results: Receipt_AtomicSubactionResultKind[];
};
/**
 * @generated from message nord.Receipt.AtomicResult
 */
export type Receipt_AtomicResultJson = {
    /**
     * @generated from field: repeated nord.Receipt.AtomicSubactionResultKind results = 1;
     */
    results?: Receipt_AtomicSubactionResultKindJson[];
};
/**
 * Describes the message nord.Receipt.AtomicResult.
 * Use `create(Receipt_AtomicResultSchema)` to create a new message.
 */
export declare const Receipt_AtomicResultSchema: GenMessage<Receipt_AtomicResult, {
    jsonType: Receipt_AtomicResultJson;
}>;
/**
 * @generated from enum nord.Side
 */
export declare enum Side {
    /**
     * @generated from enum value: ASK = 0;
     */
    ASK = 0,
    /**
     * @generated from enum value: BID = 1;
     */
    BID = 1
}
/**
 * @generated from enum nord.Side
 */
export type SideJson = "ASK" | "BID";
/**
 * Describes the enum nord.Side.
 */
export declare const SideSchema: GenEnum<Side, SideJson>;
/**
 * @generated from enum nord.TriggerKind
 */
export declare enum TriggerKind {
    /**
     * @generated from enum value: STOP_LOSS = 0;
     */
    STOP_LOSS = 0,
    /**
     * @generated from enum value: TAKE_PROFIT = 1;
     */
    TAKE_PROFIT = 1
}
/**
 * @generated from enum nord.TriggerKind
 */
export type TriggerKindJson = "STOP_LOSS" | "TAKE_PROFIT";
/**
 * Describes the enum nord.TriggerKind.
 */
export declare const TriggerKindSchema: GenEnum<TriggerKind, TriggerKindJson>;
/**
 * @generated from enum nord.FillMode
 */
export declare enum FillMode {
    /**
     * @generated from enum value: LIMIT = 0;
     */
    LIMIT = 0,
    /**
     * @generated from enum value: POST_ONLY = 1;
     */
    POST_ONLY = 1,
    /**
     * @generated from enum value: IMMEDIATE_OR_CANCEL = 2;
     */
    IMMEDIATE_OR_CANCEL = 2,
    /**
     * @generated from enum value: FILL_OR_KILL = 3;
     */
    FILL_OR_KILL = 3
}
/**
 * @generated from enum nord.FillMode
 */
export type FillModeJson = "LIMIT" | "POST_ONLY" | "IMMEDIATE_OR_CANCEL" | "FILL_OR_KILL";
/**
 * Describes the enum nord.FillMode.
 */
export declare const FillModeSchema: GenEnum<FillMode, FillModeJson>;
/**
 * @generated from enum nord.MarketType
 */
export declare enum MarketType {
    /**
     * @generated from enum value: SPOT = 0;
     */
    SPOT = 0,
    /**
     * @generated from enum value: PERPETUALS = 1;
     */
    PERPETUALS = 1
}
/**
 * @generated from enum nord.MarketType
 */
export type MarketTypeJson = "SPOT" | "PERPETUALS";
/**
 * Describes the enum nord.MarketType.
 */
export declare const MarketTypeSchema: GenEnum<MarketType, MarketTypeJson>;
/**
 * @generated from enum nord.SpecialAccount
 */
export declare enum SpecialAccount {
    /**
     * @generated from enum value: FeeVault = 0;
     */
    FeeVault = 0
}
/**
 * @generated from enum nord.SpecialAccount
 */
export type SpecialAccountJson = "FeeVault";
/**
 * Describes the enum nord.SpecialAccount.
 */
export declare const SpecialAccountSchema: GenEnum<SpecialAccount, SpecialAccountJson>;
/**
 * Error codes returned by the engine.
 * Some errors has 5bit prefix about error source and 3 bit suffix specifier.
 * Error source prefix indicates were too look into to fix error.
 * For example if order has bad input, it would be order relevant prefix.
 * But if order cannot apply results to balance, it would be balance relevant
 * prefix.
 *
 * @generated from enum nord.Error
 */
export declare enum Error {
    /**
     * @generated from enum value: DUPLICATE = 0;
     */
    DUPLICATE = 0,
    /**
     * @generated from enum value: DECODE_FAILURE = 2;
     */
    DECODE_FAILURE = 2,
    /**
     * @generated from enum value: INVALID_SIGNATURE = 3;
     */
    INVALID_SIGNATURE = 3,
    /**
     * @generated from enum value: MARKET_NOT_FOUND = 4;
     */
    MARKET_NOT_FOUND = 4,
    /**
     * @generated from enum value: TOKEN_NOT_FOUND = 5;
     */
    TOKEN_NOT_FOUND = 5,
    /**
     * @generated from enum value: USER_NOT_FOUND = 6;
     */
    USER_NOT_FOUND = 6,
    /**
     * @generated from enum value: SESSION_NOT_FOUND = 7;
     */
    SESSION_NOT_FOUND = 7,
    /**
     * @generated from enum value: ORDER_NOT_FOUND = 8;
     */
    ORDER_NOT_FOUND = 8,
    /**
     * @generated from enum value: ORDER_SIZE_ZERO = 9;
     */
    ORDER_SIZE_ZERO = 9,
    /**
     * 0000_1011
     *
     * @generated from enum value: ARITHMETIC = 11;
     */
    ARITHMETIC = 11,
    /**
     * 0000_1100
     *
     * @generated from enum value: ARITHMETIC_OVERFLOW = 12;
     */
    ARITHMETIC_OVERFLOW = 12,
    /**
     * 0000_1101
     *
     * @generated from enum value: ARITHMETIC_UNDERFLOW = 13;
     */
    ARITHMETIC_UNDERFLOW = 13,
    /**
     * 0000_1110
     *
     * @generated from enum value: ARITHMETIC_DIVISION_BY_ZERO = 14;
     */
    ARITHMETIC_DIVISION_BY_ZERO = 14,
    /**
     * @generated from enum value: KEY_ALREADY_REGISTERED = 15;
     */
    KEY_ALREADY_REGISTERED = 15,
    /**
     * @generated from enum value: UPDATE_TIMESTAMP_IN_PAST = 17;
     */
    UPDATE_TIMESTAMP_IN_PAST = 17,
    /**
     * @generated from enum value: TOO_MANY_OPEN_ORDERS = 18;
     */
    TOO_MANY_OPEN_ORDERS = 18,
    /**
     * @generated from enum value: WITHDRAW_AMOUNT_TOO_SMALL = 21;
     */
    WITHDRAW_AMOUNT_TOO_SMALL = 21,
    /**
     * @generated from enum value: INVALID_ORDER_OWNER = 22;
     */
    INVALID_ORDER_OWNER = 22,
    /**
     * @generated from enum value: DECODE_FAILURE_LENGTH_PREFIX = 33;
     */
    DECODE_FAILURE_LENGTH_PREFIX = 33,
    /**
     * Raw generated serde error
     *
     * @generated from enum value: DECODE_FAILURE_RAW = 34;
     */
    DECODE_FAILURE_RAW = 34,
    /**
     * Limitation of serde to specify types
     *
     * @generated from enum value: DECODE_FAILURE_DOMAIN = 35;
     */
    DECODE_FAILURE_DOMAIN = 35,
    /**
     * @generated from enum value: UPDATE_PUBLISH_TIME_IN_PAST = 36;
     */
    UPDATE_PUBLISH_TIME_IN_PAST = 36,
    /**
     * @generated from enum value: PYTH_FEED_NOT_ADDED = 93;
     */
    PYTH_FEED_NOT_ADDED = 93,
    /**
     * @generated from enum value: PYTH_FEED_MISSING = 94;
     */
    PYTH_FEED_MISSING = 94,
    /**
     * @generated from enum value: PYTH_FEED_ALREADY_ADDED = 95;
     */
    PYTH_FEED_ALREADY_ADDED = 95,
    /**
     * @generated from enum value: PYTH_GUARDIAN_SET_UNINITIALIZED = 96;
     */
    PYTH_GUARDIAN_SET_UNINITIALIZED = 96,
    /**
     * @generated from enum value: PYTH_GUARDIAN_SET_INVALID = 97;
     */
    PYTH_GUARDIAN_SET_INVALID = 97,
    /**
     * @generated from enum value: PYTH_FEED_DECIMALS_OUT_OF_RANGE = 98;
     */
    PYTH_FEED_DECIMALS_OUT_OF_RANGE = 98,
    /**
     * @generated from enum value: PYTH_FEED_PRICE_OUT_OF_RANGE = 99;
     */
    PYTH_FEED_PRICE_OUT_OF_RANGE = 99,
    /**
     * @generated from enum value: PYTH_FEED_VARIANCE_OUT_OF_RANGE = 100;
     */
    PYTH_FEED_VARIANCE_OUT_OF_RANGE = 100,
    /**
     * @generated from enum value: PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH = 101;
     */
    PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH = 101,
    /**
     * @generated from enum value: INVALID_TOKEN_PARAMETERS = 102;
     */
    INVALID_TOKEN_PARAMETERS = 102,
    /**
     * @generated from enum value: INDEX_PRICE_OUT_OF_RANGE = 103;
     */
    INDEX_PRICE_OUT_OF_RANGE = 103,
    /**
     * @generated from enum value: INDEX_DECIMALS_OUT_OF_RANGE = 104;
     */
    INDEX_DECIMALS_OUT_OF_RANGE = 104,
    /**
     * @generated from enum value: INVALID_STATE_VERSION = 105;
     */
    INVALID_STATE_VERSION = 105,
    /**
     * @generated from enum value: TIER_FEE_OUT_OF_RANGE = 106;
     */
    TIER_FEE_OUT_OF_RANGE = 106,
    /**
     * @generated from enum value: TIER_ID_OUT_OF_RANGE = 107;
     */
    TIER_ID_OUT_OF_RANGE = 107,
    /**
     * @generated from enum value: INVALID_MARGINS = 108;
     */
    INVALID_MARGINS = 108,
    /**
     * Market's decimal parameters exceed either "quote limit" or "base limit"
     * Two mentioned limits were deduced empirically and ensure
     * that certain overflow errors don't happen when value rescaling is performed
     * during order placement.
     *
     * For both perpetuals and spot markets,
     * `quote_token.decimals - market.size_decimals - market.price_decimals` must
     * be within range `[-19; 4]` For spot market, `base_token.decimals -
     * market.size_decimals` must be within range `[-19; 23]`
     *
     * @generated from enum value: MARKET_DECIMALS_EXCEED_LIMITS = 109;
     */
    MARKET_DECIMALS_EXCEED_LIMITS = 109,
    /**
     * @generated from enum value: TOO_MANY_TOKENS = 110;
     */
    TOO_MANY_TOKENS = 110,
    /**
     * @generated from enum value: FUNDING_OVERFLOW = 123;
     */
    FUNDING_OVERFLOW = 123,
    /**
     * If there is order to cancel for position, it should be canceled first
     * before reducing position
     *
     * @generated from enum value: CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED = 124;
     */
    CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED = 124,
    /**
     * Token was found, but not expected to be used in action context
     *
     * @generated from enum value: UNEXPECTED_TOKEN_ID = 127;
     */
    UNEXPECTED_TOKEN_ID = 127,
    /**
     * Repeated order ID detected (duplicate OrderKey from client_order_id)
     *
     * @generated from enum value: REPEATED_ORDER_ID = 128;
     */
    REPEATED_ORDER_ID = 128,
    /**
     * happens in some situation when token misses some relevant information
     * needed for operation, for example index price
     *
     * @generated from enum value: TOKEN_NOT_READY = 130;
     */
    TOKEN_NOT_READY = 130,
    /**
     * Token with specified blockchain address already registered
     *
     * @generated from enum value: TOKEN_ALREADY_REGISTERED = 112;
     */
    TOKEN_ALREADY_REGISTERED = 112,
    /**
     * @generated from enum value: IMMEDIATE_ORDER_GOT_NO_FILLS = 133;
     */
    IMMEDIATE_ORDER_GOT_NO_FILLS = 133,
    /**
     * In case there's no price, error if failed to fill at least one of limits
     *
     * @generated from enum value: FAILED_TO_FILL_LIMIT = 134;
     */
    FAILED_TO_FILL_LIMIT = 134,
    /**
     * @generated from enum value: POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS = 135;
     */
    POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS = 135,
    /**
     * @generated from enum value: INVALID = 136;
     */
    INVALID = 136,
    /**
     * Any action stopped by admin for maintenance or other reason.
     *
     * @generated from enum value: MAINTENANCE = 137;
     */
    MAINTENANCE = 137,
    /**
     * @generated from enum value: MINIMUM_SIZE_DECIMALS = 138;
     */
    MINIMUM_SIZE_DECIMALS = 138,
    /**
     * @generated from enum value: PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET = 139;
     */
    PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET = 139,
    /**
     * @generated from enum value: ONLY_IMMEDIATE_ORDERS_ALLOWED = 140;
     */
    ONLY_IMMEDIATE_ORDERS_ALLOWED = 140,
    /**
     * @generated from enum value: TOO_MANY_USER_ACCOUNTS = 141;
     */
    TOO_MANY_USER_ACCOUNTS = 141,
    /**
     * There's no such account with specified id,
     *
     * @generated from enum value: ACCOUNT_NOT_FOUND = 142;
     */
    ACCOUNT_NOT_FOUND = 142,
    /**
     * Account doesn't belong to user designated by public key or session id
     *
     * @generated from enum value: ACCOUNT_INVALID_OWNER = 143;
     */
    ACCOUNT_INVALID_OWNER = 143,
    /**
     * Operation cannot be made on account because to small amount will be
     * retained on account
     *
     * @generated from enum value: DUST_ACCOUNT = 145;
     */
    DUST_ACCOUNT = 145,
    /**
     * 10100_000
     *
     * @generated from enum value: BALANCE = 160;
     */
    BALANCE = 160,
    /**
     * 10100_001
     *
     * @generated from enum value: BALANCE_DEPOSIT_OVERFLOW = 161;
     */
    BALANCE_DEPOSIT_OVERFLOW = 161,
    /**
     * 10100_010
     *
     * @generated from enum value: BALANCE_CHANGE_OVERFLOW = 162;
     */
    BALANCE_CHANGE_OVERFLOW = 162,
    /**
     * 10100_011
     *
     * @generated from enum value: BALANCE_CHANGE_LIMIT_EXCEEDED = 163;
     */
    BALANCE_CHANGE_LIMIT_EXCEEDED = 163,
    /**
     * Happens when account balances has no sufficient token amount to perform
     * action.
     * 10100_100
     *
     * @generated from enum value: BALANCE_INSUFFICIENT = 164;
     */
    BALANCE_INSUFFICIENT = 164,
    /**
     * Happens when an action is meant to come from the settlement contract,
     * but is not authenticated, instead coming from the user channels.
     *
     * @generated from enum value: UNAUTHENTICATED_L1_ACTION = 165;
     */
    UNAUTHENTICATED_L1_ACTION = 165,
    /**
     * Happens when an encoded action is too large. This is to mitigate dos
     * attacks due to excessive padding.
     *
     * @generated from enum value: ENCODED_ACTION_TOO_LARGE = 166;
     */
    ENCODED_ACTION_TOO_LARGE = 166,
    /**
     * 10101_000
     *
     * @generated from enum value: TRIGGER = 168;
     */
    TRIGGER = 168,
    /**
     * Happens when:
     * * Trigger price is "less or equal" to its corresponding pair trigger price
     * * Trigger rice is "less" than market's current index price
     *
     * Binary pattern: 10101_001
     *
     * @generated from enum value: TRIGGER_INVALID_PRICE = 169;
     */
    TRIGGER_INVALID_PRICE = 169,
    /**
     * @generated from enum value: TRIGGER_NOT_FOUND = 170;
     */
    TRIGGER_NOT_FOUND = 170,
    /**
     * 10110_000
     * Prefix which says that timestamp used as part of action is is not allowed
     *
     * @generated from enum value: TIMESTAMP = 176;
     */
    TIMESTAMP = 176,
    /**
     * 10110_001
     * Used to ensure that client is in sync with engine timestamp,
     * to avoid replay attacks. Please update you client time periodically.
     * See `Config::ACTION_TIMESTAMP_STALE_THRESHOLD` for range allowed to be out
     * of timestamp value.
     *
     * @generated from enum value: TIMESTAMP_OUT_OF_THRESHOLD = 177;
     */
    TIMESTAMP_OUT_OF_THRESHOLD = 177,
    /**
     * @generated from enum value: TIMESTAMP_STALE = 178;
     */
    TIMESTAMP_STALE = 178,
    /**
     * Expiry of entity with lifetime must be in future, specifically session.
     *
     * @generated from enum value: EXPIRY_TIMESTAMP_IN_PAST = 16;
     */
    EXPIRY_TIMESTAMP_IN_PAST = 16,
    /**
     * 10111_000
     * BANKRUPTCY = 184;
     * 10111_001
     *
     * @generated from enum value: BANKRUPTCY_INSUFFICIENT_COVERAGE = 185;
     */
    BANKRUPTCY_INSUFFICIENT_COVERAGE = 185,
    /**
     * 10111_010
     * Account is not in bankruptcy state.
     *
     * @generated from enum value: BANKRUPTCY_NOT_FOUND = 186;
     */
    BANKRUPTCY_NOT_FOUND = 186,
    /**
     * Cannot executed this action in case of bankruptcy.
     * Source of error is BANKRUPTCY, which leads to NOT_ALLOWED.
     * Not ideal to read by human, but follows the pattern.
     * Seek for methods which need BANKRUPTCY and give BANKRUPTCY_NOT_FOUND if not
     * a case.
     *
     * @generated from enum value: BANKRUPTCY_NOT_ALLOWED = 187;
     */
    BANKRUPTCY_NOT_ALLOWED = 187,
    /**
     * 11000_000
     * Happens when market is not read to handle orders
     *
     * @generated from enum value: MARKET_NOT_READY = 192;
     */
    MARKET_NOT_READY = 192,
    /**
     * @generated from enum value: MARKET_FROZEN = 193;
     */
    MARKET_FROZEN = 193,
    /**
     * Happens when there is no liquidity on the market at the moment of trigger
     * execution
     *
     * @generated from enum value: MARKET_EMPTY = 194;
     */
    MARKET_EMPTY = 194,
    /**
     * 11001_000
     *
     * @generated from enum value: POSITION = 200;
     */
    POSITION = 200,
    /**
     * Position not found for specific entity in specific market
     *
     * @generated from enum value: POSITION_NOT_FOUND = 201;
     */
    POSITION_NOT_FOUND = 201,
    /**
     * @generated from enum value: POSITION_STATE_ORDER = 202;
     */
    POSITION_STATE_ORDER = 202,
    /**
     * @generated from enum value: POSITION_STATE_ORDER_PRICE = 203;
     */
    POSITION_STATE_ORDER_PRICE = 203,
    /**
     * position size size is smaller of counter orders (reduce counter orders
     * cannot be bigger of position).  or order is small, but its price is bad of
     * all other reduce orders and it cannot be added
     *
     * @generated from enum value: POSITION_STATE_ORDER_SIZE = 204;
     */
    POSITION_STATE_ORDER_SIZE = 204,
    /**
     * @generated from enum value: POSITION_STATE_ORDER_SIDE = 205;
     */
    POSITION_STATE_ORDER_SIDE = 205,
    /**
     * 1100_1110
     * Maximuma size of single position exceeded.
     * See `POSITION_SIZE_LIMIT` constant default limit for exacat value and
     * details.
     *
     * @generated from enum value: POSITION_SIZE_LIMIT = 206;
     */
    POSITION_SIZE_LIMIT = 206,
    /**
     * 1100_1111
     *
     * @generated from enum value: POSITION_STATE_PERP = 207;
     */
    POSITION_STATE_PERP = 207,
    /**
     * @generated from enum value: POSITION_STATE_ORDER_DELEGATION = 208;
     */
    POSITION_STATE_ORDER_DELEGATION = 208,
    /**
     * @generated from enum value: PRICE = 209;
     */
    PRICE = 209,
    /**
     * @generated from enum value: SIGNATURE_VERIFICATION = 217;
     */
    SIGNATURE_VERIFICATION = 217,
    /**
     * @generated from enum value: SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY = 218;
     */
    SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY = 218,
    /**
     * @generated from enum value: SIGNATURE_VERIFICATION_INVALID_LENGTH = 219;
     */
    SIGNATURE_VERIFICATION_INVALID_LENGTH = 219,
    /**
     * 11011_000
     * Error prefix which indicates that some actions cannot to be executed,
     * if they move account into unhealthy(liquidatable) state
     * or if liquidaiton handling action as parameterized cannot be executed
     *
     * @generated from enum value: RISK = 224;
     */
    RISK = 224,
    /**
     * @generated from enum value: RISK_DELEGATION_MF_TO_BE_LESS_THAN_OR_EQUAL_MMF = 225;
     */
    RISK_DELEGATION_MF_TO_BE_LESS_THAN_OR_EQUAL_MMF = 225,
    /**
     * @generated from enum value: RISK_OMF_LESS_THAN_OR_EQUAL_IMF = 226;
     */
    RISK_OMF_LESS_THAN_OR_EQUAL_IMF = 226,
    /**
     * @generated from enum value: RISK_OMF_LESS_THAN_OR_EQUAL_CMF = 227;
     */
    RISK_OMF_LESS_THAN_OR_EQUAL_CMF = 227,
    /**
     * See `OMF < CMF` rule in MARKETS.md.
     *
     * @generated from enum value: RISK_TRADE_OMF_LESS_THAN_OR_EQUAL_CMF = 229;
     */
    RISK_TRADE_OMF_LESS_THAN_OR_EQUAL_CMF = 229,
    /**
     * @generated from enum value: RISK_UNHEALTHY_MF_AND_PON_AFTER_BETTER_OF_BEFORE = 228;
     */
    RISK_UNHEALTHY_MF_AND_PON_AFTER_BETTER_OF_BEFORE = 228,
    /**
     * 1111_0000 = 240 -- 4 bit suffix
     *
     * @generated from enum value: ORDER_EXECUTION = 240;
     */
    ORDER_EXECUTION = 240,
    /**
     * @generated from enum value: ORDER_EXECUTION_EMPTY = 241;
     */
    ORDER_EXECUTION_EMPTY = 241,
    /**
     * @generated from enum value: ORDER_EXECUTION_FILL_OR_KILL = 242;
     */
    ORDER_EXECUTION_FILL_OR_KILL = 242,
    /**
     * Order requires some of its limits specified according to fill mode
     *
     * @generated from enum value: ORDER_EXECUTION_MISSING_LIMITS = 243;
     */
    ORDER_EXECUTION_MISSING_LIMITS = 243,
    /**
     * @generated from enum value: ORDER_EXECUTION_MISSING_PRICE = 244;
     */
    ORDER_EXECUTION_MISSING_PRICE = 244,
    /**
     * @generated from enum value: ORDER_EXECUTION_SIZE_LIMIT = 245;
     */
    ORDER_EXECUTION_SIZE_LIMIT = 245,
    /**
     * 111_0110
     * Price in order limit should be within acceptable range
     *
     * @generated from enum value: ORDER_EXECUTION_LIMIT_PRICE = 246;
     */
    ORDER_EXECUTION_LIMIT_PRICE = 246,
    /**
     * Reduce orders can only be post only.
     * 01111_0111 = 247
     *
     * @generated from enum value: ORDER_REDUCE_IS_POST_ONLY = 247;
     */
    ORDER_REDUCE_IS_POST_ONLY = 247,
    /**
     * Order was rejected, because it planned under proposed price
     * 01111_1000 = 248
     *
     * @generated from enum value: ORDER_EXECUTION_SELL_PRICE = 248;
     */
    ORDER_EXECUTION_SELL_PRICE = 248,
    /**
     * @generated from enum value: ORDER_SIZE_EXCEEDS_POSITION_SIZE = 249;
     */
    ORDER_SIZE_EXCEEDS_POSITION_SIZE = 249,
    /**
     * 10000_0000
     *
     * @generated from enum value: ATOMICS_TRADES_CANNOT_FOLLOW_PLACES = 256;
     */
    ATOMICS_TRADES_CANNOT_FOLLOW_PLACES = 256,
    /**
     * 10000_0001
     *
     * @generated from enum value: ATOMICS_CANCELS_CANNOT_FOLLOW_TRADES_PLACES = 257;
     */
    ATOMICS_CANCELS_CANNOT_FOLLOW_TRADES_PLACES = 257,
    /**
     * 10001_0001
     *
     * @generated from enum value: ACTION_POSITION_SHOULD_BE_COVERED = 273;
     */
    ACTION_POSITION_SHOULD_BE_COVERED = 273,
    /**
     * @generated from enum value: ACTION_INVALID_NONCE = 274;
     */
    ACTION_INVALID_NONCE = 274,
    /**
     * @generated from enum value: ACTION_PROPOSED_PRICE_MUST_BE_HIGHER = 275;
     */
    ACTION_PROPOSED_PRICE_MUST_BE_HIGHER = 275,
    /**
     * @generated from enum value: ADMIN_ROLE_INSUFFICIENT = 276;
     */
    ADMIN_ROLE_INSUFFICIENT = 276,
    /**
     * @generated from enum value: ADMIN_NOT_FOUND = 277;
     */
    ADMIN_NOT_FOUND = 277,
    /**
     * @generated from enum value: UNIQUE_SUPER_ADMIN_CANNOT_BE_REMOVED = 278;
     */
    UNIQUE_SUPER_ADMIN_CANNOT_BE_REMOVED = 278,
    /**
     * @generated from enum value: SUPER_ADMIN_ALREADY_EXISTS = 279;
     */
    SUPER_ADMIN_ALREADY_EXISTS = 279,
    /**
     * @generated from enum value: NOT_IMPLEMENTED = 500;
     */
    NOT_IMPLEMENTED = 500,
    /**
     * @generated from enum value: ACTION_NOT_ALLOWED = 501;
     */
    ACTION_NOT_ALLOWED = 501,
    /**
     * @generated from enum value: Dropped = 999;
     */
    Dropped = 999
}
/**
 * Error codes returned by the engine.
 * Some errors has 5bit prefix about error source and 3 bit suffix specifier.
 * Error source prefix indicates were too look into to fix error.
 * For example if order has bad input, it would be order relevant prefix.
 * But if order cannot apply results to balance, it would be balance relevant
 * prefix.
 *
 * @generated from enum nord.Error
 */
export type ErrorJson = "DUPLICATE" | "DECODE_FAILURE" | "INVALID_SIGNATURE" | "MARKET_NOT_FOUND" | "TOKEN_NOT_FOUND" | "USER_NOT_FOUND" | "SESSION_NOT_FOUND" | "ORDER_NOT_FOUND" | "ORDER_SIZE_ZERO" | "ARITHMETIC" | "ARITHMETIC_OVERFLOW" | "ARITHMETIC_UNDERFLOW" | "ARITHMETIC_DIVISION_BY_ZERO" | "KEY_ALREADY_REGISTERED" | "UPDATE_TIMESTAMP_IN_PAST" | "TOO_MANY_OPEN_ORDERS" | "WITHDRAW_AMOUNT_TOO_SMALL" | "INVALID_ORDER_OWNER" | "DECODE_FAILURE_LENGTH_PREFIX" | "DECODE_FAILURE_RAW" | "DECODE_FAILURE_DOMAIN" | "UPDATE_PUBLISH_TIME_IN_PAST" | "PYTH_FEED_NOT_ADDED" | "PYTH_FEED_MISSING" | "PYTH_FEED_ALREADY_ADDED" | "PYTH_GUARDIAN_SET_UNINITIALIZED" | "PYTH_GUARDIAN_SET_INVALID" | "PYTH_FEED_DECIMALS_OUT_OF_RANGE" | "PYTH_FEED_PRICE_OUT_OF_RANGE" | "PYTH_FEED_VARIANCE_OUT_OF_RANGE" | "PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH" | "INVALID_TOKEN_PARAMETERS" | "INDEX_PRICE_OUT_OF_RANGE" | "INDEX_DECIMALS_OUT_OF_RANGE" | "INVALID_STATE_VERSION" | "TIER_FEE_OUT_OF_RANGE" | "TIER_ID_OUT_OF_RANGE" | "INVALID_MARGINS" | "MARKET_DECIMALS_EXCEED_LIMITS" | "TOO_MANY_TOKENS" | "FUNDING_OVERFLOW" | "CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED" | "UNEXPECTED_TOKEN_ID" | "REPEATED_ORDER_ID" | "TOKEN_NOT_READY" | "TOKEN_ALREADY_REGISTERED" | "IMMEDIATE_ORDER_GOT_NO_FILLS" | "FAILED_TO_FILL_LIMIT" | "POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS" | "INVALID" | "MAINTENANCE" | "MINIMUM_SIZE_DECIMALS" | "PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET" | "ONLY_IMMEDIATE_ORDERS_ALLOWED" | "TOO_MANY_USER_ACCOUNTS" | "ACCOUNT_NOT_FOUND" | "ACCOUNT_INVALID_OWNER" | "DUST_ACCOUNT" | "BALANCE" | "BALANCE_DEPOSIT_OVERFLOW" | "BALANCE_CHANGE_OVERFLOW" | "BALANCE_CHANGE_LIMIT_EXCEEDED" | "BALANCE_INSUFFICIENT" | "UNAUTHENTICATED_L1_ACTION" | "ENCODED_ACTION_TOO_LARGE" | "TRIGGER" | "TRIGGER_INVALID_PRICE" | "TRIGGER_NOT_FOUND" | "TIMESTAMP" | "TIMESTAMP_OUT_OF_THRESHOLD" | "TIMESTAMP_STALE" | "EXPIRY_TIMESTAMP_IN_PAST" | "BANKRUPTCY_INSUFFICIENT_COVERAGE" | "BANKRUPTCY_NOT_FOUND" | "BANKRUPTCY_NOT_ALLOWED" | "MARKET_NOT_READY" | "MARKET_FROZEN" | "MARKET_EMPTY" | "POSITION" | "POSITION_NOT_FOUND" | "POSITION_STATE_ORDER" | "POSITION_STATE_ORDER_PRICE" | "POSITION_STATE_ORDER_SIZE" | "POSITION_STATE_ORDER_SIDE" | "POSITION_SIZE_LIMIT" | "POSITION_STATE_PERP" | "POSITION_STATE_ORDER_DELEGATION" | "PRICE" | "SIGNATURE_VERIFICATION" | "SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY" | "SIGNATURE_VERIFICATION_INVALID_LENGTH" | "RISK" | "RISK_DELEGATION_MF_TO_BE_LESS_THAN_OR_EQUAL_MMF" | "RISK_OMF_LESS_THAN_OR_EQUAL_IMF" | "RISK_OMF_LESS_THAN_OR_EQUAL_CMF" | "RISK_TRADE_OMF_LESS_THAN_OR_EQUAL_CMF" | "RISK_UNHEALTHY_MF_AND_PON_AFTER_BETTER_OF_BEFORE" | "ORDER_EXECUTION" | "ORDER_EXECUTION_EMPTY" | "ORDER_EXECUTION_FILL_OR_KILL" | "ORDER_EXECUTION_MISSING_LIMITS" | "ORDER_EXECUTION_MISSING_PRICE" | "ORDER_EXECUTION_SIZE_LIMIT" | "ORDER_EXECUTION_LIMIT_PRICE" | "ORDER_REDUCE_IS_POST_ONLY" | "ORDER_EXECUTION_SELL_PRICE" | "ORDER_SIZE_EXCEEDS_POSITION_SIZE" | "ATOMICS_TRADES_CANNOT_FOLLOW_PLACES" | "ATOMICS_CANCELS_CANNOT_FOLLOW_TRADES_PLACES" | "ACTION_POSITION_SHOULD_BE_COVERED" | "ACTION_INVALID_NONCE" | "ACTION_PROPOSED_PRICE_MUST_BE_HIGHER" | "ADMIN_ROLE_INSUFFICIENT" | "ADMIN_NOT_FOUND" | "UNIQUE_SUPER_ADMIN_CANNOT_BE_REMOVED" | "SUPER_ADMIN_ALREADY_EXISTS" | "NOT_IMPLEMENTED" | "ACTION_NOT_ALLOWED" | "Dropped";
/**
 * Describes the enum nord.Error.
 */
export declare const ErrorSchema: GenEnum<Error, ErrorJson>;
