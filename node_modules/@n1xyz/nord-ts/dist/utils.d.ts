import { Decimal } from "decimal.js";
import { type Market, type Token } from "./types";
import { type Message } from "@bufbuild/protobuf";
import type { GenMessage } from "@bufbuild/protobuf/codegenv2";
import { ethers } from "ethers";
import { RequestInfo, RequestInit, Response } from "node-fetch";
import { Keypair } from "@solana/web3.js";
import * as solana from "@solana/web3.js";
export declare const SESSION_TTL: bigint;
export declare const ZERO_DECIMAL: Decimal;
export declare const MAX_BUFFER_LEN = 10000;
/** Any type convertible to bigint */
export type BigIntValue = bigint | number | string;
export declare function panic(message: string): never;
export declare function isRfc3339(s: string): boolean;
export declare function assert(predicate: boolean, message?: string): asserts predicate;
/**
 * Extracts value out of optional if it's defined, or throws error if it's not
 * @param value   Optional value to unwrap
 * @param message Error message
 * @returns       Unwrapped value
 */
export declare function optExpect<T>(value: T | undefined, message: string): T;
/** Behaves same as `node-fetch/fetch` but throws if response is a failure
 *
 * @param url   Request HTTP URL
 * @param init  Request parameters
 * @returns     Raw response if fetch succeeded
 * @throws      If response wasn't Ok
 */
export declare function checkedFetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
/**
 * Constructs wallet signing function, usable with `NordUser` type
 *
 * @param walletKey   Either raw signing key as bytes array or hex string prefixed with `"0x"`
 * @returns           Async function which accepts arbitrary message, generates its digets,
 *                    then signs it with provided user wallet key and returns signature
 *                    as hex string prefixed with `"0x"`
 */
export declare function makeWalletSignFn(walletKey: ethers.BytesLike): (message: Uint8Array | string) => Promise<string>;
/**
 * Converts decimal value into rescaled 64-bit unsigned integer
 * by scaling it up by specified number of decimal digits.
 *
 * Ensures that number won't accidentally become zero
 * or exceed U64's value range
 *
 * @param x         Decimal value to rescale
 * @param decimals  Number of decimal digits
 * @returns         Rescaled unsigned integer
 */
export declare const toScaledU64: (x: Decimal.Value, decimals: number) => bigint;
/**
 * Converts decimal value into rescaled 128-bit unsigned integer
 * by scaling it up by specified number of decimal digits.
 *
 * Ensures that number won't accidentally become zero
 * or exceed U128's value range
 *
 * @param x         Decimal value to rescale
 * @param decimals  Number of decimal digits
 * @returns         Rescaled unsigned integer
 */
export declare const toScaledU128: (x: Decimal.Value, decimals: number) => bigint;
/**
 * Decodes any protobuf message from a length-delimited format,
 * i.e. prefixed with its length encoded as varint
 *
 * @param   bytes  Byte array with encoded message
 * @param   schema Message schema for decoding
 * @returns        Decoded message
 */
export declare function decodeLengthDelimited<T extends Message>(bytes: Uint8Array, schema: GenMessage<T>): T;
export declare function decodeHex(value: string): Uint8Array;
export declare function findMarket(markets: Market[], marketId: number): Market;
export declare function findToken(tokens: Token[], tokenId: number): Token;
export declare function keypairFromPrivateKey(privateKey: string | Uint8Array): Keypair;
export declare function signSolanaTransactionFramedPayload({ payload, user, signTransaction, }: Readonly<{
    payload: Uint8Array;
    user: solana.PublicKey;
    signTransaction: (tx: solana.Transaction) => Promise<solana.Transaction>;
}>): Promise<Uint8Array>;
export declare function signHexEncodedPayload({ payload, signMessage, }: Readonly<{
    payload: Uint8Array;
    signMessage: (message: Uint8Array) => Promise<Uint8Array>;
}>): Promise<Uint8Array>;
