var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/node-fetch/browser.js
var require_browser = __commonJS((exports, module) => {
  var getGlobal3 = function() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("unable to locate global object");
  };
  var globalObject = getGlobal3();
  module.exports = exports = globalObject.fetch;
  if (globalObject.fetch) {
    exports.default = globalObject.fetch.bind(globalObject);
  }
  exports.Headers = globalObject.Headers;
  exports.Request = globalObject.Request;
  exports.Response = globalObject.Response;
});

// node:buffer
var exports_buffer = {};
__export(exports_buffer, {
  transcode: () => transcode,
  resolveObjectURL: () => resolveObjectURL,
  kStringMaxLength: () => kStringMaxLength,
  kMaxLength: () => kMaxLength,
  isUtf8: () => isUtf8,
  isAscii: () => isAscii,
  default: () => buffer_default,
  constants: () => constants,
  btoa: () => btoa2,
  atob: () => atob2,
  INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
  File: () => File,
  Buffer: () => Buffer2,
  Blob: () => Blob2
});
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0)
    throw Error("Invalid string. Length must be a multiple of 4");
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function _byteLength(validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Uint8Array(_byteLength(validLen, placeHoldersLen)), curByte = 0, len2 = placeHoldersLen > 0 ? validLen - 4 : validLen, i2;
  for (i2 = 0;i2 < len2; i2 += 4)
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 2)
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4, arr[curByte++] = tmp & 255;
  if (placeHoldersLen === 1)
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp, output2 = [];
  for (var i2 = start;i2 < end; i2 += 3)
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255), output2.push(tripletToBase64(tmp));
  return output2.join("");
}
function fromByteArray(uint8) {
  var tmp, len2 = uint8.length, extraBytes = len2 % 3, parts = [], maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength)
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  if (extraBytes === 1)
    tmp = uint8[len2 - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  else if (extraBytes === 2)
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1], parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  return parts.join("");
}
function read(buffer, offset, isLE2, mLen, nBytes) {
  var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i2 = isLE2 ? nBytes - 1 : 0, d = isLE2 ? -1 : 1, s = buffer[offset + i2];
  i2 += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen;
  for (;nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8)
    ;
  m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen;
  for (;nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8)
    ;
  if (e === 0)
    e = 1 - eBias;
  else if (e === eMax)
    return m ? NaN : (s ? -1 : 1) * (1 / 0);
  else
    m = m + Math.pow(2, mLen), e = e - eBias;
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE2, mLen, nBytes) {
  var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i2 = isLE2 ? 0 : nBytes - 1, d = isLE2 ? 1 : -1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  if (value = Math.abs(value), isNaN(value) || value === 1 / 0)
    m = isNaN(value) ? 1 : 0, e = eMax;
  else {
    if (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1)
      e--, c *= 2;
    if (e + eBias >= 1)
      value += rt / c;
    else
      value += rt * Math.pow(2, 1 - eBias);
    if (value * c >= 2)
      e++, c /= 2;
    if (e + eBias >= eMax)
      m = 0, e = eMax;
    else if (e + eBias >= 1)
      m = (value * c - 1) * Math.pow(2, mLen), e = e + eBias;
    else
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0;
  }
  for (;mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8)
    ;
  e = e << mLen | m, eLen += mLen;
  for (;eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8)
    ;
  buffer[offset + i2 - d] |= s * 128;
}
function createBuffer(length) {
  if (length > kMaxLength)
    throw RangeError('The value "' + length + '" is invalid for option "size"');
  let buf = new Uint8Array(length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function E(sym, getMessage, Base) {
  return class extends Base {
    constructor() {
      super();
      Object.defineProperty(this, "message", { value: getMessage.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
    }
    get code() {
      return sym;
    }
    set code(value) {
      Object.defineProperty(this, "code", { configurable: true, enumerable: true, value, writable: true });
    }
    toString() {
      return `${this.name} [${sym}]: ${this.message}`;
    }
  };
}
function Buffer2(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string")
      throw TypeError('The "string" argument must be of type string. Received type number');
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
function from(value, encodingOrOffset, length) {
  if (typeof value === "string")
    return fromString(value, encodingOrOffset);
  if (ArrayBuffer.isView(value))
    return fromArrayView(value);
  if (value == null)
    throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer))
    return fromArrayBuffer(value, encodingOrOffset, length);
  if (typeof SharedArrayBuffer < "u" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer)))
    return fromArrayBuffer(value, encodingOrOffset, length);
  if (typeof value === "number")
    throw TypeError('The "value" argument must not be of type number. Received type number');
  let valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value)
    return Buffer2.from(valueOf, encodingOrOffset, length);
  let b2 = fromObject(value);
  if (b2)
    return b2;
  if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function")
    return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
  throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
function assertSize(size) {
  if (typeof size !== "number")
    throw TypeError('"size" argument must be of type number');
  else if (size < 0)
    throw RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
  if (assertSize(size), size <= 0)
    return createBuffer(size);
  if (fill !== undefined)
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  return createBuffer(size);
}
function allocUnsafe(size) {
  return assertSize(size), createBuffer(size < 0 ? 0 : checked(size) | 0);
}
function fromString(string, encoding) {
  if (typeof encoding !== "string" || encoding === "")
    encoding = "utf8";
  if (!Buffer2.isEncoding(encoding))
    throw TypeError("Unknown encoding: " + encoding);
  let length = byteLength(string, encoding) | 0, buf = createBuffer(length), actual = buf.write(string, encoding);
  if (actual !== length)
    buf = buf.slice(0, actual);
  return buf;
}
function fromArrayLike(array) {
  let length = array.length < 0 ? 0 : checked(array.length) | 0, buf = createBuffer(length);
  for (let i2 = 0;i2 < length; i2 += 1)
    buf[i2] = array[i2] & 255;
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    let copy4 = new Uint8Array(arrayView);
    return fromArrayBuffer(copy4.buffer, copy4.byteOffset, copy4.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset)
    throw RangeError('"offset" is outside of buffer bounds');
  if (array.byteLength < byteOffset + (length || 0))
    throw RangeError('"length" is outside of buffer bounds');
  let buf;
  if (byteOffset === undefined && length === undefined)
    buf = new Uint8Array(array);
  else if (length === undefined)
    buf = new Uint8Array(array, byteOffset);
  else
    buf = new Uint8Array(array, byteOffset, length);
  return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
}
function fromObject(obj) {
  if (Buffer2.isBuffer(obj)) {
    let len2 = checked(obj.length) | 0, buf = createBuffer(len2);
    if (buf.length === 0)
      return buf;
    return obj.copy(buf, 0, 0, len2), buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== "number" || Number.isNaN(obj.length))
      return createBuffer(0);
    return fromArrayLike(obj);
  }
  if (obj.type === "Buffer" && Array.isArray(obj.data))
    return fromArrayLike(obj.data);
}
function checked(length) {
  if (length >= kMaxLength)
    throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
  return length | 0;
}
function byteLength(string, encoding) {
  if (Buffer2.isBuffer(string))
    return string.length;
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer))
    return string.byteLength;
  if (typeof string !== "string")
    throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
  let len2 = string.length, mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len2 === 0)
    return 0;
  let loweredCase = false;
  for (;; )
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len2;
      case "utf8":
      case "utf-8":
        return utf8ToBytes3(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len2 * 2;
      case "hex":
        return len2 >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return mustMatch ? -1 : utf8ToBytes3(string).length;
        encoding = ("" + encoding).toLowerCase(), loweredCase = true;
    }
}
function slowToString(encoding, start, end) {
  let loweredCase = false;
  if (start === undefined || start < 0)
    start = 0;
  if (start > this.length)
    return "";
  if (end === undefined || end > this.length)
    end = this.length;
  if (end <= 0)
    return "";
  if (end >>>= 0, start >>>= 0, end <= start)
    return "";
  if (!encoding)
    encoding = "utf8";
  while (true)
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase(), loweredCase = true;
    }
}
function swap(b2, n2, m) {
  let i2 = b2[n2];
  b2[n2] = b2[m], b2[m] = i2;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string")
    encoding = byteOffset, byteOffset = 0;
  else if (byteOffset > 2147483647)
    byteOffset = 2147483647;
  else if (byteOffset < -2147483648)
    byteOffset = -2147483648;
  if (byteOffset = +byteOffset, Number.isNaN(byteOffset))
    byteOffset = dir ? 0 : buffer.length - 1;
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length)
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  else if (byteOffset < 0)
    if (dir)
      byteOffset = 0;
    else
      return -1;
  if (typeof val === "string")
    val = Buffer2.from(val, encoding);
  if (Buffer2.isBuffer(val)) {
    if (val.length === 0)
      return -1;
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    if (val = val & 255, typeof Uint8Array.prototype.indexOf === "function")
      if (dir)
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      else
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  let indexSize = 1, arrLength = arr.length, valLength = val.length;
  if (encoding !== undefined) {
    if (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2)
        return -1;
      indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1)
      return buf[i3];
    else
      return buf.readUInt16BE(i3 * indexSize);
  }
  let i2;
  if (dir) {
    let foundIndex = -1;
    for (i2 = byteOffset;i2 < arrLength; i2++)
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset;i2 >= 0; i2--) {
      let found = true;
      for (let j = 0;j < valLength; j++)
        if (read2(arr, i2 + j) !== read2(val, j)) {
          found = false;
          break;
        }
      if (found)
        return i2;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  let remaining = buf.length - offset;
  if (!length)
    length = remaining;
  else if (length = Number(length), length > remaining)
    length = remaining;
  let strLen = string.length;
  if (length > strLen / 2)
    length = strLen / 2;
  let i2;
  for (i2 = 0;i2 < length; ++i2) {
    let parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (Number.isNaN(parsed))
      return i2;
    buf[offset + i2] = parsed;
  }
  return i2;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes3(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length)
    return fromByteArray(buf);
  else
    return fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  let res = [], i2 = start;
  while (i2 < end) {
    let firstByte = buf[i2], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128)
            codePoint = firstByte;
          break;
        case 2:
          if (secondByte = buf[i2 + 1], (secondByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127)
              codePoint = tempCodePoint;
          }
          break;
        case 3:
          if (secondByte = buf[i2 + 1], thirdByte = buf[i2 + 2], (secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343))
              codePoint = tempCodePoint;
          }
          break;
        case 4:
          if (secondByte = buf[i2 + 1], thirdByte = buf[i2 + 2], fourthByte = buf[i2 + 3], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            if (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112)
              codePoint = tempCodePoint;
          }
      }
    }
    if (codePoint === null)
      codePoint = 65533, bytesPerSequence = 1;
    else if (codePoint > 65535)
      codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023;
    res.push(codePoint), i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  let len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, codePoints);
  let res = "", i2 = 0;
  while (i2 < len2)
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  return res;
}
function asciiSlice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i2 = start;i2 < end; ++i2)
    ret += String.fromCharCode(buf[i2] & 127);
  return ret;
}
function latin1Slice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i2 = start;i2 < end; ++i2)
    ret += String.fromCharCode(buf[i2]);
  return ret;
}
function hexSlice(buf, start, end) {
  let len2 = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len2)
    end = len2;
  let out = "";
  for (let i2 = start;i2 < end; ++i2)
    out += hexSliceLookupTable[buf[i2]];
  return out;
}
function utf16leSlice(buf, start, end) {
  let bytes2 = buf.slice(start, end), res = "";
  for (let i2 = 0;i2 < bytes2.length - 1; i2 += 2)
    res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw RangeError("offset is not uint");
  if (offset + ext > length)
    throw RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max2, min2) {
  if (!Buffer2.isBuffer(buf))
    throw TypeError('"buffer" argument must be a Buffer instance');
  if (value > max2 || value < min2)
    throw RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw RangeError("Index out of range");
}
function wrtBigUInt64LE(buf, value, offset, min2, max2) {
  checkIntBI(value, min2, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  return buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, offset;
}
function wrtBigUInt64BE(buf, value, offset, min2, max2) {
  checkIntBI(value, min2, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo, lo = lo >> 8, buf[offset + 6] = lo, lo = lo >> 8, buf[offset + 5] = lo, lo = lo >> 8, buf[offset + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  return buf[offset + 3] = hi, hi = hi >> 8, buf[offset + 2] = hi, hi = hi >> 8, buf[offset + 1] = hi, hi = hi >> 8, buf[offset] = hi, offset + 8;
}
function checkIEEE754(buf, value, offset, ext, max2, min2) {
  if (offset + ext > buf.length)
    throw RangeError("Index out of range");
  if (offset < 0)
    throw RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (value = +value, offset = offset >>> 0, !noAssert)
    checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
  return write(buf, value, offset, littleEndian, 23, 4), offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (value = +value, offset = offset >>> 0, !noAssert)
    checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
  return write(buf, value, offset, littleEndian, 52, 8), offset + 8;
}
function addNumericalSeparator(val) {
  let res = "", i2 = val.length, start = val[0] === "-" ? 1 : 0;
  for (;i2 >= start + 4; i2 -= 3)
    res = `_${val.slice(i2 - 3, i2)}${res}`;
  return `${val.slice(0, i2)}${res}`;
}
function checkBounds(buf, offset, byteLength2) {
  if (validateNumber(offset, "offset"), buf[offset] === undefined || buf[offset + byteLength2] === undefined)
    boundsError(offset, buf.length - (byteLength2 + 1));
}
function checkIntBI(value, min2, max2, buf, offset, byteLength2) {
  if (value > max2 || value < min2) {
    let n2 = typeof min2 === "bigint" ? "n" : "", range;
    if (byteLength2 > 3)
      if (min2 === 0 || min2 === BigInt(0))
        range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
      else
        range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
    else
      range = `>= ${min2}${n2} and <= ${max2}${n2}`;
    throw new ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds(buf, offset, byteLength2);
}
function validateNumber(value, name) {
  if (typeof value !== "number")
    throw new ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value)
    throw validateNumber(value, type), new ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  if (length < 0)
    throw new ERR_BUFFER_OUT_OF_BOUNDS;
  throw new ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function base64clean(str) {
  if (str = str.split("=")[0], str = str.trim().replace(INVALID_BASE64_RE, ""), str.length < 2)
    return "";
  while (str.length % 4 !== 0)
    str = str + "=";
  return str;
}
function utf8ToBytes3(string, units) {
  units = units || 1 / 0;
  let codePoint, length = string.length, leadSurrogate = null, bytes2 = [];
  for (let i2 = 0;i2 < length; ++i2) {
    if (codePoint = string.charCodeAt(i2), codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    if (leadSurrogate = null, codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else
      throw Error("Invalid code point");
  }
  return bytes2;
}
function asciiToBytes(str) {
  let byteArray = [];
  for (let i2 = 0;i2 < str.length; ++i2)
    byteArray.push(str.charCodeAt(i2) & 255);
  return byteArray;
}
function utf16leToBytes(str, units) {
  let c, hi, lo, byteArray = [];
  for (let i2 = 0;i2 < str.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i2), hi = c >> 8, lo = c % 256, byteArray.push(lo), byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  let i2;
  for (i2 = 0;i2 < length; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset] = src[i2];
  }
  return i2;
}
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function defineBigIntMethod(fn) {
  return typeof BigInt > "u" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw Error("BigInt not supported");
}
function notimpl(name) {
  return () => {
    throw Error(name + " is not implemented for node:buffer browser polyfill");
  };
}
var lookup, revLookup, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i, len, customInspectSymbol, INSPECT_MAX_BYTES = 50, kMaxLength = 2147483647, kStringMaxLength = 536870888, btoa2, atob2, File, Blob2, constants, ERR_BUFFER_OUT_OF_BOUNDS, ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, MAX_ARGUMENTS_LENGTH = 4096, INVALID_BASE64_RE, hexSliceLookupTable, resolveObjectURL, isUtf8, isAscii = (str) => {
  for (let char of str)
    if (char.charCodeAt(0) > 127)
      return false;
  return true;
}, transcode, buffer_default;
var init_buffer = __esm(() => {
  lookup = [];
  revLookup = [];
  for (i = 0, len = code.length;i < len; ++i)
    lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
  revLookup[45] = 62;
  revLookup[95] = 63;
  customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  btoa2 = globalThis.btoa;
  atob2 = globalThis.atob;
  File = globalThis.File;
  Blob2 = globalThis.Blob;
  constants = { MAX_LENGTH: kMaxLength, MAX_STRING_LENGTH: kStringMaxLength };
  ERR_BUFFER_OUT_OF_BOUNDS = E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name)
      return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  ERR_INVALID_ARG_TYPE = E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  ERR_OUT_OF_RANGE = E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`, received = input;
    if (Number.isInteger(input) && Math.abs(input) > 4294967296)
      received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
      if (received = String(input), input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32)))
        received = addNumericalSeparator(received);
      received += "n";
    }
    return msg += ` It must be ${range}. Received ${received}`, msg;
  }, RangeError);
  Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.buffer;
  } });
  Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.byteOffset;
  } });
  Buffer2.poolSize = 8192;
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.isBuffer = function(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function(a, b2) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2))
      throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b2)
      return 0;
    let x = a.length, y = b2.length;
    for (let i2 = 0, len2 = Math.min(x, y);i2 < len2; ++i2)
      if (a[i2] !== b2[i2]) {
        x = a[i2], y = b2[i2];
        break;
      }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function(list, length) {
    if (!Array.isArray(list))
      throw TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0)
      return Buffer2.alloc(0);
    let i2;
    if (length === undefined) {
      length = 0;
      for (i2 = 0;i2 < list.length; ++i2)
        length += list[i2].length;
    }
    let buffer = Buffer2.allocUnsafe(length), pos = 0;
    for (i2 = 0;i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array))
        if (pos + buf.length > buffer.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer, pos);
        } else
          Uint8Array.prototype.set.call(buffer, buf, pos);
      else if (!Buffer2.isBuffer(buf))
        throw TypeError('"list" argument must be an Array of Buffers');
      else
        buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };
  Buffer2.byteLength = byteLength;
  Buffer2.prototype._isBuffer = true;
  Buffer2.prototype.swap16 = function() {
    let len2 = this.length;
    if (len2 % 2 !== 0)
      throw RangeError("Buffer size must be a multiple of 16-bits");
    for (let i2 = 0;i2 < len2; i2 += 2)
      swap(this, i2, i2 + 1);
    return this;
  };
  Buffer2.prototype.swap32 = function() {
    let len2 = this.length;
    if (len2 % 4 !== 0)
      throw RangeError("Buffer size must be a multiple of 32-bits");
    for (let i2 = 0;i2 < len2; i2 += 4)
      swap(this, i2, i2 + 3), swap(this, i2 + 1, i2 + 2);
    return this;
  };
  Buffer2.prototype.swap64 = function() {
    let len2 = this.length;
    if (len2 % 8 !== 0)
      throw RangeError("Buffer size must be a multiple of 64-bits");
    for (let i2 = 0;i2 < len2; i2 += 8)
      swap(this, i2, i2 + 7), swap(this, i2 + 1, i2 + 6), swap(this, i2 + 2, i2 + 5), swap(this, i2 + 3, i2 + 4);
    return this;
  };
  Buffer2.prototype.toString = function() {
    let length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function(b2) {
    if (!Buffer2.isBuffer(b2))
      throw TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function() {
    let str = "", max2 = INSPECT_MAX_BYTES;
    if (str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim(), this.length > max2)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol)
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  Buffer2.prototype.compare = function(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array))
      target = Buffer2.from(target, target.offset, target.byteLength);
    if (!Buffer2.isBuffer(target))
      throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined)
      start = 0;
    if (end === undefined)
      end = target ? target.length : 0;
    if (thisStart === undefined)
      thisStart = 0;
    if (thisEnd === undefined)
      thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length)
      throw RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end)
      return 0;
    if (thisStart >= thisEnd)
      return -1;
    if (start >= end)
      return 1;
    if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
      return 0;
    let x = thisEnd - thisStart, y = end - start, len2 = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end);
    for (let i2 = 0;i2 < len2; ++i2)
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2], y = targetCopy[i2];
        break;
      }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer2.prototype.includes = function(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  Buffer2.prototype.write = function(string, offset, length, encoding) {
    if (offset === undefined)
      encoding = "utf8", length = this.length, offset = 0;
    else if (length === undefined && typeof offset === "string")
      encoding = offset, length = this.length, offset = 0;
    else if (isFinite(offset))
      if (offset = offset >>> 0, isFinite(length)) {
        if (length = length >>> 0, encoding === undefined)
          encoding = "utf8";
      } else
        encoding = length, length = undefined;
    else
      throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length)
      throw RangeError("Attempt to write outside buffer bounds");
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (;; )
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase(), loweredCase = true;
      }
  };
  Buffer2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  Buffer2.prototype.slice = function(start, end) {
    let len2 = this.length;
    if (start = ~~start, end = end === undefined ? len2 : ~~end, start < 0) {
      if (start += len2, start < 0)
        start = 0;
    } else if (start > len2)
      start = len2;
    if (end < 0) {
      if (end += len2, end < 0)
        end = 0;
    } else if (end > len2)
      end = len2;
    if (end < start)
      end = start;
    let newBuf = this.subarray(start, end);
    return Object.setPrototypeOf(newBuf, Buffer2.prototype), newBuf;
  };
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset], mul2 = 1, i2 = 0;
    while (++i2 < byteLength2 && (mul2 *= 256))
      val += this[offset + i2] * mul2;
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset + --byteLength2], mul2 = 1;
    while (byteLength2 > 0 && (mul2 *= 256))
      val += this[offset + --byteLength2] * mul2;
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216, hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 16777216;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let hi = first * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset], lo = this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset], mul2 = 1, i2 = 0;
    while (++i2 < byteLength2 && (mul2 *= 256))
      val += this[offset + i2] * mul2;
    if (mul2 *= 128, val >= mul2)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readIntBE = function(offset, byteLength2, noAssert) {
    if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i2 = byteLength2, mul2 = 1, val = this[offset + --i2];
    while (i2 > 0 && (mul2 *= 256))
      val += this[offset + --i2] * mul2;
    if (mul2 *= 128, val >= mul2)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readInt8 = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    let val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 2, this.length);
    let val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function(offset) {
    offset = offset >>> 0, validateNumber(offset, "offset");
    let first = this[offset], last = this[offset + 7];
    if (first === undefined || last === undefined)
      boundsError(offset, this.length - 8);
    let val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last);
  });
  Buffer2.prototype.readFloatLE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function(offset, noAssert) {
    if (offset = offset >>> 0, !noAssert)
      checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul2 = 1, i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul2 *= 256))
      this[offset + i2] = value / mul2 & 255;
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
      let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i2 = byteLength2 - 1, mul2 = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul2 *= 256))
      this[offset + i2] = value / mul2 & 255;
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    return this[offset] = value & 255, offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    return this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    return this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    return this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i2 = 0, mul2 = 1, sub2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul2 *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i2 - 1] !== 0)
        sub2 = 1;
      this[offset + i2] = (value / mul2 >> 0) - sub2 & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeIntBE = function(value, offset, byteLength2, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert) {
      let limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i2 = byteLength2 - 1, mul2 = 1, sub2 = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul2 *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i2 + 1] !== 0)
        sub2 = 1;
      this[offset + i2] = (value / mul2 >> 0) - sub2 & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeInt8 = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    return this[offset] = value & 255, offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    return this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    return this[offset] = value & 255, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24, offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function(value, offset, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    return this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeFloatLE = function(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.writeDoubleLE = function(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0)
      throw RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length)
      throw RangeError("Index out of range");
    if (end < 0)
      throw RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start)
      end = target.length - targetStart + start;
    let len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function")
      this.copyWithin(targetStart, start, end);
    else
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len2;
  };
  Buffer2.prototype.fill = function(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string")
        encoding = start, start = 0, end = this.length;
      else if (typeof end === "string")
        encoding = end, end = this.length;
      if (encoding !== undefined && typeof encoding !== "string")
        throw TypeError("encoding must be a string");
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding))
        throw TypeError("Unknown encoding: " + encoding);
      if (val.length === 1) {
        let code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1")
          val = code2;
      }
    } else if (typeof val === "number")
      val = val & 255;
    else if (typeof val === "boolean")
      val = Number(val);
    if (start < 0 || this.length < start || this.length < end)
      throw RangeError("Out of range index");
    if (end <= start)
      return this;
    if (start = start >>> 0, end = end === undefined ? this.length : end >>> 0, !val)
      val = 0;
    let i2;
    if (typeof val === "number")
      for (i2 = start;i2 < end; ++i2)
        this[i2] = val;
    else {
      let bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding), len2 = bytes2.length;
      if (len2 === 0)
        throw TypeError('The value "' + val + '" is invalid for argument "value"');
      for (i2 = 0;i2 < end - start; ++i2)
        this[i2 + start] = bytes2[i2 % len2];
    }
    return this;
  };
  INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  hexSliceLookupTable = function() {
    let table = Array(256);
    for (let i2 = 0;i2 < 16; ++i2) {
      let i16 = i2 * 16;
      for (let j = 0;j < 16; ++j)
        table[i16 + j] = "0123456789abcdef"[i2] + "0123456789abcdef"[j];
    }
    return table;
  }();
  resolveObjectURL = notimpl("resolveObjectURL");
  isUtf8 = notimpl("isUtf8");
  transcode = notimpl("transcode");
  buffer_default = Buffer2;
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS((exports, module) => {
  (function(module2, exports2) {
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
    function BN(number2, base, endian) {
      if (BN.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }
        this._init(number2 || 0, base || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN;
    } else {
      exports2.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer3;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer3 = window.Buffer;
      } else {
        Buffer3 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      }
    } catch (e) {}
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN.prototype._init = function init(number2, base, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base, endian);
      }
      if (base === "hex") {
        base = 16;
      }
      assert3(base === (base | 0) && base >= 2 && base <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number2, base, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert3(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number2, base, endian) {
      assert3(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0;i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i2 = number2.length - 1, j = 0;i2 >= 0; i2 -= 3) {
          w = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j = 0;i2 < number2.length; i2 += 3) {
          w = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert3(false, "Invalid character in " + string);
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0;i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i2 = number2.length - 1;i2 >= start; i2 -= 2) {
          w = parseHexByte(number2, start, i2) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i2 = parseLength % 2 === 0 ? start + 1 : start;i2 < number2.length; i2 += 2) {
          w = parseHexByte(number2, start, i2) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul2) {
      var r = 0;
      var b2 = 0;
      var len2 = Math.min(str.length, end);
      for (var i2 = start;i2 < len2; i2++) {
        var c = str.charCodeAt(i2) - 48;
        r *= mul2;
        if (c >= 49) {
          b2 = c - 49 + 10;
        } else if (c >= 17) {
          b2 = c - 17 + 10;
        } else {
          b2 = c;
        }
        assert3(c >= 0 && b2 < mul2, "Invalid character");
        r += b2;
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number2, base, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number2.length - start;
      var mod4 = total % limbLen;
      var end = Math.min(total, total - mod4) + start;
      var word = 0;
      for (var i2 = start;i2 < end; i2 += limbLen) {
        word = parseBase(number2, i2, i2 + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod4 !== 0) {
        var pow3 = 1;
        word = parseBase(number2, i2, number2.length, base);
        for (i2 = 0;i2 < mod4; i2++) {
          pow3 *= base;
        }
        this.imuln(pow3);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0;i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
      } catch (e) {
        BN.prototype.inspect = inspect;
      }
    } else {
      BN.prototype.inspect = inspect;
    }
    function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64000000,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      24300000,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN.prototype.toString = function toString(base, padding2) {
      base = base || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0;i2 < this.length; i2++) {
          var w = this.words[i2];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modrn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros2[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert3(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert3(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16, 2);
    };
    if (Buffer3) {
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer3, endian, length);
      };
    }
    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert3(byteLength2 <= reqLength, "byte array longer than desired length");
      assert3(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position = 0;
      var carry = 0;
      for (var i2 = 0, shift = 0;i2 < this.length; i2++) {
        var word = this.words[i2] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position = res.length - 1;
      var carry = 0;
      for (var i2 = 0, shift = 0;i2 < this.length; i2++) {
        var word = this.words[i2] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0;bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i2 = 0;i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r += b2;
        if (b2 !== 26)
          break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0;i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this._strip();
    };
    BN.prototype.ior = function ior(num) {
      assert3((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0;i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN.prototype.iand = function iand(num) {
      assert3((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a;
      var b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      for (var i2 = 0;i2 < b2.length; i2++) {
        this.words[i2] = a.words[i2] ^ b2.words[i2];
      }
      if (this !== a) {
        for (;i2 < a.length; i2++) {
          this.words[i2] = a.words[i2];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert3((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert3(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0;i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert3(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0;i2 < b2.length; i2++) {
        r = (a.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r & 67108863;
        carry = r >>> 26;
      }
      for (;carry !== 0 && i2 < a.length; i2++) {
        r = (a.words[i2] | 0) + carry;
        this.words[i2] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (;i2 < a.length; i2++) {
          this.words[i2] = a.words[i2];
        }
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b2;
      if (cmp > 0) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0;i2 < b2.length; i2++) {
        r = (a.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r >> 26;
        this.words[i2] = r & 67108863;
      }
      for (;carry !== 0 && i2 < a.length; i2++) {
        r = (a.words[i2] | 0) + carry;
        carry = r >> 26;
        this.words[i2] = r & 67108863;
      }
      if (carry === 0 && i2 < a.length && a !== this) {
        for (;i2 < a.length; i2++) {
          this.words[i2] = a.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r = a * b2;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1;k < len2; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i2 = k - j | 0;
          a = self2.words[i2] | 0;
          b2 = num.words[j] | 0;
          r = a * b2 + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo(self2, num, out) {
      var a = self2.words;
      var b2 = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0;k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i2 = k - j;
          var a = self2.words[i2] | 0;
          var b2 = num.words[j] | 0;
          var r = a * b2;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N3) {
      var t = new Array(N3);
      var l = BN.prototype._countBits(N3) - 1;
      for (var i2 = 0;i2 < N3; i2++) {
        t[i2] = this.revBin(i2, l, N3);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N3) {
      if (x === 0 || x === N3 - 1)
        return x;
      var rb = 0;
      for (var i2 = 0;i2 < l; i2++) {
        rb |= (x & 1) << l - i2 - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
      for (var i2 = 0;i2 < N3; i2++) {
        rtws[i2] = rws[rbt[i2]];
        itws[i2] = iws[rbt[i2]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N3);
      for (var s = 1;s < N3; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0;p < N3; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0;j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
      var N3 = Math.max(m, n2) | 1;
      var odd = N3 & 1;
      var i2 = 0;
      for (N3 = N3 / 2 | 0;N3; N3 = N3 >>> 1) {
        i2++;
      }
      return 1 << i2 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
      if (N3 <= 1)
        return;
      for (var i2 = 0;i2 < N3 / 2; i2++) {
        var t = rws[i2];
        rws[i2] = rws[N3 - i2 - 1];
        rws[N3 - i2 - 1] = t;
        t = iws[i2];
        iws[i2] = -iws[N3 - i2 - 1];
        iws[N3 - i2 - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
      var carry = 0;
      for (var i2 = 0;i2 < N3 / 2; i2++) {
        var w = Math.round(ws[2 * i2 + 1] / N3) * 8192 + Math.round(ws[2 * i2] / N3) + carry;
        ws[i2] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N3) {
      var carry = 0;
      for (var i2 = 0;i2 < len2; i2++) {
        carry = carry + (ws[i2] | 0);
        rws[2 * i2] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i2 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i2 = 2 * len2;i2 < N3; ++i2) {
        rws[i2] = 0;
      }
      assert3(carry === 0);
      assert3((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N3) {
      var ph = new Array(N3);
      for (var i2 = 0;i2 < N3; i2++) {
        ph[i2] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N3 = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N3);
      var _ = this.stub(N3);
      var rws = new Array(N3);
      var rwst = new Array(N3);
      var iwst = new Array(N3);
      var nrws = new Array(N3);
      var nrwst = new Array(N3);
      var niwst = new Array(N3);
      var rmws = out.words;
      rmws.length = N3;
      this.convert13b(x.words, x.length, rws, N3);
      this.convert13b(y.words, y.length, nrws, N3);
      this.transform(rws, _, rwst, iwst, N3, rbt);
      this.transform(nrws, _, nrwst, niwst, N3, rbt);
      for (var i2 = 0;i2 < N3; i2++) {
        var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
        iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
        rwst[i2] = rx;
      }
      this.conjugate(rwst, iwst, N3);
      this.transform(rwst, iwst, rmws, _, N3, rbt);
      this.conjugate(rmws, _, N3);
      this.normalize13b(rmws, N3);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out._strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert3(typeof num === "number");
      assert3(num < 67108864);
      var carry = 0;
      for (var i2 = 0;i2 < this.length; i2++) {
        var w = (this.words[i2] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      this.length = num === 0 ? 1 : this.length;
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN(1);
      var res = this;
      for (var i2 = 0;i2 < w.length; i2++, res = res.sqr()) {
        if (w[i2] !== 0)
          break;
      }
      if (++i2 < w.length) {
        for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
          if (w[i2] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert3(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i2;
      if (r !== 0) {
        var carry = 0;
        for (i2 = 0;i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c = (this.words[i2] | 0) - newCarry << r;
          this.words[i2] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i2 = this.length - 1;i2 >= 0; i2--) {
          this.words[i2 + s] = this.words[i2];
        }
        for (i2 = 0;i2 < s; i2++) {
          this.words[i2] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert3(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert3(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask2 = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i2 = 0;i2 < s; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s;
      }
      if (s === 0) {} else if (this.length > s) {
        this.length -= s;
        for (i2 = 0;i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r | word >>> r;
        carry = word & mask2;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert3(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert3(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert3(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert3(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask2;
      }
      return this._strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert3(typeof num === "number");
      assert3(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert3(typeof num === "number");
      assert3(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul2, shift) {
      var len2 = num.length + shift;
      var i2;
      this._expand(len2);
      var w;
      var carry = 0;
      for (i2 = 0;i2 < num.length; i2++) {
        w = (this.words[i2 + shift] | 0) + carry;
        var right = (num.words[i2] | 0) * mul2;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift] = w & 67108863;
      }
      for (;i2 < this.length - shift; i2++) {
        w = (this.words[i2 + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i2 + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert3(carry === -1);
      carry = 0;
      for (i2 = 0;i2 < this.length; i2++) {
        w = -(this.words[i2] | 0) + carry;
        carry = w >> 26;
        this.words[i2] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m = a.length - b2.length;
      var q;
      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i2 = 0;i2 < q.length; i2++) {
          q.words[i2] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b2, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1;j >= 0; j--) {
        var qj = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b2, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b2, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert3(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div2, mod4, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div2 = res.div.neg();
        }
        if (mode !== "div") {
          mod4 = res.mod.neg();
          if (positive && mod4.negative !== 0) {
            mod4.iadd(num);
          }
        }
        return {
          div: div2,
          mod: mod4
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div2 = res.div.neg();
        }
        return {
          div: div2,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod4 = res.mod.neg();
          if (positive && mod4.negative !== 0) {
            mod4.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod4
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod4 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod4.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert3(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1;i2 >= 0; i2--) {
        acc = (p * acc + (this.words[i2] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert3(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1;i2 >= 0; i2--) {
        var w = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert3(p.negative === 0);
      assert3(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x.iushrn(i2);
          while (i2-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert3(p.negative === 0);
      assert3(!p.isZero());
      var a = this;
      var b2 = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b2.clone();
      while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b2.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b2) >= 0) {
          a.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b2 = num.clone();
      a.negative = 0;
      b2.negative = 0;
      for (var shift = 0;a.isEven() && b2.isEven(); shift++) {
        a.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r = a.cmp(b2);
        if (r < 0) {
          var t = a;
          a = b2;
          b2 = t;
        } else if (r === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert3(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
        var w = this.words[i2] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i2] = w;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert3(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1;i2 >= 0; i2--) {
        var a = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a === b2)
          continue;
        if (a < b2) {
          res = -1;
        } else if (a > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert3(!this.red, "Already a number in reduction context");
      assert3(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert3(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert3(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert3(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert3(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert3(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert3(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert3(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert3(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert3(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert3(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert3(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert3(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert3(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert3(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert3(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output2) {
      var mask2 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0;i2 < outLen; i2++) {
        output2.words[i2] = input.words[i2];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask2;
      for (i2 = 10;i2 < input.length; i2++) {
        var next = input.words[i2] | 0;
        input.words[i2 - 10] = (next & mask2) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0;i2 < num.length; i2++) {
        var w = num.words[i2] | 0;
        lo += w * 977;
        num.words[i2] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0;i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === "k256") {
        prime = new K256;
      } else if (name === "p224") {
        prime = new P224;
      } else if (name === "p192") {
        prime = new P192;
      } else if (name === "p25519") {
        prime = new P25519;
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert3(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert3(a.negative === 0, "red works only with positives");
      assert3(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b2) {
      assert3((a.negative | b2.negative) === 0, "red works only with positives");
      assert3(a.red && a.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b2) {
      this._verify2(a, b2);
      var res = a.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b2) {
      this._verify2(a, b2);
      var res = a.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b2) {
      this._verify2(a, b2);
      var res = a.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b2) {
      this._verify2(a, b2);
      var res = a.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.imul(b2));
    };
    Red.prototype.mul = function mul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.mul(b2));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod32 = this.m.andln(3);
      assert3(mod32 % 2 === 1);
      if (mod32 === 3) {
        var pow3 = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow3);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert3(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i2 = 0;tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert3(i2 < m);
        var b2 = this.pow(c, new BN(1).iushln(m - i2 - 1));
        r = r.redMul(b2);
        c = b2.redSqr();
        t = t.redMul(c);
        m = i2;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i2 = 2;i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i2 = num.length - 1;i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j = start - 1;j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b2) {
      if (a.isZero() || b2.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b2) {
      if (a.isZero() || b2.isZero())
        return new BN(0)._forceRed(this);
      var t = a.mul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === "undefined" || module, exports);
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = (init_buffer(), __toCommonJS(exports_buffer));
  var Buffer3 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer3(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer3.prototype);
  copyProps(Buffer3, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer3(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer3(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer3(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/@solana/web3.js/node_modules/bs58/node_modules/base-x/src/index.js
var require_src = __commonJS((exports, module) => {
  var _Buffer = require_safe_buffer().Buffer;
  function base(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i2 = 0;i2 < ALPHABET.length; i2++) {
      var x = ALPHABET.charAt(i2);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE2 = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE2) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE2);
    function encode(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1;(carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE2 >>> 0;
          carry = carry / BASE2 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i3;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (psz < source.length) {
        var charCode = source.charCodeAt(psz);
        if (charCode > 255) {
          return;
        }
        var carry = BASE_MAP[charCode];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1;(carry !== 0 || i3 < length) && it3 !== -1; it3--, i3++) {
          carry += BASE2 * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i3;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string) {
      var buffer = decodeUnsafe(string);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE2 + " character");
    }
    return {
      encode,
      decodeUnsafe,
      decode: decode2
    };
  }
  module.exports = base;
});

// node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs58 = __commonJS((exports, module) => {
  var basex = require_src();
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET);
});

// node_modules/borsh/node_modules/bs58/node_modules/base-x/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var _Buffer = require_safe_buffer().Buffer;
  function base(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i2 = 0;i2 < ALPHABET.length; i2++) {
      var x = ALPHABET.charAt(i2);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE2 = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE2) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE2);
    function encode(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1;(carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE2 >>> 0;
          carry = carry / BASE2 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i3;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (psz < source.length) {
        var charCode = source.charCodeAt(psz);
        if (charCode > 255) {
          return;
        }
        var carry = BASE_MAP[charCode];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1;(carry !== 0 || i3 < length) && it3 !== -1; it3--, i3++) {
          carry += BASE2 * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i3;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string) {
      var buffer = decodeUnsafe(string);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE2 + " character");
    }
    return {
      encode,
      decodeUnsafe,
      decode: decode2
    };
  }
  module.exports = base;
});

// node_modules/borsh/node_modules/bs58/index.js
var require_bs582 = __commonJS((exports, module) => {
  var basex = require_src2();
  var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET);
});

// node_modules/text-encoding-utf-8/src/encoding.js
var exports_encoding = {};
__export(exports_encoding, {
  TextEncoder: () => TextEncoder2,
  TextDecoder: () => TextDecoder2
});
function inRange2(a, min2, max2) {
  return min2 <= a && a <= max2;
}
function ToDictionary(o) {
  if (o === undefined)
    return {};
  if (o === Object(o))
    return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string) {
  var s = String(string);
  var n2 = s.length;
  var i2 = 0;
  var u = [];
  while (i2 < n2) {
    var c = s.charCodeAt(i2);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i2 === n2 - 1) {
        u.push(65533);
      } else {
        var d = string.charCodeAt(i2 + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b2 = d & 1023;
          u.push(65536 + (a << 10) + b2);
          i2 += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i2 += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i2 = 0;i2 < code_points.length; ++i2) {
    var cp = code_points[i2];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
    }
  }
  return s;
}
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function Decoder() {}
function Encoder() {}
function TextDecoder2(encoding, options) {
  if (!(this instanceof TextDecoder2)) {
    return new TextDecoder2(encoding, options);
  }
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder2(encoding, options) {
  if (!(this instanceof TextEncoder2))
    return new TextEncoder2(encoding, options);
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange2(bite, 0, 127)) {
        return bite;
      }
      if (inRange2(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange2(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange2(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange2(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange2(code_point, 0, 127))
      return code_point;
    var count, offset;
    if (inRange2(code_point, 128, 2047)) {
      count = 1;
      offset = 192;
    } else if (inRange2(code_point, 2048, 65535)) {
      count = 2;
      offset = 224;
    } else if (inRange2(code_point, 65536, 1114111)) {
      count = 3;
      offset = 240;
    }
    var bytes2 = [(code_point >> 6 * count) + offset];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes2.push(128 | temp & 63);
      count -= 1;
    }
    return bytes2;
  };
}
var end_of_stream = -1, finished = -1, DEFAULT_ENCODING = "utf-8";
var init_encoding = __esm(() => {
  Stream.prototype = {
    endOfStream: function() {
      return !this.tokens.length;
    },
    read: function() {
      if (!this.tokens.length)
        return end_of_stream;
      return this.tokens.shift();
    },
    prepend: function(token) {
      if (Array.isArray(token)) {
        var tokens = token;
        while (tokens.length)
          this.tokens.unshift(tokens.pop());
      } else {
        this.tokens.unshift(token);
      }
    },
    push: function(token) {
      if (Array.isArray(token)) {
        var tokens = token;
        while (tokens.length)
          this.tokens.push(tokens.shift());
      } else {
        this.tokens.push(token);
      }
    }
  };
  Decoder.prototype = {
    handler: function(stream, bite) {}
  };
  Encoder.prototype = {
    handler: function(stream, code_point) {}
  };
  TextDecoder2.prototype = {
    decode: function decode2(input, options) {
      var bytes2;
      if (typeof input === "object" && input instanceof ArrayBuffer) {
        bytes2 = new Uint8Array(input);
      } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
        bytes2 = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
      } else {
        bytes2 = new Uint8Array(0);
      }
      options = ToDictionary(options);
      if (!this._streaming) {
        this._decoder = new UTF8Decoder({ fatal: this._fatal });
        this._BOMseen = false;
      }
      this._streaming = Boolean(options["stream"]);
      var input_stream = new Stream(bytes2);
      var code_points = [];
      var result;
      while (!input_stream.endOfStream()) {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(code_points, result);
        else
          code_points.push(result);
      }
      if (!this._streaming) {
        do {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(code_points, result);
          else
            code_points.push(result);
        } while (!input_stream.endOfStream());
        this._decoder = null;
      }
      if (code_points.length) {
        if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
          if (code_points[0] === 65279) {
            this._BOMseen = true;
            code_points.shift();
          } else {
            this._BOMseen = true;
          }
        }
      }
      return codePointsToString(code_points);
    }
  };
  TextEncoder2.prototype = {
    encode: function encode(opt_string, options) {
      opt_string = opt_string ? String(opt_string) : "";
      options = ToDictionary(options);
      if (!this._streaming)
        this._encoder = new UTF8Encoder(this._options);
      this._streaming = Boolean(options["stream"]);
      var bytes2 = [];
      var input_stream = new Stream(stringToCodePoints(opt_string));
      var result;
      while (!input_stream.endOfStream()) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes2.push.apply(bytes2, result);
        else
          bytes2.push(result);
      }
      if (!this._streaming) {
        while (true) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes2.push.apply(bytes2, result);
          else
            bytes2.push(result);
        }
        this._encoder = null;
      }
      return new Uint8Array(bytes2);
    }
  };
});

// node_modules/borsh/lib/index.js
var require_lib = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1;i2 >= 0; i2--)
        if (d = decorators[i2])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __importStar = exports && exports.__importStar || function(mod4) {
    if (mod4 && mod4.__esModule)
      return mod4;
    var result = {};
    if (mod4 != null) {
      for (var k in mod4)
        if (k !== "default" && Object.hasOwnProperty.call(mod4, k))
          __createBinding(result, mod4, k);
    }
    __setModuleDefault(result, mod4);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod4) {
    return mod4 && mod4.__esModule ? mod4 : { default: mod4 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = undefined;
  var bn_js_1 = __importDefault(require_bn());
  var bs58_1 = __importDefault(require_bs582());
  var encoding = __importStar((init_encoding(), __toCommonJS(exports_encoding)));
  var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
  var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
  function baseEncode(value) {
    if (typeof value === "string") {
      value = Buffer.from(value, "utf8");
    }
    return bs58_1.default.encode(Buffer.from(value));
  }
  exports.baseEncode = baseEncode;
  function baseDecode(value) {
    return Buffer.from(bs58_1.default.decode(value));
  }
  exports.baseDecode = baseDecode;
  var INITIAL_LENGTH = 1024;

  class BorshError extends Error {
    constructor(message) {
      super(message);
      this.fieldPath = [];
      this.originalMessage = message;
    }
    addToFieldPath(fieldName) {
      this.fieldPath.splice(0, 0, fieldName);
      this.message = this.originalMessage + ": " + this.fieldPath.join(".");
    }
  }
  exports.BorshError = BorshError;

  class BinaryWriter2 {
    constructor() {
      this.buf = Buffer.alloc(INITIAL_LENGTH);
      this.length = 0;
    }
    maybeResize() {
      if (this.buf.length < 16 + this.length) {
        this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
      }
    }
    writeU8(value) {
      this.maybeResize();
      this.buf.writeUInt8(value, this.length);
      this.length += 1;
    }
    writeU16(value) {
      this.maybeResize();
      this.buf.writeUInt16LE(value, this.length);
      this.length += 2;
    }
    writeU32(value) {
      this.maybeResize();
      this.buf.writeUInt32LE(value, this.length);
      this.length += 4;
    }
    writeU64(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
    }
    writeU128(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
    }
    writeU256(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
    }
    writeU512(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
    }
    writeBuffer(buffer) {
      this.buf = Buffer.concat([
        Buffer.from(this.buf.subarray(0, this.length)),
        buffer,
        Buffer.alloc(INITIAL_LENGTH)
      ]);
      this.length += buffer.length;
    }
    writeString(str) {
      this.maybeResize();
      const b2 = Buffer.from(str, "utf8");
      this.writeU32(b2.length);
      this.writeBuffer(b2);
    }
    writeFixedArray(array) {
      this.writeBuffer(Buffer.from(array));
    }
    writeArray(array, fn) {
      this.maybeResize();
      this.writeU32(array.length);
      for (const elem of array) {
        this.maybeResize();
        fn(elem);
      }
    }
    toArray() {
      return this.buf.subarray(0, this.length);
    }
  }
  exports.BinaryWriter = BinaryWriter2;
  function handlingRangeError(target, propertyKey, propertyDescriptor) {
    const originalMethod = propertyDescriptor.value;
    propertyDescriptor.value = function(...args) {
      try {
        return originalMethod.apply(this, args);
      } catch (e) {
        if (e instanceof RangeError) {
          const code2 = e.code;
          if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code2) >= 0) {
            throw new BorshError("Reached the end of buffer when deserializing");
          }
        }
        throw e;
      }
    };
  }

  class BinaryReader2 {
    constructor(buf) {
      this.buf = buf;
      this.offset = 0;
    }
    readU8() {
      const value = this.buf.readUInt8(this.offset);
      this.offset += 1;
      return value;
    }
    readU16() {
      const value = this.buf.readUInt16LE(this.offset);
      this.offset += 2;
      return value;
    }
    readU32() {
      const value = this.buf.readUInt32LE(this.offset);
      this.offset += 4;
      return value;
    }
    readU64() {
      const buf = this.readBuffer(8);
      return new bn_js_1.default(buf, "le");
    }
    readU128() {
      const buf = this.readBuffer(16);
      return new bn_js_1.default(buf, "le");
    }
    readU256() {
      const buf = this.readBuffer(32);
      return new bn_js_1.default(buf, "le");
    }
    readU512() {
      const buf = this.readBuffer(64);
      return new bn_js_1.default(buf, "le");
    }
    readBuffer(len2) {
      if (this.offset + len2 > this.buf.length) {
        throw new BorshError(`Expected buffer length ${len2} isn't within bounds`);
      }
      const result = this.buf.slice(this.offset, this.offset + len2);
      this.offset += len2;
      return result;
    }
    readString() {
      const len2 = this.readU32();
      const buf = this.readBuffer(len2);
      try {
        return textDecoder.decode(buf);
      } catch (e) {
        throw new BorshError(`Error decoding UTF-8 string: ${e}`);
      }
    }
    readFixedArray(len2) {
      return new Uint8Array(this.readBuffer(len2));
    }
    readArray(fn) {
      const len2 = this.readU32();
      const result = Array();
      for (let i2 = 0;i2 < len2; ++i2) {
        result.push(fn());
      }
      return result;
    }
  }
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU8", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU16", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU32", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU64", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU128", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU256", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU512", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readString", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readFixedArray", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readArray", null);
  exports.BinaryReader = BinaryReader2;
  function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  function serializeField(schema, fieldName, value, fieldType, writer) {
    try {
      if (typeof fieldType === "string") {
        writer[`write${capitalizeFirstLetter(fieldType)}`](value);
      } else if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          if (value.length !== fieldType[0]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
          }
          writer.writeFixedArray(value);
        } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
          if (value.length !== fieldType[1]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
          }
          for (let i2 = 0;i2 < fieldType[1]; i2++) {
            serializeField(schema, null, value[i2], fieldType[0], writer);
          }
        } else {
          writer.writeArray(value, (item) => {
            serializeField(schema, fieldName, item, fieldType[0], writer);
          });
        }
      } else if (fieldType.kind !== undefined) {
        switch (fieldType.kind) {
          case "option": {
            if (value === null || value === undefined) {
              writer.writeU8(0);
            } else {
              writer.writeU8(1);
              serializeField(schema, fieldName, value, fieldType.type, writer);
            }
            break;
          }
          case "map": {
            writer.writeU32(value.size);
            value.forEach((val, key) => {
              serializeField(schema, fieldName, key, fieldType.key, writer);
              serializeField(schema, fieldName, val, fieldType.value, writer);
            });
            break;
          }
          default:
            throw new BorshError(`FieldType ${fieldType} unrecognized`);
        }
      } else {
        serializeStruct(schema, value, writer);
      }
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  }
  function serializeStruct(schema, obj, writer) {
    if (typeof obj.borshSerialize === "function") {
      obj.borshSerialize(writer);
      return;
    }
    const structSchema = schema.get(obj.constructor);
    if (!structSchema) {
      throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      structSchema.fields.map(([fieldName, fieldType]) => {
        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
      });
    } else if (structSchema.kind === "enum") {
      const name = obj[structSchema.field];
      for (let idx = 0;idx < structSchema.values.length; ++idx) {
        const [fieldName, fieldType] = structSchema.values[idx];
        if (fieldName === name) {
          writer.writeU8(idx);
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          break;
        }
      }
    } else {
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
    }
  }
  function serialize(schema, obj, Writer2 = BinaryWriter2) {
    const writer = new Writer2;
    serializeStruct(schema, obj, writer);
    return writer.toArray();
  }
  exports.serialize = serialize;
  function deserializeField(schema, fieldName, fieldType, reader) {
    try {
      if (typeof fieldType === "string") {
        return reader[`read${capitalizeFirstLetter(fieldType)}`]();
      }
      if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          return reader.readFixedArray(fieldType[0]);
        } else if (typeof fieldType[1] === "number") {
          const arr = [];
          for (let i2 = 0;i2 < fieldType[1]; i2++) {
            arr.push(deserializeField(schema, null, fieldType[0], reader));
          }
          return arr;
        } else {
          return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
        }
      }
      if (fieldType.kind === "option") {
        const option = reader.readU8();
        if (option) {
          return deserializeField(schema, fieldName, fieldType.type, reader);
        }
        return;
      }
      if (fieldType.kind === "map") {
        let map = new Map;
        const length = reader.readU32();
        for (let i2 = 0;i2 < length; i2++) {
          const key = deserializeField(schema, fieldName, fieldType.key, reader);
          const val = deserializeField(schema, fieldName, fieldType.value, reader);
          map.set(key, val);
        }
        return map;
      }
      return deserializeStruct(schema, fieldType, reader);
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  }
  function deserializeStruct(schema, classType, reader) {
    if (typeof classType.borshDeserialize === "function") {
      return classType.borshDeserialize(reader);
    }
    const structSchema = schema.get(classType);
    if (!structSchema) {
      throw new BorshError(`Class ${classType.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      const result = {};
      for (const [fieldName, fieldType] of schema.get(classType).fields) {
        result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
      }
      return new classType(result);
    }
    if (structSchema.kind === "enum") {
      const idx = reader.readU8();
      if (idx >= structSchema.values.length) {
        throw new BorshError(`Enum index: ${idx} is out of range`);
      }
      const [fieldName, fieldType] = structSchema.values[idx];
      const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
      return new classType({ [fieldName]: fieldValue });
    }
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
  }
  function deserialize(schema, classType, buffer, Reader2 = BinaryReader2) {
    const reader = new Reader2(buffer);
    const result = deserializeStruct(schema, classType, reader);
    if (reader.offset < buffer.length) {
      throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
    }
    return result;
  }
  exports.deserialize = deserialize;
  function deserializeUnchecked(schema, classType, buffer, Reader2 = BinaryReader2) {
    const reader = new Reader2(buffer);
    return deserializeStruct(schema, classType, reader);
  }
  exports.deserializeUnchecked = deserializeUnchecked;
});

// node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = undefined;
  exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = undefined;
  var buffer_1 = (init_buffer(), __toCommonJS(exports_buffer));
  function checkUint8Array(b2) {
    if (!(b2 instanceof Uint8Array)) {
      throw new TypeError("b must be a Uint8Array");
    }
  }
  exports.checkUint8Array = checkUint8Array;
  function uint8ArrayToBuffer(b2) {
    checkUint8Array(b2);
    return buffer_1.Buffer.from(b2.buffer, b2.byteOffset, b2.length);
  }
  exports.uint8ArrayToBuffer = uint8ArrayToBuffer;

  class Layout {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    makeDestinationObject() {
      return {};
    }
    getSpan(b2, offset) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    fromArray(values) {
      return;
    }
  }
  exports.Layout = Layout;
  function nameWithProperty(name, lo) {
    if (lo.property) {
      return name + "[" + lo.property + "]";
    }
    return name;
  }
  exports.nameWithProperty = nameWithProperty;
  function bindConstructorLayout(Class, layout) {
    if (typeof Class !== "function") {
      throw new TypeError("Class must be constructor");
    }
    if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
      throw new Error("Class is already bound to a layout");
    }
    if (!(layout && layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
      throw new Error("layout is already bound to a constructor");
    }
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = () => new Class;
    Object.defineProperty(Class.prototype, "encode", {
      value(b2, offset) {
        return layout.encode(this, b2, offset);
      },
      writable: true
    });
    Object.defineProperty(Class, "decode", {
      value(b2, offset) {
        return layout.decode(b2, offset);
      },
      writable: true
    });
  }
  exports.bindConstructorLayout = bindConstructorLayout;

  class ExternalLayout extends Layout {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  exports.ExternalLayout = ExternalLayout;

  class GreedyCount extends ExternalLayout {
    constructor(elementSpan = 1, property) {
      if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
        throw new TypeError("elementSpan must be a (positive) integer");
      }
      super(-1, property);
      this.elementSpan = elementSpan;
    }
    isCount() {
      return true;
    }
    decode(b2, offset = 0) {
      checkUint8Array(b2);
      const rem = b2.length - offset;
      return Math.floor(rem / this.elementSpan);
    }
    encode(src, b2, offset) {
      return 0;
    }
  }
  exports.GreedyCount = GreedyCount;

  class OffsetLayout extends ExternalLayout {
    constructor(layout, offset = 0, property) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (!Number.isInteger(offset)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset;
    }
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    decode(b2, offset = 0) {
      return this.layout.decode(b2, offset + this.offset);
    }
    encode(src, b2, offset = 0) {
      return this.layout.encode(src, b2, offset + this.offset);
    }
  }
  exports.OffsetLayout = OffsetLayout;

  class UInt extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readUIntLE(offset, this.span);
    }
    encode(src, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeUIntLE(src, offset, this.span);
      return this.span;
    }
  }
  exports.UInt = UInt;

  class UIntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readUIntBE(offset, this.span);
    }
    encode(src, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeUIntBE(src, offset, this.span);
      return this.span;
    }
  }
  exports.UIntBE = UIntBE;

  class Int extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readIntLE(offset, this.span);
    }
    encode(src, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeIntLE(src, offset, this.span);
      return this.span;
    }
  }
  exports.Int = Int;

  class IntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readIntBE(offset, this.span);
    }
    encode(src, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeIntBE(src, offset, this.span);
      return this.span;
    }
  }
  exports.IntBE = IntBE;
  var V2E32 = Math.pow(2, 32);
  function divmodInt64(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return { hi32, lo32 };
  }
  function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  }

  class NearUInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b2, offset = 0) {
      const buffer = uint8ArrayToBuffer(b2);
      const lo32 = buffer.readUInt32LE(offset);
      const hi32 = buffer.readUInt32LE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b2, offset = 0) {
      const split4 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b2);
      buffer.writeUInt32LE(split4.lo32, offset);
      buffer.writeUInt32LE(split4.hi32, offset + 4);
      return 8;
    }
  }
  exports.NearUInt64 = NearUInt64;

  class NearUInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b2, offset = 0) {
      const buffer = uint8ArrayToBuffer(b2);
      const hi32 = buffer.readUInt32BE(offset);
      const lo32 = buffer.readUInt32BE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b2, offset = 0) {
      const split4 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b2);
      buffer.writeUInt32BE(split4.hi32, offset);
      buffer.writeUInt32BE(split4.lo32, offset + 4);
      return 8;
    }
  }
  exports.NearUInt64BE = NearUInt64BE;

  class NearInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b2, offset = 0) {
      const buffer = uint8ArrayToBuffer(b2);
      const lo32 = buffer.readUInt32LE(offset);
      const hi32 = buffer.readInt32LE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b2, offset = 0) {
      const split4 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b2);
      buffer.writeUInt32LE(split4.lo32, offset);
      buffer.writeInt32LE(split4.hi32, offset + 4);
      return 8;
    }
  }
  exports.NearInt64 = NearInt64;

  class NearInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b2, offset = 0) {
      const buffer = uint8ArrayToBuffer(b2);
      const hi32 = buffer.readInt32BE(offset);
      const lo32 = buffer.readUInt32BE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b2, offset = 0) {
      const split4 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b2);
      buffer.writeInt32BE(split4.hi32, offset);
      buffer.writeUInt32BE(split4.lo32, offset + 4);
      return 8;
    }
  }
  exports.NearInt64BE = NearInt64BE;

  class Float extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readFloatLE(offset);
    }
    encode(src, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeFloatLE(src, offset);
      return 4;
    }
  }
  exports.Float = Float;

  class FloatBE extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readFloatBE(offset);
    }
    encode(src, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeFloatBE(src, offset);
      return 4;
    }
  }
  exports.FloatBE = FloatBE;

  class Double extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readDoubleLE(offset);
    }
    encode(src, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeDoubleLE(src, offset);
      return 8;
    }
  }
  exports.Double = Double;

  class DoubleBE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readDoubleBE(offset);
    }
    encode(src, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeDoubleBE(src, offset);
      return 8;
    }
  }
  exports.DoubleBE = DoubleBE;

  class Sequence extends Layout {
    constructor(elementLayout, count, property) {
      if (!(elementLayout instanceof Layout)) {
        throw new TypeError("elementLayout must be a Layout");
      }
      if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
        throw new TypeError("count must be non-negative integer " + "or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
        span = count * elementLayout.span;
      }
      super(span, property);
      this.elementLayout = elementLayout;
      this.count = count;
    }
    getSpan(b2, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b2, offset);
      }
      if (0 < this.elementLayout.span) {
        span = count * this.elementLayout.span;
      } else {
        let idx = 0;
        while (idx < count) {
          span += this.elementLayout.getSpan(b2, offset + span);
          ++idx;
        }
      }
      return span;
    }
    decode(b2, offset = 0) {
      const rv = [];
      let i2 = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b2, offset);
      }
      while (i2 < count) {
        rv.push(this.elementLayout.decode(b2, offset));
        offset += this.elementLayout.getSpan(b2, offset);
        i2 += 1;
      }
      return rv;
    }
    encode(src, b2, offset = 0) {
      const elo = this.elementLayout;
      const span = src.reduce((span2, v) => {
        return span2 + elo.encode(v, b2, offset + span2);
      }, 0);
      if (this.count instanceof ExternalLayout) {
        this.count.encode(src.length, b2, offset);
      }
      return span;
    }
  }
  exports.Sequence = Sequence;

  class Structure extends Layout {
    constructor(fields2, property, decodePrefixes) {
      if (!(Array.isArray(fields2) && fields2.reduce((acc, v) => acc && v instanceof Layout, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if (typeof property === "boolean" && decodePrefixes === undefined) {
        decodePrefixes = property;
        property = undefined;
      }
      for (const fd of fields2) {
        if (0 > fd.span && fd.property === undefined) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields2.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e) {}
      super(span, property);
      this.fields = fields2;
      this.decodePrefixes = !!decodePrefixes;
    }
    getSpan(b2, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b2, offset);
          offset += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    decode(b2, offset = 0) {
      checkUint8Array(b2);
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b2, offset);
        }
        offset += fd.getSpan(b2, offset);
        if (this.decodePrefixes && b2.length === offset) {
          break;
        }
      }
      return dest;
    }
    encode(src, b2, offset = 0) {
      const firstOffset = offset;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            lastWrote = fd.encode(fv, b2, offset);
            if (0 > span) {
              span = fd.getSpan(b2, offset);
            }
          }
        }
        lastOffset = offset;
        offset += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    layoutFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return;
    }
    offsetOf(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      let offset = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset;
        }
        if (0 > fd.span) {
          offset = -1;
        } else if (0 <= offset) {
          offset += fd.span;
        }
      }
      return;
    }
  }
  exports.Structure = Structure;

  class UnionDiscriminator {
    constructor(property) {
      this.property = property;
    }
    decode(b2, offset) {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode(src, b2, offset) {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  exports.UnionDiscriminator = UnionDiscriminator;

  class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    decode(b2, offset) {
      return this.layout.decode(b2, offset);
    }
    encode(src, b2, offset) {
      return this.layout.encode(src, b2, offset);
    }
  }
  exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;

  class Union extends Layout {
    constructor(discr, defaultLayout, property) {
      let discriminator;
      if (discr instanceof UInt || discr instanceof UIntBE) {
        discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discriminator = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator " + "or an unsigned integer layout");
      } else {
        discriminator = discr;
      }
      if (defaultLayout === undefined) {
        defaultLayout = null;
      }
      if (!(defaultLayout === null || defaultLayout instanceof Layout)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (defaultLayout !== null) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (defaultLayout.property === undefined) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
          span += discriminator.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discriminator;
      this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src) {
        return boundGetSourceVariant(src);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    getSpan(b2, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      const vlo = this.getVariant(b2, offset);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b2, offset);
    }
    defaultGetSourceVariant(src) {
      if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
          return;
        }
        const vlo = this.registry[src[this.discriminator.property]];
        if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag2 in this.registry) {
          const vlo = this.registry[tag2];
          if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    decode(b2, offset = 0) {
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b2, offset);
      const clo = this.registry[discr];
      if (clo === undefined) {
        const defaultLayout = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[defaultLayout.property] = defaultLayout.decode(b2, offset + contentOffset);
      } else {
        dest = clo.decode(b2, offset);
      }
      return dest;
    }
    encode(src, b2, offset = 0) {
      const vlo = this.getSourceVariant(src);
      if (vlo === undefined) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src[dlo.property], b2, offset);
        return contentOffset + clo.encode(src[clo.property], b2, offset + contentOffset);
      }
      return vlo.encode(src, b2, offset);
    }
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    getVariant(vb, offset = 0) {
      let variant;
      if (vb instanceof Uint8Array) {
        variant = this.discriminator.decode(vb, offset);
      } else {
        variant = vb;
      }
      return this.registry[variant];
    }
  }
  exports.Union = Union;

  class VariantLayout extends Layout {
    constructor(union, variant, layout, property) {
      if (!(union instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if (typeof layout === "string" && property === undefined) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (union.defaultLayout !== null && 0 <= layout.span && layout.span > union.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if (typeof property !== "string") {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union.span;
      if (0 > union.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union.usesPrefixDiscriminator) {
          span += union.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union;
      this.variant = variant;
      this.layout = layout || null;
    }
    getSpan(b2, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      let span = 0;
      if (this.layout) {
        span = this.layout.getSpan(b2, offset + contentOffset);
      }
      return contentOffset + span;
    }
    decode(b2, offset = 0) {
      const dest = this.makeDestinationObject();
      if (this !== this.union.getVariant(b2, offset)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b2, offset + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    encode(src, b2, offset = 0) {
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b2, offset);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src[this.property], b2, offset + contentOffset);
        span += this.layout.getSpan(b2, offset + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
      return;
    }
  }
  exports.VariantLayout = VariantLayout;
  function fixBitwiseResult(v) {
    if (0 > v) {
      v += 4294967296;
    }
    return v;
  }

  class BitStructure extends Layout {
    constructor(word, msb, property) {
      if (!(word instanceof UInt || word instanceof UIntBE)) {
        throw new TypeError("word must be a UInt or UIntBE layout");
      }
      if (typeof msb === "string" && property === undefined) {
        property = msb;
        msb = false;
      }
      if (4 < word.span) {
        throw new RangeError("word cannot exceed 32 bits");
      }
      super(word.span, property);
      this.word = word;
      this.msb = !!msb;
      this.fields = [];
      let value = 0;
      this._packedSetValue = function(v) {
        value = fixBitwiseResult(v);
        return this;
      };
      this._packedGetValue = function() {
        return value;
      };
    }
    decode(b2, offset = 0) {
      const dest = this.makeDestinationObject();
      const value = this.word.decode(b2, offset);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b2);
        }
      }
      return dest;
    }
    encode(src, b2, offset = 0) {
      const value = this.word.decode(b2, offset);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            fd.encode(fv);
          }
        }
      }
      return this.word.encode(this._packedGetValue(), b2, offset);
    }
    addField(bits, property) {
      const bf = new BitField(this, bits, property);
      this.fields.push(bf);
      return bf;
    }
    addBoolean(property) {
      const bf = new Boolean2(this, property);
      this.fields.push(bf);
      return bf;
    }
    fieldFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return;
    }
  }
  exports.BitStructure = BitStructure;

  class BitField {
    constructor(container, bits, property) {
      if (!(container instanceof BitStructure)) {
        throw new TypeError("container must be a BitStructure");
      }
      if (!Number.isInteger(bits) || 0 >= bits) {
        throw new TypeError("bits must be positive integer");
      }
      const totalBits = 8 * container.span;
      const usedBits = container.fields.reduce((sum2, fd) => sum2 + fd.bits, 0);
      if (bits + usedBits > totalBits) {
        throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
      }
      this.container = container;
      this.bits = bits;
      this.valueMask = (1 << bits) - 1;
      if (bits === 32) {
        this.valueMask = 4294967295;
      }
      this.start = usedBits;
      if (this.container.msb) {
        this.start = totalBits - usedBits - bits;
      }
      this.wordMask = fixBitwiseResult(this.valueMask << this.start);
      this.property = property;
    }
    decode(b2, offset) {
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(word & this.wordMask);
      const value = wordValue >>> this.start;
      return value;
    }
    encode(value) {
      if (typeof value !== "number" || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
        throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
      }
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(value << this.start);
      this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
    }
  }
  exports.BitField = BitField;

  class Boolean2 extends BitField {
    constructor(container, property) {
      super(container, 1, property);
    }
    decode(b2, offset) {
      return !!super.decode(b2, offset);
    }
    encode(value) {
      if (typeof value === "boolean") {
        value = +value;
      }
      super.encode(value);
    }
  }
  exports.Boolean = Boolean2;

  class Blob3 extends Layout {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer " + "or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    getSpan(b2, offset) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b2, offset);
      }
      return span;
    }
    decode(b2, offset = 0) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b2, offset);
      }
      return uint8ArrayToBuffer(b2).slice(offset, offset + span);
    }
    encode(src, b2, offset) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src.length;
      }
      if (!(src instanceof Uint8Array && span === src.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
      }
      if (offset + span > b2.length) {
        throw new RangeError("encoding overruns Uint8Array");
      }
      const srcBuffer = uint8ArrayToBuffer(src);
      uint8ArrayToBuffer(b2).write(srcBuffer.toString("hex"), offset, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b2, offset);
      }
      return span;
    }
  }
  exports.Blob = Blob3;

  class CString extends Layout {
    constructor(property) {
      super(-1, property);
    }
    getSpan(b2, offset = 0) {
      checkUint8Array(b2);
      let idx = offset;
      while (idx < b2.length && b2[idx] !== 0) {
        idx += 1;
      }
      return 1 + idx - offset;
    }
    decode(b2, offset = 0) {
      const span = this.getSpan(b2, offset);
      return uint8ArrayToBuffer(b2).slice(offset, offset + span - 1).toString("utf-8");
    }
    encode(src, b2, offset = 0) {
      if (typeof src !== "string") {
        src = String(src);
      }
      const srcb = buffer_1.Buffer.from(src, "utf8");
      const span = srcb.length;
      if (offset + span > b2.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      const buffer = uint8ArrayToBuffer(b2);
      srcb.copy(buffer, offset);
      buffer[offset + span] = 0;
      return span + 1;
    }
  }
  exports.CString = CString;

  class UTF8 extends Layout {
    constructor(maxSpan, property) {
      if (typeof maxSpan === "string" && property === undefined) {
        property = maxSpan;
        maxSpan = undefined;
      }
      if (maxSpan === undefined) {
        maxSpan = -1;
      } else if (!Number.isInteger(maxSpan)) {
        throw new TypeError("maxSpan must be an integer");
      }
      super(-1, property);
      this.maxSpan = maxSpan;
    }
    getSpan(b2, offset = 0) {
      checkUint8Array(b2);
      return b2.length - offset;
    }
    decode(b2, offset = 0) {
      const span = this.getSpan(b2, offset);
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      return uint8ArrayToBuffer(b2).slice(offset, offset + span).toString("utf-8");
    }
    encode(src, b2, offset = 0) {
      if (typeof src !== "string") {
        src = String(src);
      }
      const srcb = buffer_1.Buffer.from(src, "utf8");
      const span = srcb.length;
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      if (offset + span > b2.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      srcb.copy(uint8ArrayToBuffer(b2), offset);
      return span;
    }
  }
  exports.UTF8 = UTF8;

  class Constant extends Layout {
    constructor(value, property) {
      super(0, property);
      this.value = value;
    }
    decode(b2, offset) {
      return this.value;
    }
    encode(src, b2, offset) {
      return 0;
    }
  }
  exports.Constant = Constant;
  exports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
  exports.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);
  exports.u8 = (property) => new UInt(1, property);
  exports.u16 = (property) => new UInt(2, property);
  exports.u24 = (property) => new UInt(3, property);
  exports.u32 = (property) => new UInt(4, property);
  exports.u40 = (property) => new UInt(5, property);
  exports.u48 = (property) => new UInt(6, property);
  exports.nu64 = (property) => new NearUInt64(property);
  exports.u16be = (property) => new UIntBE(2, property);
  exports.u24be = (property) => new UIntBE(3, property);
  exports.u32be = (property) => new UIntBE(4, property);
  exports.u40be = (property) => new UIntBE(5, property);
  exports.u48be = (property) => new UIntBE(6, property);
  exports.nu64be = (property) => new NearUInt64BE(property);
  exports.s8 = (property) => new Int(1, property);
  exports.s16 = (property) => new Int(2, property);
  exports.s24 = (property) => new Int(3, property);
  exports.s32 = (property) => new Int(4, property);
  exports.s40 = (property) => new Int(5, property);
  exports.s48 = (property) => new Int(6, property);
  exports.ns64 = (property) => new NearInt64(property);
  exports.s16be = (property) => new IntBE(2, property);
  exports.s24be = (property) => new IntBE(3, property);
  exports.s32be = (property) => new IntBE(4, property);
  exports.s40be = (property) => new IntBE(5, property);
  exports.s48be = (property) => new IntBE(6, property);
  exports.ns64be = (property) => new NearInt64BE(property);
  exports.f32 = (property) => new Float(property);
  exports.f32be = (property) => new FloatBE(property);
  exports.f64 = (property) => new Double(property);
  exports.f64be = (property) => new DoubleBE(property);
  exports.struct = (fields2, property, decodePrefixes) => new Structure(fields2, property, decodePrefixes);
  exports.bits = (word, msb, property) => new BitStructure(word, msb, property);
  exports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
  exports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
  exports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
  exports.blob = (length, property) => new Blob3(length, property);
  exports.cstr = (property) => new CString(property);
  exports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
  exports.constant = (value, property) => new Constant(value, property);
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm(() => {
  rnds8 = new Uint8Array(16);
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm(() => {
  regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm(() => {
  init_regex();
  validate_default = validate2;
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify3(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i2, stringify_default;
var init_stringify = __esm(() => {
  init_validate();
  byteToHex = [];
  for (i2 = 0;i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).substr(1));
  }
  stringify_default = stringify3;
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
  var i3 = buf && offset || 0;
  var b2 = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== undefined ? options.msecs : Date.now();
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 12219292800000;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b2[i3++] = tl >>> 24 & 255;
  b2[i3++] = tl >>> 16 & 255;
  b2[i3++] = tl >>> 8 & 255;
  b2[i3++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b2[i3++] = tmh >>> 8 & 255;
  b2[i3++] = tmh & 255;
  b2[i3++] = tmh >>> 24 & 15 | 16;
  b2[i3++] = tmh >>> 16 & 255;
  b2[i3++] = clockseq >>> 8 | 128;
  b2[i3++] = clockseq & 255;
  for (var n2 = 0;n2 < 6; ++n2) {
    b2[i3 + n2] = node[n2];
  }
  return buf || stringify_default(b2);
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0, v1_default;
var init_v1 = __esm(() => {
  init_rng();
  init_stringify();
  v1_default = v1;
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm(() => {
  init_validate();
  parse_default = parse;
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes2 = [];
  for (var i3 = 0;i3 < str.length; ++i3) {
    bytes2.push(str.charCodeAt(i3));
  }
  return bytes2;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i3 = 0;i3 < 16; ++i3) {
        buf[offset + i3] = bytes2[i3];
      }
      return buf;
    }
    return stringify_default(bytes2);
  }
  try {
    generateUUID.name = name;
  } catch (err) {}
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
var init_v35 = __esm(() => {
  init_stringify();
  init_parse();
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (var i3 = 0;i3 < msg.length; ++i3) {
      bytes2[i3] = msg.charCodeAt(i3);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output2 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i3 = 0;i3 < length32; i3 += 8) {
    var x = input[i3 >> 5] >>> i3 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len2) {
  x[len2 >> 5] |= 128 << len2 % 32;
  x[getOutputLength(len2) - 1] = len2;
  var a = 1732584193;
  var b2 = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i3 = 0;i3 < x.length; i3 += 16) {
    var olda = a;
    var oldb = b2;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b2, c, d, x[i3], 7, -680876936);
    d = md5ff(d, a, b2, c, x[i3 + 1], 12, -389564586);
    c = md5ff(c, d, a, b2, x[i3 + 2], 17, 606105819);
    b2 = md5ff(b2, c, d, a, x[i3 + 3], 22, -1044525330);
    a = md5ff(a, b2, c, d, x[i3 + 4], 7, -176418897);
    d = md5ff(d, a, b2, c, x[i3 + 5], 12, 1200080426);
    c = md5ff(c, d, a, b2, x[i3 + 6], 17, -1473231341);
    b2 = md5ff(b2, c, d, a, x[i3 + 7], 22, -45705983);
    a = md5ff(a, b2, c, d, x[i3 + 8], 7, 1770035416);
    d = md5ff(d, a, b2, c, x[i3 + 9], 12, -1958414417);
    c = md5ff(c, d, a, b2, x[i3 + 10], 17, -42063);
    b2 = md5ff(b2, c, d, a, x[i3 + 11], 22, -1990404162);
    a = md5ff(a, b2, c, d, x[i3 + 12], 7, 1804603682);
    d = md5ff(d, a, b2, c, x[i3 + 13], 12, -40341101);
    c = md5ff(c, d, a, b2, x[i3 + 14], 17, -1502002290);
    b2 = md5ff(b2, c, d, a, x[i3 + 15], 22, 1236535329);
    a = md5gg(a, b2, c, d, x[i3 + 1], 5, -165796510);
    d = md5gg(d, a, b2, c, x[i3 + 6], 9, -1069501632);
    c = md5gg(c, d, a, b2, x[i3 + 11], 14, 643717713);
    b2 = md5gg(b2, c, d, a, x[i3], 20, -373897302);
    a = md5gg(a, b2, c, d, x[i3 + 5], 5, -701558691);
    d = md5gg(d, a, b2, c, x[i3 + 10], 9, 38016083);
    c = md5gg(c, d, a, b2, x[i3 + 15], 14, -660478335);
    b2 = md5gg(b2, c, d, a, x[i3 + 4], 20, -405537848);
    a = md5gg(a, b2, c, d, x[i3 + 9], 5, 568446438);
    d = md5gg(d, a, b2, c, x[i3 + 14], 9, -1019803690);
    c = md5gg(c, d, a, b2, x[i3 + 3], 14, -187363961);
    b2 = md5gg(b2, c, d, a, x[i3 + 8], 20, 1163531501);
    a = md5gg(a, b2, c, d, x[i3 + 13], 5, -1444681467);
    d = md5gg(d, a, b2, c, x[i3 + 2], 9, -51403784);
    c = md5gg(c, d, a, b2, x[i3 + 7], 14, 1735328473);
    b2 = md5gg(b2, c, d, a, x[i3 + 12], 20, -1926607734);
    a = md5hh(a, b2, c, d, x[i3 + 5], 4, -378558);
    d = md5hh(d, a, b2, c, x[i3 + 8], 11, -2022574463);
    c = md5hh(c, d, a, b2, x[i3 + 11], 16, 1839030562);
    b2 = md5hh(b2, c, d, a, x[i3 + 14], 23, -35309556);
    a = md5hh(a, b2, c, d, x[i3 + 1], 4, -1530992060);
    d = md5hh(d, a, b2, c, x[i3 + 4], 11, 1272893353);
    c = md5hh(c, d, a, b2, x[i3 + 7], 16, -155497632);
    b2 = md5hh(b2, c, d, a, x[i3 + 10], 23, -1094730640);
    a = md5hh(a, b2, c, d, x[i3 + 13], 4, 681279174);
    d = md5hh(d, a, b2, c, x[i3], 11, -358537222);
    c = md5hh(c, d, a, b2, x[i3 + 3], 16, -722521979);
    b2 = md5hh(b2, c, d, a, x[i3 + 6], 23, 76029189);
    a = md5hh(a, b2, c, d, x[i3 + 9], 4, -640364487);
    d = md5hh(d, a, b2, c, x[i3 + 12], 11, -421815835);
    c = md5hh(c, d, a, b2, x[i3 + 15], 16, 530742520);
    b2 = md5hh(b2, c, d, a, x[i3 + 2], 23, -995338651);
    a = md5ii(a, b2, c, d, x[i3], 6, -198630844);
    d = md5ii(d, a, b2, c, x[i3 + 7], 10, 1126891415);
    c = md5ii(c, d, a, b2, x[i3 + 14], 15, -1416354905);
    b2 = md5ii(b2, c, d, a, x[i3 + 5], 21, -57434055);
    a = md5ii(a, b2, c, d, x[i3 + 12], 6, 1700485571);
    d = md5ii(d, a, b2, c, x[i3 + 3], 10, -1894986606);
    c = md5ii(c, d, a, b2, x[i3 + 10], 15, -1051523);
    b2 = md5ii(b2, c, d, a, x[i3 + 1], 21, -2054922799);
    a = md5ii(a, b2, c, d, x[i3 + 8], 6, 1873313359);
    d = md5ii(d, a, b2, c, x[i3 + 15], 10, -30611744);
    c = md5ii(c, d, a, b2, x[i3 + 6], 15, -1560198380);
    b2 = md5ii(b2, c, d, a, x[i3 + 13], 21, 1309151649);
    a = md5ii(a, b2, c, d, x[i3 + 4], 6, -145523070);
    d = md5ii(d, a, b2, c, x[i3 + 11], 10, -1120210379);
    c = md5ii(c, d, a, b2, x[i3 + 2], 15, 718787259);
    b2 = md5ii(b2, c, d, a, x[i3 + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b2 = safeAdd(b2, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b2, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output2 = new Uint32Array(getOutputLength(length8));
  for (var i3 = 0;i3 < length8; i3 += 8) {
    output2[i3 >> 5] |= (input[i3 / 8] & 255) << i3 % 32;
  }
  return output2;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b2, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b2);
}
function md5ff(a, b2, c, d, x, s, t) {
  return md5cmn(b2 & c | ~b2 & d, a, b2, x, s, t);
}
function md5gg(a, b2, c, d, x, s, t) {
  return md5cmn(b2 & d | c & ~d, a, b2, x, s, t);
}
function md5hh(a, b2, c, d, x, s, t) {
  return md5cmn(b2 ^ c ^ d, a, b2, x, s, t);
}
function md5ii(a, b2, c, d, x, s, t) {
  return md5cmn(c ^ (b2 | ~d), a, b2, x, s, t);
}
var md5_default;
var init_md5 = __esm(() => {
  md5_default = md5;
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm(() => {
  init_v35();
  init_md5();
  v3 = v35_default("v3", 48, md5_default);
  v3_default = v3;
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i3 = 0;i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm(() => {
  init_rng();
  init_stringify();
  v4_default = v4;
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes2) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (var i3 = 0;i3 < msg.length; ++i3) {
      bytes2.push(msg.charCodeAt(i3));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  var l = bytes2.length / 4 + 2;
  var N3 = Math.ceil(l / 16);
  var M = new Array(N3);
  for (var _i = 0;_i < N3; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0;j < 16; ++j) {
      arr[j] = bytes2[_i * 64 + j * 4] << 24 | bytes2[_i * 64 + j * 4 + 1] << 16 | bytes2[_i * 64 + j * 4 + 2] << 8 | bytes2[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N3 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N3 - 1][14] = Math.floor(M[N3 - 1][14]);
  M[N3 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (var _i2 = 0;_i2 < N3; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0;t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16;_t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b2 = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0;_t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f2(s, b2, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b2, 30) >>> 0;
      b2 = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b2 >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm(() => {
  sha1_default = sha1;
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm(() => {
  init_v35();
  init_sha1();
  v5 = v35_default("v5", 80, sha1_default);
  v5_default = v5;
});

// node_modules/uuid/dist/esm-browser/nil.js
var nil_default = "00000000-0000-0000-0000-000000000000";

// node_modules/uuid/dist/esm-browser/version.js
function version2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm(() => {
  init_validate();
  version_default = version2;
});

// node_modules/uuid/dist/esm-browser/index.js
var exports_esm_browser = {};
__export(exports_esm_browser, {
  version: () => version_default,
  validate: () => validate_default,
  v5: () => v5_default,
  v4: () => v4_default,
  v3: () => v3_default,
  v1: () => v1_default,
  stringify: () => stringify_default,
  parse: () => parse_default,
  NIL: () => nil_default
});
var init_esm_browser = __esm(() => {
  init_v1();
  init_v3();
  init_v4();
  init_v5();
  init_version();
  init_validate();
  init_stringify();
  init_parse();
});

// node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS((exports, module) => {
  var uuid = (init_esm_browser(), __toCommonJS(exports_esm_browser)).v4;
  var generateRequest = function(method, params, id2, options) {
    if (typeof method !== "string") {
      throw new TypeError(method + " must be a string");
    }
    options = options || {};
    const version3 = typeof options.version === "number" ? options.version : 2;
    if (version3 !== 1 && version3 !== 2) {
      throw new TypeError(version3 + " must be 1 or 2");
    }
    const request = {
      method
    };
    if (version3 === 2) {
      request.jsonrpc = "2.0";
    }
    if (params) {
      if (typeof params !== "object" && !Array.isArray(params)) {
        throw new TypeError(params + " must be an object, array or omitted");
      }
      request.params = params;
    }
    if (typeof id2 === "undefined") {
      const generator = typeof options.generator === "function" ? options.generator : function() {
        return uuid();
      };
      request.id = generator(request, options);
    } else if (version3 === 2 && id2 === null) {
      if (options.notificationIdNull) {
        request.id = null;
      }
    } else {
      request.id = id2;
    }
    return request;
  };
  module.exports = generateRequest;
});

// node_modules/jayson/lib/client/browser/index.js
var require_browser2 = __commonJS((exports, module) => {
  var uuid = (init_esm_browser(), __toCommonJS(exports_esm_browser)).v4;
  var generateRequest = require_generateRequest();
  var ClientBrowser = function(callServer, options) {
    if (!(this instanceof ClientBrowser)) {
      return new ClientBrowser(callServer, options);
    }
    if (!options) {
      options = {};
    }
    this.options = {
      reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
      replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
      generator: typeof options.generator !== "undefined" ? options.generator : function() {
        return uuid();
      },
      version: typeof options.version !== "undefined" ? options.version : 2,
      notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
    };
    this.callServer = callServer;
  };
  module.exports = ClientBrowser;
  ClientBrowser.prototype.request = function(method, params, id2, callback) {
    const self2 = this;
    let request = null;
    const isBatch = Array.isArray(method) && typeof params === "function";
    if (this.options.version === 1 && isBatch) {
      throw new TypeError("JSON-RPC 1.0 does not support batching");
    }
    const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
    if (isBatch || isRaw) {
      callback = params;
      request = method;
    } else {
      if (typeof id2 === "function") {
        callback = id2;
        id2 = undefined;
      }
      const hasCallback = typeof callback === "function";
      try {
        request = generateRequest(method, params, id2, {
          generator: this.options.generator,
          version: this.options.version,
          notificationIdNull: this.options.notificationIdNull
        });
      } catch (err) {
        if (hasCallback) {
          return callback(err);
        }
        throw err;
      }
      if (!hasCallback) {
        return request;
      }
    }
    let message;
    try {
      message = JSON.stringify(request, this.options.replacer);
    } catch (err) {
      return callback(err);
    }
    this.callServer(message, function(err, response) {
      self2._parseResponse(err, response, callback);
    });
    return request;
  };
  ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
    if (err) {
      callback(err);
      return;
    }
    if (!responseText) {
      return callback();
    }
    let response;
    try {
      response = JSON.parse(responseText, this.options.reviver);
    } catch (err2) {
      return callback(err2);
    }
    if (callback.length === 3) {
      if (Array.isArray(response)) {
        const isError2 = function(res) {
          return typeof res.error !== "undefined";
        };
        const isNotError = function(res) {
          return !isError2(res);
        };
        return callback(null, response.filter(isError2), response.filter(isNotError));
      } else {
        return callback(null, response.error, response.result);
      }
    }
    callback(null, response);
  };
});

// node_modules/rpc-websockets/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names2 = [], events, name;
    if (this._eventsCount === 0)
      return names2;
    for (name in events = this._events) {
      if (has.call(events, name))
        names2.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events));
    }
    return names2;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i3 = 0, l = handlers.length, ee = new Array(l);i3 < l; i3++) {
      ee[i3] = handlers[i3].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len2 = arguments.length, args, i3;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len2) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i3 = 1, args = new Array(len2 - 1);i3 < len2; i3++) {
        args[i3 - 1] = arguments[i3];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i3 = 0;i3 < length; i3++) {
        if (listeners[i3].once)
          this.removeListener(event, listeners[i3].fn, undefined, true);
        switch (len2) {
          case 1:
            listeners[i3].fn.call(listeners[i3].context);
            break;
          case 2:
            listeners[i3].fn.call(listeners[i3].context, a1);
            break;
          case 3:
            listeners[i3].fn.call(listeners[i3].context, a1, a2);
            break;
          case 4:
            listeners[i3].fn.call(listeners[i3].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len2 - 1);j < len2; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i3].fn.apply(listeners[i3].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i3 = 0, events = [], length = listeners.length;i3 < length; i3++) {
        if (listeners[i3].fn !== fn || once && !listeners[i3].once || context && listeners[i3].context !== context) {
          events.push(listeners[i3]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/ws/browser.js
var require_browser3 = __commonJS((exports, module) => {
  module.exports = function() {
    throw new Error("ws does not work in the browser. Browser clients must use the native " + "WebSocket object");
  };
});

// node_modules/bigint-buffer/dist/browser.js
var require_browser5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var converter;
  function toBigIntLE(buf) {
    {
      const reversed = Buffer.from(buf);
      reversed.reverse();
      const hex = reversed.toString("hex");
      if (hex.length === 0) {
        return BigInt(0);
      }
      return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, false);
  }
  exports.toBigIntLE = toBigIntLE;
  function toBigIntBE(buf) {
    {
      const hex = buf.toString("hex");
      if (hex.length === 0) {
        return BigInt(0);
      }
      return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, true);
  }
  exports.toBigIntBE = toBigIntBE;
  function toBufferLE(num, width) {
    {
      const hex = num.toString(16);
      const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
      buffer.reverse();
      return buffer;
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
  }
  exports.toBufferLE = toBufferLE;
  function toBufferBE(num, width) {
    {
      const hex = num.toString(16);
      return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
  }
  exports.toBufferBE = toBufferBE;
});

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/bs58/node_modules/base-x/src/index.js
var require_src4 = __commonJS((exports, module) => {
  var _Buffer = require_safe_buffer().Buffer;
  function base2(ALPHABET2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i4 = 0;i4 < ALPHABET2.length; i4++) {
      var x2 = ALPHABET2.charAt(i4);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i4;
    }
    var BASE2 = ALPHABET2.length;
    var LEADER = ALPHABET2.charAt(0);
    var FACTOR = Math.log(BASE2) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE2);
    function encode2(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i5 = 0;
        for (var it1 = size - 1;(carry !== 0 || i5 < length) && it1 !== -1; it1--, i5++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE2 >>> 0;
          carry = carry / BASE2 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i5;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET2.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (psz < source.length) {
        var charCode = source.charCodeAt(psz);
        if (charCode > 255) {
          return;
        }
        var carry = BASE_MAP[charCode];
        if (carry === 255) {
          return;
        }
        var i5 = 0;
        for (var it3 = size - 1;(carry !== 0 || i5 < length) && it3 !== -1; it3--, i5++) {
          carry += BASE2 * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i5;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode4(string4) {
      var buffer = decodeUnsafe(string4);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE2 + " character");
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode4
    };
  }
  module.exports = base2;
});

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/bs58/index.js
var require_bs584 = __commonJS((exports, module) => {
  var basex = require_src4();
  var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET2);
});

// src/gen/nord_pb.ts
var exports_nord_pb = {};
__export(exports_nord_pb, {
  file_nord: () => file_nord,
  TriggerKindSchema: () => TriggerKindSchema,
  TriggerKind: () => TriggerKind,
  TriggerKeySchema: () => TriggerKeySchema,
  TradeOrPlaceSchema: () => TradeOrPlaceSchema,
  TokenSchema: () => TokenSchema,
  SpecialAccountSchema: () => SpecialAccountSchema,
  SpecialAccount: () => SpecialAccount,
  SideSchema: () => SideSchema,
  Side: () => Side,
  Receipt_WithdrawResultSchema: () => Receipt_WithdrawResultSchema,
  Receipt_UpdateGuardianSetResultSchema: () => Receipt_UpdateGuardianSetResultSchema,
  Receipt_UnpausedSchema: () => Receipt_UnpausedSchema,
  Receipt_TriggeredSchema: () => Receipt_TriggeredSchema,
  Receipt_TriggerRemovedSchema: () => Receipt_TriggerRemovedSchema,
  Receipt_TriggerAddedSchema: () => Receipt_TriggerAddedSchema,
  Receipt_TransferredSchema: () => Receipt_TransferredSchema,
  Receipt_TradeSchema: () => Receipt_TradeSchema,
  Receipt_TakenResultSchema: () => Receipt_TakenResultSchema,
  Receipt_SessionRevokedSchema: () => Receipt_SessionRevokedSchema,
  Receipt_PostedSchema: () => Receipt_PostedSchema,
  Receipt_PositionTakenOrTradedResultSchema: () => Receipt_PositionTakenOrTradedResultSchema,
  Receipt_PlaceOrderResultSchema: () => Receipt_PlaceOrderResultSchema,
  Receipt_PerpPositionSchema: () => Receipt_PerpPositionSchema,
  Receipt_PausedSchema: () => Receipt_PausedSchema,
  Receipt_OracleUpdateResultSchema: () => Receipt_OracleUpdateResultSchema,
  Receipt_OracleSymbolFeedResultSchema: () => Receipt_OracleSymbolFeedResultSchema,
  Receipt_MarketFreezeUpdatedSchema: () => Receipt_MarketFreezeUpdatedSchema,
  Receipt_InsertTokenResultSchema: () => Receipt_InsertTokenResultSchema,
  Receipt_InsertMarketResultSchema: () => Receipt_InsertMarketResultSchema,
  Receipt_FeeVaultTransferredSchema: () => Receipt_FeeVaultTransferredSchema,
  Receipt_FeeTierUpdatedSchema: () => Receipt_FeeTierUpdatedSchema,
  Receipt_FeeTierAddedSchema: () => Receipt_FeeTierAddedSchema,
  Receipt_DepositResultSchema: () => Receipt_DepositResultSchema,
  Receipt_CreateSessionResultSchema: () => Receipt_CreateSessionResultSchema,
  Receipt_CancelOrderResultSchema: () => Receipt_CancelOrderResultSchema,
  Receipt_AtomicSubactionResultKindSchema: () => Receipt_AtomicSubactionResultKindSchema,
  Receipt_AtomicResultSchema: () => Receipt_AtomicResultSchema,
  Receipt_AclUpdatedSchema: () => Receipt_AclUpdatedSchema,
  Receipt_AccountsTierUpdatedSchema: () => Receipt_AccountsTierUpdatedSchema,
  Receipt_AccountLiquidatedSchema: () => Receipt_AccountLiquidatedSchema,
  ReceiptSchema: () => ReceiptSchema,
  QuoteSizeSchema: () => QuoteSizeSchema,
  OrderTypeSchema: () => OrderTypeSchema,
  OrderLimitSchema: () => OrderLimitSchema,
  MarketTypeSchema: () => MarketTypeSchema,
  MarketType: () => MarketType,
  MarketSchema: () => MarketSchema,
  FillModeSchema: () => FillModeSchema,
  FillMode: () => FillMode,
  FeeTierConfigSchema: () => FeeTierConfigSchema,
  ErrorSchema: () => ErrorSchema,
  Error: () => Error2,
  CancelOrderSchema: () => CancelOrderSchema,
  AtomicSubactionKindSchema: () => AtomicSubactionKindSchema,
  AtomicSchema: () => AtomicSchema,
  Action_WithdrawSchema: () => Action_WithdrawSchema,
  Action_UserSignatureFramingSchema: () => Action_UserSignatureFramingSchema,
  Action_UserSignatureFraming: () => Action_UserSignatureFraming,
  Action_UpdateFeeTierSchema: () => Action_UpdateFeeTierSchema,
  Action_UpdateAclSchema: () => Action_UpdateAclSchema,
  Action_UpdateAccountsTierSchema: () => Action_UpdateAccountsTierSchema,
  Action_UnpauseSchema: () => Action_UnpauseSchema,
  Action_UnfreezeMarketSchema: () => Action_UnfreezeMarketSchema,
  Action_TriggerPricesSchema: () => Action_TriggerPricesSchema,
  Action_TransferSchema: () => Action_TransferSchema,
  Action_TakePositionSchema: () => Action_TakePositionSchema,
  Action_RevokeSessionSchema: () => Action_RevokeSessionSchema,
  Action_RemoveTriggerSchema: () => Action_RemoveTriggerSchema,
  Action_PythSetWormholeGuardiansSchema: () => Action_PythSetWormholeGuardiansSchema,
  Action_PythSetSymbolFeedSchema: () => Action_PythSetSymbolFeedSchema,
  Action_PythPriceFeedUpdateSchema: () => Action_PythPriceFeedUpdateSchema,
  Action_PlaceOrderSchema: () => Action_PlaceOrderSchema,
  Action_PauseSchema: () => Action_PauseSchema,
  Action_LiquidateSchema: () => Action_LiquidateSchema,
  Action_FreezeMarketSchema: () => Action_FreezeMarketSchema,
  Action_FeeVaultTransferSchema: () => Action_FeeVaultTransferSchema,
  Action_DepositSchema: () => Action_DepositSchema,
  Action_CreateTokenSchema: () => Action_CreateTokenSchema,
  Action_CreateSessionSchema: () => Action_CreateSessionSchema,
  Action_CreateMarketSchema: () => Action_CreateMarketSchema,
  Action_CancelOrderByIdSchema: () => Action_CancelOrderByIdSchema,
  Action_CancelOrderByClientIdSchema: () => Action_CancelOrderByClientIdSchema,
  Action_AddTriggerSchema: () => Action_AddTriggerSchema,
  Action_AddFeeTierSchema: () => Action_AddFeeTierSchema,
  ActionSchema: () => ActionSchema
});

// node_modules/@bufbuild/protobuf/dist/esm/reflect/names.js
function protoCamelCase(snakeCase) {
  let capNext = false;
  const b = [];
  for (let i = 0;i < snakeCase.length; i++) {
    let c = snakeCase.charAt(i);
    switch (c) {
      case "_":
        capNext = true;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        b.push(c);
        capNext = false;
        break;
      default:
        if (capNext) {
          capNext = false;
          c = c.toUpperCase();
        }
        b.push(c);
        break;
    }
  }
  return b.join("");
}
var reservedObjectProperties = new Set([
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function safeObjectProperty(name) {
  return reservedObjectProperties.has(name) ? name + "$" : name;
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0;shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3;shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0;i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3;i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0;i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5;(b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
var protoInt64 = /* @__PURE__ */ makeInt64Support();
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808");
    const MAX = BigInt("9223372036854775807");
    const UMIN = BigInt("0");
    const UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
function assertInt64String(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/descriptors.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));

// node_modules/@bufbuild/protobuf/dist/esm/reflect/scalar.js
function scalarZeroValue(type, longAsString) {
  switch (type) {
    case ScalarType.STRING:
      return "";
    case ScalarType.BOOL:
      return false;
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.INT64:
    case ScalarType.UINT64:
    case ScalarType.SFIXED64:
    case ScalarType.FIXED64:
    case ScalarType.SINT64:
      return longAsString ? "0" : protoInt64.zero;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function isScalarZeroValue(type, value) {
  switch (type) {
    case ScalarType.BOOL:
      return value === false;
    case ScalarType.STRING:
      return value === "";
    case ScalarType.BYTES:
      return value instanceof Uint8Array && !value.byteLength;
    default:
      return value == 0;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/reflect/unsafe.js
var IMPLICIT = 2;
var unsafeLocal = Symbol.for("reflect unsafe local");
function unsafeOneofCase(target, oneof) {
  const c = target[oneof.localName].case;
  if (c === undefined) {
    return c;
  }
  return oneof.fields.find((f) => f.localName === c);
}
function unsafeIsSet(target, field) {
  const name = field.localName;
  if (field.oneof) {
    return target[field.oneof.localName].case === name;
  }
  if (field.presence != IMPLICIT) {
    return target[name] !== undefined && Object.prototype.hasOwnProperty.call(target, name);
  }
  switch (field.fieldKind) {
    case "list":
      return target[name].length > 0;
    case "map":
      return Object.keys(target[name]).length > 0;
    case "scalar":
      return !isScalarZeroValue(field.scalar, target[name]);
    case "enum":
      return target[name] !== field.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function unsafeIsSetExplicit(target, localName) {
  return Object.prototype.hasOwnProperty.call(target, localName) && target[localName] !== undefined;
}
function unsafeGet(target, field) {
  if (field.oneof) {
    const oneof = target[field.oneof.localName];
    if (oneof.case === field.localName) {
      return oneof.value;
    }
    return;
  }
  return target[field.localName];
}
function unsafeSet(target, field, value) {
  if (field.oneof) {
    target[field.oneof.localName] = {
      case: field.localName,
      value
    };
  } else {
    target[field.localName] = value;
  }
}
function unsafeClear(target, field) {
  const name = field.localName;
  if (field.oneof) {
    const oneofLocalName = field.oneof.localName;
    if (target[oneofLocalName].case === name) {
      target[oneofLocalName] = { case: undefined };
    }
  } else if (field.presence != IMPLICIT) {
    delete target[name];
  } else {
    switch (field.fieldKind) {
      case "map":
        target[name] = {};
        break;
      case "list":
        target[name] = [];
        break;
      case "enum":
        target[name] = field.enum.values[0].number;
        break;
      case "scalar":
        target[name] = scalarZeroValue(field.scalar, field.longAsString);
        break;
    }
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/codegenv2/restore-json-names.js
function restoreJsonNames(message) {
  for (const f of message.field) {
    if (!unsafeIsSetExplicit(f, "jsonName")) {
      f.jsonName = protoCamelCase(f.name);
    }
  }
  message.nestedType.forEach(restoreJsonNames);
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/text-format.js
function parseTextFormatEnumValue(descEnum, value) {
  const enumValue = descEnum.values.find((v) => v.name === value);
  if (!enumValue) {
    throw new Error(`cannot parse ${descEnum} default value: ${value}`);
  }
  return enumValue.number;
}
function parseTextFormatScalarValue(type, value) {
  switch (type) {
    case ScalarType.STRING:
      return value;
    case ScalarType.BYTES: {
      const u = unescapeBytesDefaultValue(value);
      if (u === false) {
        throw new Error(`cannot parse ${ScalarType[type]} default value: ${value}`);
      }
      return u;
    }
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return protoInt64.parse(value);
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return protoInt64.uParse(value);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      switch (value) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(value);
      }
    case ScalarType.BOOL:
      return value === "true";
    case ScalarType.INT32:
    case ScalarType.UINT32:
    case ScalarType.SINT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
      return parseInt(value, 10);
  }
}
function unescapeBytesDefaultValue(str) {
  const b = [];
  const input = {
    tail: str,
    c: "",
    next() {
      if (this.tail.length == 0) {
        return false;
      }
      this.c = this.tail[0];
      this.tail = this.tail.substring(1);
      return true;
    },
    take(n) {
      if (this.tail.length >= n) {
        const r = this.tail.substring(0, n);
        this.tail = this.tail.substring(n);
        return r;
      }
      return false;
    }
  };
  while (input.next()) {
    switch (input.c) {
      case "\\":
        if (input.next()) {
          switch (input.c) {
            case "\\":
              b.push(input.c.charCodeAt(0));
              break;
            case "b":
              b.push(8);
              break;
            case "f":
              b.push(12);
              break;
            case "n":
              b.push(10);
              break;
            case "r":
              b.push(13);
              break;
            case "t":
              b.push(9);
              break;
            case "v":
              b.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const s = input.c;
              const t = input.take(2);
              if (t === false) {
                return false;
              }
              const n = parseInt(s + t, 8);
              if (Number.isNaN(n)) {
                return false;
              }
              b.push(n);
              break;
            }
            case "x": {
              const s = input.c;
              const t = input.take(2);
              if (t === false) {
                return false;
              }
              const n = parseInt(s + t, 16);
              if (Number.isNaN(n)) {
                return false;
              }
              b.push(n);
              break;
            }
            case "u": {
              const s = input.c;
              const t = input.take(4);
              if (t === false) {
                return false;
              }
              const n = parseInt(s + t, 16);
              if (Number.isNaN(n)) {
                return false;
              }
              const chunk = new Uint8Array(4);
              const view = new DataView(chunk.buffer);
              view.setInt32(0, n, true);
              b.push(chunk[0], chunk[1], chunk[2], chunk[3]);
              break;
            }
            case "U": {
              const s = input.c;
              const t = input.take(8);
              if (t === false) {
                return false;
              }
              const tc = protoInt64.uEnc(s + t);
              const chunk = new Uint8Array(8);
              const view = new DataView(chunk.buffer);
              view.setInt32(0, tc.lo, true);
              view.setInt32(4, tc.hi, true);
              b.push(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7]);
              break;
            }
          }
        }
        break;
      default:
        b.push(input.c.charCodeAt(0));
    }
  }
  return new Uint8Array(b);
}

// node_modules/@bufbuild/protobuf/dist/esm/reflect/nested-types.js
function* nestedTypes(desc) {
  switch (desc.kind) {
    case "file":
      for (const message of desc.messages) {
        yield message;
        yield* nestedTypes(message);
      }
      yield* desc.enums;
      yield* desc.services;
      yield* desc.extensions;
      break;
    case "message":
      for (const message of desc.nestedMessages) {
        yield message;
        yield* nestedTypes(message);
      }
      yield* desc.nestedEnums;
      yield* desc.nestedExtensions;
      break;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/registry.js
function createFileRegistry(...args) {
  const registry = createBaseRegistry();
  if (!args.length) {
    return registry;
  }
  if ("$typeName" in args[0] && args[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const file of args[0].file) {
      addFile(file, registry);
    }
    return registry;
  }
  if ("$typeName" in args[0]) {
    let recurseDeps = function(file) {
      const deps = [];
      for (const protoFileName of file.dependency) {
        if (registry.getFile(protoFileName) != null) {
          continue;
        }
        if (seen.has(protoFileName)) {
          continue;
        }
        const dep = resolve(protoFileName);
        if (!dep) {
          throw new Error(`Unable to resolve ${protoFileName}, imported by ${file.name}`);
        }
        if ("kind" in dep) {
          registry.addFile(dep, false, true);
        } else {
          seen.add(dep.name);
          deps.push(dep);
        }
      }
      return deps.concat(...deps.map(recurseDeps));
    };
    const input = args[0];
    const resolve = args[1];
    const seen = new Set;
    for (const file of [input, ...recurseDeps(input)].reverse()) {
      addFile(file, registry);
    }
  } else {
    for (const fileReg of args) {
      for (const file of fileReg.files) {
        registry.addFile(file);
      }
    }
  }
  return registry;
}
function createBaseRegistry() {
  const types = new Map;
  const extendees = new Map;
  const files = new Map;
  return {
    kind: "registry",
    types,
    extendees,
    [Symbol.iterator]() {
      return types.values();
    },
    get files() {
      return files.values();
    },
    addFile(file, skipTypes, withDeps) {
      files.set(file.proto.name, file);
      if (!skipTypes) {
        for (const type of nestedTypes(file)) {
          this.add(type);
        }
      }
      if (withDeps) {
        for (const f of file.dependencies) {
          this.addFile(f, skipTypes, withDeps);
        }
      }
    },
    add(desc) {
      if (desc.kind == "extension") {
        let numberToExt = extendees.get(desc.extendee.typeName);
        if (!numberToExt) {
          extendees.set(desc.extendee.typeName, numberToExt = new Map);
        }
        numberToExt.set(desc.number, desc);
      }
      types.set(desc.typeName, desc);
    },
    get(typeName) {
      return types.get(typeName);
    },
    getFile(fileName) {
      return files.get(fileName);
    },
    getMessage(typeName) {
      const t = types.get(typeName);
      return (t === null || t === undefined ? undefined : t.kind) == "message" ? t : undefined;
    },
    getEnum(typeName) {
      const t = types.get(typeName);
      return (t === null || t === undefined ? undefined : t.kind) == "enum" ? t : undefined;
    },
    getExtension(typeName) {
      const t = types.get(typeName);
      return (t === null || t === undefined ? undefined : t.kind) == "extension" ? t : undefined;
    },
    getExtensionFor(extendee, no) {
      var _a;
      return (_a = extendees.get(extendee.typeName)) === null || _a === undefined ? undefined : _a.get(no);
    },
    getService(typeName) {
      const t = types.get(typeName);
      return (t === null || t === undefined ? undefined : t.kind) == "service" ? t : undefined;
    }
  };
}
var EDITION_PROTO2 = 998;
var EDITION_PROTO3 = 999;
var TYPE_STRING = 9;
var TYPE_GROUP = 10;
var TYPE_MESSAGE = 11;
var TYPE_BYTES = 12;
var TYPE_ENUM = 14;
var LABEL_REPEATED = 3;
var LABEL_REQUIRED = 2;
var JS_STRING = 1;
var IDEMPOTENCY_UNKNOWN = 0;
var EXPLICIT = 1;
var IMPLICIT2 = 2;
var LEGACY_REQUIRED = 3;
var PACKED = 1;
var DELIMITED = 2;
var OPEN = 1;
var featureDefaults = {
  998: {
    fieldPresence: 1,
    enumType: 2,
    repeatedFieldEncoding: 2,
    utf8Validation: 3,
    messageEncoding: 1,
    jsonFormat: 2,
    enforceNamingStyle: 2,
    defaultSymbolVisibility: 1
  },
  999: {
    fieldPresence: 2,
    enumType: 1,
    repeatedFieldEncoding: 1,
    utf8Validation: 2,
    messageEncoding: 1,
    jsonFormat: 1,
    enforceNamingStyle: 2,
    defaultSymbolVisibility: 1
  },
  1000: {
    fieldPresence: 1,
    enumType: 1,
    repeatedFieldEncoding: 1,
    utf8Validation: 2,
    messageEncoding: 1,
    jsonFormat: 1,
    enforceNamingStyle: 2,
    defaultSymbolVisibility: 1
  }
};
function addFile(proto, reg) {
  var _a, _b;
  const file = {
    kind: "file",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === undefined ? undefined : _a.deprecated) !== null && _b !== undefined ? _b : false,
    edition: getFileEdition(proto),
    name: proto.name.replace(/\.proto$/, ""),
    dependencies: findFileDependencies(proto, reg),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${proto.name}`;
    }
  };
  const mapEntriesStore = new Map;
  const mapEntries = {
    get(typeName) {
      return mapEntriesStore.get(typeName);
    },
    add(desc) {
      var _a2;
      assert(((_a2 = desc.proto.options) === null || _a2 === undefined ? undefined : _a2.mapEntry) === true);
      mapEntriesStore.set(desc.typeName, desc);
    }
  };
  for (const enumProto of proto.enumType) {
    addEnum(enumProto, file, undefined, reg);
  }
  for (const messageProto of proto.messageType) {
    addMessage(messageProto, file, undefined, reg, mapEntries);
  }
  for (const serviceProto of proto.service) {
    addService(serviceProto, file, reg);
  }
  addExtensions(file, reg);
  for (const mapEntry of mapEntriesStore.values()) {
    addFields(mapEntry, reg, mapEntries);
  }
  for (const message of file.messages) {
    addFields(message, reg, mapEntries);
    addExtensions(message, reg);
  }
  reg.addFile(file, true);
}
function addExtensions(desc, reg) {
  switch (desc.kind) {
    case "file":
      for (const proto of desc.proto.extension) {
        const ext = newField(proto, desc, reg);
        desc.extensions.push(ext);
        reg.add(ext);
      }
      break;
    case "message":
      for (const proto of desc.proto.extension) {
        const ext = newField(proto, desc, reg);
        desc.nestedExtensions.push(ext);
        reg.add(ext);
      }
      for (const message of desc.nestedMessages) {
        addExtensions(message, reg);
      }
      break;
  }
}
function addFields(message, reg, mapEntries) {
  const allOneofs = message.proto.oneofDecl.map((proto) => newOneof(proto, message));
  const oneofsSeen = new Set;
  for (const proto of message.proto.field) {
    const oneof = findOneof(proto, allOneofs);
    const field = newField(proto, message, reg, oneof, mapEntries);
    message.fields.push(field);
    message.field[field.localName] = field;
    if (oneof === undefined) {
      message.members.push(field);
    } else {
      oneof.fields.push(field);
      if (!oneofsSeen.has(oneof)) {
        oneofsSeen.add(oneof);
        message.members.push(oneof);
      }
    }
  }
  for (const oneof of allOneofs.filter((o) => oneofsSeen.has(o))) {
    message.oneofs.push(oneof);
  }
  for (const child of message.nestedMessages) {
    addFields(child, reg, mapEntries);
  }
}
function addEnum(proto, file, parent, reg) {
  var _a, _b, _c, _d, _e;
  const sharedPrefix = findEnumSharedPrefix(proto.name, proto.value);
  const desc = {
    kind: "enum",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === undefined ? undefined : _a.deprecated) !== null && _b !== undefined ? _b : false,
    file,
    parent,
    open: true,
    name: proto.name,
    typeName: makeTypeName(proto, parent, file),
    value: {},
    values: [],
    sharedPrefix,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  desc.open = isEnumOpen(desc);
  reg.add(desc);
  for (const p of proto.value) {
    const name = p.name;
    desc.values.push(desc.value[p.number] = {
      kind: "enum_value",
      proto: p,
      deprecated: (_d = (_c = p.options) === null || _c === undefined ? undefined : _c.deprecated) !== null && _d !== undefined ? _d : false,
      parent: desc,
      name,
      localName: safeObjectProperty(sharedPrefix == undefined ? name : name.substring(sharedPrefix.length)),
      number: p.number,
      toString() {
        return `enum value ${desc.typeName}.${name}`;
      }
    });
  }
  ((_e = parent === null || parent === undefined ? undefined : parent.nestedEnums) !== null && _e !== undefined ? _e : file.enums).push(desc);
}
function addMessage(proto, file, parent, reg, mapEntries) {
  var _a, _b, _c, _d;
  const desc = {
    kind: "message",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === undefined ? undefined : _a.deprecated) !== null && _b !== undefined ? _b : false,
    file,
    parent,
    name: proto.name,
    typeName: makeTypeName(proto, parent, file),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  if (((_c = proto.options) === null || _c === undefined ? undefined : _c.mapEntry) === true) {
    mapEntries.add(desc);
  } else {
    ((_d = parent === null || parent === undefined ? undefined : parent.nestedMessages) !== null && _d !== undefined ? _d : file.messages).push(desc);
    reg.add(desc);
  }
  for (const enumProto of proto.enumType) {
    addEnum(enumProto, file, desc, reg);
  }
  for (const messageProto of proto.nestedType) {
    addMessage(messageProto, file, desc, reg, mapEntries);
  }
}
function addService(proto, file, reg) {
  var _a, _b;
  const desc = {
    kind: "service",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === undefined ? undefined : _a.deprecated) !== null && _b !== undefined ? _b : false,
    file,
    name: proto.name,
    typeName: makeTypeName(proto, undefined, file),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  file.services.push(desc);
  reg.add(desc);
  for (const methodProto of proto.method) {
    const method = newMethod(methodProto, desc, reg);
    desc.methods.push(method);
    desc.method[method.localName] = method;
  }
}
function newMethod(proto, parent, reg) {
  var _a, _b, _c, _d;
  let methodKind;
  if (proto.clientStreaming && proto.serverStreaming) {
    methodKind = "bidi_streaming";
  } else if (proto.clientStreaming) {
    methodKind = "client_streaming";
  } else if (proto.serverStreaming) {
    methodKind = "server_streaming";
  } else {
    methodKind = "unary";
  }
  const input = reg.getMessage(trimLeadingDot(proto.inputType));
  const output = reg.getMessage(trimLeadingDot(proto.outputType));
  assert(input, `invalid MethodDescriptorProto: input_type ${proto.inputType} not found`);
  assert(output, `invalid MethodDescriptorProto: output_type ${proto.inputType} not found`);
  const name = proto.name;
  return {
    kind: "rpc",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === undefined ? undefined : _a.deprecated) !== null && _b !== undefined ? _b : false,
    parent,
    name,
    localName: safeObjectProperty(name.length ? safeObjectProperty(name[0].toLowerCase() + name.substring(1)) : name),
    methodKind,
    input,
    output,
    idempotency: (_d = (_c = proto.options) === null || _c === undefined ? undefined : _c.idempotencyLevel) !== null && _d !== undefined ? _d : IDEMPOTENCY_UNKNOWN,
    toString() {
      return `rpc ${parent.typeName}.${name}`;
    }
  };
}
function newOneof(proto, parent) {
  return {
    kind: "oneof",
    proto,
    deprecated: false,
    parent,
    fields: [],
    name: proto.name,
    localName: safeObjectProperty(protoCamelCase(proto.name)),
    toString() {
      return `oneof ${parent.typeName}.${this.name}`;
    }
  };
}
function newField(proto, parentOrFile, reg, oneof, mapEntries) {
  var _a, _b, _c;
  const isExtension = mapEntries === undefined;
  const field = {
    kind: "field",
    proto,
    deprecated: (_b = (_a = proto.options) === null || _a === undefined ? undefined : _a.deprecated) !== null && _b !== undefined ? _b : false,
    name: proto.name,
    number: proto.number,
    scalar: undefined,
    message: undefined,
    enum: undefined,
    presence: getFieldPresence(proto, oneof, isExtension, parentOrFile),
    listKind: undefined,
    mapKind: undefined,
    mapKey: undefined,
    delimitedEncoding: undefined,
    packed: undefined,
    longAsString: false,
    getDefaultValue: undefined
  };
  if (isExtension) {
    const file = parentOrFile.kind == "file" ? parentOrFile : parentOrFile.file;
    const parent = parentOrFile.kind == "file" ? undefined : parentOrFile;
    const typeName = makeTypeName(proto, parent, file);
    field.kind = "extension";
    field.file = file;
    field.parent = parent;
    field.oneof = undefined;
    field.typeName = typeName;
    field.jsonName = `[${typeName}]`;
    field.toString = () => `extension ${typeName}`;
    const extendee = reg.getMessage(trimLeadingDot(proto.extendee));
    assert(extendee, `invalid FieldDescriptorProto: extendee ${proto.extendee} not found`);
    field.extendee = extendee;
  } else {
    const parent = parentOrFile;
    assert(parent.kind == "message");
    field.parent = parent;
    field.oneof = oneof;
    field.localName = oneof ? protoCamelCase(proto.name) : safeObjectProperty(protoCamelCase(proto.name));
    field.jsonName = proto.jsonName;
    field.toString = () => `field ${parent.typeName}.${proto.name}`;
  }
  const label = proto.label;
  const type = proto.type;
  const jstype = (_c = proto.options) === null || _c === undefined ? undefined : _c.jstype;
  if (label === LABEL_REPEATED) {
    const mapEntry = type == TYPE_MESSAGE ? mapEntries === null || mapEntries === undefined ? undefined : mapEntries.get(trimLeadingDot(proto.typeName)) : undefined;
    if (mapEntry) {
      field.fieldKind = "map";
      const { key, value } = findMapEntryFields(mapEntry);
      field.mapKey = key.scalar;
      field.mapKind = value.fieldKind;
      field.message = value.message;
      field.delimitedEncoding = false;
      field.enum = value.enum;
      field.scalar = value.scalar;
      return field;
    }
    field.fieldKind = "list";
    switch (type) {
      case TYPE_MESSAGE:
      case TYPE_GROUP:
        field.listKind = "message";
        field.message = reg.getMessage(trimLeadingDot(proto.typeName));
        assert(field.message);
        field.delimitedEncoding = isDelimitedEncoding(proto, parentOrFile);
        break;
      case TYPE_ENUM:
        field.listKind = "enum";
        field.enum = reg.getEnum(trimLeadingDot(proto.typeName));
        assert(field.enum);
        break;
      default:
        field.listKind = "scalar";
        field.scalar = type;
        field.longAsString = jstype == JS_STRING;
        break;
    }
    field.packed = isPackedField(proto, parentOrFile);
    return field;
  }
  switch (type) {
    case TYPE_MESSAGE:
    case TYPE_GROUP:
      field.fieldKind = "message";
      field.message = reg.getMessage(trimLeadingDot(proto.typeName));
      assert(field.message, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
      field.delimitedEncoding = isDelimitedEncoding(proto, parentOrFile);
      field.getDefaultValue = () => {
        return;
      };
      break;
    case TYPE_ENUM: {
      const enumeration = reg.getEnum(trimLeadingDot(proto.typeName));
      assert(enumeration !== undefined, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
      field.fieldKind = "enum";
      field.enum = reg.getEnum(trimLeadingDot(proto.typeName));
      field.getDefaultValue = () => {
        return unsafeIsSetExplicit(proto, "defaultValue") ? parseTextFormatEnumValue(enumeration, proto.defaultValue) : undefined;
      };
      break;
    }
    default: {
      field.fieldKind = "scalar";
      field.scalar = type;
      field.longAsString = jstype == JS_STRING;
      field.getDefaultValue = () => {
        return unsafeIsSetExplicit(proto, "defaultValue") ? parseTextFormatScalarValue(type, proto.defaultValue) : undefined;
      };
      break;
    }
  }
  return field;
}
function getFileEdition(proto) {
  switch (proto.syntax) {
    case "":
    case "proto2":
      return EDITION_PROTO2;
    case "proto3":
      return EDITION_PROTO3;
    case "editions":
      if (proto.edition in featureDefaults) {
        return proto.edition;
      }
      throw new Error(`${proto.name}: unsupported edition`);
    default:
      throw new Error(`${proto.name}: unsupported syntax "${proto.syntax}"`);
  }
}
function findFileDependencies(proto, reg) {
  return proto.dependency.map((wantName) => {
    const dep = reg.getFile(wantName);
    if (!dep) {
      throw new Error(`Cannot find ${wantName}, imported by ${proto.name}`);
    }
    return dep;
  });
}
function findEnumSharedPrefix(enumName, values) {
  const prefix = camelToSnakeCase(enumName) + "_";
  for (const value of values) {
    if (!value.name.toLowerCase().startsWith(prefix)) {
      return;
    }
    const shortName = value.name.substring(prefix.length);
    if (shortName.length == 0) {
      return;
    }
    if (/^\d/.test(shortName)) {
      return;
    }
  }
  return prefix;
}
function camelToSnakeCase(camel) {
  return (camel.substring(0, 1) + camel.substring(1).replace(/[A-Z]/g, (c) => "_" + c)).toLowerCase();
}
function makeTypeName(proto, parent, file) {
  let typeName;
  if (parent) {
    typeName = `${parent.typeName}.${proto.name}`;
  } else if (file.proto.package.length > 0) {
    typeName = `${file.proto.package}.${proto.name}`;
  } else {
    typeName = `${proto.name}`;
  }
  return typeName;
}
function trimLeadingDot(typeName) {
  return typeName.startsWith(".") ? typeName.substring(1) : typeName;
}
function findOneof(proto, allOneofs) {
  if (!unsafeIsSetExplicit(proto, "oneofIndex")) {
    return;
  }
  if (proto.proto3Optional) {
    return;
  }
  const oneof = allOneofs[proto.oneofIndex];
  assert(oneof, `invalid FieldDescriptorProto: oneof #${proto.oneofIndex} for field #${proto.number} not found`);
  return oneof;
}
function getFieldPresence(proto, oneof, isExtension, parent) {
  if (proto.label == LABEL_REQUIRED) {
    return LEGACY_REQUIRED;
  }
  if (proto.label == LABEL_REPEATED) {
    return IMPLICIT2;
  }
  if (!!oneof || proto.proto3Optional) {
    return EXPLICIT;
  }
  if (isExtension) {
    return EXPLICIT;
  }
  const resolved = resolveFeature("fieldPresence", { proto, parent });
  if (resolved == IMPLICIT2 && (proto.type == TYPE_MESSAGE || proto.type == TYPE_GROUP)) {
    return EXPLICIT;
  }
  return resolved;
}
function isPackedField(proto, parent) {
  if (proto.label != LABEL_REPEATED) {
    return false;
  }
  switch (proto.type) {
    case TYPE_STRING:
    case TYPE_BYTES:
    case TYPE_GROUP:
    case TYPE_MESSAGE:
      return false;
  }
  const o = proto.options;
  if (o && unsafeIsSetExplicit(o, "packed")) {
    return o.packed;
  }
  return PACKED == resolveFeature("repeatedFieldEncoding", {
    proto,
    parent
  });
}
function findMapEntryFields(mapEntry) {
  const key = mapEntry.fields.find((f) => f.number === 1);
  const value = mapEntry.fields.find((f) => f.number === 2);
  assert(key && key.fieldKind == "scalar" && key.scalar != ScalarType.BYTES && key.scalar != ScalarType.FLOAT && key.scalar != ScalarType.DOUBLE && value && value.fieldKind != "list" && value.fieldKind != "map");
  return { key, value };
}
function isEnumOpen(desc) {
  var _a;
  return OPEN == resolveFeature("enumType", {
    proto: desc.proto,
    parent: (_a = desc.parent) !== null && _a !== undefined ? _a : desc.file
  });
}
function isDelimitedEncoding(proto, parent) {
  if (proto.type == TYPE_GROUP) {
    return true;
  }
  return DELIMITED == resolveFeature("messageEncoding", {
    proto,
    parent
  });
}
function resolveFeature(name, ref) {
  var _a, _b;
  const featureSet = (_a = ref.proto.options) === null || _a === undefined ? undefined : _a.features;
  if (featureSet) {
    const val = featureSet[name];
    if (val != 0) {
      return val;
    }
  }
  if ("kind" in ref) {
    if (ref.kind == "message") {
      return resolveFeature(name, (_b = ref.parent) !== null && _b !== undefined ? _b : ref.file);
    }
    const editionDefaults = featureDefaults[ref.edition];
    if (!editionDefaults) {
      throw new Error(`feature default for edition ${ref.edition} not found`);
    }
    return editionDefaults[name];
  }
  return resolveFeature(name, ref.parent);
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/codegenv2/boot.js
function boot(boot2) {
  const root = bootFileDescriptorProto(boot2);
  root.messageType.forEach(restoreJsonNames);
  const reg = createFileRegistry(root, () => {
    return;
  });
  return reg.getFile(root.name);
}
function bootFileDescriptorProto(init) {
  const proto = Object.create({
    syntax: "",
    edition: 0
  });
  return Object.assign(proto, Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, init), { messageType: init.messageType.map(bootDescriptorProto), enumType: init.enumType.map(bootEnumDescriptorProto) }));
}
function bootDescriptorProto(init) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const proto = Object.create({
    visibility: 0
  });
  return Object.assign(proto, {
    $typeName: "google.protobuf.DescriptorProto",
    name: init.name,
    field: (_b = (_a = init.field) === null || _a === undefined ? undefined : _a.map(bootFieldDescriptorProto)) !== null && _b !== undefined ? _b : [],
    extension: [],
    nestedType: (_d = (_c = init.nestedType) === null || _c === undefined ? undefined : _c.map(bootDescriptorProto)) !== null && _d !== undefined ? _d : [],
    enumType: (_f = (_e = init.enumType) === null || _e === undefined ? undefined : _e.map(bootEnumDescriptorProto)) !== null && _f !== undefined ? _f : [],
    extensionRange: (_h = (_g = init.extensionRange) === null || _g === undefined ? undefined : _g.map((e) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, e))) !== null && _h !== undefined ? _h : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function bootFieldDescriptorProto(init) {
  const proto = Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: false
  });
  return Object.assign(proto, Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, init), { options: init.options ? bootFieldOptions(init.options) : undefined }));
}
function bootFieldOptions(init) {
  var _a, _b, _c;
  const proto = Object.create({
    ctype: 0,
    packed: false,
    jstype: 0,
    lazy: false,
    unverifiedLazy: false,
    deprecated: false,
    weak: false,
    debugRedact: false,
    retention: 0
  });
  return Object.assign(proto, Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, init), { targets: (_a = init.targets) !== null && _a !== undefined ? _a : [], editionDefaults: (_c = (_b = init.editionDefaults) === null || _b === undefined ? undefined : _b.map((e) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, e))) !== null && _c !== undefined ? _c : [], uninterpretedOption: [] }));
}
function bootEnumDescriptorProto(init) {
  const proto = Object.create({
    visibility: 0
  });
  return Object.assign(proto, {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: init.name,
    reservedName: [],
    reservedRange: [],
    value: init.value.map((e) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, e))
  });
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/base64-encoding.js
function base64Decode(base64Str) {
  const table = getDecodeTable();
  let es = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es -= 1;
  let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
  for (let i = 0;i < base64Str.length; i++) {
    b = table[base64Str.charCodeAt(i)];
    if (b === undefined) {
      switch (base64Str[i]) {
        case "=":
          groupPos = 0;
        case `
`:
        case "\r":
        case "\t":
        case " ":
          continue;
        default:
          throw Error("invalid base64 string");
      }
    }
    switch (groupPos) {
      case 0:
        p = b;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p << 2 | (b & 48) >> 4;
        p = b;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
        p = b;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p & 3) << 6 | b;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error("invalid base64 string");
  return bytes.subarray(0, bytePos);
}
var encodeTableStd;
var encodeTableUrl;
var decodeTable;
function getEncodeTable(encoding) {
  if (!encodeTableStd) {
    encodeTableStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    encodeTableUrl = encodeTableStd.slice(0, -2).concat("-", "_");
  }
  return encoding == "url" ? encodeTableUrl : encodeTableStd;
}
function getDecodeTable() {
  if (!decodeTable) {
    decodeTable = [];
    const encodeTable = getEncodeTable("std");
    for (let i = 0;i < encodeTable.length; i++)
      decodeTable[encodeTable[i].charCodeAt(0)] = i;
    decodeTable[45] = encodeTable.indexOf("+");
    decodeTable[95] = encodeTable.indexOf("/");
  }
  return decodeTable;
}

// node_modules/@bufbuild/protobuf/dist/esm/is-message.js
function isMessage(arg, schema) {
  const isMessage2 = arg !== null && typeof arg == "object" && "$typeName" in arg && typeof arg.$typeName == "string";
  if (!isMessage2) {
    return false;
  }
  if (schema === undefined) {
    return true;
  }
  return schema.typeName === arg.$typeName;
}

// node_modules/@bufbuild/protobuf/dist/esm/reflect/error.js
class FieldError extends Error {
  constructor(fieldOrOneof, message, name = "FieldValueInvalidError") {
    super(message);
    this.name = name;
    this.field = () => fieldOrOneof;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/reflect/guard.js
function isObject(arg) {
  return arg !== null && typeof arg == "object" && !Array.isArray(arg);
}
function isReflectList(arg, field) {
  var _a, _b, _c, _d;
  if (isObject(arg) && unsafeLocal in arg && "add" in arg && "field" in arg && typeof arg.field == "function") {
    if (field !== undefined) {
      const a = field;
      const b = arg.field();
      return a.listKind == b.listKind && a.scalar === b.scalar && ((_a = a.message) === null || _a === undefined ? undefined : _a.typeName) === ((_b = b.message) === null || _b === undefined ? undefined : _b.typeName) && ((_c = a.enum) === null || _c === undefined ? undefined : _c.typeName) === ((_d = b.enum) === null || _d === undefined ? undefined : _d.typeName);
    }
    return true;
  }
  return false;
}
function isReflectMap(arg, field) {
  var _a, _b, _c, _d;
  if (isObject(arg) && unsafeLocal in arg && "has" in arg && "field" in arg && typeof arg.field == "function") {
    if (field !== undefined) {
      const a = field, b = arg.field();
      return a.mapKey === b.mapKey && a.mapKind == b.mapKind && a.scalar === b.scalar && ((_a = a.message) === null || _a === undefined ? undefined : _a.typeName) === ((_b = b.message) === null || _b === undefined ? undefined : _b.typeName) && ((_c = a.enum) === null || _c === undefined ? undefined : _c.typeName) === ((_d = b.enum) === null || _d === undefined ? undefined : _d.typeName);
    }
    return true;
  }
  return false;
}
function isReflectMessage(arg, messageDesc) {
  return isObject(arg) && unsafeLocal in arg && "desc" in arg && isObject(arg.desc) && arg.desc.kind === "message" && (messageDesc === undefined || arg.desc.typeName == messageDesc.typeName);
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
var symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding() {
  if (globalThis[symbol] == undefined) {
    const te = new globalThis.TextEncoder;
    const td = new globalThis.TextDecoder;
    globalThis[symbol] = {
      encodeUtf8(text) {
        return te.encode(text);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text) {
        try {
          encodeURIComponent(text);
          return true;
        } catch (_) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol];
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var FLOAT32_MAX = 340282346638528860000000000000000000000;
var FLOAT32_MIN = -340282346638528860000000000000000000000;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;

class BinaryWriter {
  constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
    this.encodeUtf8 = encodeUtf8;
    this.stack = [];
    this.chunks = [];
    this.buf = [];
  }
  finish() {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    let len = 0;
    for (let i = 0;i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0;i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  string(value) {
    let chunk = this.encodeUtf8(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  sint64(value) {
    const tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  uint64(value) {
    const tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
}

class BinaryReader {
  constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
    this.decodeUtf8 = decodeUtf8;
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {}
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (;; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== undefined && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  int32() {
    return this.uint32() | 0;
  }
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt64.dec(lo, hi);
  }
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function assertInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg == "string") {
    const o = arg;
    arg = Number(arg);
    if (Number.isNaN(arg) && o !== "NaN") {
      throw new Error("invalid float32: " + o);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
    throw new Error("invalid float32: " + arg);
}

// node_modules/@bufbuild/protobuf/dist/esm/reflect/reflect-check.js
function checkField(field, value) {
  const check = field.fieldKind == "list" ? isReflectList(value, field) : field.fieldKind == "map" ? isReflectMap(value, field) : checkSingular(field, value);
  if (check === true) {
    return;
  }
  let reason;
  switch (field.fieldKind) {
    case "list":
      reason = `expected ${formatReflectList(field)}, got ${formatVal(value)}`;
      break;
    case "map":
      reason = `expected ${formatReflectMap(field)}, got ${formatVal(value)}`;
      break;
    default: {
      reason = reasonSingular(field, value, check);
    }
  }
  return new FieldError(field, reason);
}
function checkListItem(field, index, value) {
  const check = checkSingular(field, value);
  if (check !== true) {
    return new FieldError(field, `list item #${index + 1}: ${reasonSingular(field, value, check)}`);
  }
  return;
}
function checkMapEntry(field, key, value) {
  const checkKey = checkScalarValue(key, field.mapKey);
  if (checkKey !== true) {
    return new FieldError(field, `invalid map key: ${reasonSingular({ scalar: field.mapKey }, key, checkKey)}`);
  }
  const checkVal = checkSingular(field, value);
  if (checkVal !== true) {
    return new FieldError(field, `map entry ${formatVal(key)}: ${reasonSingular(field, value, checkVal)}`);
  }
  return;
}
function checkSingular(field, value) {
  if (field.scalar !== undefined) {
    return checkScalarValue(value, field.scalar);
  }
  if (field.enum !== undefined) {
    if (field.enum.open) {
      return Number.isInteger(value);
    }
    return field.enum.values.some((v) => v.number === value);
  }
  return isReflectMessage(value, field.message);
}
function checkScalarValue(value, scalar) {
  switch (scalar) {
    case ScalarType.DOUBLE:
      return typeof value == "number";
    case ScalarType.FLOAT:
      if (typeof value != "number") {
        return false;
      }
      if (Number.isNaN(value) || !Number.isFinite(value)) {
        return true;
      }
      if (value > FLOAT32_MAX || value < FLOAT32_MIN) {
        return `${value.toFixed()} out of range`;
      }
      return true;
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      if (typeof value !== "number" || !Number.isInteger(value)) {
        return false;
      }
      if (value > INT32_MAX || value < INT32_MIN) {
        return `${value.toFixed()} out of range`;
      }
      return true;
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      if (typeof value !== "number" || !Number.isInteger(value)) {
        return false;
      }
      if (value > UINT32_MAX || value < 0) {
        return `${value.toFixed()} out of range`;
      }
      return true;
    case ScalarType.BOOL:
      return typeof value == "boolean";
    case ScalarType.STRING:
      if (typeof value != "string") {
        return false;
      }
      return getTextEncoding().checkUtf8(value) || "invalid UTF8";
    case ScalarType.BYTES:
      return value instanceof Uint8Array;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof value == "bigint" || typeof value == "number" || typeof value == "string" && value.length > 0) {
        try {
          protoInt64.parse(value);
          return true;
        } catch (_) {
          return `${value} out of range`;
        }
      }
      return false;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof value == "bigint" || typeof value == "number" || typeof value == "string" && value.length > 0) {
        try {
          protoInt64.uParse(value);
          return true;
        } catch (_) {
          return `${value} out of range`;
        }
      }
      return false;
  }
}
function reasonSingular(field, val, details) {
  details = typeof details == "string" ? `: ${details}` : `, got ${formatVal(val)}`;
  if (field.scalar !== undefined) {
    return `expected ${scalarTypeDescription(field.scalar)}` + details;
  }
  if (field.enum !== undefined) {
    return `expected ${field.enum.toString()}` + details;
  }
  return `expected ${formatReflectMessage(field.message)}` + details;
}
function formatVal(val) {
  switch (typeof val) {
    case "object":
      if (val === null) {
        return "null";
      }
      if (val instanceof Uint8Array) {
        return `Uint8Array(${val.length})`;
      }
      if (Array.isArray(val)) {
        return `Array(${val.length})`;
      }
      if (isReflectList(val)) {
        return formatReflectList(val.field());
      }
      if (isReflectMap(val)) {
        return formatReflectMap(val.field());
      }
      if (isReflectMessage(val)) {
        return formatReflectMessage(val.desc);
      }
      if (isMessage(val)) {
        return `message ${val.$typeName}`;
      }
      return "object";
    case "string":
      return val.length > 30 ? "string" : `"${val.split('"').join("\\\"")}"`;
    case "boolean":
      return String(val);
    case "number":
      return String(val);
    case "bigint":
      return String(val) + "n";
    default:
      return typeof val;
  }
}
function formatReflectMessage(desc) {
  return `ReflectMessage (${desc.typeName})`;
}
function formatReflectList(field) {
  switch (field.listKind) {
    case "message":
      return `ReflectList (${field.message.toString()})`;
    case "enum":
      return `ReflectList (${field.enum.toString()})`;
    case "scalar":
      return `ReflectList (${ScalarType[field.scalar]})`;
  }
}
function formatReflectMap(field) {
  switch (field.mapKind) {
    case "message":
      return `ReflectMap (${ScalarType[field.mapKey]}, ${field.message.toString()})`;
    case "enum":
      return `ReflectMap (${ScalarType[field.mapKey]}, ${field.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${ScalarType[field.mapKey]}, ${ScalarType[field.scalar]})`;
  }
}
function scalarTypeDescription(scalar) {
  switch (scalar) {
    case ScalarType.STRING:
      return "string";
    case ScalarType.BOOL:
      return "boolean";
    case ScalarType.INT64:
    case ScalarType.SINT64:
    case ScalarType.SFIXED64:
      return "bigint (int64)";
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return "bigint (uint64)";
    case ScalarType.BYTES:
      return "Uint8Array";
    case ScalarType.DOUBLE:
      return "number (float64)";
    case ScalarType.FLOAT:
      return "number (float32)";
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      return "number (uint32)";
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      return "number (int32)";
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/wkt/wrappers.js
function isWrapper(arg) {
  return isWrapperTypeName(arg.$typeName);
}
function isWrapperDesc(messageDesc) {
  const f = messageDesc.fields[0];
  return isWrapperTypeName(messageDesc.typeName) && f !== undefined && f.fieldKind == "scalar" && f.name == "value" && f.number == 1;
}
function isWrapperTypeName(name) {
  return name.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(name.substring(16));
}

// node_modules/@bufbuild/protobuf/dist/esm/create.js
var EDITION_PROTO32 = 999;
var EDITION_PROTO22 = 998;
var IMPLICIT3 = 2;
function create(schema, init) {
  if (isMessage(init, schema)) {
    return init;
  }
  const message = createZeroMessage(schema);
  if (init !== undefined) {
    initMessage(schema, message, init);
  }
  return message;
}
function initMessage(messageDesc, message, init) {
  for (const member of messageDesc.members) {
    let value = init[member.localName];
    if (value == null) {
      continue;
    }
    let field;
    if (member.kind == "oneof") {
      const oneofField = unsafeOneofCase(init, member);
      if (!oneofField) {
        continue;
      }
      field = oneofField;
      value = unsafeGet(init, oneofField);
    } else {
      field = member;
    }
    switch (field.fieldKind) {
      case "message":
        value = toMessage(field, value);
        break;
      case "scalar":
        value = initScalar(field, value);
        break;
      case "list":
        value = initList(field, value);
        break;
      case "map":
        value = initMap(field, value);
        break;
    }
    unsafeSet(message, field, value);
  }
  return message;
}
function initScalar(field, value) {
  if (field.scalar == ScalarType.BYTES) {
    return toU8Arr(value);
  }
  return value;
}
function initMap(field, value) {
  if (isObject(value)) {
    if (field.scalar == ScalarType.BYTES) {
      return convertObjectValues(value, toU8Arr);
    }
    if (field.mapKind == "message") {
      return convertObjectValues(value, (val) => toMessage(field, val));
    }
  }
  return value;
}
function initList(field, value) {
  if (Array.isArray(value)) {
    if (field.scalar == ScalarType.BYTES) {
      return value.map(toU8Arr);
    }
    if (field.listKind == "message") {
      return value.map((item) => toMessage(field, item));
    }
  }
  return value;
}
function toMessage(field, value) {
  if (field.fieldKind == "message" && !field.oneof && isWrapperDesc(field.message)) {
    return initScalar(field.message.fields[0], value);
  }
  if (isObject(value)) {
    if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName !== "google.protobuf.Value") {
      return value;
    }
    if (!isMessage(value, field.message)) {
      return create(field.message, value);
    }
  }
  return value;
}
function toU8Arr(value) {
  return Array.isArray(value) ? new Uint8Array(value) : value;
}
function convertObjectValues(obj, fn) {
  const ret = {};
  for (const entry of Object.entries(obj)) {
    ret[entry[0]] = fn(entry[1]);
  }
  return ret;
}
var tokenZeroMessageField = Symbol();
var messagePrototypes = new WeakMap;
function createZeroMessage(desc) {
  let msg;
  if (!needsPrototypeChain(desc)) {
    msg = {
      $typeName: desc.typeName
    };
    for (const member of desc.members) {
      if (member.kind == "oneof" || member.presence == IMPLICIT3) {
        msg[member.localName] = createZeroField(member);
      }
    }
  } else {
    const cached = messagePrototypes.get(desc);
    let prototype;
    let members;
    if (cached) {
      ({ prototype, members } = cached);
    } else {
      prototype = {};
      members = new Set;
      for (const member of desc.members) {
        if (member.kind == "oneof") {
          continue;
        }
        if (member.fieldKind != "scalar" && member.fieldKind != "enum") {
          continue;
        }
        if (member.presence == IMPLICIT3) {
          continue;
        }
        members.add(member);
        prototype[member.localName] = createZeroField(member);
      }
      messagePrototypes.set(desc, { prototype, members });
    }
    msg = Object.create(prototype);
    msg.$typeName = desc.typeName;
    for (const member of desc.members) {
      if (members.has(member)) {
        continue;
      }
      if (member.kind == "field") {
        if (member.fieldKind == "message") {
          continue;
        }
        if (member.fieldKind == "scalar" || member.fieldKind == "enum") {
          if (member.presence != IMPLICIT3) {
            continue;
          }
        }
      }
      msg[member.localName] = createZeroField(member);
    }
  }
  return msg;
}
function needsPrototypeChain(desc) {
  switch (desc.file.edition) {
    case EDITION_PROTO32:
      return false;
    case EDITION_PROTO22:
      return true;
    default:
      return desc.fields.some((f) => f.presence != IMPLICIT3 && f.fieldKind != "message" && !f.oneof);
  }
}
function createZeroField(field) {
  if (field.kind == "oneof") {
    return { case: undefined };
  }
  if (field.fieldKind == "list") {
    return [];
  }
  if (field.fieldKind == "map") {
    return {};
  }
  if (field.fieldKind == "message") {
    return tokenZeroMessageField;
  }
  const defaultValue = field.getDefaultValue();
  if (defaultValue !== undefined) {
    return field.fieldKind == "scalar" && field.longAsString ? defaultValue.toString() : defaultValue;
  }
  return field.fieldKind == "scalar" ? scalarZeroValue(field.scalar, field.longAsString) : field.enum.values[0].number;
}

// node_modules/@bufbuild/protobuf/dist/esm/reflect/reflect.js
function reflect(messageDesc, message, check = true) {
  return new ReflectMessageImpl(messageDesc, message, check);
}

class ReflectMessageImpl {
  get sortedFields() {
    var _a;
    return (_a = this._sortedFields) !== null && _a !== undefined ? _a : this._sortedFields = this.desc.fields.concat().sort((a, b) => a.number - b.number);
  }
  constructor(messageDesc, message, check = true) {
    this.lists = new Map;
    this.maps = new Map;
    this.check = check;
    this.desc = messageDesc;
    this.message = this[unsafeLocal] = message !== null && message !== undefined ? message : create(messageDesc);
    this.fields = messageDesc.fields;
    this.oneofs = messageDesc.oneofs;
    this.members = messageDesc.members;
  }
  findNumber(number) {
    if (!this._fieldsByNumber) {
      this._fieldsByNumber = new Map(this.desc.fields.map((f) => [f.number, f]));
    }
    return this._fieldsByNumber.get(number);
  }
  oneofCase(oneof) {
    assertOwn(this.message, oneof);
    return unsafeOneofCase(this.message, oneof);
  }
  isSet(field) {
    assertOwn(this.message, field);
    return unsafeIsSet(this.message, field);
  }
  clear(field) {
    assertOwn(this.message, field);
    unsafeClear(this.message, field);
  }
  get(field) {
    assertOwn(this.message, field);
    const value = unsafeGet(this.message, field);
    switch (field.fieldKind) {
      case "list":
        let list = this.lists.get(field);
        if (!list || list[unsafeLocal] !== value) {
          this.lists.set(field, list = new ReflectListImpl(field, value, this.check));
        }
        return list;
      case "map":
        let map = this.maps.get(field);
        if (!map || map[unsafeLocal] !== value) {
          this.maps.set(field, map = new ReflectMapImpl(field, value, this.check));
        }
        return map;
      case "message":
        return messageToReflect(field, value, this.check);
      case "scalar":
        return value === undefined ? scalarZeroValue(field.scalar, false) : longToReflect(field, value);
      case "enum":
        return value !== null && value !== undefined ? value : field.enum.values[0].number;
    }
  }
  set(field, value) {
    assertOwn(this.message, field);
    if (this.check) {
      const err = checkField(field, value);
      if (err) {
        throw err;
      }
    }
    let local;
    if (field.fieldKind == "message") {
      local = messageToLocal(field, value);
    } else if (isReflectMap(value) || isReflectList(value)) {
      local = value[unsafeLocal];
    } else {
      local = longToLocal(field, value);
    }
    unsafeSet(this.message, field, local);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(value) {
    this.message.$unknown = value;
  }
}
function assertOwn(owner, member) {
  if (member.parent.typeName !== owner.$typeName) {
    throw new FieldError(member, `cannot use ${member.toString()} with message ${owner.$typeName}`, "ForeignFieldError");
  }
}
class ReflectListImpl {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(field, unsafeInput, check) {
    this._field = field;
    this._arr = this[unsafeLocal] = unsafeInput;
    this.check = check;
  }
  get(index) {
    const item = this._arr[index];
    return item === undefined ? undefined : listItemToReflect(this._field, item, this.check);
  }
  set(index, item) {
    if (index < 0 || index >= this._arr.length) {
      throw new FieldError(this._field, `list item #${index + 1}: out of range`);
    }
    if (this.check) {
      const err = checkListItem(this._field, index, item);
      if (err) {
        throw err;
      }
    }
    this._arr[index] = listItemToLocal(this._field, item);
  }
  add(item) {
    if (this.check) {
      const err = checkListItem(this._field, this._arr.length, item);
      if (err) {
        throw err;
      }
    }
    this._arr.push(listItemToLocal(this._field, item));
    return;
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const item of this._arr) {
      yield listItemToReflect(this._field, item, this.check);
    }
  }
  *entries() {
    for (let i = 0;i < this._arr.length; i++) {
      yield [i, listItemToReflect(this._field, this._arr[i], this.check)];
    }
  }
}
class ReflectMapImpl {
  constructor(field, unsafeInput, check = true) {
    this.obj = this[unsafeLocal] = unsafeInput !== null && unsafeInput !== undefined ? unsafeInput : {};
    this.check = check;
    this._field = field;
  }
  field() {
    return this._field;
  }
  set(key, value) {
    if (this.check) {
      const err = checkMapEntry(this._field, key, value);
      if (err) {
        throw err;
      }
    }
    this.obj[mapKeyToLocal(key)] = mapValueToLocal(this._field, value);
    return this;
  }
  delete(key) {
    const k = mapKeyToLocal(key);
    const has = Object.prototype.hasOwnProperty.call(this.obj, k);
    if (has) {
      delete this.obj[k];
    }
    return has;
  }
  clear() {
    for (const key of Object.keys(this.obj)) {
      delete this.obj[key];
    }
  }
  get(key) {
    let val = this.obj[mapKeyToLocal(key)];
    if (val !== undefined) {
      val = mapValueToReflect(this._field, val, this.check);
    }
    return val;
  }
  has(key) {
    return Object.prototype.hasOwnProperty.call(this.obj, mapKeyToLocal(key));
  }
  *keys() {
    for (const objKey of Object.keys(this.obj)) {
      yield mapKeyToReflect(objKey, this._field.mapKey);
    }
  }
  *entries() {
    for (const objEntry of Object.entries(this.obj)) {
      yield [
        mapKeyToReflect(objEntry[0], this._field.mapKey),
        mapValueToReflect(this._field, objEntry[1], this.check)
      ];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const val of Object.values(this.obj)) {
      yield mapValueToReflect(this._field, val, this.check);
    }
  }
  forEach(callbackfn, thisArg) {
    for (const mapEntry of this.entries()) {
      callbackfn.call(thisArg, mapEntry[1], mapEntry[0], this);
    }
  }
}
function messageToLocal(field, value) {
  if (!isReflectMessage(value)) {
    return value;
  }
  if (isWrapper(value.message) && !field.oneof && field.fieldKind == "message") {
    return value.message.value;
  }
  if (value.desc.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value") {
    return wktStructToLocal(value.message);
  }
  return value.message;
}
function messageToReflect(field, value, check) {
  if (value !== undefined) {
    if (isWrapperDesc(field.message) && !field.oneof && field.fieldKind == "message") {
      value = {
        $typeName: field.message.typeName,
        value: longToReflect(field.message.fields[0], value)
      };
    } else if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value" && isObject(value)) {
      value = wktStructToReflect(value);
    }
  }
  return new ReflectMessageImpl(field.message, value, check);
}
function listItemToLocal(field, value) {
  if (field.listKind == "message") {
    return messageToLocal(field, value);
  }
  return longToLocal(field, value);
}
function listItemToReflect(field, value, check) {
  if (field.listKind == "message") {
    return messageToReflect(field, value, check);
  }
  return longToReflect(field, value);
}
function mapValueToLocal(field, value) {
  if (field.mapKind == "message") {
    return messageToLocal(field, value);
  }
  return longToLocal(field, value);
}
function mapValueToReflect(field, value, check) {
  if (field.mapKind == "message") {
    return messageToReflect(field, value, check);
  }
  return value;
}
function mapKeyToLocal(key) {
  return typeof key == "string" || typeof key == "number" ? key : String(key);
}
function mapKeyToReflect(key, type) {
  switch (type) {
    case ScalarType.STRING:
      return key;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32: {
      const n = Number.parseInt(key);
      if (Number.isFinite(n)) {
        return n;
      }
      break;
    }
    case ScalarType.BOOL:
      switch (key) {
        case "true":
          return true;
        case "false":
          return false;
      }
      break;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      try {
        return protoInt64.uParse(key);
      } catch (_a) {}
      break;
    default:
      try {
        return protoInt64.parse(key);
      } catch (_b) {}
      break;
  }
  return key;
}
function longToReflect(field, value) {
  switch (field.scalar) {
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if ("longAsString" in field && field.longAsString && typeof value == "string") {
        value = protoInt64.parse(value);
      }
      break;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if ("longAsString" in field && field.longAsString && typeof value == "string") {
        value = protoInt64.uParse(value);
      }
      break;
  }
  return value;
}
function longToLocal(field, value) {
  switch (field.scalar) {
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if ("longAsString" in field && field.longAsString) {
        value = String(value);
      } else if (typeof value == "string" || typeof value == "number") {
        value = protoInt64.parse(value);
      }
      break;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if ("longAsString" in field && field.longAsString) {
        value = String(value);
      } else if (typeof value == "string" || typeof value == "number") {
        value = protoInt64.uParse(value);
      }
      break;
  }
  return value;
}
function wktStructToReflect(json) {
  const struct = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (isObject(json)) {
    for (const [k, v] of Object.entries(json)) {
      struct.fields[k] = wktValueToReflect(v);
    }
  }
  return struct;
}
function wktStructToLocal(val) {
  const json = {};
  for (const [k, v] of Object.entries(val.fields)) {
    json[k] = wktValueToLocal(v);
  }
  return json;
}
function wktValueToLocal(val) {
  switch (val.kind.case) {
    case "structValue":
      return wktStructToLocal(val.kind.value);
    case "listValue":
      return val.kind.value.values.map(wktValueToLocal);
    case "nullValue":
    case undefined:
      return null;
    default:
      return val.kind.value;
  }
}
function wktValueToReflect(json) {
  const value = {
    $typeName: "google.protobuf.Value",
    kind: { case: undefined }
  };
  switch (typeof json) {
    case "number":
      value.kind = { case: "numberValue", value: json };
      break;
    case "string":
      value.kind = { case: "stringValue", value: json };
      break;
    case "boolean":
      value.kind = { case: "boolValue", value: json };
      break;
    case "object":
      if (json === null) {
        const nullValue = 0;
        value.kind = { case: "nullValue", value: nullValue };
      } else if (Array.isArray(json)) {
        const listValue = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(json)) {
          for (const e of json) {
            listValue.values.push(wktValueToReflect(e));
          }
        }
        value.kind = {
          case: "listValue",
          value: listValue
        };
      } else {
        value.kind = {
          case: "structValue",
          value: wktStructToReflect(json)
        };
      }
      break;
  }
  return value;
}

// node_modules/@bufbuild/protobuf/dist/esm/to-binary.js
var LEGACY_REQUIRED2 = 3;
var writeDefaults = {
  writeUnknownFields: true
};
function makeWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
function toBinary(schema, message, options) {
  return writeFields(new BinaryWriter, makeWriteOptions(options), reflect(schema, message)).finish();
}
function writeFields(writer, opts, msg) {
  var _a;
  for (const f of msg.sortedFields) {
    if (!msg.isSet(f)) {
      if (f.presence == LEGACY_REQUIRED2) {
        throw new Error(`cannot encode ${f} to binary: required field not set`);
      }
      continue;
    }
    writeField(writer, opts, msg, f);
  }
  if (opts.writeUnknownFields) {
    for (const { no, wireType, data } of (_a = msg.getUnknown()) !== null && _a !== undefined ? _a : []) {
      writer.tag(no, wireType).raw(data);
    }
  }
  return writer;
}
function writeField(writer, opts, msg, field) {
  var _a;
  switch (field.fieldKind) {
    case "scalar":
    case "enum":
      writeScalar(writer, msg.desc.typeName, field.name, (_a = field.scalar) !== null && _a !== undefined ? _a : ScalarType.INT32, field.number, msg.get(field));
      break;
    case "list":
      writeListField(writer, opts, field, msg.get(field));
      break;
    case "message":
      writeMessageField(writer, opts, field, msg.get(field));
      break;
    case "map":
      for (const [key, val] of msg.get(field)) {
        writeMapEntry(writer, opts, field, key, val);
      }
      break;
  }
}
function writeScalar(writer, msgName, fieldName, scalarType, fieldNo, value) {
  writeScalarValue(writer.tag(fieldNo, writeTypeOfScalar(scalarType)), msgName, fieldName, scalarType, value);
}
function writeMessageField(writer, opts, field, message) {
  if (field.delimitedEncoding) {
    writeFields(writer.tag(field.number, WireType.StartGroup), opts, message).tag(field.number, WireType.EndGroup);
  } else {
    writeFields(writer.tag(field.number, WireType.LengthDelimited).fork(), opts, message).join();
  }
}
function writeListField(writer, opts, field, list) {
  var _a;
  if (field.listKind == "message") {
    for (const item of list) {
      writeMessageField(writer, opts, field, item);
    }
    return;
  }
  const scalarType = (_a = field.scalar) !== null && _a !== undefined ? _a : ScalarType.INT32;
  if (field.packed) {
    if (!list.size) {
      return;
    }
    writer.tag(field.number, WireType.LengthDelimited).fork();
    for (const item of list) {
      writeScalarValue(writer, field.parent.typeName, field.name, scalarType, item);
    }
    writer.join();
    return;
  }
  for (const item of list) {
    writeScalar(writer, field.parent.typeName, field.name, scalarType, field.number, item);
  }
}
function writeMapEntry(writer, opts, field, key, value) {
  var _a;
  writer.tag(field.number, WireType.LengthDelimited).fork();
  writeScalar(writer, field.parent.typeName, field.name, field.mapKey, 1, key);
  switch (field.mapKind) {
    case "scalar":
    case "enum":
      writeScalar(writer, field.parent.typeName, field.name, (_a = field.scalar) !== null && _a !== undefined ? _a : ScalarType.INT32, 2, value);
      break;
    case "message":
      writeFields(writer.tag(2, WireType.LengthDelimited).fork(), opts, value).join();
      break;
  }
  writer.join();
}
function writeScalarValue(writer, msgName, fieldName, type, value) {
  try {
    switch (type) {
      case ScalarType.STRING:
        writer.string(value);
        break;
      case ScalarType.BOOL:
        writer.bool(value);
        break;
      case ScalarType.DOUBLE:
        writer.double(value);
        break;
      case ScalarType.FLOAT:
        writer.float(value);
        break;
      case ScalarType.INT32:
        writer.int32(value);
        break;
      case ScalarType.INT64:
        writer.int64(value);
        break;
      case ScalarType.UINT64:
        writer.uint64(value);
        break;
      case ScalarType.FIXED64:
        writer.fixed64(value);
        break;
      case ScalarType.BYTES:
        writer.bytes(value);
        break;
      case ScalarType.FIXED32:
        writer.fixed32(value);
        break;
      case ScalarType.SFIXED32:
        writer.sfixed32(value);
        break;
      case ScalarType.SFIXED64:
        writer.sfixed64(value);
        break;
      case ScalarType.SINT64:
        writer.sint64(value);
        break;
      case ScalarType.UINT32:
        writer.uint32(value);
        break;
      case ScalarType.SINT32:
        writer.sint32(value);
        break;
    }
  } catch (e) {
    if (e instanceof Error) {
      throw new Error(`cannot encode field ${msgName}.${fieldName} to binary: ${e.message}`);
    }
    throw e;
  }
}
function writeTypeOfScalar(type) {
  switch (type) {
    case ScalarType.BYTES:
    case ScalarType.STRING:
      return WireType.LengthDelimited;
    case ScalarType.DOUBLE:
    case ScalarType.FIXED64:
    case ScalarType.SFIXED64:
      return WireType.Bit64;
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.FLOAT:
      return WireType.Bit32;
    default:
      return WireType.Varint;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/codegenv2/message.js
function messageDesc(file, path, ...paths) {
  return paths.reduce((acc, cur) => acc.nestedMessages[cur], file.messages[path]);
}

// node_modules/@bufbuild/protobuf/dist/esm/codegenv2/enum.js
function enumDesc(file, path, ...paths) {
  if (paths.length == 0) {
    return file.enums[path];
  }
  const e = paths.pop();
  return paths.reduce((acc, cur) => acc.nestedMessages[cur], file.messages[path]).nestedEnums[e];
}

// node_modules/@bufbuild/protobuf/dist/esm/wkt/gen/google/protobuf/descriptor_pb.js
var file_google_protobuf_descriptor = /* @__PURE__ */ boot({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536000000, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: true } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: true } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: true } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1000, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1000 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1000, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: true } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: true } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536000000, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: true } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1000 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] });
var FileDescriptorProtoSchema = /* @__PURE__ */ messageDesc(file_google_protobuf_descriptor, 1);
var ExtensionRangeOptions_VerificationState;
(function(ExtensionRangeOptions_VerificationState2) {
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["DECLARATION"] = 0] = "DECLARATION";
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["UNVERIFIED"] = 1] = "UNVERIFIED";
})(ExtensionRangeOptions_VerificationState || (ExtensionRangeOptions_VerificationState = {}));
var FieldDescriptorProto_Type;
(function(FieldDescriptorProto_Type2) {
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["DOUBLE"] = 1] = "DOUBLE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FLOAT"] = 2] = "FLOAT";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT64"] = 3] = "INT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT64"] = 4] = "UINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT32"] = 5] = "INT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED64"] = 6] = "FIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED32"] = 7] = "FIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BOOL"] = 8] = "BOOL";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["STRING"] = 9] = "STRING";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["GROUP"] = 10] = "GROUP";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["MESSAGE"] = 11] = "MESSAGE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BYTES"] = 12] = "BYTES";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT32"] = 13] = "UINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["ENUM"] = 14] = "ENUM";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED32"] = 15] = "SFIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED64"] = 16] = "SFIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT32"] = 17] = "SINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT64"] = 18] = "SINT64";
})(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));
var FieldDescriptorProto_Label;
(function(FieldDescriptorProto_Label2) {
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["OPTIONAL"] = 1] = "OPTIONAL";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REPEATED"] = 3] = "REPEATED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REQUIRED"] = 2] = "REQUIRED";
})(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));
var FileOptions_OptimizeMode;
(function(FileOptions_OptimizeMode2) {
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
})(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));
var FieldOptions_CType;
(function(FieldOptions_CType2) {
  FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
  FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
  FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
})(FieldOptions_CType || (FieldOptions_CType = {}));
var FieldOptions_JSType;
(function(FieldOptions_JSType2) {
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
})(FieldOptions_JSType || (FieldOptions_JSType = {}));
var FieldOptions_OptionRetention;
(function(FieldOptions_OptionRetention2) {
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
})(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));
var FieldOptions_OptionTargetType;
(function(FieldOptions_OptionTargetType2) {
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
})(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));
var MethodOptions_IdempotencyLevel;
(function(MethodOptions_IdempotencyLevel2) {
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
})(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));
var FeatureSet_VisibilityFeature_DefaultSymbolVisibility;
(function(FeatureSet_VisibilityFeature_DefaultSymbolVisibility2) {
  FeatureSet_VisibilityFeature_DefaultSymbolVisibility2[FeatureSet_VisibilityFeature_DefaultSymbolVisibility2["DEFAULT_SYMBOL_VISIBILITY_UNKNOWN"] = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN";
  FeatureSet_VisibilityFeature_DefaultSymbolVisibility2[FeatureSet_VisibilityFeature_DefaultSymbolVisibility2["EXPORT_ALL"] = 1] = "EXPORT_ALL";
  FeatureSet_VisibilityFeature_DefaultSymbolVisibility2[FeatureSet_VisibilityFeature_DefaultSymbolVisibility2["EXPORT_TOP_LEVEL"] = 2] = "EXPORT_TOP_LEVEL";
  FeatureSet_VisibilityFeature_DefaultSymbolVisibility2[FeatureSet_VisibilityFeature_DefaultSymbolVisibility2["LOCAL_ALL"] = 3] = "LOCAL_ALL";
  FeatureSet_VisibilityFeature_DefaultSymbolVisibility2[FeatureSet_VisibilityFeature_DefaultSymbolVisibility2["STRICT"] = 4] = "STRICT";
})(FeatureSet_VisibilityFeature_DefaultSymbolVisibility || (FeatureSet_VisibilityFeature_DefaultSymbolVisibility = {}));
var FeatureSet_FieldPresence;
(function(FeatureSet_FieldPresence2) {
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["FIELD_PRESENCE_UNKNOWN"] = 0] = "FIELD_PRESENCE_UNKNOWN";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["EXPLICIT"] = 1] = "EXPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["IMPLICIT"] = 2] = "IMPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["LEGACY_REQUIRED"] = 3] = "LEGACY_REQUIRED";
})(FeatureSet_FieldPresence || (FeatureSet_FieldPresence = {}));
var FeatureSet_EnumType;
(function(FeatureSet_EnumType2) {
  FeatureSet_EnumType2[FeatureSet_EnumType2["ENUM_TYPE_UNKNOWN"] = 0] = "ENUM_TYPE_UNKNOWN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["OPEN"] = 1] = "OPEN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["CLOSED"] = 2] = "CLOSED";
})(FeatureSet_EnumType || (FeatureSet_EnumType = {}));
var FeatureSet_RepeatedFieldEncoding;
(function(FeatureSet_RepeatedFieldEncoding2) {
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["REPEATED_FIELD_ENCODING_UNKNOWN"] = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["PACKED"] = 1] = "PACKED";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["EXPANDED"] = 2] = "EXPANDED";
})(FeatureSet_RepeatedFieldEncoding || (FeatureSet_RepeatedFieldEncoding = {}));
var FeatureSet_Utf8Validation;
(function(FeatureSet_Utf8Validation2) {
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["UTF8_VALIDATION_UNKNOWN"] = 0] = "UTF8_VALIDATION_UNKNOWN";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["VERIFY"] = 2] = "VERIFY";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["NONE"] = 3] = "NONE";
})(FeatureSet_Utf8Validation || (FeatureSet_Utf8Validation = {}));
var FeatureSet_MessageEncoding;
(function(FeatureSet_MessageEncoding2) {
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["MESSAGE_ENCODING_UNKNOWN"] = 0] = "MESSAGE_ENCODING_UNKNOWN";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["LENGTH_PREFIXED"] = 1] = "LENGTH_PREFIXED";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["DELIMITED"] = 2] = "DELIMITED";
})(FeatureSet_MessageEncoding || (FeatureSet_MessageEncoding = {}));
var FeatureSet_JsonFormat;
(function(FeatureSet_JsonFormat2) {
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["JSON_FORMAT_UNKNOWN"] = 0] = "JSON_FORMAT_UNKNOWN";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["ALLOW"] = 1] = "ALLOW";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["LEGACY_BEST_EFFORT"] = 2] = "LEGACY_BEST_EFFORT";
})(FeatureSet_JsonFormat || (FeatureSet_JsonFormat = {}));
var FeatureSet_EnforceNamingStyle;
(function(FeatureSet_EnforceNamingStyle2) {
  FeatureSet_EnforceNamingStyle2[FeatureSet_EnforceNamingStyle2["ENFORCE_NAMING_STYLE_UNKNOWN"] = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN";
  FeatureSet_EnforceNamingStyle2[FeatureSet_EnforceNamingStyle2["STYLE2024"] = 1] = "STYLE2024";
  FeatureSet_EnforceNamingStyle2[FeatureSet_EnforceNamingStyle2["STYLE_LEGACY"] = 2] = "STYLE_LEGACY";
})(FeatureSet_EnforceNamingStyle || (FeatureSet_EnforceNamingStyle = {}));
var GeneratedCodeInfo_Annotation_Semantic;
(function(GeneratedCodeInfo_Annotation_Semantic2) {
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
})(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));
var Edition;
(function(Edition2) {
  Edition2[Edition2["EDITION_UNKNOWN"] = 0] = "EDITION_UNKNOWN";
  Edition2[Edition2["EDITION_LEGACY"] = 900] = "EDITION_LEGACY";
  Edition2[Edition2["EDITION_PROTO2"] = 998] = "EDITION_PROTO2";
  Edition2[Edition2["EDITION_PROTO3"] = 999] = "EDITION_PROTO3";
  Edition2[Edition2["EDITION_2023"] = 1000] = "EDITION_2023";
  Edition2[Edition2["EDITION_2024"] = 1001] = "EDITION_2024";
  Edition2[Edition2["EDITION_1_TEST_ONLY"] = 1] = "EDITION_1_TEST_ONLY";
  Edition2[Edition2["EDITION_2_TEST_ONLY"] = 2] = "EDITION_2_TEST_ONLY";
  Edition2[Edition2["EDITION_99997_TEST_ONLY"] = 99997] = "EDITION_99997_TEST_ONLY";
  Edition2[Edition2["EDITION_99998_TEST_ONLY"] = 99998] = "EDITION_99998_TEST_ONLY";
  Edition2[Edition2["EDITION_99999_TEST_ONLY"] = 99999] = "EDITION_99999_TEST_ONLY";
  Edition2[Edition2["EDITION_MAX"] = 2147483647] = "EDITION_MAX";
})(Edition || (Edition = {}));
var SymbolVisibility;
(function(SymbolVisibility2) {
  SymbolVisibility2[SymbolVisibility2["VISIBILITY_UNSET"] = 0] = "VISIBILITY_UNSET";
  SymbolVisibility2[SymbolVisibility2["VISIBILITY_LOCAL"] = 1] = "VISIBILITY_LOCAL";
  SymbolVisibility2[SymbolVisibility2["VISIBILITY_EXPORT"] = 2] = "VISIBILITY_EXPORT";
})(SymbolVisibility || (SymbolVisibility = {}));

// node_modules/@bufbuild/protobuf/dist/esm/from-binary.js
var readDefaults = {
  readUnknownFields: true
};
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function fromBinary(schema, bytes, options) {
  const msg = reflect(schema, undefined, false);
  readMessage(msg, new BinaryReader(bytes), makeReadOptions(options), false, bytes.byteLength);
  return msg.message;
}
function readMessage(message, reader, options, delimited, lengthOrDelimitedFieldNo) {
  var _a;
  const end = delimited ? reader.len : reader.pos + lengthOrDelimitedFieldNo;
  let fieldNo;
  let wireType;
  const unknownFields = (_a = message.getUnknown()) !== null && _a !== undefined ? _a : [];
  while (reader.pos < end) {
    [fieldNo, wireType] = reader.tag();
    if (delimited && wireType == WireType.EndGroup) {
      break;
    }
    const field = message.findNumber(fieldNo);
    if (!field) {
      const data = reader.skip(wireType, fieldNo);
      if (options.readUnknownFields) {
        unknownFields.push({ no: fieldNo, wireType, data });
      }
      continue;
    }
    readField(message, reader, field, wireType, options);
  }
  if (delimited) {
    if (wireType != WireType.EndGroup || fieldNo !== lengthOrDelimitedFieldNo) {
      throw new Error("invalid end group tag");
    }
  }
  if (unknownFields.length > 0) {
    message.setUnknown(unknownFields);
  }
}
function readField(message, reader, field, wireType, options) {
  var _a;
  switch (field.fieldKind) {
    case "scalar":
      message.set(field, readScalar(reader, field.scalar));
      break;
    case "enum":
      const val = readScalar(reader, ScalarType.INT32);
      if (field.enum.open) {
        message.set(field, val);
      } else {
        const ok = field.enum.values.some((v) => v.number === val);
        if (ok) {
          message.set(field, val);
        } else if (options.readUnknownFields) {
          const data = new BinaryWriter().int32(val).finish();
          const unknownFields = (_a = message.getUnknown()) !== null && _a !== undefined ? _a : [];
          unknownFields.push({ no: field.number, wireType, data });
          message.setUnknown(unknownFields);
        }
      }
      break;
    case "message":
      message.set(field, readMessageField(reader, options, field, message.get(field)));
      break;
    case "list":
      readListField(reader, wireType, message.get(field), options);
      break;
    case "map":
      readMapEntry(reader, message.get(field), options);
      break;
  }
}
function readMapEntry(reader, map, options) {
  const field = map.field();
  let key;
  let val;
  const len = reader.uint32();
  const end = reader.pos + len;
  while (reader.pos < end) {
    const [fieldNo] = reader.tag();
    switch (fieldNo) {
      case 1:
        key = readScalar(reader, field.mapKey);
        break;
      case 2:
        switch (field.mapKind) {
          case "scalar":
            val = readScalar(reader, field.scalar);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, options, field);
            break;
        }
        break;
    }
  }
  if (key === undefined) {
    key = scalarZeroValue(field.mapKey, false);
  }
  if (val === undefined) {
    switch (field.mapKind) {
      case "scalar":
        val = scalarZeroValue(field.scalar, false);
        break;
      case "enum":
        val = field.enum.values[0].number;
        break;
      case "message":
        val = reflect(field.message, undefined, false);
        break;
    }
  }
  map.set(key, val);
}
function readListField(reader, wireType, list, options) {
  var _a;
  const field = list.field();
  if (field.listKind === "message") {
    list.add(readMessageField(reader, options, field));
    return;
  }
  const scalarType = (_a = field.scalar) !== null && _a !== undefined ? _a : ScalarType.INT32;
  const packed = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
  if (!packed) {
    list.add(readScalar(reader, scalarType));
    return;
  }
  const e = reader.uint32() + reader.pos;
  while (reader.pos < e) {
    list.add(readScalar(reader, scalarType));
  }
}
function readMessageField(reader, options, field, mergeMessage) {
  const delimited = field.delimitedEncoding;
  const message = mergeMessage !== null && mergeMessage !== undefined ? mergeMessage : reflect(field.message, undefined, false);
  readMessage(message, reader, options, delimited, delimited ? field.number : reader.uint32());
  return message;
}
function readScalar(reader, type) {
  switch (type) {
    case ScalarType.STRING:
      return reader.string();
    case ScalarType.BOOL:
      return reader.bool();
    case ScalarType.DOUBLE:
      return reader.double();
    case ScalarType.FLOAT:
      return reader.float();
    case ScalarType.INT32:
      return reader.int32();
    case ScalarType.INT64:
      return reader.int64();
    case ScalarType.UINT64:
      return reader.uint64();
    case ScalarType.FIXED64:
      return reader.fixed64();
    case ScalarType.BYTES:
      return reader.bytes();
    case ScalarType.FIXED32:
      return reader.fixed32();
    case ScalarType.SFIXED32:
      return reader.sfixed32();
    case ScalarType.SFIXED64:
      return reader.sfixed64();
    case ScalarType.SINT64:
      return reader.sint64();
    case ScalarType.UINT32:
      return reader.uint32();
    case ScalarType.SINT32:
      return reader.sint32();
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/codegenv2/file.js
function fileDesc(b64, imports) {
  var _a;
  const root = fromBinary(FileDescriptorProtoSchema, base64Decode(b64));
  root.messageType.forEach(restoreJsonNames);
  root.dependency = (_a = imports === null || imports === undefined ? undefined : imports.map((f) => f.proto.name)) !== null && _a !== undefined ? _a : [];
  const reg = createFileRegistry(root, (protoFileName) => imports === null || imports === undefined ? undefined : imports.find((f) => f.proto.name === protoFileName));
  return reg.getFile(root.name);
}

// src/gen/nord_pb.ts
var file_nord = /* @__PURE__ */ fileDesc("Cgpub3JkLnByb3RvEgRub3JkIj0KDUZlZVRpZXJDb25maWcSFQoNbWFrZXJfZmVlX3BwbRgBIAEoDRIVCg10YWtlcl9mZWVfcHBtGAIgASgNItABCgZNYXJrZXQSEQoJbWFya2V0X2lkGAEgASgNEhYKDnByaWNlX2RlY2ltYWxzGAIgASgNEhUKDXNpemVfZGVjaW1hbHMYAyABKA0SFQoNYmFzZV90b2tlbl9pZBgEIAEoDRIlCgttYXJrZXRfdHlwZRgFIAEoDjIQLm5vcmQuTWFya2V0VHlwZRIPCgdpbWZfYnBzGAYgASgNEg8KB2NtZl9icHMYByABKA0SDwoHbW1mX2JwcxgIIAEoDRITCgt2aWV3X3N5bWJvbBgKIAEoCSJaCgVUb2tlbhIQCgh0b2tlbl9pZBgBIAEoDRIWCg50b2tlbl9kZWNpbWFscxgCIAEoDRISCgp3ZWlnaHRfYnBzGAQgASgNEhMKC3ZpZXdfc3ltYm9sGAUgASgJIigKCVF1b3RlU2l6ZRIMCgRzaXplGAEgASgEEg0KBXByaWNlGAIgASgEIk4KCk9yZGVyTGltaXQSDQoFcHJpY2UYBiABKAQSDAoEc2l6ZRgHIAEoBBIjCgpxdW90ZV9zaXplGAggASgLMg8ubm9yZC5RdW90ZVNpemUiYAoJT3JkZXJUeXBlEhgKBHNpZGUYAyABKA4yCi5ub3JkLlNpZGUSIQoJZmlsbF9tb2RlGAQgASgOMg4ubm9yZC5GaWxsTW9kZRIWCg5pc19yZWR1Y2Vfb25seRgFIAEoCCKZAQoMVHJhZGVPclBsYWNlEhEKCW1hcmtldF9pZBgCIAEoDRIjCgpvcmRlcl90eXBlGAMgASgLMg8ubm9yZC5PcmRlclR5cGUSHwoFbGltaXQYBiABKAsyEC5ub3JkLk9yZGVyTGltaXQSHAoPY2xpZW50X29yZGVyX2lkGCEgASgESACIAQFCEgoQX2NsaWVudF9vcmRlcl9pZCIfCgtDYW5jZWxPcmRlchIQCghvcmRlcl9pZBgCIAEoBCJHCgpUcmlnZ2VyS2V5Eh8KBGtpbmQYAyABKA4yES5ub3JkLlRyaWdnZXJLaW5kEhgKBHNpZGUYBCABKA4yCi5ub3JkLlNpZGUidwoTQXRvbWljU3ViYWN0aW9uS2luZBIsCg50cmFkZV9vcl9wbGFjZRgGIAEoCzISLm5vcmQuVHJhZGVPclBsYWNlSAASKQoMY2FuY2VsX29yZGVyGAcgASgLMhEubm9yZC5DYW5jZWxPcmRlckgAQgcKBWlubmVyInAKBkF0b21pYxISCgpzZXNzaW9uX2lkGAEgASgEEhcKCmFjY291bnRfaWQYAiABKA1IAIgBARIqCgdhY3Rpb25zGAYgAygLMhkubm9yZC5BdG9taWNTdWJhY3Rpb25LaW5kQg0KC19hY2NvdW50X2lkIq8lCgZBY3Rpb24SGQoRY3VycmVudF90aW1lc3RhbXAYASABKAMSDQoFbm9uY2UYAiABKA0SNAoOY3JlYXRlX3Nlc3Npb24YBCABKAsyGi5ub3JkLkFjdGlvbi5DcmVhdGVTZXNzaW9uSAASMAoMY3JlYXRlX3Rva2VuGAUgASgLMhgubm9yZC5BY3Rpb24uQ3JlYXRlVG9rZW5IABIyCg1jcmVhdGVfbWFya2V0GAYgASgLMhkubm9yZC5BY3Rpb24uQ3JlYXRlTWFya2V0SAASLgoLcGxhY2Vfb3JkZXIYByABKAsyFy5ub3JkLkFjdGlvbi5QbGFjZU9yZGVySAASOgoSY2FuY2VsX29yZGVyX2J5X2lkGAggASgLMhwubm9yZC5BY3Rpb24uQ2FuY2VsT3JkZXJCeUlkSAASJwoHZGVwb3NpdBgJIAEoCzIULm5vcmQuQWN0aW9uLkRlcG9zaXRIABIpCgh3aXRoZHJhdxgKIAEoCzIVLm5vcmQuQWN0aW9uLldpdGhkcmF3SAASTAobcHl0aF9zZXRfd29ybWhvbGVfZ3VhcmRpYW5zGAsgASgLMiUubm9yZC5BY3Rpb24uUHl0aFNldFdvcm1ob2xlR3VhcmRpYW5zSAASPgoUcHl0aF9zZXRfc3ltYm9sX2ZlZWQYDCABKAsyHi5ub3JkLkFjdGlvbi5QeXRoU2V0U3ltYm9sRmVlZEgAEkIKFnB5dGhfcHJpY2VfZmVlZF91cGRhdGUYDSABKAsyIC5ub3JkLkFjdGlvbi5QeXRoUHJpY2VGZWVkVXBkYXRlSAASKwoJbGlxdWlkYXRlGA4gASgLMhYubm9yZC5BY3Rpb24uTGlxdWlkYXRlSAASNAoOcmV2b2tlX3Nlc3Npb24YDyABKAsyGi5ub3JkLkFjdGlvbi5SZXZva2VTZXNzaW9uSAASIwoFcGF1c2UYECABKAsyEi5ub3JkLkFjdGlvbi5QYXVzZUgAEicKB3VucGF1c2UYESABKAsyFC5ub3JkLkFjdGlvbi5VbnBhdXNlSAASKQoIdHJhbnNmZXIYEiABKAsyFS5ub3JkLkFjdGlvbi5UcmFuc2ZlckgAEi4KC2FkZF90cmlnZ2VyGCAgASgLMhcubm9yZC5BY3Rpb24uQWRkVHJpZ2dlckgAEjQKDnJlbW92ZV90cmlnZ2VyGCEgASgLMhoubm9yZC5BY3Rpb24uUmVtb3ZlVHJpZ2dlckgAEjIKDXRha2VfcG9zaXRpb24YIiABKAsyGS5ub3JkLkFjdGlvbi5UYWtlUG9zaXRpb25IABIeCgZhdG9taWMYIyABKAsyDC5ub3JkLkF0b21pY0gAEjIKDWZyZWV6ZV9tYXJrZXQYJCABKAsyGS5ub3JkLkFjdGlvbi5GcmVlemVNYXJrZXRIABI2Cg91bmZyZWV6ZV9tYXJrZXQYJSABKAsyGy5ub3JkLkFjdGlvbi5VbmZyZWV6ZU1hcmtldEgAEi8KDGFkZF9mZWVfdGllchgmIAEoCzIXLm5vcmQuQWN0aW9uLkFkZEZlZVRpZXJIABI1Cg91cGRhdGVfZmVlX3RpZXIYJyABKAsyGi5ub3JkLkFjdGlvbi5VcGRhdGVGZWVUaWVySAASPwoUdXBkYXRlX2FjY291bnRzX3RpZXIYKCABKAsyHy5ub3JkLkFjdGlvbi5VcGRhdGVBY2NvdW50c1RpZXJIABIsCgp1cGRhdGVfYWNsGCkgASgLMhYubm9yZC5BY3Rpb24uVXBkYXRlQWNsSAASOwoSZmVlX3ZhdWx0X3RyYW5zZmVyGCogASgLMh0ubm9yZC5BY3Rpb24uRmVlVmF1bHRUcmFuc2ZlckgAEkcKGWNhbmNlbF9vcmRlcl9ieV9jbGllbnRfaWQYLCABKAsyIi5ub3JkLkFjdGlvbi5DYW5jZWxPcmRlckJ5Q2xpZW50SWRIABqvAQoNQ3JlYXRlU2Vzc2lvbhITCgt1c2VyX3B1YmtleRgBIAEoDBIWCg5zZXNzaW9uX3B1YmtleRgCIAEoDBIYChBleHBpcnlfdGltZXN0YW1wGAMgASgDEkEKEXNpZ25hdHVyZV9mcmFtaW5nGAQgASgOMiEubm9yZC5BY3Rpb24uVXNlclNpZ25hdHVyZUZyYW1pbmdIAIgBAUIUChJfc2lnbmF0dXJlX2ZyYW1pbmcaiwEKC0NyZWF0ZVRva2VuEhYKDnRva2VuX2RlY2ltYWxzGAEgASgNEhIKCndlaWdodF9icHMYAyABKA0SEwoLdmlld19zeW1ib2wYBCABKAkSFQoNb3JhY2xlX3N5bWJvbBgFIAEoCRIQCghzb2xfYWRkchgGIAEoDBISCgphY2xfcHVia2V5GAcgASgMGu4BCgxDcmVhdGVNYXJrZXQSFQoNc2l6ZV9kZWNpbWFscxgBIAEoDRIWCg5wcmljZV9kZWNpbWFscxgCIAEoDRIPCgdpbWZfYnBzGAMgASgNEg8KB2NtZl9icHMYBCABKA0SDwoHbW1mX2JwcxgFIAEoDRIlCgttYXJrZXRfdHlwZRgGIAEoDjIQLm5vcmQuTWFya2V0VHlwZRITCgt2aWV3X3N5bWJvbBgHIAEoCRIVCg1vcmFjbGVfc3ltYm9sGAggASgJEhUKDWJhc2VfdG9rZW5faWQYCSABKA0SEgoKYWNsX3B1YmtleRgKIAEoDBqmAwoKUGxhY2VPcmRlchISCgpzZXNzaW9uX2lkGAEgASgEEhEKCW1hcmtldF9pZBgCIAEoDRIYCgRzaWRlGAMgASgOMgoubm9yZC5TaWRlEiEKCWZpbGxfbW9kZRgEIAEoDjIOLm5vcmQuRmlsbE1vZGUSFgoOaXNfcmVkdWNlX29ubHkYBSABKAgSDQoFcHJpY2UYBiABKAQSDAoEc2l6ZRgHIAEoBBIjCgpxdW90ZV9zaXplGAggASgLMg8ubm9yZC5RdW90ZVNpemUSIQoUZGVsZWdhdG9yX2FjY291bnRfaWQYICABKA1IAIgBARIcCg9jbGllbnRfb3JkZXJfaWQYISABKARIAYgBARIeChFzZW5kZXJfYWNjb3VudF9pZBgiIAEoDUgCiAEBEh8KEnNlbmRlcl90cmFja2luZ19pZBgjIAEoBEgDiAEBQhcKFV9kZWxlZ2F0b3JfYWNjb3VudF9pZEISChBfY2xpZW50X29yZGVyX2lkQhQKEl9zZW5kZXJfYWNjb3VudF9pZEIVChNfc2VuZGVyX3RyYWNraW5nX2lkGqkBCg9DYW5jZWxPcmRlckJ5SWQSEgoKc2Vzc2lvbl9pZBgBIAEoBBIQCghvcmRlcl9pZBgCIAEoBBIhChRkZWxlZ2F0b3JfYWNjb3VudF9pZBggIAEoDUgAiAEBEh4KEXNlbmRlcl9hY2NvdW50X2lkGCEgASgNSAGIAQFCFwoVX2RlbGVnYXRvcl9hY2NvdW50X2lkQhQKEl9zZW5kZXJfYWNjb3VudF9pZBp6ChVDYW5jZWxPcmRlckJ5Q2xpZW50SWQSEgoKc2Vzc2lvbl9pZBgBIAEoBBIXCg9jbGllbnRfb3JkZXJfaWQYAiABKAQSHgoRc2VuZGVyX2FjY291bnRfaWQYAyABKA1IAIgBAUIUChJfc2VuZGVyX2FjY291bnRfaWQabwoHRGVwb3NpdBIUCgxhY3Rpb25fbm9uY2UYASABKAQSEgoKdG9rZW5fYWRkchgCIAEoDBIOCgZhbW91bnQYAyABKAQSEwoLdXNlcl9wdWJrZXkYBCABKAwSFQoNc2VuZGVyX3B1YmtleRgFIAEoDBpqCghXaXRoZHJhdxIQCgh0b2tlbl9pZBgBIAEoDRISCgpzZXNzaW9uX2lkGAIgASgEEg4KBmFtb3VudBgDIAEoBBIYCgtkZXN0X3B1YmtleRgEIAEoDEgAiAEBQg4KDF9kZXN0X3B1YmtleRpdChhQeXRoU2V0V29ybWhvbGVHdWFyZGlhbnMSGgoSZ3VhcmRpYW5fc2V0X2luZGV4GAEgASgNEhEKCWFkZHJlc3NlcxgCIAMoDBISCgphY2xfcHVia2V5GAMgASgMGlUKEVB5dGhTZXRTeW1ib2xGZWVkEhUKDW9yYWNsZV9zeW1ib2wYASABKAkSFQoNcHJpY2VfZmVlZF9pZBgCIAEoDBISCgphY2xfcHVia2V5GAMgASgMGi8KE1B5dGhQcmljZUZlZWRVcGRhdGUSGAoQcmF3X3B5dGhuZXRfZGF0YRgBIAEoDBqHAQoJTGlxdWlkYXRlEh0KFWxpcXVpZGF0b3Jfc2Vzc2lvbl9pZBgBIAEoBBIdChVsaXF1aWRhdGVlX2FjY291bnRfaWQYAiABKA0SIgoVbGlxdWlkYXRvcl9hY2NvdW50X2lkGAMgASgNSACIAQFCGAoWX2xpcXVpZGF0b3JfYWNjb3VudF9pZBojCg1SZXZva2VTZXNzaW9uEhIKCnNlc3Npb25faWQYASABKAQaGwoFUGF1c2USEgoKYWNsX3B1YmtleRgBIAEoDBodCgdVbnBhdXNlEhIKCmFjbF9wdWJrZXkYASABKAwazwEKCFRyYW5zZmVyEhIKCnNlc3Npb25faWQYASABKAQSFwoPZnJvbV9hY2NvdW50X2lkGAIgASgNEhAKCHRva2VuX2lkGAMgASgNEg4KBmFtb3VudBgEIAEoBBIaCg10b19hY2NvdW50X2lkGAggASgNSACIAQESMgoPc3BlY2lhbF9hY2NvdW50GAkgASgOMhQubm9yZC5TcGVjaWFsQWNjb3VudEgBiAEBQhAKDl90b19hY2NvdW50X2lkQhIKEF9zcGVjaWFsX2FjY291bnQaWwoQRmVlVmF1bHRUcmFuc2ZlchISCgphY2xfcHVia2V5GAEgASgMEhEKCXJlY2lwaWVudBgCIAEoDRIQCgh0b2tlbl9pZBgDIAEoDRIOCgZhbW91bnQYBCABKAQaUAoNVHJpZ2dlclByaWNlcxIVCg10cmlnZ2VyX3ByaWNlGAUgASgEEhgKC2xpbWl0X3ByaWNlGAYgASgESACIAQFCDgoMX2xpbWl0X3ByaWNlGqYBCgpBZGRUcmlnZ2VyEhIKCnNlc3Npb25faWQYASABKAQSEQoJbWFya2V0X2lkGAIgASgNEh0KA2tleRgDIAEoCzIQLm5vcmQuVHJpZ2dlcktleRIqCgZwcmljZXMYBCABKAsyGi5ub3JkLkFjdGlvbi5UcmlnZ2VyUHJpY2VzEhcKCmFjY291bnRfaWQYCiABKA1IAIgBAUINCgtfYWNjb3VudF9pZBp9Cg1SZW1vdmVUcmlnZ2VyEhIKCnNlc3Npb25faWQYASABKAQSEQoJbWFya2V0X2lkGAIgASgNEh0KA2tleRgDIAEoCzIQLm5vcmQuVHJpZ2dlcktleRIXCgphY2NvdW50X2lkGAogASgNSACIAQFCDQoLX2FjY291bnRfaWQaRQoKQWRkRmVlVGllchISCgphY2xfcHVia2V5GAEgASgMEiMKBmNvbmZpZxgCIAEoCzITLm5vcmQuRmVlVGllckNvbmZpZxpUCg1VcGRhdGVGZWVUaWVyEgoKAmlkGAEgASgNEiMKBmNvbmZpZxgCIAEoCzITLm5vcmQuRmVlVGllckNvbmZpZxISCgphY2xfcHVia2V5GAMgASgMGksKElVwZGF0ZUFjY291bnRzVGllchIPCgd0aWVyX2lkGAEgASgNEhAKCGFjY291bnRzGAIgAygNEhIKCmFjbF9wdWJrZXkYAyABKAwaXwoJVXBkYXRlQWNsEhIKCmFjbF9wdWJrZXkYASABKAwSFQoNdGFyZ2V0X3B1YmtleRgCIAEoDBISCgpyb2xlc19tYXNrGAMgASgNEhMKC3JvbGVzX3ZhbHVlGAQgASgNGjUKDEZyZWV6ZU1hcmtldBISCgphY2xfcHVia2V5GAEgASgMEhEKCW1hcmtldF9pZBgCIAEoDRo3Cg5VbmZyZWV6ZU1hcmtldBISCgphY2xfcHVia2V5GAEgASgMEhEKCW1hcmtldF9pZBgCIAEoDRqXAQoMVGFrZVBvc2l0aW9uEhIKCnNlc3Npb25faWQYASABKAQSEQoJbWFya2V0X2lkGAIgASgNEgwKBHNpemUYAyABKAMSHgoRc2VuZGVyX2FjY291bnRfaWQYBCABKA1IAIgBARISCgVwcmljZRgFIAEoBEgBiAEBQhQKEl9zZW5kZXJfYWNjb3VudF9pZEIICgZfcHJpY2UiNwoUVXNlclNpZ25hdHVyZUZyYW1pbmcSBwoDSEVYEAASFgoSU09MQU5BX1RSQU5TQUNUSU9OEAFCBgoEa2luZCLIIAoHUmVjZWlwdBIRCglhY3Rpb25faWQYASABKAQSGgoDZXJyGCAgASgOMgsubm9yZC5FcnJvckgAEkIKFWNyZWF0ZV9zZXNzaW9uX3Jlc3VsdBghIAEoCzIhLm5vcmQuUmVjZWlwdC5DcmVhdGVTZXNzaW9uUmVzdWx0SAASPAoScGxhY2Vfb3JkZXJfcmVzdWx0GCIgASgLMh4ubm9yZC5SZWNlaXB0LlBsYWNlT3JkZXJSZXN1bHRIABI+ChNjYW5jZWxfb3JkZXJfcmVzdWx0GCMgASgLMh8ubm9yZC5SZWNlaXB0LkNhbmNlbE9yZGVyUmVzdWx0SAASNQoOZGVwb3NpdF9yZXN1bHQYJCABKAsyGy5ub3JkLlJlY2VpcHQuRGVwb3NpdFJlc3VsdEgAEj4KE2luc2VydF90b2tlbl9yZXN1bHQYJSABKAsyHy5ub3JkLlJlY2VpcHQuSW5zZXJ0VG9rZW5SZXN1bHRIABJAChRpbnNlcnRfbWFya2V0X3Jlc3VsdBgmIAEoCzIgLm5vcmQuUmVjZWlwdC5JbnNlcnRNYXJrZXRSZXN1bHRIABI3Cg93aXRoZHJhd19yZXN1bHQYJyABKAsyHC5ub3JkLlJlY2VpcHQuV2l0aGRyYXdSZXN1bHRIABJJChlvcmFjbGVfc3ltYm9sX2ZlZWRfcmVzdWx0GCggASgLMiQubm9yZC5SZWNlaXB0Lk9yYWNsZVN5bWJvbEZlZWRSZXN1bHRIABJAChRvcmFjbGVfdXBkYXRlX3Jlc3VsdBgpIAEoCzIgLm5vcmQuUmVjZWlwdC5PcmFjbGVVcGRhdGVSZXN1bHRIABJLChp1cGRhdGVfZ3VhcmRpYW5fc2V0X3Jlc3VsdBgqIAEoCzIlLm5vcmQuUmVjZWlwdC5VcGRhdGVHdWFyZGlhblNldFJlc3VsdEgAEjUKCmxpcXVpZGF0ZWQYKyABKAsyHy5ub3JkLlJlY2VpcHQuQWNjb3VudExpcXVpZGF0ZWRIABI3Cg9zZXNzaW9uX3Jldm9rZWQYLCABKAsyHC5ub3JkLlJlY2VpcHQuU2Vzc2lvblJldm9rZWRIABImCgZwYXVzZWQYLSABKAsyFC5ub3JkLlJlY2VpcHQuUGF1c2VkSAASKgoIdW5wYXVzZWQYLiABKAsyFi5ub3JkLlJlY2VpcHQuVW5wYXVzZWRIABIwCgt0cmFuc2ZlcnJlZBgvIAEoCzIZLm5vcmQuUmVjZWlwdC5UcmFuc2ZlcnJlZEgAEjMKDXRyaWdnZXJfYWRkZWQYQCABKAsyGi5ub3JkLlJlY2VpcHQuVHJpZ2dlckFkZGVkSAASNwoPdHJpZ2dlcl9yZW1vdmVkGEEgASgLMhwubm9yZC5SZWNlaXB0LlRyaWdnZXJSZW1vdmVkSAASTQoYcG9zaXRpb25fdGFrZW5fb3JfdHJhZGVkGEIgASgLMikubm9yZC5SZWNlaXB0LlBvc2l0aW9uVGFrZW5PclRyYWRlZFJlc3VsdEgAEiwKBmF0b21pYxhDIAEoCzIaLm5vcmQuUmVjZWlwdC5BdG9taWNSZXN1bHRIABJCChVtYXJrZXRfZnJlZXplX3VwZGF0ZWQYRCABKAsyIS5ub3JkLlJlY2VpcHQuTWFya2V0RnJlZXplVXBkYXRlZEgAEjQKDmZlZV90aWVyX2FkZGVkGEUgASgLMhoubm9yZC5SZWNlaXB0LkZlZVRpZXJBZGRlZEgAEjgKEGZlZV90aWVyX3VwZGF0ZWQYRiABKAsyHC5ub3JkLlJlY2VpcHQuRmVlVGllclVwZGF0ZWRIABJCChVhY2NvdW50c190aWVyX3VwZGF0ZWQYRyABKAsyIS5ub3JkLlJlY2VpcHQuQWNjb3VudHNUaWVyVXBkYXRlZEgAEi8KC2FjbF91cGRhdGVkGEggASgLMhgubm9yZC5SZWNlaXB0LkFjbFVwZGF0ZWRIABJCChVmZWVfdmF1bHRfdHJhbnNmZXJyZWQYSSABKAsyIS5ub3JkLlJlY2VpcHQuRmVlVmF1bHRUcmFuc2ZlcnJlZEgAGngKBlBvc3RlZBIYCgRzaWRlGAEgASgOMgoubm9yZC5TaWRlEhEKCW1hcmtldF9pZBgCIAEoDRINCgVwcmljZRgDIAEoBBIMCgRzaXplGAQgASgEEhAKCG9yZGVyX2lkGAUgASgEEhIKCmFjY291bnRfaWQYBiABKA0aSgoFVHJhZGUSEAoIb3JkZXJfaWQYAiABKAQSDQoFcHJpY2UYBCABKAQSDAoEc2l6ZRgFIAEoBBISCgphY2NvdW50X2lkGAYgASgNGikKE0NyZWF0ZVNlc3Npb25SZXN1bHQSEgoKc2Vzc2lvbl9pZBgBIAEoBBpDCglUcmlnZ2VyZWQSHwoEa2luZBgDIAEoDjIRLm5vcmQuVHJpZ2dlcktpbmQSFQoNdHJpZ2dlcl9wcmljZRgEIAEoBBqVAgoQUGxhY2VPcmRlclJlc3VsdBIpCgZwb3N0ZWQYASABKAsyFC5ub3JkLlJlY2VpcHQuUG9zdGVkSACIAQESIgoFZmlsbHMYAiADKAsyEy5ub3JkLlJlY2VpcHQuVHJhZGUSHAoPY2xpZW50X29yZGVyX2lkGAMgASgESAGIAQESHwoSc2VuZGVyX3RyYWNraW5nX2lkGAQgASgESAKIAQESLwoJdHJpZ2dlcmVkGAUgASgLMhcubm9yZC5SZWNlaXB0LlRyaWdnZXJlZEgDiAEBQgkKB19wb3N0ZWRCEgoQX2NsaWVudF9vcmRlcl9pZEIVChNfc2VuZGVyX3RyYWNraW5nX2lkQgwKCl90cmlnZ2VyZWQaQgoLVGFrZW5SZXN1bHQSCwoDcG5sGAEgASgDEgwKBHNpemUYAiABKAMSGAoQdGFrZXJfYWNjb3VudF9pZBgDIAEoDRqrAQobUG9zaXRpb25UYWtlbk9yVHJhZGVkUmVzdWx0EhEKCW1hcmtldF9pZBgBIAEoDRIqCgV0YWtlbhgCIAEoCzIZLm5vcmQuUmVjZWlwdC5UYWtlblJlc3VsdEgAEjAKBnRyYWRlZBgDIAEoCzIeLm5vcmQuUmVjZWlwdC5QbGFjZU9yZGVyUmVzdWx0SABCGwoZUG9zaXRpb25UYWtlbk9yVHJhZGVkS2luZBo5ChFDYW5jZWxPcmRlclJlc3VsdBIQCghvcmRlcl9pZBgBIAEoBBISCgphY2NvdW50X2lkGAIgASgNGnAKDURlcG9zaXRSZXN1bHQSEAoIdG9rZW5faWQYASABKA0SDgoGYW1vdW50GAIgASgEEhIKCmFjY291bnRfaWQYAyABKA0SFAoMdXNlcl9jcmVhdGVkGAQgASgIEhMKC3VzZXJfcHVia2V5GAUgASgMGkMKEUluc2VydFRva2VuUmVzdWx0EhIKCmNoYWluX2FkZHIYASABKAwSGgoFdG9rZW4YAiABKAsyCy5ub3JkLlRva2VuGjIKEkluc2VydE1hcmtldFJlc3VsdBIcCgZtYXJrZXQYASABKAsyDC5ub3JkLk1hcmtldBp5Cg5XaXRoZHJhd1Jlc3VsdBIQCgh0b2tlbl9pZBgBIAEoDRIOCgZhbW91bnQYAiABKAQSDwoHYmFsYW5jZRgDIAEoBBISCgphY2NvdW50X2lkGAQgASgNEgsKA2ZlZRgFIAEoBBITCgt1c2VyX3B1YmtleRgGIAEoDBpAChZPcmFjbGVTeW1ib2xGZWVkUmVzdWx0EhUKDW9yYWNsZV9zeW1ib2wYASABKAkSDwoHZmVlZF9pZBgCIAEoDBonChJPcmFjbGVVcGRhdGVSZXN1bHQSEQoJdGltZXN0YW1wGAEgASgDGkgKF1VwZGF0ZUd1YXJkaWFuU2V0UmVzdWx0EhoKEmd1YXJkaWFuX3NldF9pbmRleBgBIAEoDRIRCglhZGRyZXNzZXMYAiADKAwaQwoMUGVycFBvc2l0aW9uEhEKCW1hcmtldF9pZBgBIAEoDRIRCgliYXNlX3NpemUYAiABKAMSDQoFcHJpY2UYAyABKAQangEKEUFjY291bnRMaXF1aWRhdGVkEh0KFWxpcXVpZGF0b3JfYWNjb3VudF9pZBgBIAEoDRIdChVsaXF1aWRhdGVlX2FjY291bnRfaWQYAiABKA0SGAoQY2FuY2VsbGVkX29yZGVycxgDIAMoBBIxCg1yZW1vdmVkX3BlcnBzGAQgAygLMhoubm9yZC5SZWNlaXB0LlBlcnBQb3NpdGlvbhoQCg5TZXNzaW9uUmV2b2tlZBoICgZQYXVzZWQaCgoIVW5wYXVzZWQa4QEKC1RyYW5zZmVycmVkEhcKD2Zyb21fYWNjb3VudF9pZBgBIAEoDRIcCg90b191c2VyX2FjY291bnQYAiABKA1IAIgBARIQCgh0b2tlbl9pZBgDIAEoDRIOCgZhbW91bnQYBCABKAQSFwoPYWNjb3VudF9jcmVhdGVkGAUgASgIEjUKEnRvX3NwZWNpYWxfYWNjb3VudBgGIAEoDjIULm5vcmQuU3BlY2lhbEFjY291bnRIAYgBAUISChBfdG9fdXNlcl9hY2NvdW50QhUKE190b19zcGVjaWFsX2FjY291bnQaSgoTRmVlVmF1bHRUcmFuc2ZlcnJlZBIRCglyZWNpcGllbnQYASABKA0SEAoIdG9rZW5faWQYAiABKA0SDgoGYW1vdW50GAMgASgEGg4KDFRyaWdnZXJBZGRlZBoQCg5UcmlnZ2VyUmVtb3ZlZBo4ChNNYXJrZXRGcmVlemVVcGRhdGVkEhEKCW1hcmtldF9pZBgBIAEoDRIOCgZmcm96ZW4YAiABKAgaMwoMRmVlVGllckFkZGVkEiMKBmNvbmZpZxgBIAEoCzITLm5vcmQuRmVlVGllckNvbmZpZxpBCg5GZWVUaWVyVXBkYXRlZBIKCgJpZBgBIAEoDRIjCgZjb25maWcYAiABKAsyEy5ub3JkLkZlZVRpZXJDb25maWcaOAoTQWNjb3VudHNUaWVyVXBkYXRlZBIPCgd0aWVyX2lkGAEgASgNEhAKCGFjY291bnRzGAIgAygNGmAKCkFjbFVwZGF0ZWQSEgoKYWNsX3B1YmtleRgBIAEoDBISCgpyb2xlc19tYXNrGAIgASgEEhUKDXRhcmdldF9wdWJrZXkYAyABKAwSEwoLcm9sZXNfdmFsdWUYBCABKAQamwEKGUF0b21pY1N1YmFjdGlvblJlc3VsdEtpbmQSPAoScGxhY2Vfb3JkZXJfcmVzdWx0GAEgASgLMh4ubm9yZC5SZWNlaXB0LlBsYWNlT3JkZXJSZXN1bHRIABI3CgxjYW5jZWxfb3JkZXIYAiABKAsyHy5ub3JkLlJlY2VpcHQuQ2FuY2VsT3JkZXJSZXN1bHRIAEIHCgVpbm5lchpICgxBdG9taWNSZXN1bHQSOAoHcmVzdWx0cxgBIAMoCzInLm5vcmQuUmVjZWlwdC5BdG9taWNTdWJhY3Rpb25SZXN1bHRLaW5kQgYKBGtpbmQqGAoEU2lkZRIHCgNBU0sQABIHCgNCSUQQASotCgtUcmlnZ2VyS2luZBINCglTVE9QX0xPU1MQABIPCgtUQUtFX1BST0ZJVBABKk8KCEZpbGxNb2RlEgkKBUxJTUlUEAASDQoJUE9TVF9PTkxZEAESFwoTSU1NRURJQVRFX09SX0NBTkNFTBACEhAKDEZJTExfT1JfS0lMTBADKiYKCk1hcmtldFR5cGUSCAoEU1BPVBAAEg4KClBFUlBFVFVBTFMQASoeCg5TcGVjaWFsQWNjb3VudBIMCghGZWVWYXVsdBAAKsMbCgVFcnJvchINCglEVVBMSUNBVEUQABISCg5ERUNPREVfRkFJTFVSRRACEhUKEUlOVkFMSURfU0lHTkFUVVJFEAMSFAoQTUFSS0VUX05PVF9GT1VORBAEEhMKD1RPS0VOX05PVF9GT1VORBAFEhIKDlVTRVJfTk9UX0ZPVU5EEAYSFQoRU0VTU0lPTl9OT1RfRk9VTkQQBxITCg9PUkRFUl9OT1RfRk9VTkQQCBITCg9PUkRFUl9TSVpFX1pFUk8QCRIOCgpBUklUSE1FVElDEAsSFwoTQVJJVEhNRVRJQ19PVkVSRkxPVxAMEhgKFEFSSVRITUVUSUNfVU5ERVJGTE9XEA0SHwobQVJJVEhNRVRJQ19ESVZJU0lPTl9CWV9aRVJPEA4SGgoWS0VZX0FMUkVBRFlfUkVHSVNURVJFRBAPEhwKGFVQREFURV9USU1FU1RBTVBfSU5fUEFTVBAREhgKFFRPT19NQU5ZX09QRU5fT1JERVJTEBISHQoZV0lUSERSQVdfQU1PVU5UX1RPT19TTUFMTBAVEhcKE0lOVkFMSURfT1JERVJfT1dORVIQFhIgChxERUNPREVfRkFJTFVSRV9MRU5HVEhfUFJFRklYECESFgoSREVDT0RFX0ZBSUxVUkVfUkFXECISGQoVREVDT0RFX0ZBSUxVUkVfRE9NQUlOECMSHwobVVBEQVRFX1BVQkxJU0hfVElNRV9JTl9QQVNUECQSFwoTUFlUSF9GRUVEX05PVF9BRERFRBBdEhUKEVBZVEhfRkVFRF9NSVNTSU5HEF4SGwoXUFlUSF9GRUVEX0FMUkVBRFlfQURERUQQXxIjCh9QWVRIX0dVQVJESUFOX1NFVF9VTklOSVRJQUxJWkVEEGASHQoZUFlUSF9HVUFSRElBTl9TRVRfSU5WQUxJRBBhEiMKH1BZVEhfRkVFRF9ERUNJTUFMU19PVVRfT0ZfUkFOR0UQYhIgChxQWVRIX0ZFRURfUFJJQ0VfT1VUX09GX1JBTkdFEGMSIwofUFlUSF9GRUVEX1ZBUklBTkNFX09VVF9PRl9SQU5HRRBkEjUKMVBZVEhfR1VBUkRJQU5fU0VUX0FORF9QWVRIX1NJR05BVFVSRV9ET19OT1RfTUFUQ0gQZRIcChhJTlZBTElEX1RPS0VOX1BBUkFNRVRFUlMQZhIcChhJTkRFWF9QUklDRV9PVVRfT0ZfUkFOR0UQZxIfChtJTkRFWF9ERUNJTUFMU19PVVRfT0ZfUkFOR0UQaBIZChVJTlZBTElEX1NUQVRFX1ZFUlNJT04QaRIZChVUSUVSX0ZFRV9PVVRfT0ZfUkFOR0UQahIYChRUSUVSX0lEX09VVF9PRl9SQU5HRRBrEhMKD0lOVkFMSURfTUFSR0lOUxBsEiEKHU1BUktFVF9ERUNJTUFMU19FWENFRURfTElNSVRTEG0SEwoPVE9PX01BTllfVE9LRU5TEG4SFAoQRlVORElOR19PVkVSRkxPVxB7EjcKM0NBTl9SRURVQ0VfUE9TSVRJT05fT05MWV9JRl9BTExfT1JERVJTX0FSRV9DQU5DRUxFRBB8EhcKE1VORVhQRUNURURfVE9LRU5fSUQQfxIWChFSRVBFQVRFRF9PUkRFUl9JRBCAARIUCg9UT0tFTl9OT1RfUkVBRFkQggESHAoYVE9LRU5fQUxSRUFEWV9SRUdJU1RFUkVEEHASIQocSU1NRURJQVRFX09SREVSX0dPVF9OT19GSUxMUxCFARIZChRGQUlMRURfVE9fRklMTF9MSU1JVBCGARIwCitQT1NUX09OTFlfTVVTVF9OT1RfRklMTF9BTllfT1BQT1NJVEVfT1JERVJTEIcBEgwKB0lOVkFMSUQQiAESEAoLTUFJTlRFTkFOQ0UQiQESGgoVTUlOSU1VTV9TSVpFX0RFQ0lNQUxTEIoBEjIKLVBBUkFNRVRFUlNfV0lMTF9DUkVBVEVfTk9OX09QRVJBVElPTkFMX01BUktFVBCLARIiCh1PTkxZX0lNTUVESUFURV9PUkRFUlNfQUxMT1dFRBCMARIbChZUT09fTUFOWV9VU0VSX0FDQ09VTlRTEI0BEhYKEUFDQ09VTlRfTk9UX0ZPVU5EEI4BEhoKFUFDQ09VTlRfSU5WQUxJRF9PV05FUhCPARIRCgxEVVNUX0FDQ09VTlQQkQESDAoHQkFMQU5DRRCgARIdChhCQUxBTkNFX0RFUE9TSVRfT1ZFUkZMT1cQoQESHAoXQkFMQU5DRV9DSEFOR0VfT1ZFUkZMT1cQogESIgodQkFMQU5DRV9DSEFOR0VfTElNSVRfRVhDRUVERUQQowESGQoUQkFMQU5DRV9JTlNVRkZJQ0lFTlQQpAESHgoZVU5BVVRIRU5USUNBVEVEX0wxX0FDVElPThClARIdChhFTkNPREVEX0FDVElPTl9UT09fTEFSR0UQpgESDAoHVFJJR0dFUhCoARIaChVUUklHR0VSX0lOVkFMSURfUFJJQ0UQqQESFgoRVFJJR0dFUl9OT1RfRk9VTkQQqgESDgoJVElNRVNUQU1QELABEh8KGlRJTUVTVEFNUF9PVVRfT0ZfVEhSRVNIT0xEELEBEhQKD1RJTUVTVEFNUF9TVEFMRRCyARIcChhFWFBJUllfVElNRVNUQU1QX0lOX1BBU1QQEBIlCiBCQU5LUlVQVENZX0lOU1VGRklDSUVOVF9DT1ZFUkFHRRC5ARIZChRCQU5LUlVQVENZX05PVF9GT1VORBC6ARIbChZCQU5LUlVQVENZX05PVF9BTExPV0VEELsBEhUKEE1BUktFVF9OT1RfUkVBRFkQwAESEgoNTUFSS0VUX0ZST1pFThDBARIRCgxNQVJLRVRfRU1QVFkQwgESDQoIUE9TSVRJT04QyAESFwoSUE9TSVRJT05fTk9UX0ZPVU5EEMkBEhkKFFBPU0lUSU9OX1NUQVRFX09SREVSEMoBEh8KGlBPU0lUSU9OX1NUQVRFX09SREVSX1BSSUNFEMsBEh4KGVBPU0lUSU9OX1NUQVRFX09SREVSX1NJWkUQzAESHgoZUE9TSVRJT05fU1RBVEVfT1JERVJfU0lERRDNARIYChNQT1NJVElPTl9TSVpFX0xJTUlUEM4BEhgKE1BPU0lUSU9OX1NUQVRFX1BFUlAQzwESJAofUE9TSVRJT05fU1RBVEVfT1JERVJfREVMRUdBVElPThDQARIKCgVQUklDRRDRARIbChZTSUdOQVRVUkVfVkVSSUZJQ0FUSU9OENkBEjAKK1NJR05BVFVSRV9WRVJJRklDQVRJT05fTUFMRk9STUVEX1BVQkxJQ19LRVkQ2gESKgolU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9JTlZBTElEX0xFTkdUSBDbARIJCgRSSVNLEOABEjQKL1JJU0tfREVMRUdBVElPTl9NRl9UT19CRV9MRVNTX1RIQU5fT1JfRVFVQUxfTU1GEOEBEiQKH1JJU0tfT01GX0xFU1NfVEhBTl9PUl9FUVVBTF9JTUYQ4gESJAofUklTS19PTUZfTEVTU19USEFOX09SX0VRVUFMX0NNRhDjARIqCiVSSVNLX1RSQURFX09NRl9MRVNTX1RIQU5fT1JfRVFVQUxfQ01GEOUBEjUKMFJJU0tfVU5IRUFMVEhZX01GX0FORF9QT05fQUZURVJfQkVUVEVSX09GX0JFRk9SRRDkARIUCg9PUkRFUl9FWEVDVVRJT04Q8AESGgoVT1JERVJfRVhFQ1VUSU9OX0VNUFRZEPEBEiEKHE9SREVSX0VYRUNVVElPTl9GSUxMX09SX0tJTEwQ8gESIwoeT1JERVJfRVhFQ1VUSU9OX01JU1NJTkdfTElNSVRTEPMBEiIKHU9SREVSX0VYRUNVVElPTl9NSVNTSU5HX1BSSUNFEPQBEh8KGk9SREVSX0VYRUNVVElPTl9TSVpFX0xJTUlUEPUBEiAKG09SREVSX0VYRUNVVElPTl9MSU1JVF9QUklDRRD2ARIeChlPUkRFUl9SRURVQ0VfSVNfUE9TVF9PTkxZEPcBEh8KGk9SREVSX0VYRUNVVElPTl9TRUxMX1BSSUNFEPgBEiUKIE9SREVSX1NJWkVfRVhDRUVEU19QT1NJVElPTl9TSVpFEPkBEigKI0FUT01JQ1NfVFJBREVTX0NBTk5PVF9GT0xMT1dfUExBQ0VTEIACEjAKK0FUT01JQ1NfQ0FOQ0VMU19DQU5OT1RfRk9MTE9XX1RSQURFU19QTEFDRVMQgQISJgohQUNUSU9OX1BPU0lUSU9OX1NIT1VMRF9CRV9DT1ZFUkVEEJECEhkKFEFDVElPTl9JTlZBTElEX05PTkNFEJICEikKJEFDVElPTl9QUk9QT1NFRF9QUklDRV9NVVNUX0JFX0hJR0hFUhCTAhIcChdBRE1JTl9ST0xFX0lOU1VGRklDSUVOVBCUAhIUCg9BRE1JTl9OT1RfRk9VTkQQlQISKQokVU5JUVVFX1NVUEVSX0FETUlOX0NBTk5PVF9CRV9SRU1PVkVEEJYCEh8KGlNVUEVSX0FETUlOX0FMUkVBRFlfRVhJU1RTEJcCEhQKD05PVF9JTVBMRU1FTlRFRBD0AxIXChJBQ1RJT05fTk9UX0FMTE9XRUQQ9QMSDAoHRHJvcHBlZBDnB2IGcHJvdG8z");
var FeeTierConfigSchema = /* @__PURE__ */ messageDesc(file_nord, 0);
var MarketSchema = /* @__PURE__ */ messageDesc(file_nord, 1);
var TokenSchema = /* @__PURE__ */ messageDesc(file_nord, 2);
var QuoteSizeSchema = /* @__PURE__ */ messageDesc(file_nord, 3);
var OrderLimitSchema = /* @__PURE__ */ messageDesc(file_nord, 4);
var OrderTypeSchema = /* @__PURE__ */ messageDesc(file_nord, 5);
var TradeOrPlaceSchema = /* @__PURE__ */ messageDesc(file_nord, 6);
var CancelOrderSchema = /* @__PURE__ */ messageDesc(file_nord, 7);
var TriggerKeySchema = /* @__PURE__ */ messageDesc(file_nord, 8);
var AtomicSubactionKindSchema = /* @__PURE__ */ messageDesc(file_nord, 9);
var AtomicSchema = /* @__PURE__ */ messageDesc(file_nord, 10);
var ActionSchema = /* @__PURE__ */ messageDesc(file_nord, 11);
var Action_CreateSessionSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 0);
var Action_CreateTokenSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 1);
var Action_CreateMarketSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 2);
var Action_PlaceOrderSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 3);
var Action_CancelOrderByIdSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 4);
var Action_CancelOrderByClientIdSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 5);
var Action_DepositSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 6);
var Action_WithdrawSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 7);
var Action_PythSetWormholeGuardiansSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 8);
var Action_PythSetSymbolFeedSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 9);
var Action_PythPriceFeedUpdateSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 10);
var Action_LiquidateSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 11);
var Action_RevokeSessionSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 12);
var Action_PauseSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 13);
var Action_UnpauseSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 14);
var Action_TransferSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 15);
var Action_FeeVaultTransferSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 16);
var Action_TriggerPricesSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 17);
var Action_AddTriggerSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 18);
var Action_RemoveTriggerSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 19);
var Action_AddFeeTierSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 20);
var Action_UpdateFeeTierSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 21);
var Action_UpdateAccountsTierSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 22);
var Action_UpdateAclSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 23);
var Action_FreezeMarketSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 24);
var Action_UnfreezeMarketSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 25);
var Action_TakePositionSchema = /* @__PURE__ */ messageDesc(file_nord, 11, 26);
var Action_UserSignatureFraming;
((Action_UserSignatureFraming2) => {
  Action_UserSignatureFraming2[Action_UserSignatureFraming2["HEX"] = 0] = "HEX";
  Action_UserSignatureFraming2[Action_UserSignatureFraming2["SOLANA_TRANSACTION"] = 1] = "SOLANA_TRANSACTION";
})(Action_UserSignatureFraming ||= {});
var Action_UserSignatureFramingSchema = /* @__PURE__ */ enumDesc(file_nord, 11, 0);
var ReceiptSchema = /* @__PURE__ */ messageDesc(file_nord, 12);
var Receipt_PostedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 0);
var Receipt_TradeSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 1);
var Receipt_CreateSessionResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 2);
var Receipt_TriggeredSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 3);
var Receipt_PlaceOrderResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 4);
var Receipt_TakenResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 5);
var Receipt_PositionTakenOrTradedResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 6);
var Receipt_CancelOrderResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 7);
var Receipt_DepositResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 8);
var Receipt_InsertTokenResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 9);
var Receipt_InsertMarketResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 10);
var Receipt_WithdrawResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 11);
var Receipt_OracleSymbolFeedResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 12);
var Receipt_OracleUpdateResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 13);
var Receipt_UpdateGuardianSetResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 14);
var Receipt_PerpPositionSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 15);
var Receipt_AccountLiquidatedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 16);
var Receipt_SessionRevokedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 17);
var Receipt_PausedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 18);
var Receipt_UnpausedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 19);
var Receipt_TransferredSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 20);
var Receipt_FeeVaultTransferredSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 21);
var Receipt_TriggerAddedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 22);
var Receipt_TriggerRemovedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 23);
var Receipt_MarketFreezeUpdatedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 24);
var Receipt_FeeTierAddedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 25);
var Receipt_FeeTierUpdatedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 26);
var Receipt_AccountsTierUpdatedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 27);
var Receipt_AclUpdatedSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 28);
var Receipt_AtomicSubactionResultKindSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 29);
var Receipt_AtomicResultSchema = /* @__PURE__ */ messageDesc(file_nord, 12, 30);
var Side;
((Side2) => {
  Side2[Side2["ASK"] = 0] = "ASK";
  Side2[Side2["BID"] = 1] = "BID";
})(Side ||= {});
var SideSchema = /* @__PURE__ */ enumDesc(file_nord, 0);
var TriggerKind;
((TriggerKind2) => {
  TriggerKind2[TriggerKind2["STOP_LOSS"] = 0] = "STOP_LOSS";
  TriggerKind2[TriggerKind2["TAKE_PROFIT"] = 1] = "TAKE_PROFIT";
})(TriggerKind ||= {});
var TriggerKindSchema = /* @__PURE__ */ enumDesc(file_nord, 1);
var FillMode;
((FillMode2) => {
  FillMode2[FillMode2["LIMIT"] = 0] = "LIMIT";
  FillMode2[FillMode2["POST_ONLY"] = 1] = "POST_ONLY";
  FillMode2[FillMode2["IMMEDIATE_OR_CANCEL"] = 2] = "IMMEDIATE_OR_CANCEL";
  FillMode2[FillMode2["FILL_OR_KILL"] = 3] = "FILL_OR_KILL";
})(FillMode ||= {});
var FillModeSchema = /* @__PURE__ */ enumDesc(file_nord, 2);
var MarketType;
((MarketType2) => {
  MarketType2[MarketType2["SPOT"] = 0] = "SPOT";
  MarketType2[MarketType2["PERPETUALS"] = 1] = "PERPETUALS";
})(MarketType ||= {});
var MarketTypeSchema = /* @__PURE__ */ enumDesc(file_nord, 3);
var SpecialAccount;
((SpecialAccount2) => {
  SpecialAccount2[SpecialAccount2["FeeVault"] = 0] = "FeeVault";
})(SpecialAccount ||= {});
var SpecialAccountSchema = /* @__PURE__ */ enumDesc(file_nord, 4);
var Error2;
((Error3) => {
  Error3[Error3["DUPLICATE"] = 0] = "DUPLICATE";
  Error3[Error3["DECODE_FAILURE"] = 2] = "DECODE_FAILURE";
  Error3[Error3["INVALID_SIGNATURE"] = 3] = "INVALID_SIGNATURE";
  Error3[Error3["MARKET_NOT_FOUND"] = 4] = "MARKET_NOT_FOUND";
  Error3[Error3["TOKEN_NOT_FOUND"] = 5] = "TOKEN_NOT_FOUND";
  Error3[Error3["USER_NOT_FOUND"] = 6] = "USER_NOT_FOUND";
  Error3[Error3["SESSION_NOT_FOUND"] = 7] = "SESSION_NOT_FOUND";
  Error3[Error3["ORDER_NOT_FOUND"] = 8] = "ORDER_NOT_FOUND";
  Error3[Error3["ORDER_SIZE_ZERO"] = 9] = "ORDER_SIZE_ZERO";
  Error3[Error3["ARITHMETIC"] = 11] = "ARITHMETIC";
  Error3[Error3["ARITHMETIC_OVERFLOW"] = 12] = "ARITHMETIC_OVERFLOW";
  Error3[Error3["ARITHMETIC_UNDERFLOW"] = 13] = "ARITHMETIC_UNDERFLOW";
  Error3[Error3["ARITHMETIC_DIVISION_BY_ZERO"] = 14] = "ARITHMETIC_DIVISION_BY_ZERO";
  Error3[Error3["KEY_ALREADY_REGISTERED"] = 15] = "KEY_ALREADY_REGISTERED";
  Error3[Error3["UPDATE_TIMESTAMP_IN_PAST"] = 17] = "UPDATE_TIMESTAMP_IN_PAST";
  Error3[Error3["TOO_MANY_OPEN_ORDERS"] = 18] = "TOO_MANY_OPEN_ORDERS";
  Error3[Error3["WITHDRAW_AMOUNT_TOO_SMALL"] = 21] = "WITHDRAW_AMOUNT_TOO_SMALL";
  Error3[Error3["INVALID_ORDER_OWNER"] = 22] = "INVALID_ORDER_OWNER";
  Error3[Error3["DECODE_FAILURE_LENGTH_PREFIX"] = 33] = "DECODE_FAILURE_LENGTH_PREFIX";
  Error3[Error3["DECODE_FAILURE_RAW"] = 34] = "DECODE_FAILURE_RAW";
  Error3[Error3["DECODE_FAILURE_DOMAIN"] = 35] = "DECODE_FAILURE_DOMAIN";
  Error3[Error3["UPDATE_PUBLISH_TIME_IN_PAST"] = 36] = "UPDATE_PUBLISH_TIME_IN_PAST";
  Error3[Error3["PYTH_FEED_NOT_ADDED"] = 93] = "PYTH_FEED_NOT_ADDED";
  Error3[Error3["PYTH_FEED_MISSING"] = 94] = "PYTH_FEED_MISSING";
  Error3[Error3["PYTH_FEED_ALREADY_ADDED"] = 95] = "PYTH_FEED_ALREADY_ADDED";
  Error3[Error3["PYTH_GUARDIAN_SET_UNINITIALIZED"] = 96] = "PYTH_GUARDIAN_SET_UNINITIALIZED";
  Error3[Error3["PYTH_GUARDIAN_SET_INVALID"] = 97] = "PYTH_GUARDIAN_SET_INVALID";
  Error3[Error3["PYTH_FEED_DECIMALS_OUT_OF_RANGE"] = 98] = "PYTH_FEED_DECIMALS_OUT_OF_RANGE";
  Error3[Error3["PYTH_FEED_PRICE_OUT_OF_RANGE"] = 99] = "PYTH_FEED_PRICE_OUT_OF_RANGE";
  Error3[Error3["PYTH_FEED_VARIANCE_OUT_OF_RANGE"] = 100] = "PYTH_FEED_VARIANCE_OUT_OF_RANGE";
  Error3[Error3["PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH"] = 101] = "PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH";
  Error3[Error3["INVALID_TOKEN_PARAMETERS"] = 102] = "INVALID_TOKEN_PARAMETERS";
  Error3[Error3["INDEX_PRICE_OUT_OF_RANGE"] = 103] = "INDEX_PRICE_OUT_OF_RANGE";
  Error3[Error3["INDEX_DECIMALS_OUT_OF_RANGE"] = 104] = "INDEX_DECIMALS_OUT_OF_RANGE";
  Error3[Error3["INVALID_STATE_VERSION"] = 105] = "INVALID_STATE_VERSION";
  Error3[Error3["TIER_FEE_OUT_OF_RANGE"] = 106] = "TIER_FEE_OUT_OF_RANGE";
  Error3[Error3["TIER_ID_OUT_OF_RANGE"] = 107] = "TIER_ID_OUT_OF_RANGE";
  Error3[Error3["INVALID_MARGINS"] = 108] = "INVALID_MARGINS";
  Error3[Error3["MARKET_DECIMALS_EXCEED_LIMITS"] = 109] = "MARKET_DECIMALS_EXCEED_LIMITS";
  Error3[Error3["TOO_MANY_TOKENS"] = 110] = "TOO_MANY_TOKENS";
  Error3[Error3["FUNDING_OVERFLOW"] = 123] = "FUNDING_OVERFLOW";
  Error3[Error3["CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED"] = 124] = "CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED";
  Error3[Error3["UNEXPECTED_TOKEN_ID"] = 127] = "UNEXPECTED_TOKEN_ID";
  Error3[Error3["REPEATED_ORDER_ID"] = 128] = "REPEATED_ORDER_ID";
  Error3[Error3["TOKEN_NOT_READY"] = 130] = "TOKEN_NOT_READY";
  Error3[Error3["TOKEN_ALREADY_REGISTERED"] = 112] = "TOKEN_ALREADY_REGISTERED";
  Error3[Error3["IMMEDIATE_ORDER_GOT_NO_FILLS"] = 133] = "IMMEDIATE_ORDER_GOT_NO_FILLS";
  Error3[Error3["FAILED_TO_FILL_LIMIT"] = 134] = "FAILED_TO_FILL_LIMIT";
  Error3[Error3["POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS"] = 135] = "POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS";
  Error3[Error3["INVALID"] = 136] = "INVALID";
  Error3[Error3["MAINTENANCE"] = 137] = "MAINTENANCE";
  Error3[Error3["MINIMUM_SIZE_DECIMALS"] = 138] = "MINIMUM_SIZE_DECIMALS";
  Error3[Error3["PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET"] = 139] = "PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET";
  Error3[Error3["ONLY_IMMEDIATE_ORDERS_ALLOWED"] = 140] = "ONLY_IMMEDIATE_ORDERS_ALLOWED";
  Error3[Error3["TOO_MANY_USER_ACCOUNTS"] = 141] = "TOO_MANY_USER_ACCOUNTS";
  Error3[Error3["ACCOUNT_NOT_FOUND"] = 142] = "ACCOUNT_NOT_FOUND";
  Error3[Error3["ACCOUNT_INVALID_OWNER"] = 143] = "ACCOUNT_INVALID_OWNER";
  Error3[Error3["DUST_ACCOUNT"] = 145] = "DUST_ACCOUNT";
  Error3[Error3["BALANCE"] = 160] = "BALANCE";
  Error3[Error3["BALANCE_DEPOSIT_OVERFLOW"] = 161] = "BALANCE_DEPOSIT_OVERFLOW";
  Error3[Error3["BALANCE_CHANGE_OVERFLOW"] = 162] = "BALANCE_CHANGE_OVERFLOW";
  Error3[Error3["BALANCE_CHANGE_LIMIT_EXCEEDED"] = 163] = "BALANCE_CHANGE_LIMIT_EXCEEDED";
  Error3[Error3["BALANCE_INSUFFICIENT"] = 164] = "BALANCE_INSUFFICIENT";
  Error3[Error3["UNAUTHENTICATED_L1_ACTION"] = 165] = "UNAUTHENTICATED_L1_ACTION";
  Error3[Error3["ENCODED_ACTION_TOO_LARGE"] = 166] = "ENCODED_ACTION_TOO_LARGE";
  Error3[Error3["TRIGGER"] = 168] = "TRIGGER";
  Error3[Error3["TRIGGER_INVALID_PRICE"] = 169] = "TRIGGER_INVALID_PRICE";
  Error3[Error3["TRIGGER_NOT_FOUND"] = 170] = "TRIGGER_NOT_FOUND";
  Error3[Error3["TIMESTAMP"] = 176] = "TIMESTAMP";
  Error3[Error3["TIMESTAMP_OUT_OF_THRESHOLD"] = 177] = "TIMESTAMP_OUT_OF_THRESHOLD";
  Error3[Error3["TIMESTAMP_STALE"] = 178] = "TIMESTAMP_STALE";
  Error3[Error3["EXPIRY_TIMESTAMP_IN_PAST"] = 16] = "EXPIRY_TIMESTAMP_IN_PAST";
  Error3[Error3["BANKRUPTCY_INSUFFICIENT_COVERAGE"] = 185] = "BANKRUPTCY_INSUFFICIENT_COVERAGE";
  Error3[Error3["BANKRUPTCY_NOT_FOUND"] = 186] = "BANKRUPTCY_NOT_FOUND";
  Error3[Error3["BANKRUPTCY_NOT_ALLOWED"] = 187] = "BANKRUPTCY_NOT_ALLOWED";
  Error3[Error3["MARKET_NOT_READY"] = 192] = "MARKET_NOT_READY";
  Error3[Error3["MARKET_FROZEN"] = 193] = "MARKET_FROZEN";
  Error3[Error3["MARKET_EMPTY"] = 194] = "MARKET_EMPTY";
  Error3[Error3["POSITION"] = 200] = "POSITION";
  Error3[Error3["POSITION_NOT_FOUND"] = 201] = "POSITION_NOT_FOUND";
  Error3[Error3["POSITION_STATE_ORDER"] = 202] = "POSITION_STATE_ORDER";
  Error3[Error3["POSITION_STATE_ORDER_PRICE"] = 203] = "POSITION_STATE_ORDER_PRICE";
  Error3[Error3["POSITION_STATE_ORDER_SIZE"] = 204] = "POSITION_STATE_ORDER_SIZE";
  Error3[Error3["POSITION_STATE_ORDER_SIDE"] = 205] = "POSITION_STATE_ORDER_SIDE";
  Error3[Error3["POSITION_SIZE_LIMIT"] = 206] = "POSITION_SIZE_LIMIT";
  Error3[Error3["POSITION_STATE_PERP"] = 207] = "POSITION_STATE_PERP";
  Error3[Error3["POSITION_STATE_ORDER_DELEGATION"] = 208] = "POSITION_STATE_ORDER_DELEGATION";
  Error3[Error3["PRICE"] = 209] = "PRICE";
  Error3[Error3["SIGNATURE_VERIFICATION"] = 217] = "SIGNATURE_VERIFICATION";
  Error3[Error3["SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY"] = 218] = "SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY";
  Error3[Error3["SIGNATURE_VERIFICATION_INVALID_LENGTH"] = 219] = "SIGNATURE_VERIFICATION_INVALID_LENGTH";
  Error3[Error3["RISK"] = 224] = "RISK";
  Error3[Error3["RISK_DELEGATION_MF_TO_BE_LESS_THAN_OR_EQUAL_MMF"] = 225] = "RISK_DELEGATION_MF_TO_BE_LESS_THAN_OR_EQUAL_MMF";
  Error3[Error3["RISK_OMF_LESS_THAN_OR_EQUAL_IMF"] = 226] = "RISK_OMF_LESS_THAN_OR_EQUAL_IMF";
  Error3[Error3["RISK_OMF_LESS_THAN_OR_EQUAL_CMF"] = 227] = "RISK_OMF_LESS_THAN_OR_EQUAL_CMF";
  Error3[Error3["RISK_TRADE_OMF_LESS_THAN_OR_EQUAL_CMF"] = 229] = "RISK_TRADE_OMF_LESS_THAN_OR_EQUAL_CMF";
  Error3[Error3["RISK_UNHEALTHY_MF_AND_PON_AFTER_BETTER_OF_BEFORE"] = 228] = "RISK_UNHEALTHY_MF_AND_PON_AFTER_BETTER_OF_BEFORE";
  Error3[Error3["ORDER_EXECUTION"] = 240] = "ORDER_EXECUTION";
  Error3[Error3["ORDER_EXECUTION_EMPTY"] = 241] = "ORDER_EXECUTION_EMPTY";
  Error3[Error3["ORDER_EXECUTION_FILL_OR_KILL"] = 242] = "ORDER_EXECUTION_FILL_OR_KILL";
  Error3[Error3["ORDER_EXECUTION_MISSING_LIMITS"] = 243] = "ORDER_EXECUTION_MISSING_LIMITS";
  Error3[Error3["ORDER_EXECUTION_MISSING_PRICE"] = 244] = "ORDER_EXECUTION_MISSING_PRICE";
  Error3[Error3["ORDER_EXECUTION_SIZE_LIMIT"] = 245] = "ORDER_EXECUTION_SIZE_LIMIT";
  Error3[Error3["ORDER_EXECUTION_LIMIT_PRICE"] = 246] = "ORDER_EXECUTION_LIMIT_PRICE";
  Error3[Error3["ORDER_REDUCE_IS_POST_ONLY"] = 247] = "ORDER_REDUCE_IS_POST_ONLY";
  Error3[Error3["ORDER_EXECUTION_SELL_PRICE"] = 248] = "ORDER_EXECUTION_SELL_PRICE";
  Error3[Error3["ORDER_SIZE_EXCEEDS_POSITION_SIZE"] = 249] = "ORDER_SIZE_EXCEEDS_POSITION_SIZE";
  Error3[Error3["ATOMICS_TRADES_CANNOT_FOLLOW_PLACES"] = 256] = "ATOMICS_TRADES_CANNOT_FOLLOW_PLACES";
  Error3[Error3["ATOMICS_CANCELS_CANNOT_FOLLOW_TRADES_PLACES"] = 257] = "ATOMICS_CANCELS_CANNOT_FOLLOW_TRADES_PLACES";
  Error3[Error3["ACTION_POSITION_SHOULD_BE_COVERED"] = 273] = "ACTION_POSITION_SHOULD_BE_COVERED";
  Error3[Error3["ACTION_INVALID_NONCE"] = 274] = "ACTION_INVALID_NONCE";
  Error3[Error3["ACTION_PROPOSED_PRICE_MUST_BE_HIGHER"] = 275] = "ACTION_PROPOSED_PRICE_MUST_BE_HIGHER";
  Error3[Error3["ADMIN_ROLE_INSUFFICIENT"] = 276] = "ADMIN_ROLE_INSUFFICIENT";
  Error3[Error3["ADMIN_NOT_FOUND"] = 277] = "ADMIN_NOT_FOUND";
  Error3[Error3["UNIQUE_SUPER_ADMIN_CANNOT_BE_REMOVED"] = 278] = "UNIQUE_SUPER_ADMIN_CANNOT_BE_REMOVED";
  Error3[Error3["SUPER_ADMIN_ALREADY_EXISTS"] = 279] = "SUPER_ADMIN_ALREADY_EXISTS";
  Error3[Error3["NOT_IMPLEMENTED"] = 500] = "NOT_IMPLEMENTED";
  Error3[Error3["ACTION_NOT_ALLOWED"] = 501] = "ACTION_NOT_ALLOWED";
  Error3[Error3["Dropped"] = 999] = "Dropped";
})(Error2 ||= {});
var ErrorSchema = /* @__PURE__ */ enumDesc(file_nord, 5);

// node_modules/decimal.js/decimal.mjs
/*!
 *  decimal.js v10.6.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9000000000000000;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min, max) {
  var k, x = this, Ctor = x.constructor;
  min = new Ctor(min);
  max = new Ctor(max);
  if (!min.s || !max.s)
    return new Ctor(NaN);
  if (min.gt(max))
    throw Error(invalidArgument + max);
  k = x.cmp(min);
  return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL;i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (;; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (;w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (;i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (;k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k;i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (;i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== undefined)
      for (i = j;r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0];k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 100000000000000) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k;i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0;i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len;i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length;i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i;j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (;xd[--len] === 0; )
    xd.pop();
  for (;xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (;i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0;i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length;xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== undefined && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (;; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL;i--; )
    r.push(0);
  for (i = ydL;--i >= 0; ) {
    carry = 0;
    for (k = xdL + i;k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (;!r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === undefined)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === undefined)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === undefined) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === undefined) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (;; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === undefined) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 100000000000000) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === undefined) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === undefined) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1;i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (;w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0];k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1000 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (;i < strL; ) {
    for (arrL = arr.length;arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0;j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === undefined)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k;i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice();i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0;i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (;aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (;!a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign);
    qd = q.d = [];
    for (i = 0;yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (;(i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (;remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== undefined) && sd--);
        more = rem[0] !== undefined;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0];k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits = 1, k = xd[0];k >= 10; k /= 10)
        digits++;
      i = sd - digits;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (;k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits = 1;k >= 10; k /= 10)
            digits++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits;
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== undefined || (j < 0 ? w : w % mathpow(10, digits - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (;; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0];j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1;j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length;xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE;w >= 10; w /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE + 1;
  w = digits[w];
  if (w) {
    for (;w % 10 == 0; w /= 10)
      len--;
    for (w = digits[0];w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (;k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (;; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, n) {
  var k, y, x = new Ctor(args[0]), i = 0;
  for (;++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    }
    k = x.cmp(y);
    if (k === n || k === 0 && x.s === n) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(1);
  Ctor.precision = wpr;
  for (;; ) {
    pow = finalise(pow.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum = finalise(sum.times(sum), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }
    sum = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 1500000000000000) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (;; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e !== 0)
        sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum = divide(sum, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }
    sum = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0;str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length;str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE;i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (;i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe;xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (;k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (;; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== undefined) {
      for (j = k;t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== undefined;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === undefined)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (;xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== undefined;
      roundUp = rm < 4 ? (i !== undefined || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (;++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length;!xd[len - 1]; --len)
        ;
      for (i = 0, str = "";i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len;len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length;!xd[len - 1]; --len)
              ;
            for (i = 1, str = "1.";i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (;++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len;e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min, max) {
  return new this(x).clamp(min, max);
}
function config(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0;i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== undefined) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== undefined) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh(x) {
  return new this(x).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal))
      return new Decimal(v);
    x.constructor = Decimal;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v;i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      }
      if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    }
    if (t === "string") {
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43)
          v = v.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    if (t === "bigint") {
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      return parseDecimal(x, v.toString());
    }
    throw Error(invalidArgument + v);
  }
  Decimal.prototype = P;
  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;
  Decimal.EUCLID = 9;
  Decimal.config = Decimal.set = config;
  Decimal.clone = clone;
  Decimal.isDecimal = isDecimalInstance;
  Decimal.abs = abs;
  Decimal.acos = acos;
  Decimal.acosh = acosh;
  Decimal.add = add;
  Decimal.asin = asin;
  Decimal.asinh = asinh;
  Decimal.atan = atan;
  Decimal.atanh = atanh;
  Decimal.atan2 = atan2;
  Decimal.cbrt = cbrt;
  Decimal.ceil = ceil;
  Decimal.clamp = clamp;
  Decimal.cos = cos;
  Decimal.cosh = cosh;
  Decimal.div = div;
  Decimal.exp = exp;
  Decimal.floor = floor;
  Decimal.hypot = hypot;
  Decimal.ln = ln;
  Decimal.log = log;
  Decimal.log10 = log10;
  Decimal.log2 = log2;
  Decimal.max = max;
  Decimal.min = min;
  Decimal.mod = mod;
  Decimal.mul = mul;
  Decimal.pow = pow;
  Decimal.random = random;
  Decimal.round = round;
  Decimal.sign = sign;
  Decimal.sin = sin;
  Decimal.sinh = sinh;
  Decimal.sqrt = sqrt;
  Decimal.sub = sub;
  Decimal.sum = sum;
  Decimal.tan = tan;
  Decimal.tanh = tanh;
  Decimal.trunc = trunc;
  if (obj === undefined)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0;i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal.config(obj);
  return Decimal;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0;i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, -1);
}
function min() {
  return maxOrMin(this, arguments, 1);
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === undefined)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (;i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (;i < k; ) {
      n = d[i];
      if (n >= 4290000000) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (;i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 2140000000) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (;rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (;rd[0] === 0; e -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0];n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (;x.s && ++i < args.length; )
    x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// node_modules/@bufbuild/protobuf/dist/esm/wire/size-delimited.js
function sizeDelimitedEncode(messageDesc2, message, options) {
  const writer = new BinaryWriter;
  writer.bytes(toBinary(messageDesc2, message, options));
  return writer.finish();
}
function sizeDelimitedPeek(data) {
  const sizeEof = { eof: true, size: null, offset: null };
  for (let i = 0;i < 10; i++) {
    if (i > data.byteLength) {
      return sizeEof;
    }
    if ((data[i] & 128) == 0) {
      const reader = new BinaryReader(data);
      let size;
      try {
        size = reader.uint32();
      } catch (e) {
        if (e instanceof RangeError) {
          return sizeEof;
        }
        throw e;
      }
      return {
        eof: false,
        size,
        offset: reader.pos
      };
    }
  }
  throw new Error("invalid varint");
}
// node_modules/ethers/lib.esm/ethers.js
var exports_ethers = {};
__export(exports_ethers, {
  zeroPadValue: () => zeroPadValue,
  zeroPadBytes: () => zeroPadBytes,
  wordlists: () => wordlists,
  version: () => version,
  verifyTypedData: () => verifyTypedData,
  verifyMessage: () => verifyMessage,
  verifyAuthorization: () => verifyAuthorization,
  uuidV4: () => uuidV4,
  toUtf8String: () => toUtf8String,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8Bytes: () => toUtf8Bytes,
  toTwos: () => toTwos,
  toQuantity: () => toQuantity,
  toNumber: () => toNumber,
  toBigInt: () => toBigInt,
  toBeHex: () => toBeHex,
  toBeArray: () => toBeArray,
  stripZerosLeft: () => stripZerosLeft,
  solidityPackedSha256: () => solidityPackedSha256,
  solidityPackedKeccak256: () => solidityPackedKeccak256,
  solidityPacked: () => solidityPacked,
  showThrottleMessage: () => showThrottleMessage,
  sha512: () => sha5122,
  sha256: () => sha2562,
  scryptSync: () => scryptSync,
  scrypt: () => scrypt2,
  ripemd160: () => ripemd1602,
  resolveProperties: () => resolveProperties,
  resolveAddress: () => resolveAddress,
  recoverAddress: () => recoverAddress,
  randomBytes: () => randomBytes3,
  pbkdf2: () => pbkdf22,
  parseUnits: () => parseUnits,
  parseEther: () => parseEther,
  namehash: () => namehash,
  mask: () => mask,
  makeError: () => makeError,
  lock: () => lock,
  keccak256: () => keccak256,
  isValidName: () => isValidName,
  isKeystoreJson: () => isKeystoreJson,
  isHexString: () => isHexString,
  isError: () => isError,
  isCrowdsaleJson: () => isCrowdsaleJson,
  isCallException: () => isCallException,
  isBytesLike: () => isBytesLike,
  isAddressable: () => isAddressable,
  isAddress: () => isAddress,
  id: () => id,
  hexlify: () => hexlify,
  hashMessage: () => hashMessage,
  hashAuthorization: () => hashAuthorization,
  getUint: () => getUint,
  getNumber: () => getNumber,
  getIndexedAccountPath: () => getIndexedAccountPath,
  getIcapAddress: () => getIcapAddress,
  getDefaultProvider: () => getDefaultProvider,
  getCreateAddress: () => getCreateAddress,
  getCreate2Address: () => getCreate2Address,
  getBytesCopy: () => getBytesCopy,
  getBytes: () => getBytes,
  getBigInt: () => getBigInt,
  getAddress: () => getAddress,
  getAccountPath: () => getAccountPath,
  fromTwos: () => fromTwos,
  formatUnits: () => formatUnits,
  formatEther: () => formatEther,
  ensNormalize: () => ensNormalize,
  encryptKeystoreJsonSync: () => encryptKeystoreJsonSync,
  encryptKeystoreJson: () => encryptKeystoreJson,
  encodeRlp: () => encodeRlp,
  encodeBytes32String: () => encodeBytes32String,
  encodeBase64: () => encodeBase64,
  encodeBase58: () => encodeBase58,
  dnsEncode: () => dnsEncode,
  defineProperties: () => defineProperties,
  defaultPath: () => defaultPath2,
  decryptKeystoreJsonSync: () => decryptKeystoreJsonSync,
  decryptKeystoreJson: () => decryptKeystoreJson,
  decryptCrowdsaleJson: () => decryptCrowdsaleJson,
  decodeRlp: () => decodeRlp,
  decodeBytes32String: () => decodeBytes32String,
  decodeBase64: () => decodeBase64,
  decodeBase58: () => decodeBase58,
  dataSlice: () => dataSlice,
  dataLength: () => dataLength,
  copyRequest: () => copyRequest,
  concat: () => concat,
  computeHmac: () => computeHmac,
  computeAddress: () => computeAddress,
  checkResultErrors: () => checkResultErrors,
  authorizationify: () => authorizationify,
  assertPrivate: () => assertPrivate,
  assertNormalize: () => assertNormalize,
  assertArgumentCount: () => assertArgumentCount,
  assertArgument: () => assertArgument,
  assert: () => assert2,
  accessListify: () => accessListify,
  ZeroHash: () => ZeroHash,
  ZeroAddress: () => ZeroAddress,
  WordlistOwlA: () => WordlistOwlA,
  WordlistOwl: () => WordlistOwl,
  Wordlist: () => Wordlist,
  WeiPerEther: () => WeiPerEther,
  WebSocketProvider: () => WebSocketProvider,
  Wallet: () => Wallet,
  VoidSigner: () => VoidSigner,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  UnmanagedSubscriber: () => UnmanagedSubscriber,
  UndecodedEventLog: () => UndecodedEventLog,
  TypedDataEncoder: () => TypedDataEncoder,
  Typed: () => Typed,
  TransactionResponse: () => TransactionResponse,
  TransactionReceipt: () => TransactionReceipt,
  TransactionDescription: () => TransactionDescription,
  Transaction: () => Transaction,
  StructFragment: () => StructFragment,
  SocketSubscriber: () => SocketSubscriber,
  SocketProvider: () => SocketProvider,
  SocketPendingSubscriber: () => SocketPendingSubscriber,
  SocketEventSubscriber: () => SocketEventSubscriber,
  SocketBlockSubscriber: () => SocketBlockSubscriber,
  SigningKey: () => SigningKey,
  Signature: () => Signature,
  Result: () => Result,
  QuickNodeProvider: () => QuickNodeProvider,
  PocketProvider: () => PocketProvider,
  ParamType: () => ParamType,
  NonceManager: () => NonceManager,
  NetworkPlugin: () => NetworkPlugin,
  Network: () => Network,
  NamedFragment: () => NamedFragment,
  N: () => N,
  MulticoinProviderPlugin: () => MulticoinProviderPlugin,
  Mnemonic: () => Mnemonic,
  MinInt256: () => MinInt256,
  MessagePrefix: () => MessagePrefix,
  MaxUint256: () => MaxUint256,
  MaxInt256: () => MaxInt256,
  LogDescription: () => LogDescription,
  Log: () => Log,
  LangEn: () => LangEn,
  JsonRpcSigner: () => JsonRpcSigner,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcApiProvider: () => JsonRpcApiProvider,
  IpcSocketProvider: () => IpcSocketProvider,
  Interface: () => Interface,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  InfuraProvider: () => InfuraProvider,
  Indexed: () => Indexed,
  HDNodeWallet: () => HDNodeWallet,
  HDNodeVoidWallet: () => HDNodeVoidWallet,
  GasCostPlugin: () => GasCostPlugin,
  FunctionFragment: () => FunctionFragment,
  Fragment: () => Fragment,
  FixedNumber: () => FixedNumber,
  FetchUrlFeeDataNetworkPlugin: () => FetchUrlFeeDataNetworkPlugin,
  FetchResponse: () => FetchResponse,
  FetchRequest: () => FetchRequest,
  FetchCancelSignal: () => FetchCancelSignal,
  FeeDataNetworkPlugin: () => FeeDataNetworkPlugin,
  FeeData: () => FeeData,
  FallbackProvider: () => FallbackProvider,
  FallbackFragment: () => FallbackFragment,
  EventPayload: () => EventPayload,
  EventLog: () => EventLog,
  EventFragment: () => EventFragment,
  EtherscanProvider: () => EtherscanProvider,
  EtherscanPlugin: () => EtherscanPlugin,
  EtherSymbol: () => EtherSymbol,
  ErrorFragment: () => ErrorFragment,
  ErrorDescription: () => ErrorDescription,
  EnsResolver: () => EnsResolver,
  EnsPlugin: () => EnsPlugin,
  ContractUnknownEventPayload: () => ContractUnknownEventPayload,
  ContractTransactionResponse: () => ContractTransactionResponse,
  ContractTransactionReceipt: () => ContractTransactionReceipt,
  ContractFactory: () => ContractFactory,
  ContractEventPayload: () => ContractEventPayload,
  Contract: () => Contract,
  ConstructorFragment: () => ConstructorFragment,
  CloudflareProvider: () => CloudflareProvider,
  ChainstackProvider: () => ChainstackProvider,
  BrowserProvider: () => BrowserProvider,
  BlockscoutProvider: () => BlockscoutProvider,
  Block: () => Block,
  BaseWallet: () => BaseWallet,
  BaseContract: () => BaseContract,
  AnkrProvider: () => AnkrProvider,
  AlchemyProvider: () => AlchemyProvider,
  AbstractSigner: () => AbstractSigner,
  AbstractProvider: () => AbstractProvider,
  AbiCoder: () => AbiCoder
});

// node_modules/ethers/lib.esm/_version.js
var version = "6.15.0";
// node_modules/ethers/lib.esm/utils/properties.js
function checkType(value, type, name) {
  const types2 = type.split("|").map((t) => t.trim());
  for (let i = 0;i < types2.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys[index]] = v;
    return accum;
  }, {});
}
function defineProperties(target, values, types2) {
  for (let key in values) {
    let value = values[key];
    const type = types2 ? types2[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// node_modules/ethers/lib.esm/utils/errors.js
function stringify(value, seen) {
  if (value == null) {
    return "null";
  }
  if (seen == null) {
    seen = new Set;
  }
  if (typeof value === "object") {
    if (seen.has(value)) {
      return "[Circular]";
    }
    seen.add(value);
  }
  if (Array.isArray(value)) {
    return "[ " + value.map((v) => stringify(v, seen)).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0;i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON(), seen);
  }
  switch (typeof value) {
    case "boolean":
    case "number":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        if (key === "shortMessage") {
          continue;
        }
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert2(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert2(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert2(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert2(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {}
  return accum;
}, []);
function assertNormalize(form) {
  assert2(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert2(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}

// node_modules/ethers/lib.esm/utils/data.js
function _getBytes(value, name, copy) {
  if (value instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0;i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
var HexCharacters = "0123456789abcdef";
function hexlify(data) {
  const bytes = getBytes(data);
  let result = "0x";
  for (let i = 0;i < bytes.length; i++) {
    const v = bytes[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes = getBytes(data);
  if (end != null && end > bytes.length) {
    assert2(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes,
      length: bytes.length,
      offset: end
    });
  }
  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
}
function stripZerosLeft(data) {
  let bytes = hexlify(data).substring(2);
  while (bytes.startsWith("00")) {
    bytes = bytes.substring(2);
  }
  return "0x" + bytes;
}
function zeroPad(data, length, left) {
  const bytes = getBytes(data);
  assert2(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes, length - bytes.length);
  } else {
    result.set(bytes, 0);
  }
  return hexlify(result);
}
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}

// node_modules/ethers/lib.esm/utils/maths.js
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
function fromTwos(_value, _width) {
  const value = getUint(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert2(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value >> width - BN_1) {
    const mask = (BN_1 << width) - BN_1;
    return -((~value & mask) + BN_1);
  }
  return value;
}
function toTwos(_value, _width) {
  let value = getBigInt(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1 << width - BN_1;
  if (value < BN_0) {
    value = -value;
    assert2(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask = (BN_1 << width) - BN_1;
    return (~value & mask) + BN_1;
  } else {
    assert2(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
function mask(_value, _bits) {
  const value = getUint(_value, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1 << bits) - BN_1;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert2(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
var Nibbles = "0123456789abcdef";
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value, _width) {
  const value = getUint(_value, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert2(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value) {
  const value = getUint(_value, "value");
  if (value === BN_0) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0;i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}

// node_modules/ethers/lib.esm/utils/base58.js
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0;i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
var BN_02 = BigInt(0);
var BN_58 = BigInt(58);
function encodeBase58(_value) {
  const bytes = getBytes(_value);
  let value = toBigInt(bytes);
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  for (let i = 0;i < bytes.length; i++) {
    if (bytes[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_02;
  for (let i = 0;i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
// node_modules/ethers/lib.esm/utils/base64-browser.js
function decodeBase64(textData) {
  textData = atob(textData);
  const data = new Uint8Array(textData.length);
  for (let i = 0;i < textData.length; i++) {
    data[i] = textData.charCodeAt(i);
  }
  return getBytes(data);
}
function encodeBase64(_data) {
  const data = getBytes(_data);
  let textData = "";
  for (let i = 0;i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
// node_modules/ethers/lib.esm/utils/events.js
class EventPayload {
  filter;
  emitter;
  #listener;
  constructor(emitter, listener, filter) {
    this.#listener = listener;
    defineProperties(this, { emitter, filter });
  }
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
}
// node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1;o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes.length) {
    const c = bytes[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes.length) {
      i += onError("OVERRUN", i - 1, bytes, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0;j < extraLength; j++) {
      let nextChar = bytes[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form) {
  assertArgument(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0;i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

// node_modules/ethers/lib.esm/utils/geturl-browser.js
function createGetUrl(options) {
  async function getUrl(req, _signal) {
    assert2(_signal == null || !_signal.cancelled, "request cancelled before sending", "CANCELLED");
    const protocol = req.url.split(":")[0].toLowerCase();
    assert2(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert2(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let error = null;
    const controller = new AbortController;
    const timer = setTimeout(() => {
      error = makeError("request timeout", "TIMEOUT");
      controller.abort();
    }, req.timeout);
    if (_signal) {
      _signal.addListener(() => {
        error = makeError("request cancelled", "CANCELLED");
        controller.abort();
      });
    }
    const init = Object.assign({}, options, {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || undefined,
      signal: controller.signal
    });
    let resp;
    try {
      resp = await fetch(req.url, init);
    } catch (_error) {
      clearTimeout(timer);
      if (error) {
        throw error;
      }
      throw _error;
    }
    clearTimeout(timer);
    const headers = {};
    resp.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body
    };
  }
  return getUrl;
}
var defaultGetUrl = createGetUrl({});

// node_modules/ethers/lib.esm/utils/fetch.js
var MAX_ATTEMPTS = 12;
var SLOT_INTERVAL = 250;
var defaultGetUrlFunc = createGetUrl();
var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
var locked = false;
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
var Gateways = {
  data: dataGatewayFunc,
  ipfs: getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
var fetchSignals = new WeakMap;

class FetchCancelSignal {
  #listeners;
  #cancelled;
  constructor(request) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals.set(request, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert2(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert2(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}

class FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  #getUrlFunc;
  get url() {
    return this.#url;
  }
  set url(url) {
    this.#url = String(url);
  }
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body) {
    if (body == null) {
      this.#body = undefined;
      this.#bodyType = undefined;
    } else if (typeof body === "string") {
      this.#body = toUtf8Bytes(body);
      this.#bodyType = "text/plain";
    } else if (body instanceof Uint8Array) {
      this.#body = body;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body === "object") {
      this.#body = toUtf8Bytes(JSON.stringify(body));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  hasBody() {
    return this.#body != null;
  }
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  setHeader(key, value) {
    this.#headers[String(key).toLowerCase()] = String(value);
  }
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get credentials() {
    return this.#creds || null;
  }
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value) {
    this.#gzip = !!value;
  }
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value) {
    this.#allowInsecure = !!value;
  }
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process2) {
    this.#process = process2;
  }
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  get getUrlFunc() {
    return this.#getUrlFunc || defaultGetUrlFunc;
  }
  set getUrlFunc(value) {
    this.#getUrlFunc = value;
  }
  constructor(url) {
    this.#url = String(url);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 300000;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    };
    this.#getUrlFunc = null;
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async#send(attempt, expires, delay, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert2(getTime() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay > 0) {
      await wait(delay);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways) {
      const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
      if (result instanceof FetchResponse) {
        let response2 = result;
        if (this.processFunc) {
          checkSignal(_request.#signal);
          try {
            response2 = await this.processFunc(req, response2);
          } catch (error) {
            if (error.throttle == null || typeof error.stall !== "number") {
              response2.makeServerError("error in post-processing function", error).assertOk();
            }
          }
        }
        return response2;
      }
      req = result;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
    let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response.statusCode === 301 || response.statusCode === 302) {
      try {
        const location = response.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
      } catch (error) {}
      return response;
    } else if (response.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
        const retryAfter = response.headers["retry-after"];
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay2 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    if (this.processFunc) {
      checkSignal(_request.#signal);
      try {
        response = await this.processFunc(req, response);
      } catch (error) {
        if (error.throttle == null || typeof error.stall !== "number") {
          response.makeServerError("error in post-processing function", error).assertOk();
        }
        let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (error.stall >= 0) {
          delay2 = error.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay2, _request, response);
      }
    }
    return response;
  }
  send() {
    assert2(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal(this);
    return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  cancel() {
    assert2(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert2(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  clone() {
    const clone3 = new FetchRequest(this.url);
    clone3.#method = this.#method;
    if (this.#body) {
      clone3.#body = this.#body;
    }
    clone3.#bodyType = this.#bodyType;
    clone3.#headers = Object.assign({}, this.#headers);
    clone3.#creds = this.#creds;
    if (this.allowGzip) {
      clone3.allowGzip = true;
    }
    clone3.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone3.allowInsecureAuthentication = true;
    }
    clone3.#preflight = this.#preflight;
    clone3.#process = this.#process;
    clone3.#retry = this.#retry;
    clone3.#throttle = Object.assign({}, this.#throttle);
    clone3.#getUrlFunc = this.#getUrlFunc;
    return clone3;
  }
  static lockConfig() {
    locked = true;
  }
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  static registerGetUrl(getUrl) {
    if (locked) {
      throw new Error("gateways locked");
    }
    defaultGetUrlFunc = getUrl;
  }
  static createGetUrlFunc(options) {
    return createGetUrl(options);
  }
  static createDataGateway() {
    return dataGatewayFunc;
  }
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
}

class FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  get statusCode() {
    return this.#statusCode;
  }
  get statusMessage() {
    return this.#statusMessage;
  }
  get headers() {
    return Object.assign({}, this.#headers);
  }
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String(this.#body);
    } catch (error) {
      assert2(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert2(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body, request) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body == null ? null : new Uint8Array(body);
    this.#request = request || null;
    this.#error = { message: "" };
  }
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);
    response.#error = { message, error };
    return response;
  }
  throwThrottleError(message, stall) {
    if (stall == null) {
      stall = -1;
    } else {
      assertArgument(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall, throttle: true });
    throw error;
  }
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  hasBody() {
    return this.#body != null;
  }
  get request() {
    return this.#request;
  }
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    let requestUrl = null;
    if (this.request) {
      requestUrl = this.request.url;
    }
    let responseBody = null;
    try {
      if (this.#body) {
        responseBody = toUtf8String(this.#body);
      }
    } catch (e) {}
    assert2(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error,
      info: {
        requestUrl,
        responseBody,
        responseStatus: `${this.statusCode} ${this.statusMessage}`
      }
    });
  }
}
function getTime() {
  return new Date().getTime();
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
// node_modules/ethers/lib.esm/utils/fixednumber.js
var BN_N1 = BigInt(-1);
var BN_03 = BigInt(0);
var BN_12 = BigInt(1);
var BN_5 = BigInt(5);
var _guard = {};
var Zeros = "0000";
while (Zeros.length < 80) {
  Zeros += Zeros;
}
function getTens(decimals) {
  let result = Zeros;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
  const width = BigInt(format.width);
  if (format.signed) {
    const limit = BN_12 << width - BN_12;
    assert2(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_03) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_12 << width;
    assert2(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_12;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") {} else if (value === "ufixed") {
      signed = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v = value;
    const check = (key, type, defaultValue) => {
      if (v[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
      return v[key];
    };
    signed = check("signed", "boolean", signed);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_03) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}

class FixedNumber {
  format;
  #format;
  #val;
  #tens;
  _value;
  constructor(guard, value, format) {
    assertPrivate(guard, _guard, "FixedNumber");
    this.#val = value;
    this.#format = format;
    const _value = toString(value, format.decimals);
    defineProperties(this, { format: format.name, _value });
    this.#tens = getTens(format.decimals);
  }
  get signed() {
    return this.#format.signed;
  }
  get width() {
    return this.#format.width;
  }
  get decimals() {
    return this.#format.decimals;
  }
  get value() {
    return this.#val;
  }
  #checkFormat(other) {
    assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
  }
  #checkValue(val, safeOp) {
    val = checkValue(val, this.#format, safeOp);
    return new FixedNumber(_guard, val, this.#format);
  }
  #add(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val + o.#val, safeOp);
  }
  addUnsafe(other) {
    return this.#add(other);
  }
  add(other) {
    return this.#add(other, "add");
  }
  #sub(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val - o.#val, safeOp);
  }
  subUnsafe(other) {
    return this.#sub(other);
  }
  sub(other) {
    return this.#sub(other, "sub");
  }
  #mul(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);
  }
  mulUnsafe(other) {
    return this.#mul(other);
  }
  mul(other) {
    return this.#mul(other, "mul");
  }
  mulSignal(other) {
    this.#checkFormat(other);
    const value = this.#val * other.#val;
    assert2(value % this.#tens === BN_03, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / this.#tens, "mulSignal");
  }
  #div(o, safeOp) {
    assert2(o.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(o);
    return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);
  }
  divUnsafe(other) {
    return this.#div(other);
  }
  div(other) {
    return this.#div(other, "div");
  }
  divSignal(other) {
    assert2(other.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(other);
    const value = this.#val * this.#tens;
    assert2(value % other.#val === BN_03, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / other.#val, "divSignal");
  }
  cmp(other) {
    let a = this.value, b = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b *= getTens(delta);
    } else if (delta < 0) {
      a *= getTens(-delta);
    }
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }
  eq(other) {
    return this.cmp(other) === 0;
  }
  lt(other) {
    return this.cmp(other) < 0;
  }
  lte(other) {
    return this.cmp(other) <= 0;
  }
  gt(other) {
    return this.cmp(other) > 0;
  }
  gte(other) {
    return this.cmp(other) >= 0;
  }
  floor() {
    let val = this.#val;
    if (this.#val < BN_03) {
      val -= this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "floor");
  }
  ceiling() {
    let val = this.#val;
    if (this.#val > BN_03) {
      val += this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "ceiling");
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, this.#format, "round");
    return new FixedNumber(_guard, value, this.#format);
  }
  isZero() {
    return this.#val === BN_03;
  }
  isNegative() {
    return this.#val < BN_03;
  }
  toString() {
    return this._value;
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this.toString(), format);
  }
  static fromValue(_value, _decimals, _format) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format = getFormat(_format);
    let value = getBigInt(_value, "value");
    const delta = decimals - format.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert2(value % tens === BN_03, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format, "fromValue");
    return new FixedNumber(_guard, value, format);
  }
  static fromString(_value, _format) {
    const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
    const format = getFormat(_format);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format.decimals) {
      decimal += Zeros;
    }
    assert2(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value
    });
    decimal = decimal.substring(0, format.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format, "fromString");
    return new FixedNumber(_guard, value, format);
  }
  static fromBytes(_value, _format) {
    let value = toBigInt(getBytes(_value, "value"));
    const format = getFormat(_format);
    if (format.signed) {
      value = fromTwos(value, format.width);
    }
    checkValue(value, format, "fromBytes");
    return new FixedNumber(_guard, value, format);
  }
}
// node_modules/ethers/lib.esm/utils/rlp-decode.js
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i = 0;i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert2(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  assert2(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert2(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset2
    });
  };
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data[offset]) };
}
function decodeRlp(_data) {
  const data = getBytes(_data, "data");
  const decoded = _decode(data, 0);
  assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}
// node_modules/ethers/lib.esm/utils/rlp-encode.js
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data = Array.prototype.slice.call(getBytes(object, "object"));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
var nibbles = "0123456789abcdef";
function encodeRlp(object) {
  let result = "0x";
  for (const v of _encode(object)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}
// node_modules/ethers/lib.esm/utils/units.js
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
// node_modules/ethers/lib.esm/utils/uuid.js
function uuidV4(randomBytes) {
  const bytes = getBytes(randomBytes, "randomBytes");
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = hexlify(bytes);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
// node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
var WordSize = 32;
var Padding = new Uint8Array(WordSize);
var passProperties = ["then"];
var _guard2 = {};
var resultNames = new WeakMap;
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names2) {
  resultNames.set(result, names2);
}
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function toObject(names2, items, deep) {
  if (names2.indexOf(null) >= 0) {
    return items.map((item, index) => {
      if (item instanceof Result) {
        return toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names2.reduce((accum, name, index) => {
    let item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}

class Result extends Array {
  #names;
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard2) {
      items = args;
      names2 = [];
      wrap = false;
    }
    super(items.length);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, new Map);
    setNames(this, Object.freeze(items.map((item, index) => {
      const name = names2[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    this.#names = [];
    if (this.#names == null) {
      this.#names;
    }
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    const proxy = new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(this));
    return proxy;
  }
  toArray(deep) {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      if (deep && item instanceof Result) {
        item = item.toArray(deep);
      }
      result.push(item);
    });
    return result;
  }
  toObject(deep) {
    const names2 = getNames(this);
    return names2.reduce((accum, name, index) => {
      assert2(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      return toObject(names2, this, deep);
    }, {});
  }
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const _names = getNames(this);
    const result = [], names2 = [];
    for (let i = start;i < end; i++) {
      result.push(this[i]);
      names2.push(_names[i]);
    }
    return new Result(_guard2, result, names2);
  }
  filter(callback, thisArg) {
    const _names = getNames(this);
    const result = [], names2 = [];
    for (let i = 0;i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names2.push(_names[i]);
      }
    }
    return new Result(_guard2, result, names2);
  }
  map(callback, thisArg) {
    const result = [];
    for (let i = 0;i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  getValue(name) {
    const index = getNames(this).indexOf(name);
    if (index === -1) {
      return;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  static fromItems(items, keys) {
    return new Result(_guard2, items, keys);
  }
}
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key in object) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object[key]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
function getValue(value) {
  let bytes = toBeArray(value);
  assert2(bytes.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes, length: WordSize, offset: bytes.length });
  if (bytes.length !== WordSize) {
    bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));
  }
  return bytes;
}

class Coder {
  name;
  type;
  localName;
  dynamic;
  constructor(name, type, localName, dynamic) {
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}

class Writer {
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data) {
    this.#data.push(data);
    this.#dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy(writer.data));
  }
  writeBytes(value) {
    let bytes = getBytesCopy(value);
    const paddingOffset = bytes.length % WordSize;
    if (paddingOffset) {
      bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));
    }
    return this.#writeData(bytes);
  }
  writeValue(value) {
    return this.#writeData(getValue(value));
  }
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding);
    this.#dataLength += WordSize;
    return (value) => {
      this.#data[offset] = getValue(value);
    };
  }
}

class Reader {
  allowLoose;
  #data;
  #offset;
  #bytesRead;
  #parent;
  #maxInflation;
  constructor(data, allowLoose, maxInflation) {
    defineProperties(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy(data);
    this.#bytesRead = 0;
    this.#parent = null;
    this.#maxInflation = maxInflation != null ? maxInflation : 1024;
    this.#offset = 0;
  }
  get data() {
    return hexlify(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #incrementBytesRead(count) {
    if (this.#parent) {
      return this.#parent.#incrementBytesRead(count);
    }
    this.#bytesRead += count;
    assert2(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: getBytesCopy(this.#data),
      offset: this.#offset,
      length: count,
      info: {
        bytesRead: this.#bytesRead,
        dataLength: this.dataLength
      }
    });
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize) * WordSize;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert2(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  subReader(offset) {
    const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
    reader.#parent = this;
    return reader;
  }
  readBytes(length, loose) {
    let bytes = this.#peekBytes(0, length, !!loose);
    this.#incrementBytesRead(length);
    this.#offset += bytes.length;
    return bytes.slice(0, length);
  }
  readValue() {
    return toBigInt(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber(this.readBytes(WordSize));
  }
}

// node_modules/ethers/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}

// node_modules/ethers/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;

// node_modules/ethers/node_modules/@noble/hashes/esm/utils.js
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u8a = (a) => a instanceof Uint8Array;
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var nextTick = async () => {};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0;i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum2, a) => sum2 + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}

class Hash {
  clone() {
    return this._cloneInto();
  }
}
var toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/ethers/node_modules/@noble/hashes/esm/hmac.js
class HMAC extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/ethers/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash2, _password, _salt, _opts) {
  hash(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2(hash2, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0;pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1;ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0;i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/ethers/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}

class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos;i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0;i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}

// node_modules/ethers/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);

class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16;i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0;i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256);

// node_modules/ethers/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add2(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add: add2,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var _u64_default = u64;

// node_modules/ethers/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);

class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16;i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = _u64_default.rotrSH(W15h, W15l, 1) ^ _u64_default.rotrSH(W15h, W15l, 8) ^ _u64_default.shrSH(W15h, W15l, 7);
      const s0l = _u64_default.rotrSL(W15h, W15l, 1) ^ _u64_default.rotrSL(W15h, W15l, 8) ^ _u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = _u64_default.rotrSH(W2h, W2l, 19) ^ _u64_default.rotrBH(W2h, W2l, 61) ^ _u64_default.shrSH(W2h, W2l, 6);
      const s1l = _u64_default.rotrSL(W2h, W2l, 19) ^ _u64_default.rotrBL(W2h, W2l, 61) ^ _u64_default.shrSL(W2h, W2l, 6);
      const SUMl = _u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = _u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0;i < 80; i++) {
      const sigma1h = _u64_default.rotrSH(Eh, El, 14) ^ _u64_default.rotrSH(Eh, El, 18) ^ _u64_default.rotrBH(Eh, El, 41);
      const sigma1l = _u64_default.rotrSL(Eh, El, 14) ^ _u64_default.rotrSL(Eh, El, 18) ^ _u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = _u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = _u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = _u64_default.rotrSH(Ah, Al, 28) ^ _u64_default.rotrBH(Ah, Al, 34) ^ _u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = _u64_default.rotrSL(Ah, Al, 28) ^ _u64_default.rotrBL(Ah, Al, 34) ^ _u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = _u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = _u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = _u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = _u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = _u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = _u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = _u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = _u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = _u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = _u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = _u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
var sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512);

// node_modules/ethers/lib.esm/crypto/crypto-browser.js
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal = getGlobal();
var crypto3 = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256.create();
    case "sha512":
      return sha512.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key) {
  const algo = { sha256, sha512 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac.create(algo, key);
}
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  const algo = { sha256, sha512 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes2(length) {
  assert2(crypto3 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result = new Uint8Array(length);
  crypto3.getRandomValues(result);
  return result;
}

// node_modules/ethers/lib.esm/crypto/hmac.js
var locked2 = false;
var _computeHmac = function(algorithm, key, data) {
  return createHmac(algorithm, key).update(data).digest();
};
var __computeHmac = _computeHmac;
function computeHmac(algorithm, _key, _data) {
  const key = getBytes(_key, "key");
  const data = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data));
}
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked2 = true;
};
computeHmac.register = function(func) {
  if (locked2) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

// node_modules/ethers/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
var _7n = /* @__PURE__ */ BigInt(7);
var _256n = /* @__PURE__ */ BigInt(256);
var _0x71n = /* @__PURE__ */ BigInt(113);
for (let round2 = 0, R = _1n, x = 1, y = 0;round2 < 24; round2++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds;round2 < 24; round2++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI2 = SHA3_PI[t];
      curH = s[PI2];
      curL = s[PI2 + 1];
      s[PI2] = Th;
      s[PI2 + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round2];
    s[1] ^= SHA3_IOTA_L[round2];
  }
  B.fill(0);
}

class Keccak extends Hash {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0;i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length;pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

// node_modules/ethers/lib.esm/crypto/keccak.js
var locked3 = false;
var _keccak256 = function(data) {
  return keccak_256(data);
};
var __keccak256 = _keccak256;
function keccak256(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__keccak256(data));
}
keccak256._ = _keccak256;
keccak256.lock = function() {
  locked3 = true;
};
keccak256.register = function(func) {
  if (locked3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);

// node_modules/ethers/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
var Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i = 0;i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
var shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
var shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
var shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
var Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
var BUF = /* @__PURE__ */ new Uint32Array(16);

class RIPEMD160 extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0;group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0;i < 16; i++) {
        const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0;i < 16; i++) {
        const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
var ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160);

// node_modules/ethers/lib.esm/crypto/ripemd160.js
var locked4 = false;
var _ripemd160 = function(data) {
  return ripemd160(data);
};
var __ripemd160 = _ripemd160;
function ripemd1602(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__ripemd160(data));
}
ripemd1602._ = _ripemd160;
ripemd1602.lock = function() {
  locked4 = true;
};
ripemd1602.register = function(func) {
  if (locked4) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd1602);

// node_modules/ethers/lib.esm/crypto/pbkdf2.js
var locked5 = false;
var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
function pbkdf22(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
pbkdf22._ = _pbkdf2;
pbkdf22.lock = function() {
  locked5 = true;
};
pbkdf22.register = function(func) {
  if (locked5) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf22);

// node_modules/ethers/lib.esm/crypto/random.js
var locked6 = false;
var _randomBytes = function(length) {
  return new Uint8Array(randomBytes2(length));
};
var __randomBytes = _randomBytes;
function randomBytes3(length) {
  return __randomBytes(length);
}
randomBytes3._ = _randomBytes;
randomBytes3.lock = function() {
  locked6 = true;
};
randomBytes3.register = function(func) {
  if (locked6) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes3);

// node_modules/ethers/node_modules/@noble/hashes/esm/scrypt.js
var rotl2 = (a, b) => a << b | a >>> 32 - b;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0;i < 8; i += 2) {
    x04 ^= rotl2(x00 + x12 | 0, 7);
    x08 ^= rotl2(x04 + x00 | 0, 9);
    x12 ^= rotl2(x08 + x04 | 0, 13);
    x00 ^= rotl2(x12 + x08 | 0, 18);
    x09 ^= rotl2(x05 + x01 | 0, 7);
    x13 ^= rotl2(x09 + x05 | 0, 9);
    x01 ^= rotl2(x13 + x09 | 0, 13);
    x05 ^= rotl2(x01 + x13 | 0, 18);
    x14 ^= rotl2(x10 + x06 | 0, 7);
    x02 ^= rotl2(x14 + x10 | 0, 9);
    x06 ^= rotl2(x02 + x14 | 0, 13);
    x10 ^= rotl2(x06 + x02 | 0, 18);
    x03 ^= rotl2(x15 + x11 | 0, 7);
    x07 ^= rotl2(x03 + x15 | 0, 9);
    x11 ^= rotl2(x07 + x03 | 0, 13);
    x15 ^= rotl2(x11 + x07 | 0, 18);
    x01 ^= rotl2(x00 + x03 | 0, 7);
    x02 ^= rotl2(x01 + x00 | 0, 9);
    x03 ^= rotl2(x02 + x01 | 0, 13);
    x00 ^= rotl2(x03 + x02 | 0, 18);
    x06 ^= rotl2(x05 + x04 | 0, 7);
    x07 ^= rotl2(x06 + x05 | 0, 9);
    x04 ^= rotl2(x07 + x06 | 0, 13);
    x05 ^= rotl2(x04 + x07 | 0, 18);
    x11 ^= rotl2(x10 + x09 | 0, 7);
    x08 ^= rotl2(x11 + x10 | 0, 9);
    x09 ^= rotl2(x08 + x11 | 0, 13);
    x10 ^= rotl2(x09 + x08 | 0, 18);
    x12 ^= rotl2(x15 + x14 | 0, 7);
    x13 ^= rotl2(x12 + x15 | 0, 9);
    x14 ^= rotl2(x13 + x12 | 0, 13);
    x15 ^= rotl2(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0;i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0;i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N);
  number(r);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== undefined && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {};
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0;i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i = 0;i < N; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    await asyncLoop(N, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}

// node_modules/ethers/lib.esm/crypto/scrypt.js
var lockedSync = false;
var lockedAsync = false;
var _scryptAsync = async function(passwd, salt, N, r, p, dkLen, onProgress) {
  return await scryptAsync(passwd, salt, { N, r, p, dkLen, onProgress });
};
var _scryptSync = function(passwd, salt, N, r, p, dkLen) {
  return scrypt(passwd, salt, { N, r, p, dkLen });
};
var __scryptAsync = _scryptAsync;
var __scryptSync = _scryptSync;
async function scrypt2(_passwd, _salt, N, r, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));
}
scrypt2._ = _scryptAsync;
scrypt2.lock = function() {
  lockedAsync = true;
};
scrypt2.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt2);
function scryptSync(_passwd, _salt, N, r, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen));
}
scryptSync._ = _scryptSync;
scryptSync.lock = function() {
  lockedSync = true;
};
scryptSync.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);

// node_modules/ethers/lib.esm/crypto/sha2.js
var _sha256 = function(data) {
  return createHash("sha256").update(data).digest();
};
var _sha512 = function(data) {
  return createHash("sha512").update(data).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false;
var locked512 = false;
function sha2562(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__sha256(data));
}
sha2562._ = _sha256;
sha2562.lock = function() {
  locked256 = true;
};
sha2562.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha2562);
function sha5122(_data) {
  const data = getBytes(_data, "data");
  return hexlify(__sha512(data));
}
sha5122._ = _sha512;
sha5122.lock = function() {
  locked512 = true;
};
sha5122.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha2562);

// node_modules/ethers/node_modules/@noble/curves/esm/abstract/utils.js
var exports_utils = {};
__export(exports_utils, {
  validateObject: () => validateObject,
  utf8ToBytes: () => utf8ToBytes2,
  numberToVarBytesBE: () => numberToVarBytesBE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToBytesLE: () => numberToBytesLE,
  numberToBytesBE: () => numberToBytesBE,
  hexToNumber: () => hexToNumber,
  hexToBytes: () => hexToBytes,
  equalBytes: () => equalBytes,
  ensureBytes: () => ensureBytes,
  createHmacDrbg: () => createHmacDrbg,
  concatBytes: () => concatBytes2,
  bytesToNumberLE: () => bytesToNumberLE,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToHex: () => bytesToHex,
  bitSet: () => bitSet,
  bitMask: () => bitMask,
  bitLen: () => bitLen,
  bitGet: () => bitGet
});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var u8a2 = (a) => a instanceof Uint8Array;
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!u8a2(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0;i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0;i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a2(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum2, a) => sum2 + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0;i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0;n > _0n2; n >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n2;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField2 = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === undefined)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField2(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField2(fieldName, type, true);
  return object;
}

// node_modules/ethers/node_modules/@noble/curves/esm/abstract/modular.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod2(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow2(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow22(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod2(number2, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function tonelliShanks(P2) {
  const legendreC = (P2 - _1n3) / _2n3;
  let Q, S, Z;
  for (Q = P2 - _1n3, S = 0;Q % _2n3 === _0n3; Q /= _2n3, S++)
    ;
  for (Z = _2n3;Z < P2 && pow2(Z, legendreC, P2) !== P2 - _1n3; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P2 + _1n3) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b);m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n) {
    const p1div4 = (P2 + _1n3) / _4n;
    return function sqrt3mod4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _8n === _5n) {
    const c1 = (P2 - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n3);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n3), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P2 % _16n === _9n) {}
  return tonelliShanks(P2);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f2.ONE;
  if (power === _1n3)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f2, n)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod2(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/ethers/node_modules/@noble/curves/esm/abstract/curve.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1;i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask2);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P2, precomputesMap, n, transform) {
      const W = P2._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W);
        if (W !== 1) {
          precomputesMap.set(P2, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/ethers/node_modules/@noble/curves/esm/abstract/weierstrass.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = exports_utils;
var DER = {
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod2(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = new Map;
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }

  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp.eql(i, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    static fromHex(hex) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    multiplyUnsafe(n) {
      const I = Point.ZERO;
      if (n === _0n5)
        return I;
      assertGE(n);
      if (n === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n);
        point = p;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point.BASE;
      const mul2 = (P2, a2) => a2 === _0n5 || a2 === _1n5 || !P2.equals(G) ? P2.multiplyUnsafe(a2) : P2.multiply(a2);
      const sum2 = mul2(this, a).add(mul2(Q, b));
      return sum2.is0() ? undefined : sum2;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp.ONE : Fp.inv(z);
      const ax = Fp.mul(x, iz);
      const ay = Fp.mul(y, iz);
      const zz = Fp.mul(z, iz);
      if (is0)
        return { x: Fp.ZERO, y: Fp.ZERO };
      if (!Fp.eql(zz, Fp.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp.ORDER;
  }
  function modN(a) {
    return mod2(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));

  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes4 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes4(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n5)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = undefined;
    let P2;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P2 = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils
  };
}

// node_modules/ethers/node_modules/@noble/curves/esm/_shortw_utils.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create3 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}

// node_modules/ethers/node_modules/@noble/curves/esm/secp256k1.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n5) / b;
function sqrtMod(y) {
  const P2 = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P2;
  const b3 = b2 * b2 * y % P2;
  const b6 = pow22(b3, _3n3, P2) * b3 % P2;
  const b9 = pow22(b6, _3n3, P2) * b3 % P2;
  const b11 = pow22(b9, _2n5, P2) * b2 % P2;
  const b22 = pow22(b11, _11n, P2) * b11 % P2;
  const b44 = pow22(b22, _22n, P2) * b22 % P2;
  const b88 = pow22(b44, _44n, P2) * b44 % P2;
  const b176 = pow22(b88, _88n, P2) * b88 % P2;
  const b220 = pow22(b176, _44n, P2) * b44 % P2;
  const b223 = pow22(b220, _3n3, P2) * b3 % P2;
  const t1 = pow22(b223, _23n, P2) * b22 % P2;
  const t2 = pow22(t1, _6n, P2) * b2 % P2;
  const root = pow22(t2, _2n5, P2);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod2(k - c1 * a1 - c2 * a2, n);
      let k2 = mod2(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n6 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress = "0x0000000000000000000000000000000000000000";
// node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
// node_modules/ethers/lib.esm/constants/numbers.js
var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var WeiPerEther = BigInt("1000000000000000000");
var MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
var MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
// node_modules/ethers/lib.esm/constants/strings.js
var EtherSymbol = "";
var MessagePrefix = `\x19Ethereum Signed Message:
`;
// node_modules/ethers/lib.esm/crypto/signature.js
var BN_04 = BigInt(0);
var BN_13 = BigInt(1);
var BN_2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var _guard3 = {};
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}

class Signature {
  #r;
  #s;
  #v;
  #networkV;
  get r() {
    return this.#r;
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    this.#r = hexlify(value);
  }
  get s() {
    assertArgument(parseInt(this.#s.substring(0, 3)) < 8, "non-canonical s; use ._s", "s", this.#s);
    return this.#s;
  }
  set s(_value) {
    assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
    this.#s = hexlify(_value);
  }
  get _s() {
    return this.#s;
  }
  isValid() {
    return parseInt(this.#s.substring(0, 3)) < 8;
  }
  get v() {
    return this.#v;
  }
  set v(value) {
    const v = getNumber(value, "value");
    assertArgument(v === 27 || v === 28, "invalid v", "v", value);
    this.#v = v;
  }
  get networkV() {
    return this.#networkV;
  }
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return Signature.getChainId(v);
  }
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  constructor(guard, r, s, v) {
    assertPrivate(guard, _guard3, "Signature");
    this.#r = r;
    this.#s = s;
    this.#v = v;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  clone() {
    const clone3 = new Signature(_guard3, this.r, this._s, this.v);
    if (this.networkV) {
      clone3.#networkV = this.networkV;
    }
    return clone3;
  }
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this._s,
      v: this.v
    };
  }
  static getChainId(v) {
    const bv = getBigInt(v, "v");
    if (bv == BN_27 || bv == BN_28) {
      return BN_04;
    }
    assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v);
    return (bv - BN_35) / BN_2;
  }
  static getChainIdV(chainId, v) {
    return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);
  }
  static getNormalizedV(v) {
    const bv = getBigInt(v);
    if (bv === BN_04 || bv === BN_27) {
      return 27;
    }
    if (bv === BN_13 || bv === BN_28) {
      return 28;
    }
    assertArgument(bv >= BN_35, "invalid v", "v", v);
    return bv & BN_13 ? 27 : 28;
  }
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new Signature(_guard3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes2 = getBytes(sig, "signature");
      if (bytes2.length === 64) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = bytes2.slice(32, 64);
        const v2 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new Signature(_guard3, r2, hexlify(s2), v2);
      }
      if (bytes2.length === 65) {
        const r2 = hexlify(bytes2.slice(0, 32));
        const s2 = hexlify(bytes2.slice(32, 64));
        const v2 = Signature.getNormalizedV(bytes2[64]);
        return new Signature(_guard3, r2, s2, v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof Signature) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r = toUint256(_r);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        const bytes2 = getBytes(yParityAndS);
        bytes2[0] &= 127;
        return hexlify(bytes2);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    const { networkV, v } = function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v2 = getBigInt(_v);
        return {
          networkV: v2 >= BN_35 ? v2 : undefined,
          v: Signature.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new Signature(_guard3, r, s, v);
    if (networkV) {
      result.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
}

// node_modules/ethers/lib.esm/crypto/signing-key.js
class SigningKey {
  #privateKey;
  constructor(privateKey) {
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify(privateKey);
  }
  get privateKey() {
    return this.#privateKey;
  }
  get publicKey() {
    return SigningKey.computePublicKey(this.#privateKey);
  }
  get compressedPublicKey() {
    return SigningKey.computePublicKey(this.#privateKey, true);
  }
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
      lowS: true
    });
    return Signature.from({
      r: toBeHex(sig.r, 32),
      s: toBeHex(sig.s, 32),
      v: sig.recovery ? 28 : 27
    });
  }
  computeSharedSecret(other) {
    const pubKey = SigningKey.computePublicKey(other);
    return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
  }
  static computePublicKey(key, compressed) {
    let bytes2 = getBytes(key, "key");
    if (bytes2.length === 32) {
      const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes2.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes2, 1);
      bytes2 = pub;
    }
    const point = secp256k1.ProjectivePoint.fromHex(bytes2);
    return hexlify(point.toRawBytes(compressed));
  }
  static recoverPublicKey(digest, signature) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature.from(signature);
    let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
    secpSig = secpSig.addRecoveryBit(sig.yParity);
    const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
    assertArgument(pubKey != null, "invalid signature for digest", "signature", signature);
    return "0x" + pubKey.toHex(false);
  }
  static addPoints(p0, p1, compressed) {
    const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
    const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
}
// node_modules/ethers/lib.esm/crypto/index.js
function lock() {
  computeHmac.lock();
  keccak256.lock();
  pbkdf22.lock();
  randomBytes3.lock();
  ripemd1602.lock();
  scrypt2.lock();
  scryptSync.lock();
  sha2562.lock();
  sha5122.lock();
  randomBytes3.lock();
}

// node_modules/ethers/lib.esm/address/address.js
var BN_05 = BigInt(0);
var BN_36 = BigInt(36);
function getChecksumAddress(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0;i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak256(expanded));
  for (let i = 0;i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var ibanLookup = {};
for (let i = 0;i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0;i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
var Base36 = function() {
  const result = {};
  for (let i = 0;i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_05;
  for (let i = 0;i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
function getIcapAddress(address) {
  let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
// node_modules/ethers/lib.esm/address/contract-address.js
function getCreateAddress(tx) {
  const from = getAddress(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from, _salt, _initCodeHash) {
  const from = getAddress(_from);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12));
}
// node_modules/ethers/lib.esm/address/checks.js
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress(value) {
  try {
    getAddress(value);
    return true;
  } catch (error) {}
  return false;
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert2(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert2(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
// node_modules/ethers/lib.esm/abi/typed.js
var _gaurd = {};
function n(value, width) {
  let signed = false;
  if (width < 0) {
    signed = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, { signed, width });
}
function b(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
var _typedSymbol = Symbol.for("_ethers_typed");

class Typed {
  type;
  value;
  #options;
  _typedSymbol;
  constructor(gaurd, type, value, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    this.#options = options;
    this.format();
  }
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  defaultValue() {
    return 0;
  }
  minValue() {
    return 0;
  }
  maxValue() {
    return 0;
  }
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  isData() {
    return this.type.startsWith("bytes");
  }
  isString() {
    return this.type === "string";
  }
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  static from(type, value) {
    return new Typed(_gaurd, type, value);
  }
  static uint8(v) {
    return n(v, 8);
  }
  static uint16(v) {
    return n(v, 16);
  }
  static uint24(v) {
    return n(v, 24);
  }
  static uint32(v) {
    return n(v, 32);
  }
  static uint40(v) {
    return n(v, 40);
  }
  static uint48(v) {
    return n(v, 48);
  }
  static uint56(v) {
    return n(v, 56);
  }
  static uint64(v) {
    return n(v, 64);
  }
  static uint72(v) {
    return n(v, 72);
  }
  static uint80(v) {
    return n(v, 80);
  }
  static uint88(v) {
    return n(v, 88);
  }
  static uint96(v) {
    return n(v, 96);
  }
  static uint104(v) {
    return n(v, 104);
  }
  static uint112(v) {
    return n(v, 112);
  }
  static uint120(v) {
    return n(v, 120);
  }
  static uint128(v) {
    return n(v, 128);
  }
  static uint136(v) {
    return n(v, 136);
  }
  static uint144(v) {
    return n(v, 144);
  }
  static uint152(v) {
    return n(v, 152);
  }
  static uint160(v) {
    return n(v, 160);
  }
  static uint168(v) {
    return n(v, 168);
  }
  static uint176(v) {
    return n(v, 176);
  }
  static uint184(v) {
    return n(v, 184);
  }
  static uint192(v) {
    return n(v, 192);
  }
  static uint200(v) {
    return n(v, 200);
  }
  static uint208(v) {
    return n(v, 208);
  }
  static uint216(v) {
    return n(v, 216);
  }
  static uint224(v) {
    return n(v, 224);
  }
  static uint232(v) {
    return n(v, 232);
  }
  static uint240(v) {
    return n(v, 240);
  }
  static uint248(v) {
    return n(v, 248);
  }
  static uint256(v) {
    return n(v, 256);
  }
  static uint(v) {
    return n(v, 256);
  }
  static int8(v) {
    return n(v, -8);
  }
  static int16(v) {
    return n(v, -16);
  }
  static int24(v) {
    return n(v, -24);
  }
  static int32(v) {
    return n(v, -32);
  }
  static int40(v) {
    return n(v, -40);
  }
  static int48(v) {
    return n(v, -48);
  }
  static int56(v) {
    return n(v, -56);
  }
  static int64(v) {
    return n(v, -64);
  }
  static int72(v) {
    return n(v, -72);
  }
  static int80(v) {
    return n(v, -80);
  }
  static int88(v) {
    return n(v, -88);
  }
  static int96(v) {
    return n(v, -96);
  }
  static int104(v) {
    return n(v, -104);
  }
  static int112(v) {
    return n(v, -112);
  }
  static int120(v) {
    return n(v, -120);
  }
  static int128(v) {
    return n(v, -128);
  }
  static int136(v) {
    return n(v, -136);
  }
  static int144(v) {
    return n(v, -144);
  }
  static int152(v) {
    return n(v, -152);
  }
  static int160(v) {
    return n(v, -160);
  }
  static int168(v) {
    return n(v, -168);
  }
  static int176(v) {
    return n(v, -176);
  }
  static int184(v) {
    return n(v, -184);
  }
  static int192(v) {
    return n(v, -192);
  }
  static int200(v) {
    return n(v, -200);
  }
  static int208(v) {
    return n(v, -208);
  }
  static int216(v) {
    return n(v, -216);
  }
  static int224(v) {
    return n(v, -224);
  }
  static int232(v) {
    return n(v, -232);
  }
  static int240(v) {
    return n(v, -240);
  }
  static int248(v) {
    return n(v, -248);
  }
  static int256(v) {
    return n(v, -256);
  }
  static int(v) {
    return n(v, -256);
  }
  static bytes1(v) {
    return b(v, 1);
  }
  static bytes2(v) {
    return b(v, 2);
  }
  static bytes3(v) {
    return b(v, 3);
  }
  static bytes4(v) {
    return b(v, 4);
  }
  static bytes5(v) {
    return b(v, 5);
  }
  static bytes6(v) {
    return b(v, 6);
  }
  static bytes7(v) {
    return b(v, 7);
  }
  static bytes8(v) {
    return b(v, 8);
  }
  static bytes9(v) {
    return b(v, 9);
  }
  static bytes10(v) {
    return b(v, 10);
  }
  static bytes11(v) {
    return b(v, 11);
  }
  static bytes12(v) {
    return b(v, 12);
  }
  static bytes13(v) {
    return b(v, 13);
  }
  static bytes14(v) {
    return b(v, 14);
  }
  static bytes15(v) {
    return b(v, 15);
  }
  static bytes16(v) {
    return b(v, 16);
  }
  static bytes17(v) {
    return b(v, 17);
  }
  static bytes18(v) {
    return b(v, 18);
  }
  static bytes19(v) {
    return b(v, 19);
  }
  static bytes20(v) {
    return b(v, 20);
  }
  static bytes21(v) {
    return b(v, 21);
  }
  static bytes22(v) {
    return b(v, 22);
  }
  static bytes23(v) {
    return b(v, 23);
  }
  static bytes24(v) {
    return b(v, 24);
  }
  static bytes25(v) {
    return b(v, 25);
  }
  static bytes26(v) {
    return b(v, 26);
  }
  static bytes27(v) {
    return b(v, 27);
  }
  static bytes28(v) {
    return b(v, 28);
  }
  static bytes29(v) {
    return b(v, 29);
  }
  static bytes30(v) {
    return b(v, 30);
  }
  static bytes31(v) {
    return b(v, 31);
  }
  static bytes32(v) {
    return b(v, 32);
  }
  static address(v) {
    return new Typed(_gaurd, "address", v);
  }
  static bool(v) {
    return new Typed(_gaurd, "bool", !!v);
  }
  static bytes(v) {
    return new Typed(_gaurd, "bytes", v);
  }
  static string(v) {
    return new Typed(_gaurd, "string", v);
  }
  static array(v, dynamic) {
    throw new Error("not implemented yet");
    return new Typed(_gaurd, "array", v, dynamic);
  }
  static tuple(v, name) {
    throw new Error("not implemented yet");
    return new Typed(_gaurd, "tuple", v, name);
  }
  static overrides(v) {
    return new Typed(_gaurd, "overrides", Object.assign({}, v));
  }
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  static dereference(value, type) {
    if (Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
}

// node_modules/ethers/lib.esm/abi/coders/address.js
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value = Typed.dereference(_value, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}

// node_modules/ethers/lib.esm/abi/coders/anonymous.js
class AnonymousCoder extends Coder {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}

// node_modules/ethers/lib.esm/abi/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert2(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert2(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer;
  let dynamicWriter = new Writer;
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == undefined) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}

class ArrayCoder extends Coder {
  coder;
  length;
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0;i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0;i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert2(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0;i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}

// node_modules/ethers/lib.esm/abi/coders/boolean.js
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}

// node_modules/ethers/lib.esm/abi/coders/bytes.js
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}

class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}

// node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
class FixedBytesCoder extends Coder {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data = getBytesCopy(Typed.dereference(_value, this.type));
    if (data.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}

// node_modules/ethers/lib.esm/abi/coders/null.js
var Empty = new Uint8Array([]);

class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}

// node_modules/ethers/lib.esm/abi/coders/number.js
var BN_06 = BigInt(0);
var BN_14 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

class NumberCoder extends Coder {
  size;
  signed;
  constructor(size, signed, localName) {
    const name = (signed ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties(this, { size, signed }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value = getBigInt(Typed.dereference(_value, this.type));
    let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);
    if (this.signed) {
      let bounds = mask(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_14)) {
        this._throwError("value out-of-bounds", _value);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_06 || value > mask(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}

// node_modules/ethers/lib.esm/abi/coders/string.js
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}

// node_modules/ethers/lib.esm/abi/coders/tuple.js
class TupleCoder extends Coder {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type = "tuple(" + types2.join(",") + ")";
    super("tuple", type, localName, dynamic);
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}

// node_modules/ethers/lib.esm/transaction/accesslist.js
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
// node_modules/ethers/lib.esm/transaction/authorization.js
function authorizationify(auth) {
  return {
    address: getAddress(auth.address),
    nonce: getBigInt(auth.nonce != null ? auth.nonce : 0),
    chainId: getBigInt(auth.chainId != null ? auth.chainId : 0),
    signature: Signature.from(auth.signature)
  };
}
// node_modules/ethers/lib.esm/transaction/address.js
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak256("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature));
}
// node_modules/ethers/lib.esm/transaction/transaction.js
var BN_07 = BigInt(0);
var BN_22 = BigInt(2);
var BN_272 = BigInt(27);
var BN_282 = BigInt(28);
var BN_352 = BigInt(35);
var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var BLOB_SIZE = 4096 * 32;
function getKzgLibrary(kzg) {
  const blobToKzgCommitment = (blob) => {
    if ("computeBlobProof" in kzg) {
      if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
        return getBytes(kzg.blobToKzgCommitment(hexlify(blob)));
      }
    } else if ("blobToKzgCommitment" in kzg && typeof kzg.blobToKzgCommitment === "function") {
      return getBytes(kzg.blobToKzgCommitment(blob));
    }
    if ("blobToKZGCommitment" in kzg && typeof kzg.blobToKZGCommitment === "function") {
      return getBytes(kzg.blobToKZGCommitment(hexlify(blob)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  const computeBlobKzgProof = (blob, commitment) => {
    if ("computeBlobProof" in kzg && typeof kzg.computeBlobProof === "function") {
      return getBytes(kzg.computeBlobProof(hexlify(blob), hexlify(commitment)));
    }
    if ("computeBlobKzgProof" in kzg && typeof kzg.computeBlobKzgProof === "function") {
      return kzg.computeBlobKzgProof(blob, commitment);
    }
    if ("computeBlobKZGProof" in kzg && typeof kzg.computeBlobKZGProof === "function") {
      return getBytes(kzg.computeBlobKZGProof(hexlify(blob), hexlify(commitment)));
    }
    assertArgument(false, "unsupported KZG library", "kzg", kzg);
  };
  return { blobToKzgCommitment, computeBlobKzgProof };
}
function getVersionedHash(version2, hash2) {
  let versioned = version2.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += sha2562(hash2).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleAuthorizationList(value, param) {
  try {
    if (!Array.isArray(value)) {
      throw new Error("authorizationList: invalid array");
    }
    const result = [];
    for (let i = 0;i < value.length; i++) {
      const auth = value[i];
      if (!Array.isArray(auth)) {
        throw new Error(`authorization[${i}]: invalid array`);
      }
      if (auth.length !== 6) {
        throw new Error(`authorization[${i}]: wrong length`);
      }
      if (!auth[1]) {
        throw new Error(`authorization[${i}]: null address`);
      }
      result.push({
        address: handleAddress(auth[1]),
        nonce: handleUint(auth[2], "nonce"),
        chainId: handleUint(auth[0], "chainId"),
        signature: Signature.from({
          yParity: handleNumber(auth[3], "yParity"),
          r: zeroPadValue(auth[4], 32),
          s: zeroPadValue(auth[5], 32)
        })
      });
    }
    return result;
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber(_value, param);
}
function handleUint(_value, param) {
  if (_value === "0x") {
    return BN_07;
  }
  const value = getBigInt(_value, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value, name) {
  const value = getBigInt(_value, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function formatAuthorizationList(value) {
  return value.map((a) => {
    return [
      formatNumber(a.chainId, "chainId"),
      a.address,
      formatNumber(a.nonce, "nonce"),
      formatNumber(a.signature.yParity, "yParity"),
      toBeArray(a.signature.r),
      toBeArray(a.signature.s)
    ];
  });
}
function formatHashes(value, param) {
  assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
  for (let i = 0;i < value.length; i++) {
    assertArgument(isHexString(value[i], 32), "invalid ${ param } hash", `value[${i}]`, value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  const fields2 = decodeRlp(data);
  assertArgument(Array.isArray(fields2) && (fields2.length === 9 || fields2.length === 6), "invalid field count for legacy transaction", "data", data);
  const tx = {
    type: 0,
    nonce: handleNumber(fields2[0], "nonce"),
    gasPrice: handleUint(fields2[1], "gasPrice"),
    gasLimit: handleUint(fields2[2], "gasLimit"),
    to: handleAddress(fields2[3]),
    value: handleUint(fields2[4], "value"),
    data: hexlify(fields2[5]),
    chainId: BN_07
  };
  if (fields2.length === 6) {
    return tx;
  }
  const v = handleUint(fields2[6], "v");
  const r = handleUint(fields2[7], "r");
  const s = handleUint(fields2[8], "s");
  if (r === BN_07 && s === BN_07) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_352) / BN_22;
    if (chainId < BN_07) {
      chainId = BN_07;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_07 || (v === BN_272 || v === BN_282), "non-canonical legacy v", "v", fields2[6]);
    tx.signature = Signature.from({
      r: zeroPadValue(fields2[7], 32),
      s: zeroPadValue(fields2[8], 32),
      v
    });
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields2 = [
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data
  ];
  let chainId = BN_07;
  if (tx.chainId != BN_07) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_07) {
      fields2.push(toBeArray(chainId));
      fields2.push("0x");
      fields2.push("0x");
    }
    return encodeRlp(fields2);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_07) {
    v = Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields2.push(toBeArray(v));
  fields2.push(toBeArray(sig.r));
  fields2.push(toBeArray(sig.s));
  return encodeRlp(fields2);
}
function _parseEipSignature(tx, fields2) {
  let yParity;
  try {
    yParity = handleNumber(fields2[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields2[0]);
  }
  const r = zeroPadValue(fields2[1], 32);
  const s = zeroPadValue(fields2[2], 32);
  const signature = Signature.from({ r, s, yParity });
  tx.signature = signature;
}
function _parseEip1559(data) {
  const fields2 = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields2) && (fields2.length === 9 || fields2.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
  const tx = {
    type: 2,
    chainId: handleUint(fields2[0], "chainId"),
    nonce: handleNumber(fields2[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields2[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields2[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields2[4], "gasLimit"),
    to: handleAddress(fields2[5]),
    value: handleUint(fields2[6], "value"),
    data: hexlify(fields2[7]),
    accessList: handleAccessList(fields2[8], "accessList")
  };
  if (fields2.length === 9) {
    return tx;
  }
  _parseEipSignature(tx, fields2.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  const fields2 = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields2.push(formatNumber(sig.yParity, "yParity"));
    fields2.push(toBeArray(sig.r));
    fields2.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields2)]);
}
function _parseEip2930(data) {
  const fields2 = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields2) && (fields2.length === 8 || fields2.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
  const tx = {
    type: 1,
    chainId: handleUint(fields2[0], "chainId"),
    nonce: handleNumber(fields2[1], "nonce"),
    gasPrice: handleUint(fields2[2], "gasPrice"),
    gasLimit: handleUint(fields2[3], "gasLimit"),
    to: handleAddress(fields2[4]),
    value: handleUint(fields2[5], "value"),
    data: hexlify(fields2[6]),
    accessList: handleAccessList(fields2[7], "accessList")
  };
  if (fields2.length === 8) {
    return tx;
  }
  _parseEipSignature(tx, fields2.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  const fields2 = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.gasPrice || 0, "gasPrice"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || [])
  ];
  if (sig) {
    fields2.push(formatNumber(sig.yParity, "recoveryParam"));
    fields2.push(toBeArray(sig.r));
    fields2.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields2)]);
}
function _parseEip4844(data) {
  let fields2 = decodeRlp(getBytes(data).slice(1));
  let typeName = "3";
  let blobs = null;
  if (fields2.length === 4 && Array.isArray(fields2[0])) {
    typeName = "3 (network format)";
    const fBlobs = fields2[1], fCommits = fields2[2], fProofs = fields2[3];
    assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields2);
    assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields2);
    blobs = [];
    for (let i = 0;i < fields2[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields2 = fields2[0];
  }
  assertArgument(Array.isArray(fields2) && (fields2.length === 11 || fields2.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
  const tx = {
    type: 3,
    chainId: handleUint(fields2[0], "chainId"),
    nonce: handleNumber(fields2[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields2[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields2[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields2[4], "gasLimit"),
    to: handleAddress(fields2[5]),
    value: handleUint(fields2[6], "value"),
    data: hexlify(fields2[7]),
    accessList: handleAccessList(fields2[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields2[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields2[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
  assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (let i = 0;i < tx.blobVersionedHashes.length; i++) {
    assertArgument(isHexString(tx.blobVersionedHashes[i], 32), `invalid blobVersionedHash at index ${i}: must be length 32`, "data", data);
  }
  if (fields2.length === 11) {
    return tx;
  }
  _parseEipSignature(tx, fields2.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  const fields2 = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || ZeroAddress,
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
    formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
  ];
  if (sig) {
    fields2.push(formatNumber(sig.yParity, "yParity"));
    fields2.push(toBeArray(sig.r));
    fields2.push(toBeArray(sig.s));
    if (blobs) {
      return concat([
        "0x03",
        encodeRlp([
          fields2,
          blobs.map((b2) => b2.data),
          blobs.map((b2) => b2.commitment),
          blobs.map((b2) => b2.proof)
        ])
      ]);
    }
  }
  return concat(["0x03", encodeRlp(fields2)]);
}
function _parseEip7702(data) {
  const fields2 = decodeRlp(getBytes(data).slice(1));
  assertArgument(Array.isArray(fields2) && (fields2.length === 10 || fields2.length === 13), "invalid field count for transaction type: 4", "data", hexlify(data));
  const tx = {
    type: 4,
    chainId: handleUint(fields2[0], "chainId"),
    nonce: handleNumber(fields2[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields2[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields2[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields2[4], "gasLimit"),
    to: handleAddress(fields2[5]),
    value: handleUint(fields2[6], "value"),
    data: hexlify(fields2[7]),
    accessList: handleAccessList(fields2[8], "accessList"),
    authorizationList: handleAuthorizationList(fields2[9], "authorizationList")
  };
  if (fields2.length === 10) {
    return tx;
  }
  _parseEipSignature(tx, fields2.slice(10));
  return tx;
}
function _serializeEip7702(tx, sig) {
  const fields2 = [
    formatNumber(tx.chainId, "chainId"),
    formatNumber(tx.nonce, "nonce"),
    formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx.gasLimit, "gasLimit"),
    tx.to || "0x",
    formatNumber(tx.value, "value"),
    tx.data,
    formatAccessList(tx.accessList || []),
    formatAuthorizationList(tx.authorizationList || [])
  ];
  if (sig) {
    fields2.push(formatNumber(sig.yParity, "yParity"));
    fields2.push(toBeArray(sig.r));
    fields2.push(toBeArray(sig.s));
  }
  return concat(["0x04", encodeRlp(fields2)]);
}

class Transaction {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  #maxFeePerBlobGas;
  #blobVersionedHashes;
  #kzg;
  #blobs;
  #auths;
  get type() {
    return this.#type;
  }
  set type(value) {
    switch (value) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      case 3:
      case "cancun":
      case "eip-4844":
        this.#type = 3;
        break;
      case 4:
      case "pectra":
      case "eip-7702":
        this.#type = 4;
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
      case 3:
        return "eip-4844";
      case 4:
        return "eip-7702";
    }
    return null;
  }
  get to() {
    const value = this.#to;
    if (value == null && this.type === 3) {
      return ZeroAddress;
    }
    return value;
  }
  set to(value) {
    this.#to = value == null ? null : getAddress(value);
  }
  get nonce() {
    return this.#nonce;
  }
  set nonce(value) {
    this.#nonce = getNumber(value, "value");
  }
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value) {
    this.#gasLimit = getBigInt(value);
  }
  get gasPrice() {
    const value = this.#gasPrice;
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_07;
    }
    return value;
  }
  set gasPrice(value) {
    this.#gasPrice = value == null ? null : getBigInt(value, "gasPrice");
  }
  get maxPriorityFeePerGas() {
    const value = this.#maxPriorityFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
  }
  get maxFeePerGas() {
    const value = this.#maxFeePerGas;
    if (value == null) {
      if (this.type === 2 || this.type === 3) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    this.#maxFeePerGas = value == null ? null : getBigInt(value, "maxFeePerGas");
  }
  get data() {
    return this.#data;
  }
  set data(value) {
    this.#data = hexlify(value);
  }
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = getBigInt(value, "value");
  }
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value);
  }
  get signature() {
    return this.#sig || null;
  }
  set signature(value) {
    this.#sig = value == null ? null : Signature.from(value);
  }
  get accessList() {
    const value = this.#accessList || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2 || this.type === 3) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    this.#accessList = value == null ? null : accessListify(value);
  }
  get authorizationList() {
    const value = this.#auths || null;
    if (value == null) {
      if (this.type === 4) {
        return [];
      }
    }
    return value;
  }
  set authorizationList(auths) {
    this.#auths = auths == null ? null : auths.map((a) => authorizationify(a));
  }
  get maxFeePerBlobGas() {
    const value = this.#maxFeePerBlobGas;
    if (value == null && this.type === 3) {
      return BN_07;
    }
    return value;
  }
  set maxFeePerBlobGas(value) {
    this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, "maxFeePerBlobGas");
  }
  get blobVersionedHashes() {
    let value = this.#blobVersionedHashes;
    if (value == null && this.type === 3) {
      return [];
    }
    return value;
  }
  set blobVersionedHashes(value) {
    if (value != null) {
      assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
      value = value.slice();
      for (let i = 0;i < value.length; i++) {
        assertArgument(isHexString(value[i], 32), "invalid blobVersionedHash", `value[${i}]`, value[i]);
      }
    }
    this.#blobVersionedHashes = value;
  }
  get blobs() {
    if (this.#blobs == null) {
      return null;
    }
    return this.#blobs.map((b2) => Object.assign({}, b2));
  }
  set blobs(_blobs) {
    if (_blobs == null) {
      this.#blobs = null;
      return;
    }
    const blobs = [];
    const versionedHashes = [];
    for (let i = 0;i < _blobs.length; i++) {
      const blob = _blobs[i];
      if (isBytesLike(blob)) {
        assert2(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
          operation: "set blobs()"
        });
        let data = getBytes(blob);
        assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i}]`, blob);
        if (data.length !== BLOB_SIZE) {
          const padded = new Uint8Array(BLOB_SIZE);
          padded.set(data);
          data = padded;
        }
        const commit = this.#kzg.blobToKzgCommitment(data);
        const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));
        blobs.push({
          data: hexlify(data),
          commitment: hexlify(commit),
          proof
        });
        versionedHashes.push(getVersionedHash(1, commit));
      } else {
        const commit = hexlify(blob.commitment);
        blobs.push({
          data: hexlify(blob.data),
          commitment: commit,
          proof: hexlify(blob.proof)
        });
        versionedHashes.push(getVersionedHash(1, commit));
      }
    }
    this.#blobs = blobs;
    this.#blobVersionedHashes = versionedHashes;
  }
  get kzg() {
    return this.#kzg;
  }
  set kzg(kzg) {
    if (kzg == null) {
      this.#kzg = null;
    } else {
      this.#kzg = getKzgLibrary(kzg);
    }
  }
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BN_07;
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BN_07;
    this.#chainId = BN_07;
    this.#sig = null;
    this.#accessList = null;
    this.#maxFeePerBlobGas = null;
    this.#blobVersionedHashes = null;
    this.#kzg = null;
    this.#blobs = null;
    this.#auths = null;
  }
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak256(this.#getSerialized(true, false));
  }
  get unsignedHash() {
    return keccak256(this.unsignedSerialized);
  }
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  isSigned() {
    return this.signature != null;
  }
  #getSerialized(signed, sidecar) {
    assert2(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    const sig = signed ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this, sig);
      case 1:
        return _serializeEip2930(this, sig);
      case 2:
        return _serializeEip1559(this, sig);
      case 3:
        return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
      case 4:
        return _serializeEip7702(this, sig);
    }
    assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  get serialized() {
    return this.#getSerialized(true, true);
  }
  get unsignedSerialized() {
    return this.#getSerialized(false, false);
  }
  inferType() {
    const types2 = this.inferTypes();
    if (types2.indexOf(2) >= 0) {
      return 2;
    }
    return types2.pop();
  }
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert2(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert2(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert2(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types2 = [];
    if (this.type != null) {
      types2.push(this.type);
    } else {
      if (this.authorizationList && this.authorizationList.length) {
        types2.push(4);
      } else if (hasFee) {
        types2.push(2);
      } else if (hasGasPrice) {
        types2.push(1);
        if (!hasAccessList) {
          types2.push(0);
        }
      } else if (hasAccessList) {
        types2.push(1);
        types2.push(2);
      } else if (hasBlob && this.to) {
        types2.push(3);
      } else {
        types2.push(0);
        types2.push(1);
        types2.push(2);
        types2.push(3);
      }
    }
    types2.sort();
    return types2;
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  isCancun() {
    return this.type === 3;
  }
  clone() {
    return Transaction.from(this);
  }
  toJSON() {
    const s = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  static from(tx) {
    if (tx == null) {
      return new Transaction;
    }
    if (typeof tx === "string") {
      const payload = getBytes(tx);
      if (payload[0] >= 127) {
        return Transaction.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return Transaction.from(_parseEip2930(payload));
        case 2:
          return Transaction.from(_parseEip1559(payload));
        case 3:
          return Transaction.from(_parseEip4844(payload));
        case 4:
          return Transaction.from(_parseEip7702(payload));
      }
      assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new Transaction;
    if (tx.type != null) {
      result.type = tx.type;
    }
    if (tx.to != null) {
      result.to = tx.to;
    }
    if (tx.nonce != null) {
      result.nonce = tx.nonce;
    }
    if (tx.gasLimit != null) {
      result.gasLimit = tx.gasLimit;
    }
    if (tx.gasPrice != null) {
      result.gasPrice = tx.gasPrice;
    }
    if (tx.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
    }
    if (tx.maxFeePerGas != null) {
      result.maxFeePerGas = tx.maxFeePerGas;
    }
    if (tx.maxFeePerBlobGas != null) {
      result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
    }
    if (tx.data != null) {
      result.data = tx.data;
    }
    if (tx.value != null) {
      result.value = tx.value;
    }
    if (tx.chainId != null) {
      result.chainId = tx.chainId;
    }
    if (tx.signature != null) {
      result.signature = Signature.from(tx.signature);
    }
    if (tx.accessList != null) {
      result.accessList = tx.accessList;
    }
    if (tx.authorizationList != null) {
      result.authorizationList = tx.authorizationList;
    }
    if (tx.blobVersionedHashes != null) {
      result.blobVersionedHashes = tx.blobVersionedHashes;
    }
    if (tx.kzg != null) {
      result.kzg = tx.kzg;
    }
    if (tx.blobs != null) {
      result.blobs = tx.blobs;
    }
    if (tx.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
      assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
    }
    if (tx.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
      assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
    }
    return result;
  }
}
// node_modules/ethers/lib.esm/hash/authorization.js
function hashAuthorization(auth) {
  assertArgument(typeof auth.address === "string", "invalid address for hashAuthorization", "auth.address", auth);
  return keccak256(concat([
    "0x05",
    encodeRlp([
      auth.chainId != null ? toBeArray(auth.chainId) : "0x",
      getAddress(auth.address),
      auth.nonce != null ? toBeArray(auth.nonce) : "0x"
    ])
  ]));
}
function verifyAuthorization(auth, sig) {
  return recoverAddress(hashAuthorization(auth), sig);
}
// node_modules/ethers/lib.esm/hash/id.js
function id(value) {
  return keccak256(toUtf8Bytes(value));
}
// node_modules/@adraffy/ens-normalize/dist/index.mjs
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
var FENCED = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
function decode_arithmetic(bytes2) {
  let pos = 0;
  function u16() {
    return bytes2[pos++] << 8 | bytes2[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1;i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes2[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0;i < N2; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b2 - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 2:
        return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
      case 1:
        return offset + bytes2[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n2 = s.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0;i < n2; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = 0;i < n2; i++)
    v[i] = x += signed(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n2 = next();
    if (!n2)
      break;
    prev += x;
    for (let i = 0;i < n2; i++) {
      ret.push(prev + i);
    }
    prev += n2 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length)
      return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x)
      break;
    v.push(x);
  }
  return v;
}
function read_transposed(n2, w, next) {
  let m = Array(n2).fill().map(() => []);
  for (let i = 0;i < w; i++) {
    read_deltas(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n2 = 1 + next();
  let m = read_transposed(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode([]), []);
  return ret;
  function decode(Q) {
    let S = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length)
        return decode(cps);
    });
    return { S, B, Q };
  }
  function expand({ S, B }, cps, saved) {
    if (S & 4 && saved === cps[cps.length - 1])
      return;
    if (S & 2)
      saved = cps[cps.length - 1];
    if (S & 1)
      ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len = s.length;pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0;i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a, b2) {
  let n2 = a.length;
  let c = n2 - b2.length;
  for (let i = 0;c == 0 && i < n2; i++)
    c = a[i] - b2[i];
  return c;
}
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
function init$1() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = new Map;
  RECOMP = new Map;
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b2] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = new Map;
        RECOMP.set(a, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b2) {
  if (a >= L0 && a < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a) && b2 > T0 && b2 < T1 && (a - S0) % T_COUNT == 0) {
    return a + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK)
    init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add3(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add3(L0 + l_index);
        add3(V0 + v_index);
        if (t_index > 0)
          add3(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add3(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1;i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j)
          break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x) => Array.from(x);
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}

class Emoji extends Array {
  get is_emoji() {
    return true;
  }
}
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;
function init() {
  if (MAPPED)
    return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v) => v.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set = new Set;
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N2 = read_array_while(r).map((x) => x + 96);
    if (N2.length) {
      let R = i >= unrestricted;
      N2[0] -= 32;
      N2 = str_from_cps(N2);
      if (R)
        N2 = `Restricted[${N2}]`;
      let P2 = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N: N2, P: P2, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = new Map;
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b2) => a - b2);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: new Map };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: new Set, V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = new Set;
  let multi = new Set;
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P)
      add_to_union(cp);
    for (let cp of g.Q)
      add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = new Map;
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = new Map;
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE);i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev)
    throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i = 1;i < n2; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i)
        throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n2)
    throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max2 = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0]))
    buf.push("");
  if (cps.length > max2) {
    max2 >>= 1;
    cps = [...cps.slice(0, max2), 8230, ...cps.slice(-max2)];
  }
  let prev = 0;
  let n2 = cps.length;
  for (let i = 0;i < n2; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split2(name, nfc, filter_fe0f));
}
function split2(name, nf, ef) {
  if (!name)
    return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0]))
            throw error_placement("leading combining mark");
          for (let i = 1;i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH)
      return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
      if (!maker.length)
        return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
}
function flatten(split3) {
  return split3.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split3.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length;i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp;j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i;k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node)
      break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}

// node_modules/ethers/lib.esm/hash/namehash.js
var Zeros2 = new Uint8Array(32);
Zeros2.fill(0);
function checkComponent(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  const bytes2 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0;i < bytes2.length; i++) {
    const d = bytes2[i];
    if (d === 46) {
      comps.push(checkComponent(bytes2.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes2.slice(last)));
  return comps;
}
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {}
  return false;
}
function namehash(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros2;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name, _maxLength) {
  const length = _maxLength != null ? _maxLength : 63;
  assertArgument(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    assertArgument(comp.length <= length, `label ${JSON.stringify(name)} exceeds ${length} bytes`, "name", name);
    const bytes2 = new Uint8Array(comp.length + 1);
    bytes2.set(comp, 1);
    bytes2[0] = bytes2.length - 1;
    return bytes2;
  }))) + "00";
}
// node_modules/ethers/lib.esm/hash/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage(message);
  return recoverAddress(digest, sig);
}
// node_modules/ethers/lib.esm/hash/solidity.js
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(getAddress(value));
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return getBytes(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let signed2 = match[1] === "int";
    let size = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray) {
      size = 256;
    }
    if (signed2) {
      value = toTwos(value, size);
    }
    return getBytes(zeroPadValue(toBeArray(value), size / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    assertArgument(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
    assertArgument(dataLength(value) === size, `invalid value for ${type}`, "value", value);
    if (isArray) {
      return getBytes(zeroPadBytes(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    assertArgument(count === value.length, `invalid array length for ${type}`, "value", value);
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return getBytes(concat(result));
  }
  assertArgument(false, "invalid type", "type", type);
}
function solidityPacked(types2, values) {
  assertArgument(types2.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types2.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function solidityPackedKeccak256(types2, values) {
  return keccak256(solidityPacked(types2, values));
}
function solidityPackedSha256(types2, values) {
  return sha2562(solidityPacked(types2, values));
}
// node_modules/ethers/lib.esm/hash/typed-data.js
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_08 = BigInt(0);
var BN_15 = BigInt(1);
var BN_MAX_UINT2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes2 = getBytes(value);
  const padOffset = bytes2.length % 32;
  if (padOffset) {
    return concat([bytes2, padding.slice(padOffset)]);
  }
  return hexlify(bytes2);
}
var hexTrue = toBeHex(BN_15, 32);
var hexFalse = toBeHex(BN_08, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value) {
    const value = getBigInt(_value, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {}
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes2 = getBytes(value, "domain.salt");
    assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes2);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2]);
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT2562, signed2 ? width - 1 : width);
      const boundsLower = signed2 ? (boundsUpper + BN_15) * BN__1 : BN_08;
      return function(_value) {
        const value = getBigInt(_value, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes2 = getBytes(value);
        assertArgument(bytes2.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields2) {
  return `${name}(${fields2.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
function splitArray(type) {
  const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return { base: type };
}

class TypedDataEncoder {
  primaryType;
  #types;
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  constructor(_types) {
    this.#fullTypes = new Map;
    this.#encoderCache = new Map;
    const links = new Map;
    const parents = new Map;
    const subtypes = new Map;
    const types2 = {};
    Object.keys(_types).forEach((type) => {
      types2[type] = _types[type].map(({ name, type: type2 }) => {
        let { base, index } = splitArray(type2);
        if (base === "int" && !_types["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types["uint"]) {
          base = "uint256";
        }
        return { name, type: base + (index || "") };
      });
      links.set(type, new Set);
      parents.set(type, []);
      subtypes.set(type, new Set);
    });
    this.#types = JSON.stringify(types2);
    for (const name in types2) {
      const uniqueNames = new Set;
      for (const field of types2[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
        uniqueNames.add(field.name);
        const baseType = splitArray(field.type).base;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", _types);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, new Set);
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      this.#fullTypes.set(name, encodeType(name, types2[name]) + st.map((t) => encodeType(t, types2[t])).join(""));
    }
  }
  getEncoder(type) {
    let encoder = this.#encoderCache.get(type);
    if (!encoder) {
      encoder = this.#getEncoder(type);
      this.#encoderCache.set(type, encoder);
    }
    return encoder;
  }
  #getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const array = splitArray(type).array;
    if (array) {
      const subtype = array.prefix;
      const subEncoder = this.getEncoder(subtype);
      return (value) => {
        assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
        let result = value.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result = result.map(keccak256);
        }
        return keccak256(concat(result));
      };
    }
    const fields2 = this.types[type];
    if (fields2) {
      const encodedType = id(this.#fullTypes.get(type));
      return (value) => {
        const values = fields2.map(({ name, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name]);
          if (this.#fullTypes.has(type2)) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return concat(values);
      };
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  encodeType(name) {
    const result = this.#fullTypes.get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name, value) {
    return keccak256(this.encodeData(name, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const array = splitArray(type).array;
    if (array) {
      assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
      return value.map((v) => this._visit(array.prefix, v, callback));
    }
    const fields2 = this.types[type];
    if (fields2) {
      return fields2.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types2) {
    return new TypedDataEncoder(types2);
  }
  static getPrimaryType(types2) {
    return TypedDataEncoder.from(types2).primaryType;
  }
  static hashStruct(name, types2, value) {
    return TypedDataEncoder.from(types2).hashStruct(name, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types2, value) {
    return concat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types2).hash(value)
    ]);
  }
  static hash(domain, types2, value) {
    return keccak256(TypedDataEncoder.encode(domain, types2, value));
  }
  static async resolveNames(domain, types2, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = TypedDataEncoder.from(types2);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  static getPayload(domain, types2, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = TypedDataEncoder.from(types2);
    types2 = encoder.types;
    const typesWithDomain = Object.assign({}, types2);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
}
function verifyTypedData(domain, types2, value, signature) {
  return recoverAddress(TypedDataEncoder.hash(domain, types2, value), signature);
}
// node_modules/ethers/lib.esm/abi/fragments.js
function setify(items) {
  const result = new Set;
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
var _kwVisibDeploy = "external public payable override";
var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
var _kwVisib = "constant external internal payable private public pure view override";
var KwVisib = setify(_kwVisib.split(" "));
var _kwTypes = "constructor error event fallback function receive struct";
var KwTypes = setify(_kwTypes.split(" "));
var _kwModifiers = "calldata memory storage payable indexed";
var KwModifiers = setify(_kwModifiers.split(" "));
var _kwOther = "tuple returns";
var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
var Keywords = setify(_keywords.split(" "));
var SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix = new RegExp("^(\\s*)");
var regexNumberPrefix = new RegExp("^([0-9]+)");
var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");

class TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new TokenString(this.#tokens.slice(from, to).map((t) => {
      return Object.freeze(Object.assign({}, t, {
        match: t.match - from,
        linkBack: t.linkBack - from,
        linkNext: t.linkNext - from
      }));
    }));
  }
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  popType(type) {
    if (this.peek().type !== type) {
      const top = this.peek();
      throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);
    }
    return this.pop().text;
  }
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result;
  }
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (this.#offset < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(this.#subTokenString(this.#offset + 1, link));
      this.#offset = link;
    }
    this.#offset = top.match + 1;
    return result;
  }
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  pop() {
    const result = this.peek();
    this.#offset++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = this.#offset;i < this.#tokens.length; i++) {
      const token = this.#tokens[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
}
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = new Set;
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
  }
}
var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
var _guard4 = {};
var internal = Symbol.for("_ethers_internal");
var ParamTypeInternal = "_ParamTypeInternal";
var ErrorFragmentInternal = "_ErrorInternal";
var EventFragmentInternal = "_EventInternal";
var ConstructorFragmentInternal = "_ConstructorInternal";
var FallbackFragmentInternal = "_FallbackInternal";
var FunctionFragmentInternal = "_FunctionInternal";
var StructFragmentInternal = "_StructInternal";

class ParamType {
  name;
  type;
  baseType;
  indexed;
  components;
  arrayLength;
  arrayChildren;
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    assertPrivate(guard, _guard4, "ParamType");
    Object.defineProperty(this, internal, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  isArray() {
    return this.baseType === "array";
  }
  isTuple() {
    return this.baseType === "tuple";
  }
  isIndexable() {
    return this.indexed != null;
  }
  walk(value, process2) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process2));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process2));
    }
    return process2(this.type, value);
  }
  #walkAsync(promises, value, process2, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result2 = value.slice();
      result2.forEach((value2, index) => {
        childType.#walkAsync(promises, value2, process2, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result2;
      if (Array.isArray(value)) {
        result2 = value.slice();
      } else {
        if (value == null || typeof value !== "object") {
          throw new Error("invalid tuple value");
        }
        result2 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value[param.name];
        });
      }
      if (result2.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result2.forEach((value2, index) => {
        components[index].#walkAsync(promises, value2, process2, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    const result = process2(this.type, value);
    if (result.then) {
      promises.push(async function() {
        setValue(await result);
      }());
    } else {
      setValue(result);
    }
  }
  async walkAsync(value, process2) {
    const promises = [];
    const result = [value];
    this.#walkAsync(promises, value, process2, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  static from(obj, allowIndexed) {
    if (ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => ParamType.from(t));
        type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new ParamType(_guard4, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new ParamType(_guard4, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new ParamType(_guard4, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith("tuple(") || type.startsWith("(")) {
      const comps = obj.components != null ? obj.components.map((c) => ParamType.from(c)) : null;
      const tuple = new ParamType(_guard4, name || "", type, "tuple", indexed, comps, null, null);
      return tuple;
    }
    type = verifyBasicType(obj.type);
    return new ParamType(_guard4, name || "", type, type, indexed, null, null, null);
  }
  static isParamType(value) {
    return value && value[internal] === ParamTypeInternal;
  }
}

class Fragment {
  type;
  inputs;
  constructor(guard, type, inputs) {
    assertPrivate(guard, _guard4, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e) {}
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert2(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}

class NamedFragment extends Fragment {
  name;
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}
function joinParams(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}

class ErrorFragment extends NamedFragment {
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
  }
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format, this.inputs));
    return result.join(" ");
  }
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard4, name, inputs);
    }
    return new ErrorFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  static isFragment(value) {
    return value && value[internal] === ErrorFragmentInternal;
  }
}

class EventFragment extends NamedFragment {
  anonymous;
  constructor(guard, name, inputs, anonymous) {
    super(guard, "event", name, inputs);
    Object.defineProperty(this, internal, { value: EventFragmentInternal });
    defineProperties(this, { anonymous });
  }
  get topicHash() {
    return id(this.format("sighash"));
  }
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new EventFragment(_guard4, name, params, false);
    return fragment.topicHash;
  }
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard4, name, inputs, anonymous);
    }
    return new EventFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  static isFragment(value) {
    return value && value[internal] === EventFragmentInternal;
  }
}

class ConstructorFragment extends Fragment {
  payable;
  gas;
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  format(format) {
    assert2(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : undefined,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
      });
    }
    const result = [`constructor${joinParams(format, this.inputs)}`];
    if (this.payable) {
      result.push("payable");
    }
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard4, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard4, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  static isFragment(value) {
    return value && value[internal] === ConstructorFragmentInternal;
  }
}

class FallbackFragment extends Fragment {
  payable;
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  format(format) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard4, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard4, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard4, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard4, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  static isFragment(value) {
    return value && value[internal] === FallbackFragmentInternal;
  }
}

class FunctionFragment extends NamedFragment {
  constant;
  outputs;
  stateMutability;
  payable;
  gas;
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  format(format) {
    if (format == null) {
      format = "sighash";
    }
    if (format === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas != null ? this.gas : undefined,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
      });
    }
    const result = [];
    if (format !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format, this.inputs));
    if (format !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new FunctionFragment(_guard4, name, "view", params, [], null);
    return fragment.selector;
  }
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard4, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard4, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  static isFragment(value) {
    return value && value[internal] === FunctionFragmentInternal;
  }
}

class StructFragment extends NamedFragment {
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal, { value: StructFragmentInternal });
  }
  format() {
    throw new Error("@TODO");
  }
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard4, name, inputs);
    }
    return new StructFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  static isFragment(value) {
    return value && value[internal] === StructFragmentInternal;
  }
}

// node_modules/ethers/lib.esm/abi/abi-coder.js
var PanicReasons = new Map;
PanicReasons.set(0, "GENERIC_PANIC");
PanicReasons.set(1, "ASSERT_FALSE");
PanicReasons.set(17, "OVERFLOW");
PanicReasons.set(18, "DIVIDE_BY_ZERO");
PanicReasons.set(33, "ENUM_RANGE_ERROR");
PanicReasons.set(34, "BAD_STORAGE_DATA");
PanicReasons.set(49, "STACK_UNDERFLOW");
PanicReasons.set(50, "ARRAY_RANGE_ERROR");
PanicReasons.set(65, "OUT_OF_MEMORY");
PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder = null;
var defaultMaxInflation = 1024;
function getBuiltinCallException(action, tx, data, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data) {
    message = "execution reverted";
    const bytes2 = getBytes(data);
    data = hexlify(data);
    if (bytes2.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes2.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data,
    reason,
    transaction,
    invocation,
    revert
  });
}

class AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder(size, param.name);
    }
    assertArgument(false, "invalid type", "type", param.type);
  }
  getDefaultValue(types2) {
    const coders = types2.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types2, values) {
    assertArgumentCount(values.length, types2.length, "types/values length mismatch");
    const coders = types2.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer;
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types2, data, loose) {
    const coders = types2.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data, loose, defaultMaxInflation));
  }
  static _setDefaultMaxInflation(value) {
    assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
    defaultMaxInflation = value;
  }
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new AbiCoder;
    }
    return defaultCoder;
  }
  static getBuiltinCallException(action, tx, data) {
    return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
  }
}
// node_modules/ethers/lib.esm/abi/bytes32.js
function encodeBytes32String(text) {
  const bytes2 = toUtf8Bytes(text);
  if (bytes2.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return zeroPadBytes(bytes2, 32);
}
function decodeBytes32String(_bytes) {
  const data = getBytes(_bytes, "bytes");
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}
// node_modules/ethers/lib.esm/abi/interface.js
class LogDescription {
  fragment;
  name;
  signature;
  topic;
  args;
  constructor(fragment, topic, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature,
      topic,
      args
    });
  }
}

class TransactionDescription {
  fragment;
  name;
  args;
  signature;
  selector;
  value;
  constructor(fragment, selector, args, value) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector,
      value
    });
  }
}

class ErrorDescription {
  fragment;
  name;
  args;
  signature;
  selector;
  constructor(fragment, selector, args) {
    const name = fragment.name, signature = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature,
      selector
    });
  }
}

class Indexed {
  hash;
  _isIndexed;
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
  constructor(hash2) {
    defineProperties(this, { hash: hash2, _isIndexed: true });
  }
}
var PanicReasons2 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons2[code.toString()]) {
        reason = PanicReasons2[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};

class Interface {
  fragments;
  deploy;
  fallback;
  receive;
  #errors;
  #events;
  #functions;
  #abiCoder;
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    this.#functions = new Map;
    this.#errors = new Map;
    this.#events = new Map;
    const frags = [];
    for (const a of abi) {
      try {
        frags.push(Fragment.from(a));
      } catch (error) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  format(minimal) {
    const format = minimal ? "minimal" : "full";
    const abi = this.fragments.map((f2) => f2.format(format));
    return abi;
  }
  formatJson() {
    const abi = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi.map((j) => JSON.parse(j)));
  }
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  #getFunction(key, values, forceUnique) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i = matching.length - 1;i >= 0; i--) {
          const inputs = matching[i].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1;i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0;j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#functions.get(FunctionFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  forEachFunction(callback) {
    const names2 = Array.from(this.#functions.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0;i < names2.length; i++) {
      const name = names2[i];
      callback(this.#functions.get(name), i);
    }
  }
  #getEvent(key, values, forceUnique) {
    if (isHexString(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i = matching.length - 1;i >= 0; i--) {
          if (matching[i].inputs.length < values.length) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1;i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0;j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#events.get(EventFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  forEachEvent(callback) {
    const names2 = Array.from(this.#events.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0;i < names2.length; i++) {
      const name = names2[i];
      callback(this.#events.get(name), i);
    }
  }
  getError(key, values) {
    if (isHexString(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = this.#errors.get(key);
    if (result) {
      return result;
    }
    return null;
  }
  forEachError(callback) {
    const names2 = Array.from(this.#errors.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0;i < names2.length; i++) {
      const name = names2[i];
      callback(this.#errors.get(name), i);
    }
  }
  _decodeParams(params, data) {
    return this.#abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  decodeFunctionData(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
    return this._decodeParams(fragment.inputs, dataSlice(data, 4));
  }
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  decodeFunctionResult(fragment, data) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes2 = getBytesCopy(data);
    if (bytes2.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes2);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert2(false, message, "BAD_DATA", {
      value: hexlify(bytes2),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx) {
    const data = getBytes(_data, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx, data);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert2(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(fragment, data, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  parseTransaction(tx) {
    const data = getBytes(tx.data, "tx.data");
    const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data) {
    throw new Error("@TODO");
  }
  parseLog(log3) {
    const fragment = this.getEvent(log3.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log3.data, log3.topics));
  }
  parseError(data) {
    const hexData = hexlify(data);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  static from(value) {
    if (value instanceof Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new Interface(JSON.parse(value));
    }
    if (typeof value.formatJson === "function") {
      return new Interface(value.formatJson());
    }
    if (typeof value.format === "function") {
      return new Interface(value.format("json"));
    }
    return new Interface(value);
  }
}
// node_modules/ethers/lib.esm/providers/provider.js
var BN_09 = BigInt(0);
function getValue2(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}

class FeeData {
  gasPrice;
  maxFeePerGas;
  maxPriorityFeePerGas;
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties(this, {
      gasPrice: getValue2(gasPrice),
      maxFeePerGas: getValue2(maxFeePerGas),
      maxPriorityFeePerGas: getValue2(maxPriorityFeePerGas)
    });
  }
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if (req.authorizationList) {
    result.authorizationList = req.authorizationList.slice();
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map((b2) => {
      if (isBytesLike(b2)) {
        return hexlify(b2);
      }
      return Object.assign({}, b2);
    });
  }
  return result;
}

class Block {
  provider;
  number;
  hash;
  timestamp;
  parentHash;
  parentBeaconBlockRoot;
  nonce;
  difficulty;
  gasLimit;
  gasUsed;
  stateRoot;
  receiptsRoot;
  blobGasUsed;
  excessBlobGas;
  miner;
  prevRandao;
  extraData;
  baseFeePerGas;
  #transactions;
  constructor(block, provider) {
    this.#transactions = block.transactions.map((tx) => {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    });
    defineProperties(this, {
      provider,
      hash: getValue2(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue2(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue2(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  get transactions() {
    return this.#transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return tx.hash;
    });
  }
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert2(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash2, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      blobGasUsed: toJson(this.blobGasUsed),
      excessBlobGas: toJson(this.excessBlobGas),
      hash: hash2,
      miner,
      prevRandao,
      nonce,
      number: number2,
      parentHash,
      timestamp,
      parentBeaconBlockRoot,
      stateRoot,
      receiptsRoot,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get length() {
    return this.#transactions.length;
  }
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1000);
  }
  async getTransaction(indexOrHash) {
    let tx = undefined;
    if (typeof indexOrHash === "number") {
      tx = this.#transactions[indexOrHash];
    } else {
      const hash2 = indexOrHash.toLowerCase();
      for (const v of this.#transactions) {
        if (typeof v === "string") {
          if (v !== hash2) {
            continue;
          }
          tx = v;
          break;
        } else {
          if (v.hash !== hash2) {
            continue;
          }
          tx = v;
          break;
        }
      }
    }
    if (tx == null) {
      throw new Error("no such tx");
    }
    if (typeof tx === "string") {
      return await this.provider.getTransaction(tx);
    } else {
      return tx;
    }
  }
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx of txs) {
      if (tx.hash === indexOrHash) {
        return tx;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  isMined() {
    return !!this.hash;
  }
  isLondon() {
    return !!this.baseFeePerGas;
  }
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}

class Log {
  provider;
  transactionHash;
  blockHash;
  blockNumber;
  removed;
  address;
  data;
  topics;
  index;
  transactionIndex;
  constructor(log3, provider) {
    this.provider = provider;
    const topics = Object.freeze(log3.topics.slice());
    defineProperties(this, {
      transactionHash: log3.transactionHash,
      blockHash: log3.blockHash,
      blockNumber: log3.blockNumber,
      removed: log3.removed,
      address: log3.address,
      data: log3.data,
      topics,
      index: log3.index,
      transactionIndex: log3.transactionIndex
    });
  }
  toJSON() {
    const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address,
      blockHash,
      blockNumber,
      data,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    assert2(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block;
  }
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.transactionHash);
    assert2(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx;
  }
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert2(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}

class TransactionReceipt {
  provider;
  to;
  from;
  contractAddress;
  hash;
  index;
  blockHash;
  blockNumber;
  logsBloom;
  gasUsed;
  blobGasUsed;
  cumulativeGasUsed;
  gasPrice;
  blobGasPrice;
  type;
  status;
  root;
  #logs;
  constructor(tx, provider) {
    this.#logs = Object.freeze(tx.logs.map((log3) => {
      return new Log(log3, provider);
    }));
    let gasPrice = BN_09;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      status: tx.status,
      root: tx.root
    });
  }
  get logs() {
    return this.#logs;
  }
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash2,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      blobGasUsed: toJson(this.blobGasUsed),
      blobGasPrice: toJson(this.blobGasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash2,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  async getBlock() {
    const block = await this.provider.getBlock(this.blockHash);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  async getTransaction() {
    const tx = await this.provider.getTransaction(this.hash);
    if (tx == null) {
      throw new Error("TODO");
    }
    return tx;
  }
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  reorderedEvent(other) {
    assert2(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}

class TransactionResponse {
  provider;
  blockNumber;
  blockHash;
  index;
  hash;
  type;
  to;
  from;
  nonce;
  gasLimit;
  gasPrice;
  maxPriorityFeePerGas;
  maxFeePerGas;
  maxFeePerBlobGas;
  data;
  value;
  chainId;
  signature;
  accessList;
  blobVersionedHashes;
  authorizationList;
  #startBlock;
  constructor(tx, provider) {
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;
    this.#startBlock = -1;
  }
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash2, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;
    return {
      _type: "TransactionResponse",
      accessList,
      blockNumber,
      blockHash,
      blobVersionedHashes,
      chainId: toJson(this.chainId),
      data,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash2,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
      nonce,
      signature,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx = await this.getTransaction();
      if (tx) {
        blockNumber = tx.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block = this.provider.getBlock(blockNumber);
    if (block == null) {
      throw new Error("TODO");
    }
    return block;
  }
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx == null || tx.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block = await this.provider.getBlock(nextScan, true);
        if (block == null) {
          return;
        }
        for (const hash2 of block) {
          if (hash2 === this.hash) {
            return;
          }
        }
        for (let i = 0;i < block.length; i++) {
          const tx = await block.getTransaction(i);
          if (tx.from === this.from && tx.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
              reason = "repriced";
            } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_09) {
              reason = "cancelled";
            }
            assert2(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx.replaceableTransaction(startBlock),
              hash: tx.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert2(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (confirms === 1 || await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c) => c());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  isMined() {
    return this.blockHash != null;
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  isCancun() {
    return this.type === 3;
  }
  removedEvent() {
    assert2(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  reorderedEvent(other) {
    assert2(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert2(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx = new TransactionResponse(this, this.provider);
    tx.#startBlock = startBlock;
    return tx;
  }
}
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log3) {
  return { orphan: "drop-log", log: {
    transactionHash: log3.transactionHash,
    blockHash: log3.blockHash,
    blockNumber: log3.blockNumber,
    address: log3.address,
    data: log3.data,
    topics: Object.freeze(log3.topics.slice()),
    index: log3.index
  } };
}

// node_modules/ethers/lib.esm/contract/wrappers.js
class EventLog extends Log {
  interface;
  fragment;
  args;
  constructor(log3, iface, fragment) {
    super(log3, log3.provider);
    const args = iface.decodeEventLog(fragment, log3.data, log3.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  get eventName() {
    return this.fragment.name;
  }
  get eventSignature() {
    return this.fragment.format();
  }
}

class UndecodedEventLog extends Log {
  error;
  constructor(log3, error) {
    super(log3, log3.provider);
    defineProperties(this, { error });
  }
}

class ContractTransactionReceipt extends TransactionReceipt {
  #iface;
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  get logs() {
    return super.logs.map((log3) => {
      const fragment = log3.topics.length ? this.#iface.getEvent(log3.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log3, this.#iface, fragment);
        } catch (error) {
          return new UndecodedEventLog(log3, error);
        }
      }
      return log3;
    });
  }
}

class ContractTransactionResponse extends TransactionResponse {
  #iface;
  constructor(iface, provider, tx) {
    super(tx, provider);
    this.#iface = iface;
  }
  async wait(confirms, timeout) {
    const receipt = await super.wait(confirms, timeout);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
  }
}

class ContractUnknownEventPayload extends EventPayload {
  log;
  constructor(contract, listener, filter, log3) {
    super(contract, listener, filter);
    defineProperties(this, { log: log3 });
  }
  async getBlock() {
    return await this.log.getBlock();
  }
  async getTransaction() {
    return await this.log.getTransaction();
  }
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}

class ContractEventPayload extends ContractUnknownEventPayload {
  constructor(contract, listener, filter, fragment, _log) {
    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  get eventName() {
    return this.fragment.name;
  }
  get eventSignature() {
    return this.fragment.format();
  }
}

// node_modules/ethers/lib.esm/contract/contract.js
var BN_010 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return;
}

class PreparedTopicFilter {
  #filter;
  fragment;
  constructor(contract, fragment, args) {
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract.runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    this.#filter = async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress(v, resolver)));
            }
            return resolveAddress(value, resolver);
          }
          return value;
        });
      }));
      return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
    }();
  }
  getTopicFilter() {
    return this.#filter;
  }
}
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_010, "overrides.value") === BN_010;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract.runner, "call");
    assert2(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(overrides);
    try {
      return await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract.runner;
    assert2(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(overrides));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert2(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key, args);
    assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract.runner;
    assert2(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner.sendTransaction(await populateTransaction(...args));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner = getRunner(contract.runner, "estimateGas");
    assert2(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract.runner, "call");
    assert2(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment,
    estimateGas,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key);
      assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key, args);
    assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key),
    _contract: contract,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key);
      assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
}
var internal2 = Symbol.for("_ethersInternal_contract");
var internalValues = new WeakMap;
function setInternal(contract, values) {
  internalValues.set(contract[internal2], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal2]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag2 = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag: tag2, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider(contract.runner);
  assert2(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag: tag2, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub2 = subs.get(tag2);
  if (!sub2) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log3) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log3.topics[0]);
        } catch (error) {}
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log3.data, log3.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log3);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log3);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub2 = { tag: tag2, listeners: [], start, stop };
    subs.set(tag2, sub2);
  }
  return sub2;
}
var lastEmit = Promise.resolve();
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub2 = await hasSub(contract, event);
  if (!sub2) {
    return false;
  }
  const count = sub2.listeners.length;
  sub2.listeners = sub2.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {}
    return !once;
  });
  if (sub2.listeners.length === 0) {
    sub2.stop();
    getInternal(contract).subs.delete(sub2.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {}
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
var passProperties2 = ["then"];

class BaseContract {
  target;
  interface;
  runner;
  filters;
  [internal2];
  fallback;
  constructor(target, abi, runner, _deployTx) {
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal2, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
    }
    let subs = new Map;
    if (typeof target === "string") {
      if (isHexString(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return;
      },
      has: (target2, prop) => {
        if (passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  connect(runner) {
    return new BaseContract(this.target, this.interface, runner);
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  async getDeployedCode() {
    const provider = getProvider(this.runner);
    assert2(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider = getProvider(this.runner);
    assert2(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  async queryTransaction(hash2) {
    throw new Error("@TODO");
  }
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter = { address, topics, fromBlock, toBlock };
    const provider = getProvider(this.runner);
    assert2(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider.getLogs(filter)).map((log3) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log3.topics[0]);
        } catch (error) {}
      }
      if (foundFragment) {
        try {
          return new EventLog(log3, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log3, error);
        }
      }
      return new Log(log3, provider);
    });
  }
  async on(event, listener) {
    const sub2 = await getSub(this, "on", event);
    sub2.listeners.push({ listener, once: false });
    sub2.start();
    return this;
  }
  async once(event, listener) {
    const sub2 = await getSub(this, "once", event);
    sub2.listeners.push({ listener, once: true });
    sub2.start();
    return this;
  }
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  async listenerCount(event) {
    if (event) {
      const sub2 = await hasSub(this, event);
      if (!sub2) {
        return 0;
      }
      return sub2.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub2 = await hasSub(this, event);
      if (!sub2) {
        return [];
      }
      return sub2.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub2 = await hasSub(this, event);
    if (!sub2) {
      return this;
    }
    if (listener) {
      const index = sub2.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub2.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub2.listeners.length === 0) {
      sub2.stop();
      getInternal(this).subs.delete(sub2.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const sub2 = await hasSub(this, event);
      if (!sub2) {
        return this;
      }
      sub2.stop();
      getInternal(this).subs.delete(sub2.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag: tag2, stop } of subs.values()) {
        stop();
        subs.delete(tag2);
      }
    }
    return this;
  }
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  static buildClass(abi) {

    class CustomContract extends BaseContract {
      constructor(address, runner = null) {
        super(address, abi, runner);
      }
    }
    return CustomContract;
  }
  static from(target, abi, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract = new this(target, abi, runner);
    return contract;
  }
}
function _ContractBase() {
  return BaseContract;
}

class Contract extends _ContractBase() {
}
// node_modules/ethers/lib.esm/contract/factory.js
class ContractFactory {
  interface;
  bytecode;
  runner;
  constructor(abi, bytecode, runner) {
    const iface = Interface.from(abi);
    if (bytecode instanceof Uint8Array) {
      bytecode = hexlify(getBytes(bytecode));
    } else {
      if (typeof bytecode === "object") {
        bytecode = bytecode.object;
      }
      if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
      }
      bytecode = hexlify(getBytes(bytecode));
    }
    defineProperties(this, {
      bytecode,
      interface: iface,
      runner: runner || null
    });
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  async getDeployTransaction(...args) {
    let overrides = {};
    const fragment = this.interface.deploy;
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("incorrect number of arguments to constructor");
    }
    const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);
    const data = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
    return Object.assign({}, overrides, { data });
  }
  async deploy(...args) {
    const tx = await this.getDeployTransaction(...args);
    assert2(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
      operation: "sendTransaction"
    });
    const sentTx = await this.runner.sendTransaction(tx);
    const address = getCreateAddress(sentTx);
    return new BaseContract(address, this.interface, this.runner, sentTx);
  }
  connect(runner) {
    return new ContractFactory(this.interface, this.bytecode, runner);
  }
  static fromSolidity(output2, runner) {
    assertArgument(output2 != null, "bad compiler output", "output", output2);
    if (typeof output2 === "string") {
      output2 = JSON.parse(output2);
    }
    const abi = output2.abi;
    let bytecode = "";
    if (output2.bytecode) {
      bytecode = output2.bytecode;
    } else if (output2.evm && output2.evm.bytecode) {
      bytecode = output2.evm.bytecode;
    }
    return new this(abi, bytecode, runner);
  }
}
// node_modules/ethers/lib.esm/providers/ens-resolver.js
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}

class MulticoinProviderPlugin {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  supportsCoinType(coinType) {
    return false;
  }
  async encodeAddress(coinType, address) {
    throw new Error("unsupported coin");
  }
  async decodeAddress(coinType, data) {
    throw new Error("unsupported coin");
  }
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];

class EnsResolver {
  provider;
  address;
  name;
  #supports2544;
  #resolver;
  constructor(provider, address, name) {
    defineProperties(this, { provider, address, name });
    this.#supports2544 = null;
    this.#resolver = new Contract(address, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider);
  }
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error;
        }
      })();
    }
    return await this.#supports2544;
  }
  async#fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert2(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode(this.name, 255),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result)[0];
      }
      return result;
    } catch (error) {
      if (!isError(error, "CALL_EXCEPTION")) {
        throw error;
      }
    }
    return null;
  }
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await this.#fetch("addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data2 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString(data2, 20)) {
        return getAddress(data2);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data == null || data === "0x") {
      return null;
    }
    const address = await coinPlugin.decodeAddress(coinType, data);
    if (address != null) {
      return address;
    }
    assert2(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data }
    });
  }
  async getText(key) {
    const data = await this.#fetch("text(bytes32,string)", [key]);
    if (data == null || data === "0x") {
      return null;
    }
    return data;
  }
  async getContentHash() {
    const data = await this.#fetch("contenthash(bytes32)");
    if (data == null || data === "0x") {
      return null;
    }
    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert2(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data }
    });
  }
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0;i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract = new Contract(comps[0], [
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes2 = response.body;
                if (bytes2) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {} else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {}
    return { linkage, url: null };
  }
  static async getEnsAddress(provider) {
    const network = await provider.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert2(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async#getResolver(provider, name) {
    const ensAddr = await EnsResolver.getEnsAddress(provider);
    try {
      const contract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider);
      const addr = await contract.resolver(namehash(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress) {
        return null;
      }
      return addr;
    } catch (error) {
      throw error;
    }
    return null;
  }
  static async fromName(provider, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await EnsResolver.#getResolver(provider, currentName);
      if (addr != null) {
        const resolver = new EnsResolver(provider, addr, name);
        if (currentName !== name && !await resolver.supportsWildcard()) {
          return null;
        }
        return resolver;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
}

// node_modules/ethers/lib.esm/providers/format.js
var BN_011 = BigInt(0);
function allowNull(format, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  };
}
function arrayOf(format, allowNull2) {
  return (array) => {
    if (allowNull2 && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format(i));
  };
}
function object(format, altNames) {
  return (value) => {
    const result = {};
    for (const key in format) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key](value[srcKey]);
        if (nv !== undefined) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert2(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString(value, 32), "invalid hash", "value", value);
  return value;
}
var _formatLog = object({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
var _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(getBigInt, null),
  excessBlobGas: allowNull(getBigInt, null),
  miner: allowNull(getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
var _formatReceiptLog = object({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
var _formatTransactionReceipt = object({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  blobGasUsed: allowNull(getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  blobGasPrice: allowNull(getBigInt, null),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_011) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    index: allowNull(getNumber, undefined),
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    authorizationList: allowNull(arrayOf((v) => {
      let sig;
      if (v.signature) {
        sig = v.signature;
      } else {
        let yParity = v.yParity;
        if (yParity === "0x1b") {
          yParity = 0;
        } else if (yParity === "0x1c") {
          yParity = 1;
        }
        sig = Object.assign({}, v, { yParity });
      }
      return {
        address: getAddress(v.address),
        chainId: getBigInt(v.chainId),
        nonce: getBigInt(v.nonce),
        signature: Signature.from(sig)
      };
    }, false), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    maxFeePerBlobGas: allowNull(getBigInt, null),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature.from(value.signature);
  } else {
    result.signature = Signature.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_011) {
    result.blockHash = null;
  }
  return result;
}

// node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";

class NetworkPlugin {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  clone() {
    return new NetworkPlugin(this.name);
  }
}

class GasCostPlugin extends NetworkPlugin {
  effectiveBlock;
  txBase;
  txCreate;
  txDataZero;
  txDataNonzero;
  txAccessListStorageKey;
  txAccessListAddress;
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21000);
    set("txCreate", 32000);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}

class EnsPlugin extends NetworkPlugin {
  address;
  targetNetwork;
  constructor(address, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties(this, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}

class FeeDataNetworkPlugin extends NetworkPlugin {
  #feeDataFunc;
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  async getFeeData(provider) {
    return await this.#feeDataFunc(provider);
  }
  clone() {
    return new FeeDataNetworkPlugin(this.#feeDataFunc);
  }
}

class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  #url;
  #processFunc;
  get url() {
    return this.#url;
  }
  get processFunc() {
    return this.#processFunc;
  }
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url;
    this.#processFunc = processFunc;
  }
  clone() {
    return this;
  }
}

// node_modules/ethers/lib.esm/providers/network.js
var Networks = new Map;

class Network {
  #name;
  #chainId;
  #plugins;
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt(chainId);
    this.#plugins = new Map;
  }
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value, "chainId");
  }
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {}
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {}
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {}
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  clone() {
    const clone3 = new Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone3.attachPlugin(plugin.clone());
    });
    return clone3;
  }
  computeIntrinsicGas(tx) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin;
    let gas = costs.txBase;
    if (tx.to == null) {
      gas += costs.txCreate;
    }
    if (tx.data) {
      for (let i = 2;i < tx.data.length; i += 2) {
        if (tx.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx.accessList) {
      const accessList = accessListify(tx.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone3 = network.clone();
      return clone3;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom = new Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
}
function parseUnits2(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits2(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits2(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert2(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
var injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin);
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("holesky", 17000, { ensNetwork: 17000 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, { ensNetwork: 1 });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}

// node_modules/ethers/lib.esm/providers/subscriber-polling.js
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
class PollingBlockSubscriber {
  #provider;
  #poller;
  #interval;
  #blockNumber;
  constructor(provider) {
    this.#provider = provider;
    this.#poller = null;
    this.#interval = 4000;
    this.#blockNumber = -2;
  }
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value) {
    this.#interval = value;
  }
  async#poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b2 = this.#blockNumber + 1;b2 <= blockNumber; b2++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b2);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error) {}
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}

class OnBlockSubscriber {
  #provider;
  #poll;
  #running;
  constructor(provider) {
    this.#provider = provider;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  async _poll(blockNumber, provider) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}

class PollingBlockTagSubscriber extends OnBlockSubscriber {
  #tag;
  #lastBlock;
  constructor(provider, tag2) {
    super(provider);
    this.#tag = tag2;
    this.#lastBlock = -2;
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#lastBlock = -2;
    }
    super.pause(dropWhilePaused);
  }
  async _poll(blockNumber, provider) {
    const block = await provider.getBlock(this.#tag);
    if (block == null) {
      return;
    }
    if (this.#lastBlock === -2) {
      this.#lastBlock = block.number;
    } else if (block.number > this.#lastBlock) {
      provider.emit(this.#tag, block.number);
      this.#lastBlock = block.number;
    }
  }
}

class PollingOrphanSubscriber extends OnBlockSubscriber {
  #filter;
  constructor(provider, filter) {
    super(provider);
    this.#filter = copy(filter);
  }
  async _poll(blockNumber, provider) {
    throw new Error("@TODO");
    console.log(this.#filter);
  }
}

class PollingTransactionSubscriber extends OnBlockSubscriber {
  #hash;
  constructor(provider, hash2) {
    super(provider);
    this.#hash = hash2;
  }
  async _poll(blockNumber, provider) {
    const tx = await provider.getTransactionReceipt(this.#hash);
    if (tx) {
      provider.emit(this.#hash, tx);
    }
  }
}

class PollingEventSubscriber {
  #provider;
  #filter;
  #poller;
  #running;
  #blockNumber;
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = copy(filter);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async#poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter = copy(this.#filter);
    filter.fromBlock = this.#blockNumber + 1;
    filter.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log3 of logs) {
      this.#provider.emit(this.#filter, log3);
      this.#blockNumber = log3.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}

// node_modules/ethers/lib.esm/providers/abstract-provider.js
var BN_23 = BigInt(2);
var MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys = Object.keys(v);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
}

class UnmanagedSubscriber {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  start() {}
  stop() {}
  pause(dropWhilePaused) {}
  resume() {}
}
function copy2(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event, provider) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString(_event, 32)) {
    const hash2 = _event.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash2 }), hash: hash2 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy2(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a) => a.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event);
}
function getTime2() {
  return new Date().getTime();
}
var defaultOptions = {
  cacheTimeout: 250,
  pollingInterval: 4000
};

class AbstractProvider {
  #subs;
  #plugins;
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network = Network.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network);
      setTimeout(() => {
        this.emit("network", network, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = new Map;
    this.#subs = new Map;
    this.#plugins = new Map;
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = new Map;
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  get provider() {
    return this;
  }
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value) {
    this.#disableCcipRead = !!value;
  }
  async#perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag2 = getTag(req.method, req);
    let perform = this.#performCache.get(tag2);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag2, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag2) === perform) {
          this.#performCache.delete(tag2);
        }
      }, timeout);
    }
    return await perform;
  }
  async ccipReadFetch(tx, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
      return null;
    }
    const sender = tx.to.toLowerCase();
    const data = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0;i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      let resp;
      try {
        resp = await request.send();
      } catch (error) {
        errorMessages.push(error.message);
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error } });
        continue;
      }
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {}
      assert2(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert2(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx,
      info: { urls, errorMessages }
    });
  }
  _wrapBlock(value, network) {
    return new Block(formatBlock(value), this);
  }
  _wrapLog(value, network) {
    return new Log(formatLog(value), this);
  }
  _wrapTransactionReceipt(value, network) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  _wrapTransactionResponse(tx, network) {
    return new TransactionResponse(formatTransactionResponse(tx), this);
  }
  _detectNetwork() {
    assert2(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  async _perform(req) {
    assert2(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  async getBlockNumber() {
    const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  _getAddress(address) {
    return resolveAddress(address, this);
  }
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "finalized":
      case "latest":
      case "pending":
      case "safe":
        return blockTag;
    }
    if (isHexString(blockTag)) {
      if (isHexString(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  _getFilter(filter) {
    const topics = (filter.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter ? filter.blockHash : undefined;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address2 = undefined;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address2 = _address[0];
          break;
        default:
          _address.sort();
          address2 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter2 = {};
      if (address2) {
        filter2.address = address2;
      }
      if (topics.length) {
        filter2.topics = topics;
      }
      if (fromBlock2) {
        filter2.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter2.toBlock = toBlock2;
      }
      if (blockHash) {
        filter2.blockHash = blockHash;
      }
      return filter2;
    };
    let address = [];
    if (filter.address) {
      if (Array.isArray(filter.address)) {
        for (const addr of filter.address) {
          address.push(this._getAddress(addr));
        }
      } else {
        address.push(this._getAddress(filter.address));
      }
    }
    let fromBlock = undefined;
    if ("fromBlock" in filter) {
      fromBlock = this._getBlockTag(filter.fromBlock);
    }
    let toBlock = undefined;
    if ("toBlock" in filter) {
      toBlock = this._getBlockTag(filter.toBlock);
    }
    if (address.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address, fromBlock, toBlock);
  }
  _getTransactionRequest(_request) {
    const request = copyRequest(_request);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress(request[key], this);
      if (isPromise(addr)) {
        promises.push(async function() {
          request[key] = await addr;
        }());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise(blockTag)) {
        promises.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = (async () => {
        try {
          const network = await this._detectNetwork();
          this.emit("network", network, null);
          return network;
        } catch (error) {
          if (this.#networkPromise === detectNetwork) {
            this.#networkPromise = null;
          }
          throw error;
        }
      })();
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert2(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice, priorityFee } = await resolveProperties({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const value = await this.#perform({ method: "getGasPrice" });
            return getBigInt(value, "%response");
          } catch (error) {}
          return null;
        })(),
        priorityFee: (async () => {
          try {
            const value = await this.#perform({ method: "getPriorityFee" });
            return getBigInt(value, "%response");
          } catch (error) {}
          return null;
        })()
      });
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      const block = this._wrapBlock(_block, network);
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
        maxFeePerGas = block.baseFeePerGas * BN_23 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx = this._getTransactionRequest(_tx);
    if (isPromise(tx)) {
      tx = await tx;
    }
    return getBigInt(await this.#perform({
      method: "estimateGas",
      transaction: tx
    }), "%response");
  }
  async#call(tx, blockTag, attempt) {
    assert2(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
    });
    const transaction = copyRequest(tx);
    try {
      return hexlify(await this._perform({ method: "call", transaction, blockTag }));
    } catch (error) {
      if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
        const data = error.data;
        const txSender = await resolveAddress(transaction.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
        } catch (error2) {
          assert2(false, error2.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction,
            info: { data }
          });
        }
        assert2(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data,
          reason: "OffchainLookup",
          transaction,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        assert2(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction,
          info: { data: error.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx2 = {
          to: txSender,
          data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
        try {
          const result = await this.#call(tx2, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
          return result;
        } catch (error2) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
          throw error2;
        }
      }
      throw error;
    }
  }
  async#checkNetwork(promise) {
    const { value } = await resolveProperties({
      network: this.getNetwork(),
      value: promise
    });
    return value;
  }
  async call(_tx) {
    const { tx, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async#getAccountValue(request, _address, _blockTag) {
    let address = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address !== "string" || typeof blockTag !== "string") {
      [address, blockTag] = await Promise.all([address, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
  }
  async getBalance(address, blockTag) {
    return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
  }
  async getTransactionCount(address, blockTag) {
    return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
  }
  async getCode(address, blockTag) {
    return hexlify(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
  }
  async getStorage(address, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
  }
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash2, network } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx = Transaction.from(signedTx);
    if (tx.hash !== hash2) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
  }
  async#getBlock(block, includeTransactions) {
    if (isHexString(block, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  async getBlock(block, prefetchTxs) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#getBlock(block, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network);
  }
  async getTransaction(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network);
  }
  async getTransactionReceipt(hash2) {
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash2 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx = await this.#perform({ method: "getTransaction", hash: hash2 });
      if (tx == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network);
  }
  async getTransactionResult(hash2) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash2 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  async getLogs(_filter) {
    let filter = this._getFilter(_filter);
    if (isPromise(filter)) {
      filter = await filter;
    }
    const { network, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter })
    });
    return params.map((p) => this._wrapLog(p, network));
  }
  _getProvider(chainId) {
    assert2(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver = await this.getResolver(name);
    if (resolver) {
      return await resolver.getAddress();
    }
    return null;
  }
  async lookupAddress(address) {
    address = getAddress(address);
    const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver = await ensContract.resolver(node);
      if (resolver == null || resolver === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract(resolver, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash2, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash2);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash2);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert2(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime2() });
    }
    return timerId;
  }
  _forEachSubscriber(func) {
    for (const sub2 of this.#subs.values()) {
      func(sub2.subscriber);
    }
  }
  _getSubscriber(sub2) {
    switch (sub2.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub2.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "safe":
      case "finalized":
        return new PollingBlockTagSubscriber(this, sub2.type);
      case "event":
        return new PollingEventSubscriber(this, sub2.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub2.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub2.filter);
    }
    throw new Error(`unsupported event: ${sub2.type}`);
  }
  _recoverSubscriber(oldSub, newSub) {
    for (const sub2 of this.#subs.values()) {
      if (sub2.subscriber === oldSub) {
        if (sub2.started) {
          sub2.subscriber.stop();
        }
        sub2.subscriber = newSub;
        if (sub2.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async#hasSub(event, emitArgs) {
    let sub2 = await getSubscription(event, this);
    if (sub2.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub2 = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub2.tag) || null;
  }
  async#getSub(event) {
    const subscription = await getSubscription(event, this);
    const tag2 = subscription.tag;
    let sub2 = this.#subs.get(tag2);
    if (!sub2) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = new WeakMap;
      const nameMap = new Map;
      sub2 = { subscriber, tag: tag2, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag2, sub2);
    }
    return sub2;
  }
  async on(event, listener) {
    const sub2 = await this.#getSub(event);
    sub2.listeners.push({ listener, once: false });
    if (!sub2.started) {
      sub2.subscriber.start();
      sub2.started = true;
      if (this.#pausedState != null) {
        sub2.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub2 = await this.#getSub(event);
    sub2.listeners.push({ listener, once: true });
    if (!sub2.started) {
      sub2.subscriber.start();
      sub2.started = true;
      if (this.#pausedState != null) {
        sub2.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub2 = await this.#hasSub(event, args);
    if (!sub2 || sub2.listeners.length === 0) {
      return false;
    }
    const count = sub2.listeners.length;
    sub2.listeners = sub2.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {}
      return !once;
    });
    if (sub2.listeners.length === 0) {
      if (sub2.started) {
        sub2.subscriber.stop();
      }
      this.#subs.delete(sub2.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub2 = await this.#hasSub(event);
      if (!sub2) {
        return 0;
      }
      return sub2.listeners.length;
    }
    let total = 0;
    for (const { listeners } of this.#subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub2 = await this.#hasSub(event);
      if (!sub2) {
        return [];
      }
      return sub2.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of this.#subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub2 = await this.#hasSub(event);
    if (!sub2) {
      return this;
    }
    if (listener) {
      const index = sub2.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub2.listeners.splice(index, 1);
      }
    }
    if (!listener || sub2.listeners.length === 0) {
      if (sub2.started) {
        sub2.subscriber.stop();
      }
      this.#subs.delete(sub2.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag: tag2, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag2);
    } else {
      for (const [tag2, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag2);
      }
    }
    return this;
  }
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  get destroyed() {
    return this.#destroyed;
  }
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert2(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime2() - timer.time;
    }
  }
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime2();
      setTimeout(timer.func, timeout);
    }
  }
}
function _parseString(result, start) {
  try {
    const bytes2 = _parseBytes(result, start);
    if (bytes2) {
      return toUtf8String(bytes2);
    }
  } catch (error) {}
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {}
  return null;
}
function numPad(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
var empty = new Uint8Array([]);
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0;i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0;i < datas.length; i++) {
    const data = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return concat(result);
}
var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert2(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data, 0, 32);
  assert2(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data, 32, 64));
    const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data, urlsOffset + 32);
    for (let u = 0;u < urlsLength; u++) {
      const url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert2(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data, 96, 100);
  try {
    const extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}
// node_modules/ethers/lib.esm/providers/abstract-signer.js
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert2(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}

class AbstractSigner {
  provider;
  constructor(provider) {
    defineProperties(this, { provider: provider || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx) {
    const pop = await populate(this, tx);
    return pop;
  }
  async populateTransaction(tx) {
    const provider = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
    } else {
      pop.chainId = network.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider.getFeeData();
      assert2(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          if (pop.authorizationList && pop.authorizationList.length) {
            pop.type = 4;
          } else {
            pop.type = 2;
          }
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert2(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert2(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2 || pop.type === 3 || pop.type === 4) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async populateAuthorization(_auth) {
    const auth = Object.assign({}, _auth);
    if (auth.chainId == null) {
      auth.chainId = (await checkProvider(this, "getNetwork").getNetwork()).chainId;
    }
    if (auth.nonce == null) {
      auth.nonce = await this.getNonce();
    }
    return auth;
  }
  async estimateGas(tx) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
  }
  async call(tx) {
    return checkProvider(this, "call").call(await this.populateCall(tx));
  }
  async resolveName(name) {
    const provider = checkProvider(this, "resolveName");
    return await provider.resolveName(name);
  }
  async sendTransaction(tx) {
    const provider = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx);
    delete pop.from;
    const txObj = Transaction.from(pop);
    return await provider.broadcastTransaction(await this.signTransaction(txObj));
  }
  authorize(authorization) {
    assert2(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", { operation: "authorize" });
  }
}

class VoidSigner extends AbstractSigner {
  address;
  constructor(address, provider) {
    super(provider);
    defineProperties(this, { address });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
  #throwUnsupported(suffix, operation) {
    assert2(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
  }
  async signTransaction(tx) {
    this.#throwUnsupported("transactions", "signTransaction");
  }
  async signMessage(message) {
    this.#throwUnsupported("messages", "signMessage");
  }
  async signTypedData(domain, types2, value) {
    this.#throwUnsupported("typed-data", "signTypedData");
  }
}
// node_modules/ethers/lib.esm/providers/community.js
var shown = new Set;
function showThrottleMessage(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}
// node_modules/ethers/lib.esm/providers/subscriber-filterid.js
function copy3(obj) {
  return JSON.parse(JSON.stringify(obj));
}

class FilterIdSubscriber {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  constructor(provider) {
    this.#provider = provider;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  _subscribe(provider) {
    throw new Error("subclasses must override this");
  }
  _emitResults(provider, result) {
    throw new Error("subclasses must override this");
  }
  _recover(provider) {
    throw new Error("subclasses must override this");
  }
  async#poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error) {
        if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
          throw error;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network;
      }
      if (this.#network.chainId !== network.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result);
    } catch (error) {
      console.log("@TODO", error);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        if (this.#provider.destroyed) {
          return;
        }
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
}

class FilterIdEventSubscriber extends FilterIdSubscriber {
  #event;
  constructor(provider, filter) {
    super(provider);
    this.#event = copy3(filter);
  }
  _recover(provider) {
    return new PollingEventSubscriber(provider, this.#event);
  }
  async _subscribe(provider) {
    const filterId = await provider.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit(this.#event, provider._wrapLog(result, provider._network));
    }
  }
}

class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider) {
    return await provider.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider, results) {
    for (const result of results) {
      provider.emit("pending", result);
    }
  }
}

// node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
var defaultOptions2 = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4000
};

class JsonRpcSigner extends AbstractSigner {
  address;
  constructor(provider, address) {
    super(provider);
    address = getAddress(address);
    defineProperties(this, { address });
  }
  connect(provider) {
    assert2(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  async populateTransaction(tx) {
    return await this.populateCall(tx);
  }
  async sendUncheckedTransaction(_tx) {
    const tx = deepCopy(_tx);
    const promises = [];
    if (tx.from) {
      const _from = tx.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from;
      })());
    } else {
      tx.from = this.address;
    }
    if (tx.gasLimit == null) {
      promises.push((async () => {
        tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
      })());
    }
    if (tx.to != null) {
      const _to = tx.to;
      promises.push((async () => {
        tx.to = await resolveAddress(_to, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash2 = await this.sendUncheckedTransaction(tx);
    return await new Promise((resolve, reject) => {
      const timeouts = [1000, 100];
      let invalids = 0;
      const checkTx = async () => {
        try {
          const tx2 = await this.provider.getTransaction(hash2);
          if (tx2 != null) {
            resolve(tx2.replaceableTransaction(blockNumber));
            return;
          }
        } catch (error) {
          if (isError(error, "CANCELLED") || isError(error, "BAD_DATA") || isError(error, "NETWORK_ERROR") || isError(error, "UNSUPPORTED_OPERATION")) {
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            reject(error);
            return;
          }
          if (isError(error, "INVALID_ARGUMENT")) {
            invalids++;
            if (error.info == null) {
              error.info = {};
            }
            error.info.sendTransactionHash = hash2;
            if (invalids > 10) {
              reject(error);
              return;
            }
          }
          this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4000);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx = deepCopy(_tx);
    if (tx.from) {
      const from = await resolveAddress(tx.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx.from = from;
    } else {
      tx.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types2, _value) {
    const value = deepCopy(_value);
    const populated = await TypedDataEncoder.resolveNames(domain, types2, value, async (value2) => {
      const address = await resolveAddress(value2);
      assertArgument(address != null, "TypedData does not support null address", "value", value2);
      return address;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}

class JsonRpcApiProvider extends AbstractProvider {
  #options;
  #nextId;
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #pendingDetectNetwork;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes2 = JSON.stringify(batch.map((p) => p.payload));
          if (bytes2.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result });
            for (const { resolve, reject, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result.filter((r) => r.id === payload2.id)[0];
              if (resp == null) {
                const error = makeError("missing response for request", "BAD_DATA", {
                  value: result,
                  info: { payload: payload2 }
                });
                this.emit("error", error);
                reject(error);
                continue;
              }
              if ("error" in resp) {
                reject(this.getRpcError(payload2, resp));
                continue;
              }
              resolve(resp.result);
            }
          } catch (error) {
            this.emit("debug", { action: "receiveRpcError", error });
            for (const { reject } of batch) {
              reject(error);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network, options) {
    super(network, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions2, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    this.#pendingDetectNetwork = null;
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      this.#notReady = { promise, resolve };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        this.#network = Network.from(network);
      }
    } else if (staticNetwork) {
      assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  _getOption(key) {
    return this.#options[key];
  }
  get _network() {
    assert2(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx = req.transaction;
      if (tx && tx.type != null && getBigInt(tx.type)) {
        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx, { type: undefined })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  async _detectNetwork() {
    const network = this._getOption("staticNetwork");
    if (network) {
      if (network === true) {
        if (this.#network) {
          return this.#network;
        }
      } else {
        return network;
      }
    }
    if (this.#pendingDetectNetwork) {
      return await this.#pendingDetectNetwork;
    }
    if (this.ready) {
      this.#pendingDetectNetwork = (async () => {
        try {
          const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
          this.#pendingDetectNetwork = null;
          return result;
        } catch (error) {
          this.#pendingDetectNetwork = null;
          throw error;
        }
      })();
      return await this.#pendingDetectNetwork;
    }
    this.#pendingDetectNetwork = (async () => {
      const payload = {
        id: this.#nextId++,
        method: "eth_chainId",
        params: [],
        jsonrpc: "2.0"
      };
      this.emit("debug", { action: "sendRpcPayload", payload });
      let result;
      try {
        result = (await this._send(payload))[0];
        this.#pendingDetectNetwork = null;
      } catch (error) {
        this.#pendingDetectNetwork = null;
        this.emit("debug", { action: "receiveRpcError", error });
        throw error;
      }
      this.emit("debug", { action: "receiveRpcResult", result });
      if ("result" in result) {
        return Network.from(getBigInt(result.result));
      }
      throw this.getRpcError(payload, result);
    })();
    return await this.#pendingDetectNetwork;
  }
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error) {
          if (this.destroyed) {
            break;
          }
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall(1000);
        }
      }
      this.#scheduleDrain();
    })();
  }
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  _getSubscriber(sub2) {
    if (sub2.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub2.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub2.filter);
      }
      return new FilterIdEventSubscriber(this, sub2.filter);
    }
    if (sub2.type === "orphan" && sub2.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub2);
  }
  get ready() {
    return this.#notReady == null;
  }
  getRpcTransaction(tx) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      result[key] = hexlify(tx[key]);
    });
    if (tx.accessList) {
      result["accessList"] = accessListify(tx.accessList);
    }
    if (tx.blobVersionedHashes) {
      result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
    }
    if (tx.authorizationList) {
      result["authorizationList"] = tx.authorizationList.map((_a) => {
        const a = authorizationify(_a);
        return {
          address: a.address,
          nonce: toQuantity(a.nonce),
          chainId: toQuantity(a.chainId),
          yParity: toQuantity(a.signature.yParity),
          r: toQuantity(a.signature.r),
          s: toQuantity(a.signature.s)
        };
      });
    }
    return result;
  }
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getPriorityFee":
        return { method: "eth_maxPriorityFeePerGas", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error } = _error;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      } else if (msg.match(/nonce/i) && msg.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e.info = { error, payload };
      return e;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id2 = this.#nextId++;
    const promise = new Promise((resolve, reject) => {
      this.#payloads.push({
        resolve,
        reject,
        payload: { method, params, id: id2, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address === "number") {
      const accounts2 = await accountsPromise;
      if (address >= accounts2.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts2[address]);
    }
    const { accounts } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address = getAddress(address);
    for (const account of accounts) {
      if (getAddress(account) === address) {
        return new JsonRpcSigner(this, address);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts = await this.send("eth_accounts", []);
    return accounts.map((a) => new JsonRpcSigner(this, a));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject } of this.#payloads) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
}

class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  #pollingInterval;
  constructor(network, options) {
    super(network, options);
    let pollingInterval = this._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions2.pollingInterval;
    }
    this.#pollingInterval = pollingInterval;
  }
  _getSubscriber(sub2) {
    const subscriber = super._getSubscriber(sub2);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value;
    this._forEachSubscriber((sub2) => {
      if (isPollable(sub2)) {
        sub2.pollingInterval = this.#pollingInterval;
      }
    });
  }
}

class JsonRpcProvider extends JsonRpcApiPollingProvider {
  #connect;
  constructor(url, network, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network, options);
    if (typeof url === "string") {
      this.#connect = new FetchRequest(url);
    } else {
      this.#connect = url.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {}
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {}
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}

// node_modules/ethers/lib.esm/providers/provider-ankr.js
var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "sepolia":
      return "rpc.ankr.com/eth_sepolia";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
    case "base":
      return "rpc.ankr.com/base";
    case "base-goerli":
      return "rpc.ankr.com/base_goerli";
    case "base-sepolia":
      return "rpc.ankr.com/base_sepolia";
    case "bnb":
      return "rpc.ankr.com/bsc";
    case "bnbt":
      return "rpc.ankr.com/bsc_testnet_chapel";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "matic-mumbai":
      return "rpc.ankr.com/polygon_mumbai";
    case "optimism":
      return "rpc.ankr.com/optimism";
    case "optimism-goerli":
      return "rpc.ankr.com/optimism_testnet";
    case "optimism-sepolia":
      return "rpc.ankr.com/optimism_sepolia";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class AnkrProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const options = { polling: true, staticNetwork: network };
    const request = AnkrProvider.getRequest(network, apiKey);
    super(request, network, options);
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new AnkrProvider(chainId, this.apiKey);
    } catch (error) {}
    return super._getProvider(chainId);
  }
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const request = new FetchRequest(`https://${getHost(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("AnkrProvider");
        return true;
      };
    }
    return request;
  }
  getRpcError(payload, error) {
    if (payload.method === "eth_sendRawTransaction") {
      if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
        error.error.message = "replacement transaction underpriced";
      }
    }
    return super.getRpcError(payload, error);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
}

// node_modules/ethers/lib.esm/providers/provider-alchemy.js
var defaultApiKey2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost2(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "arbitrum-sepolia":
      return "arb-sepolia.g.alchemy.com";
    case "base":
      return "base-mainnet.g.alchemy.com";
    case "base-goerli":
      return "base-goerli.g.alchemy.com";
    case "base-sepolia":
      return "base-sepolia.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-amoy":
      return "polygon-amoy.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
    case "optimism-sepolia":
      return "opt-sepolia.g.alchemy.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class AlchemyProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request = AlchemyProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new AlchemyProvider(chainId, this.apiKey);
    } catch (error) {}
    return super._getProvider(chainId);
  }
  async _perform(req) {
    if (req.method === "getTransactionResult") {
      const { trace, tx } = await resolveProperties({
        trace: this.send("trace_transaction", [req.hash]),
        tx: this.getTransaction(req.hash)
      });
      if (trace == null || tx == null) {
        return null;
      }
      let data;
      let error = false;
      try {
        data = trace[0].result.output;
        error = trace[0].error === "Reverted";
      } catch (error2) {}
      if (data) {
        assert2(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
          action: "getTransactionResult",
          data,
          reason: null,
          transaction: tx,
          invocation: null,
          revert: null
        });
        return data;
      }
      assert2(false, "could not parse trace result", "BAD_DATA", { value: trace });
    }
    return await super._perform(req);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request = new FetchRequest(`https://${getHost2(network.name)}/v2/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("alchemy");
        return true;
      };
    }
    return request;
  }
}

// node_modules/ethers/lib.esm/providers/provider-chainstack.js
function getApiKey(name) {
  switch (name) {
    case "mainnet":
      return "39f1d67cedf8b7831010a665328c9197";
    case "arbitrum":
      return "0550c209db33c3abf4cc927e1e18cea1";
    case "bnb":
      return "98b5a77e531614387366f6fc5da097f8";
    case "matic":
      return "cd9d4d70377471aa7c142ec4a4205249";
  }
  assertArgument(false, "unsupported network", "network", name);
}
function getHost3(name) {
  switch (name) {
    case "mainnet":
      return "ethereum-mainnet.core.chainstack.com";
    case "arbitrum":
      return "arbitrum-mainnet.core.chainstack.com";
    case "bnb":
      return "bsc-mainnet.core.chainstack.com";
    case "matic":
      return "polygon-mainnet.core.chainstack.com";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class ChainstackProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = getApiKey(network.name);
    }
    const request = ChainstackProvider.getRequest(network, apiKey);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new ChainstackProvider(chainId, this.apiKey);
    } catch (error) {}
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === getApiKey(this._network.name);
  }
  static getRequest(network, apiKey) {
    if (apiKey == null) {
      apiKey = getApiKey(network.name);
    }
    const request = new FetchRequest(`https://${getHost3(network.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === getApiKey(network.name)) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("ChainstackProvider");
        return true;
      };
    }
    return request;
  }
}

// node_modules/ethers/lib.esm/providers/provider-cloudflare.js
class CloudflareProvider extends JsonRpcProvider {
  constructor(_network) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    assertArgument(network.name === "mainnet", "unsupported network", "network", _network);
    super("https://cloudflare-eth.com/", network, { staticNetwork: network });
  }
}

// node_modules/ethers/lib.esm/providers/provider-etherscan.js
var THROTTLE = 2000;
function isPromise2(value) {
  return value && typeof value.then === "function";
}
var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";

class EtherscanPlugin extends NetworkPlugin {
  baseUrl;
  constructor(baseUrl) {
    super(EtherscanPluginId);
    defineProperties(this, { baseUrl });
  }
  clone() {
    return new EtherscanPlugin(this.baseUrl);
  }
}
var skipKeys = ["enableCcipRead"];
var nextId = 1;

class EtherscanProvider extends AbstractProvider {
  network;
  apiKey;
  #plugin;
  constructor(_network, _apiKey) {
    const apiKey = _apiKey != null ? _apiKey : null;
    super();
    const network = Network.from(_network);
    this.#plugin = network.getPlugin(EtherscanPluginId);
    defineProperties(this, { apiKey, network });
  }
  getBaseUrl() {
    if (this.#plugin) {
      return this.#plugin.baseUrl;
    }
    switch (this.network.name) {
      case "mainnet":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "holesky":
        return "https://api-holesky.etherscan.io";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "base":
        return "https://api.basescan.org";
      case "base-sepolia":
        return "https://api-sepolia.basescan.org";
      case "bnb":
        return "https://api.bscscan.com";
      case "bnbt":
        return "https://api-testnet.bscscan.com";
      case "matic":
        return "https://api.polygonscan.com";
      case "matic-amoy":
        return "https://api-amoy.polygonscan.com";
      case "matic-mumbai":
        return "https://api-testnet.polygonscan.com";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    assertArgument(false, "unsupported network", "network", this.network);
  }
  getUrl(module, params) {
    let query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    if (this.apiKey) {
      query += `&apikey=${this.apiKey}`;
    }
    return `https://api.etherscan.io/v2/api?chainid=${this.network.chainId}&module=${module}${query}`;
  }
  getPostUrl() {
    return `https://api.etherscan.io/v2/api?chainid=${this.network.chainId}`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    params.chainid = this.network.chainId;
    return params;
  }
  async detectNetwork() {
    return this.network;
  }
  async fetch(module, params, post) {
    const id2 = nextId++;
    const url = post ? this.getPostUrl() : this.getUrl(module, params);
    const payload = post ? this.getPostData(module, params) : null;
    this.emit("debug", { action: "sendRequest", id: id2, url, payload });
    const request = new FetchRequest(url);
    request.setThrottleParams({ slotInterval: 1000 });
    request.retryFunc = (req, resp, attempt) => {
      if (this.isCommunityResource()) {
        showThrottleMessage("Etherscan");
      }
      return Promise.resolve(true);
    };
    request.processFunc = async (request2, response2) => {
      const result2 = response2.hasBody() ? JSON.parse(toUtf8String(response2.body)) : {};
      const throttle = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
      if (module === "proxy") {
        if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle) {
          this.emit("debug", { action: "receiveError", id: id2, reason: "proxy-NOTOK", error: result2 });
          response2.throwThrottleError(result2.result, THROTTLE);
        }
      } else {
        if (throttle) {
          this.emit("debug", { action: "receiveError", id: id2, reason: "null result", error: result2.result });
          response2.throwThrottleError(result2.result, THROTTLE);
        }
      }
      return response2;
    };
    if (payload) {
      request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
      request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
    }
    const response = await request.send();
    try {
      response.assertOk();
    } catch (error) {
      this.emit("debug", { action: "receiveError", id: id2, error, reason: "assertOk" });
      assert2(false, "response error", "SERVER_ERROR", { request, response });
    }
    if (!response.hasBody()) {
      this.emit("debug", { action: "receiveError", id: id2, error: "missing body", reason: "null body" });
      assert2(false, "missing response", "SERVER_ERROR", { request, response });
    }
    const result = JSON.parse(toUtf8String(response.body));
    if (module === "proxy") {
      if (result.jsonrpc != "2.0") {
        this.emit("debug", { action: "receiveError", id: id2, result, reason: "invalid JSON-RPC" });
        assert2(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
      }
      if (result.error) {
        this.emit("debug", { action: "receiveError", id: id2, result, reason: "JSON-RPC error" });
        assert2(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id2, result });
      return result.result;
    } else {
      if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        this.emit("debug", { action: "receiveRequest", id: id2, result });
        return result.result;
      }
      if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
        this.emit("debug", { action: "receiveError", id: id2, result });
        assert2(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id2, result });
      return result.result;
    }
  }
  _getTransactionPostData(transaction) {
    const result = {};
    for (let key in transaction) {
      if (skipKeys.indexOf(key) >= 0) {
        continue;
      }
      if (transaction[key] == null) {
        continue;
      }
      let value = transaction[key];
      if (key === "type" && value === 0) {
        continue;
      }
      if (key === "blockTag" && value === "latest") {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value = toQuantity(value);
      } else if (key === "accessList") {
        value = "[" + accessListify(value).map((set) => {
          return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else if (key === "blobVersionedHashes") {
        if (value.length === 0) {
          continue;
        }
        assert2(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
          operation: "_getTransactionPostData",
          info: { transaction }
        });
      } else {
        value = hexlify(value);
      }
      result[key] = value;
    }
    return result;
  }
  _checkError(req, error, transaction) {
    let message = "";
    if (isError(error, "SERVER_ERROR")) {
      try {
        message = error.info.result.error.message;
      } catch (e) {}
      if (!message) {
        try {
          message = error.info.message;
        } catch (e) {}
      }
    }
    if (req.method === "estimateGas") {
      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
        assert2(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: req.transaction
        });
      }
    }
    if (req.method === "call" || req.method === "estimateGas") {
      if (message.match(/execution reverted/i)) {
        let data = "";
        try {
          data = error.info.result.error.data;
        } catch (error2) {}
        const e = AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
        e.info = { request: req, error };
        throw e;
      }
    }
    if (message) {
      if (req.method === "broadcastTransaction") {
        const transaction2 = Transaction.from(req.signedTransaction);
        if (message.match(/replacement/i) && message.match(/underpriced/i)) {
          assert2(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction2
          });
        }
        if (message.match(/insufficient funds/)) {
          assert2(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction2
          });
        }
        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
          assert2(false, "nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction2
          });
        }
      }
    }
    throw error;
  }
  async _detectNetwork() {
    return this.network;
  }
  async _perform(req) {
    switch (req.method) {
      case "chainId":
        return this.network.chainId;
      case "getBlockNumber":
        return this.fetch("proxy", { action: "eth_blockNumber" });
      case "getGasPrice":
        return this.fetch("proxy", { action: "eth_gasPrice" });
      case "getPriorityFee":
        if (this.network.name === "mainnet") {
          return "1000000000";
        } else if (this.network.name === "optimism") {
          return "1000000";
        } else {
          throw new Error("fallback onto the AbstractProvider default");
        }
      case "getBalance":
        return this.fetch("account", {
          action: "balance",
          address: req.address,
          tag: req.blockTag
        });
      case "getTransactionCount":
        return this.fetch("proxy", {
          action: "eth_getTransactionCount",
          address: req.address,
          tag: req.blockTag
        });
      case "getCode":
        return this.fetch("proxy", {
          action: "eth_getCode",
          address: req.address,
          tag: req.blockTag
        });
      case "getStorage":
        return this.fetch("proxy", {
          action: "eth_getStorageAt",
          address: req.address,
          position: req.position,
          tag: req.blockTag
        });
      case "broadcastTransaction":
        return this.fetch("proxy", {
          action: "eth_sendRawTransaction",
          hex: req.signedTransaction
        }, true).catch((error) => {
          return this._checkError(req, error, req.signedTransaction);
        });
      case "getBlock":
        if ("blockTag" in req) {
          return this.fetch("proxy", {
            action: "eth_getBlockByNumber",
            tag: req.blockTag,
            boolean: req.includeTransactions ? "true" : "false"
          });
        }
        assert2(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
          operation: "getBlock(blockHash)"
        });
      case "getTransaction":
        return this.fetch("proxy", {
          action: "eth_getTransactionByHash",
          txhash: req.hash
        });
      case "getTransactionReceipt":
        return this.fetch("proxy", {
          action: "eth_getTransactionReceipt",
          txhash: req.hash
        });
      case "call": {
        if (req.blockTag !== "latest") {
          throw new Error("EtherscanProvider does not support blockTag for call");
        }
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_call";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      case "estimateGas": {
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_estimateGas";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      default:
        break;
    }
    return super._perform(req);
  }
  async getNetwork() {
    return this.network;
  }
  async getEtherPrice() {
    if (this.network.name !== "mainnet") {
      return 0;
    }
    return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
  }
  async getContract(_address) {
    let address = this._getAddress(_address);
    if (isPromise2(address)) {
      address = await address;
    }
    try {
      const resp = await this.fetch("contract", {
        action: "getabi",
        address
      });
      const abi = JSON.parse(resp);
      return new Contract(address, abi, this);
    } catch (error) {
      return null;
    }
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}

// node_modules/ethers/lib.esm/providers/ws-browser.js
function getGlobal2() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var _WebSocket = getGlobal2().WebSocket;

// node_modules/ethers/lib.esm/providers/provider-socket.js
class SocketSubscriber {
  #provider;
  #filter;
  get filter() {
    return JSON.parse(this.#filter);
  }
  #filterId;
  #paused;
  #emitPromise;
  constructor(provider, filter) {
    this.#provider = provider;
    this.#filter = JSON.stringify(filter);
    this.#filterId = null;
    this.#paused = null;
    this.#emitPromise = null;
  }
  start() {
    this.#filterId = this.#provider.send("eth_subscribe", this.filter).then((filterId) => {
      this.#provider._register(filterId, this);
      return filterId;
    });
  }
  stop() {
    this.#filterId.then((filterId) => {
      if (this.#provider.destroyed) {
        return;
      }
      this.#provider.send("eth_unsubscribe", [filterId]);
    });
    this.#filterId = null;
  }
  pause(dropWhilePaused) {
    assert2(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    this.#paused = !!dropWhilePaused;
  }
  resume() {
    this.#paused = null;
  }
  _handleMessage(message) {
    if (this.#filterId == null) {
      return;
    }
    if (this.#paused === null) {
      let emitPromise = this.#emitPromise;
      if (emitPromise == null) {
        emitPromise = this._emit(this.#provider, message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(this.#provider, message);
        });
      }
      this.#emitPromise = emitPromise.then(() => {
        if (this.#emitPromise === emitPromise) {
          this.#emitPromise = null;
        }
      });
    }
  }
  async _emit(provider, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
}

class SocketBlockSubscriber extends SocketSubscriber {
  constructor(provider) {
    super(provider, ["newHeads"]);
  }
  async _emit(provider, message) {
    provider.emit("block", parseInt(message.number));
  }
}

class SocketPendingSubscriber extends SocketSubscriber {
  constructor(provider) {
    super(provider, ["newPendingTransactions"]);
  }
  async _emit(provider, message) {
    provider.emit("pending", message);
  }
}

class SocketEventSubscriber extends SocketSubscriber {
  #logFilter;
  get logFilter() {
    return JSON.parse(this.#logFilter);
  }
  constructor(provider, filter) {
    super(provider, ["logs", filter]);
    this.#logFilter = JSON.stringify(filter);
  }
  async _emit(provider, message) {
    provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
  }
}

class SocketProvider extends JsonRpcApiProvider {
  #callbacks;
  #subs;
  #pending;
  constructor(network, _options) {
    const options = Object.assign({}, _options != null ? _options : {});
    assertArgument(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
    options.batchMaxCount = 1;
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    super(network, options);
    this.#callbacks = new Map;
    this.#subs = new Map;
    this.#pending = new Map;
  }
  _getSubscriber(sub2) {
    switch (sub2.type) {
      case "close":
        return new UnmanagedSubscriber("close");
      case "block":
        return new SocketBlockSubscriber(this);
      case "pending":
        return new SocketPendingSubscriber(this);
      case "event":
        return new SocketEventSubscriber(this, sub2.filter);
      case "orphan":
        if (sub2.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber("drop-log");
        }
    }
    return super._getSubscriber(sub2);
  }
  _register(filterId, subscriber) {
    this.#subs.set(filterId, subscriber);
    const pending = this.#pending.get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      this.#pending.delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise = new Promise((resolve, reject) => {
      this.#callbacks.set(payload.id, { payload, resolve, reject });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise];
  }
  async _processMessage(message) {
    const result = JSON.parse(message);
    if (result && typeof result === "object" && "id" in result) {
      const callback = this.#callbacks.get(result.id);
      if (callback == null) {
        this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result
        }));
        return;
      }
      this.#callbacks.delete(result.id);
      callback.resolve(result);
    } else if (result && result.method === "eth_subscription") {
      const filterId = result.params.subscription;
      const subscriber = this.#subs.get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result.params.result);
      } else {
        let pending = this.#pending.get(filterId);
        if (pending == null) {
          pending = [];
          this.#pending.set(filterId, pending);
        }
        pending.push(result.params.result);
      }
    } else {
      this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result
      }));
      return;
    }
  }
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
}

// node_modules/ethers/lib.esm/providers/provider-websocket.js
class WebSocketProvider extends SocketProvider {
  #connect;
  #websocket;
  get websocket() {
    if (this.#websocket == null) {
      throw new Error("websocket closed");
    }
    return this.#websocket;
  }
  constructor(url, network, options) {
    super(network, options);
    if (typeof url === "string") {
      this.#connect = () => {
        return new _WebSocket(url);
      };
      this.#websocket = this.#connect();
    } else if (typeof url === "function") {
      this.#connect = url;
      this.#websocket = url();
    } else {
      this.#connect = null;
      this.#websocket = url;
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error) {
        console.log("failed to start WebsocketProvider", error);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (this.#websocket != null) {
      this.#websocket.close();
      this.#websocket = null;
    }
    super.destroy();
  }
}

// node_modules/ethers/lib.esm/providers/provider-infura.js
var defaultProjectId = "84842078b09946638c03157f83405213";
function getHost4(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
    case "base-goerli":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bsc-mainnet.infura.io";
    case "bnbt":
      return "bsc-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "linea-sepolia":
      return "linea-sepolia.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-amoy":
      return "polygon-amoy.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class InfuraWebSocketProvider extends WebSocketProvider {
  projectId;
  projectSecret;
  constructor(network, projectId) {
    const provider = new InfuraProvider(network, projectId);
    const req = provider._getConnection();
    assert2(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, provider._network);
    defineProperties(this, {
      projectId: provider.projectId,
      projectSecret: provider.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}

class InfuraProvider extends JsonRpcProvider {
  projectId;
  projectSecret;
  constructor(_network, projectId, projectSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = InfuraProvider.getRequest(network, projectId, projectSecret);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error) {}
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
  static getWebSocketProvider(network, projectId) {
    return new InfuraWebSocketProvider(network, projectId);
  }
  static getRequest(network, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = new FetchRequest(`https://${getHost4(network.name)}/v3/${projectId}`);
    request.allowGzip = true;
    if (projectSecret) {
      request.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("InfuraProvider");
        return true;
      };
    }
    return request;
  }
}

// node_modules/ethers/lib.esm/providers/provider-quicknode.js
var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
function getHost5(name) {
  switch (name) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    case "sepolia":
      return "ethers.ethereum-sepolia.quiknode.pro";
    case "holesky":
      return "ethers.ethereum-holesky.quiknode.pro";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "arbitrum-sepolia":
      return "ethers.arbitrum-sepolia.quiknode.pro";
    case "base":
      return "ethers.base-mainnet.quiknode.pro";
    case "base-goerli":
      return "ethers.base-goerli.quiknode.pro";
    case "base-spolia":
      return "ethers.base-sepolia.quiknode.pro";
    case "bnb":
      return "ethers.bsc.quiknode.pro";
    case "bnbt":
      return "ethers.bsc-testnet.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "matic-mumbai":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
    case "optimism-sepolia":
      return "ethers.optimism-sepolia.quiknode.pro";
    case "xdai":
      return "ethers.xdai.quiknode.pro";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class QuickNodeProvider extends JsonRpcProvider {
  token;
  constructor(_network, token) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (token == null) {
      token = defaultToken;
    }
    const request = QuickNodeProvider.getRequest(network, token);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { token });
  }
  _getProvider(chainId) {
    try {
      return new QuickNodeProvider(chainId, this.token);
    } catch (error) {}
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.token === defaultToken;
  }
  static getRequest(network, token) {
    if (token == null) {
      token = defaultToken;
    }
    const request = new FetchRequest(`https://${getHost5(network.name)}/${token}`);
    request.allowGzip = true;
    if (token === defaultToken) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("QuickNodeProvider");
        return true;
      };
    }
    return request;
  }
}

// node_modules/ethers/lib.esm/providers/provider-fallback.js
var BN_16 = BigInt("1");
var BN_24 = BigInt("2");
function shuffle(array) {
  for (let i = array.length - 1;i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
}
function stall2(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function getTime3() {
  return new Date().getTime();
}
function stringify2(value) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof value2 === "bigint") {
      return { type: "bigint", value: value2.toString() };
    }
    return value2;
  });
}
var defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
var defaultState = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0,
  _lastFatalError: null,
  _lastFatalErrorTimestamp: 0
};
async function waitForSync(config2, blockNumber) {
  while (config2.blockNumber < 0 || config2.blockNumber < blockNumber) {
    if (!config2._updateNumber) {
      config2._updateNumber = (async () => {
        try {
          const blockNumber2 = await config2.provider.getBlockNumber();
          if (blockNumber2 > config2.blockNumber) {
            config2.blockNumber = blockNumber2;
          }
        } catch (error) {
          config2.blockNumber = -2;
          config2._lastFatalError = error;
          config2._lastFatalErrorTimestamp = getTime3();
        }
        config2._updateNumber = null;
      })();
    }
    await config2._updateNumber;
    config2.outOfSync++;
    if (config2._lastFatalError) {
      break;
    }
  }
}
function _normalize(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize).join(",") + "]";
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return _normalize(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(",") + "}";
    }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
}
function normalizeResult(method, value) {
  if ("error" in value) {
    const error = value.error;
    let tag2;
    if (isError(error, "CALL_EXCEPTION")) {
      tag2 = _normalize(Object.assign({}, error, {
        shortMessage: undefined,
        reason: undefined,
        info: undefined
      }));
    } else {
      tag2 = _normalize(error);
    }
    return { tag: tag2, value: error };
  }
  const result = value.result;
  return { tag: _normalize(result), value: result };
}
function checkQuorum(quorum, results) {
  const tally = new Map;
  for (const { value, tag: tag2, weight } of results) {
    const t = tally.get(tag2) || { value, weight: 0 };
    t.weight += weight;
    tally.set(tag2, t);
  }
  let best = null;
  for (const r of tally.values()) {
    if (r.weight >= quorum && (!best || r.weight > best.weight)) {
      best = r;
    }
  }
  if (best) {
    return best.value;
  }
  return;
}
function getMedian(quorum, results) {
  let resultWeight = 0;
  const errorMap = new Map;
  let bestError = null;
  const values = [];
  for (const { value, tag: tag2, weight } of results) {
    if (value instanceof Error) {
      const e = errorMap.get(tag2) || { value, weight: 0 };
      e.weight += weight;
      errorMap.set(tag2, e);
      if (bestError == null || e.weight > bestError.weight) {
        bestError = e;
      }
    } else {
      values.push(BigInt(value));
      resultWeight += weight;
    }
  }
  if (resultWeight < quorum) {
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    return;
  }
  values.sort((a, b2) => a < b2 ? -1 : b2 > a ? 1 : 0);
  const mid = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[mid];
  }
  return (values[mid - 1] + values[mid] + BN_16) / BN_24;
}
function getAnyResult(quorum, results) {
  const result = checkQuorum(quorum, results);
  if (result !== undefined) {
    return result;
  }
  for (const r of results) {
    if (r.value) {
      return r.value;
    }
  }
  return;
}
function getFuzzyMode(quorum, results) {
  if (quorum === 1) {
    return getNumber(getMedian(quorum, results), "%internal");
  }
  const tally = new Map;
  const add3 = (result, weight) => {
    const t = tally.get(result) || { result, weight: 0 };
    t.weight += weight;
    tally.set(result, t);
  };
  for (const { weight, value } of results) {
    const r = getNumber(value);
    add3(r - 1, weight);
    add3(r, weight);
    add3(r + 1, weight);
  }
  let bestWeight = 0;
  let bestResult = undefined;
  for (const { weight, result } of tally.values()) {
    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
      bestWeight = weight;
      bestResult = result;
    }
  }
  return bestResult;
}

class FallbackProvider extends AbstractProvider {
  quorum;
  eventQuorum;
  eventWorkers;
  #configs;
  #height;
  #initialSyncPromise;
  constructor(providers, network, options) {
    super(network, options);
    this.#configs = providers.map((p) => {
      if (p instanceof AbstractProvider) {
        return Object.assign({ provider: p }, defaultConfig, defaultState);
      } else {
        return Object.assign({}, defaultConfig, p, defaultState);
      }
    });
    this.#height = -2;
    this.#initialSyncPromise = null;
    if (options && options.quorum != null) {
      this.quorum = options.quorum;
    } else {
      this.quorum = Math.ceil(this.#configs.reduce((accum, config2) => {
        accum += config2.weight;
        return accum;
      }, 0) / 2);
    }
    this.eventQuorum = 1;
    this.eventWorkers = 1;
    assertArgument(this.quorum <= this.#configs.reduce((a, c) => a + c.weight, 0), "quorum exceed provider weight", "quorum", this.quorum);
  }
  get providerConfigs() {
    return this.#configs.map((c) => {
      const result = Object.assign({}, c);
      for (const key in result) {
        if (key[0] === "_") {
          delete result[key];
        }
      }
      return result;
    });
  }
  async _detectNetwork() {
    return Network.from(getBigInt(await this._perform({ method: "chainId" })));
  }
  async _translatePerform(provider, req) {
    switch (req.method) {
      case "broadcastTransaction":
        return await provider.broadcastTransaction(req.signedTransaction);
      case "call":
        return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
      case "chainId":
        return (await provider.getNetwork()).chainId;
      case "estimateGas":
        return await provider.estimateGas(req.transaction);
      case "getBalance":
        return await provider.getBalance(req.address, req.blockTag);
      case "getBlock": {
        const block = "blockHash" in req ? req.blockHash : req.blockTag;
        return await provider.getBlock(block, req.includeTransactions);
      }
      case "getBlockNumber":
        return await provider.getBlockNumber();
      case "getCode":
        return await provider.getCode(req.address, req.blockTag);
      case "getGasPrice":
        return (await provider.getFeeData()).gasPrice;
      case "getPriorityFee":
        return (await provider.getFeeData()).maxPriorityFeePerGas;
      case "getLogs":
        return await provider.getLogs(req.filter);
      case "getStorage":
        return await provider.getStorage(req.address, req.position, req.blockTag);
      case "getTransaction":
        return await provider.getTransaction(req.hash);
      case "getTransactionCount":
        return await provider.getTransactionCount(req.address, req.blockTag);
      case "getTransactionReceipt":
        return await provider.getTransactionReceipt(req.hash);
      case "getTransactionResult":
        return await provider.getTransactionResult(req.hash);
    }
  }
  #getNextConfig(running) {
    const configs = Array.from(running).map((r) => r.config);
    const allConfigs = this.#configs.slice();
    shuffle(allConfigs);
    allConfigs.sort((a, b2) => a.priority - b2.priority);
    for (const config2 of allConfigs) {
      if (config2._lastFatalError) {
        continue;
      }
      if (configs.indexOf(config2) === -1) {
        return config2;
      }
    }
    return null;
  }
  #addRunner(running, req) {
    const config2 = this.#getNextConfig(running);
    if (config2 == null) {
      return null;
    }
    const runner = {
      config: config2,
      result: null,
      didBump: false,
      perform: null,
      staller: null
    };
    const now = getTime3();
    runner.perform = (async () => {
      try {
        config2.requests++;
        const result = await this._translatePerform(config2.provider, req);
        runner.result = { result };
      } catch (error) {
        config2.errorResponses++;
        runner.result = { error };
      }
      const dt = getTime3() - now;
      config2._totalTime += dt;
      config2.rollingDuration = 0.95 * config2.rollingDuration + 0.05 * dt;
      runner.perform = null;
    })();
    runner.staller = (async () => {
      await stall2(config2.stallTimeout);
      runner.staller = null;
    })();
    running.add(runner);
    return runner;
  }
  async#initialSync() {
    let initialSync = this.#initialSyncPromise;
    if (!initialSync) {
      const promises = [];
      this.#configs.forEach((config2) => {
        promises.push((async () => {
          await waitForSync(config2, 0);
          if (!config2._lastFatalError) {
            config2._network = await config2.provider.getNetwork();
          }
        })());
      });
      this.#initialSyncPromise = initialSync = (async () => {
        await Promise.all(promises);
        let chainId = null;
        for (const config2 of this.#configs) {
          if (config2._lastFatalError) {
            continue;
          }
          const network = config2._network;
          if (chainId == null) {
            chainId = network.chainId;
          } else if (network.chainId !== chainId) {
            assert2(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
              operation: "new FallbackProvider"
            });
          }
        }
      })();
    }
    await initialSync;
  }
  async#checkQuorum(running, req) {
    const results = [];
    for (const runner of running) {
      if (runner.result != null) {
        const { tag: tag2, value } = normalizeResult(req.method, runner.result);
        results.push({ tag: tag2, value, weight: runner.config.weight });
      }
    }
    if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {
      return;
    }
    switch (req.method) {
      case "getBlockNumber": {
        if (this.#height === -2) {
          this.#height = Math.ceil(getNumber(getMedian(this.quorum, this.#configs.filter((c) => !c._lastFatalError).map((c) => ({
            value: c.blockNumber,
            tag: getNumber(c.blockNumber).toString(),
            weight: c.weight
          })))));
        }
        const mode = getFuzzyMode(this.quorum, results);
        if (mode === undefined) {
          return;
        }
        if (mode > this.#height) {
          this.#height = mode;
        }
        return this.#height;
      }
      case "getGasPrice":
      case "getPriorityFee":
      case "estimateGas":
        return getMedian(this.quorum, results);
      case "getBlock":
        if ("blockTag" in req && req.blockTag === "pending") {
          return getAnyResult(this.quorum, results);
        }
        return checkQuorum(this.quorum, results);
      case "call":
      case "chainId":
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorage":
      case "getTransaction":
      case "getTransactionReceipt":
      case "getLogs":
        return checkQuorum(this.quorum, results);
      case "broadcastTransaction":
        return getAnyResult(this.quorum, results);
    }
    assert2(false, "unsupported method", "UNSUPPORTED_OPERATION", {
      operation: `_perform(${stringify2(req.method)})`
    });
  }
  async#waitForQuorum(running, req) {
    if (running.size === 0) {
      throw new Error("no runners?!");
    }
    const interesting = [];
    let newRunners = 0;
    for (const runner of running) {
      if (runner.perform) {
        interesting.push(runner.perform);
      }
      if (runner.staller) {
        interesting.push(runner.staller);
        continue;
      }
      if (runner.didBump) {
        continue;
      }
      runner.didBump = true;
      newRunners++;
    }
    const value = await this.#checkQuorum(running, req);
    if (value !== undefined) {
      if (value instanceof Error) {
        throw value;
      }
      return value;
    }
    for (let i = 0;i < newRunners; i++) {
      this.#addRunner(running, req);
    }
    assert2(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
      request: "%sub-requests",
      info: { request: req, results: Array.from(running).map((r) => stringify2(r.result)) }
    });
    await Promise.race(interesting);
    return await this.#waitForQuorum(running, req);
  }
  async _perform(req) {
    if (req.method === "broadcastTransaction") {
      const results = this.#configs.map((c) => null);
      const broadcasts = this.#configs.map(async ({ provider, weight }, index) => {
        try {
          const result3 = await provider._perform(req);
          results[index] = Object.assign(normalizeResult(req.method, { result: result3 }), { weight });
        } catch (error) {
          results[index] = Object.assign(normalizeResult(req.method, { error }), { weight });
        }
      });
      while (true) {
        const done = results.filter((r) => r != null);
        for (const { value } of done) {
          if (!(value instanceof Error)) {
            return value;
          }
        }
        const result3 = checkQuorum(this.quorum, results.filter((r) => r != null));
        if (isError(result3, "INSUFFICIENT_FUNDS")) {
          throw result3;
        }
        const waiting = broadcasts.filter((b2, i) => results[i] == null);
        if (waiting.length === 0) {
          break;
        }
        await Promise.race(waiting);
      }
      const result2 = getAnyResult(this.quorum, results);
      assert2(result2 !== undefined, "problem multi-broadcasting", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: results.map(stringify2) }
      });
      if (result2 instanceof Error) {
        throw result2;
      }
      return result2;
    }
    await this.#initialSync();
    const running = new Set;
    let inflightQuorum = 0;
    while (true) {
      const runner = this.#addRunner(running, req);
      if (runner == null) {
        break;
      }
      inflightQuorum += runner.config.weight;
      if (inflightQuorum >= this.quorum) {
        break;
      }
    }
    const result = await this.#waitForQuorum(running, req);
    for (const runner of running) {
      if (runner.perform && runner.result == null) {
        runner.config.lateResponses++;
      }
    }
    return result;
  }
  async destroy() {
    for (const { provider } of this.#configs) {
      provider.destroy();
    }
    super.destroy();
  }
}

// node_modules/ethers/lib.esm/providers/default-provider.js
function isWebSocketLike(value) {
  return value && typeof value.send === "function" && typeof value.close === "function";
}
var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
function getDefaultProvider(network, options) {
  if (options == null) {
    options = {};
  }
  const allowService = (name) => {
    if (options[name] === "-") {
      return false;
    }
    if (typeof options.exclusive === "string") {
      return name === options.exclusive;
    }
    if (Array.isArray(options.exclusive)) {
      return options.exclusive.indexOf(name) !== -1;
    }
    return true;
  };
  if (typeof network === "string" && network.match(/^https?:/)) {
    return new JsonRpcProvider(network);
  }
  if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
    return new WebSocketProvider(network);
  }
  let staticNetwork = null;
  try {
    staticNetwork = Network.from(network);
  } catch (error) {}
  const providers = [];
  if (allowService("publicPolygon") && staticNetwork) {
    if (staticNetwork.name === "matic") {
      providers.push(new JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
    } else if (staticNetwork.name === "matic-amoy") {
      providers.push(new JsonRpcProvider("https://rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
    }
  }
  if (allowService("alchemy")) {
    try {
      providers.push(new AlchemyProvider(network, options.alchemy));
    } catch (error) {}
  }
  if (allowService("ankr") && options.ankr != null) {
    try {
      providers.push(new AnkrProvider(network, options.ankr));
    } catch (error) {}
  }
  if (allowService("chainstack")) {
    try {
      providers.push(new ChainstackProvider(network, options.chainstack));
    } catch (error) {}
  }
  if (allowService("cloudflare")) {
    try {
      providers.push(new CloudflareProvider(network));
    } catch (error) {}
  }
  if (allowService("etherscan")) {
    try {
      providers.push(new EtherscanProvider(network, options.etherscan));
    } catch (error) {}
  }
  if (allowService("infura")) {
    try {
      let projectId = options.infura;
      let projectSecret = undefined;
      if (typeof projectId === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new InfuraProvider(network, projectId, projectSecret));
    } catch (error) {}
  }
  if (allowService("quicknode")) {
    try {
      let token = options.quicknode;
      providers.push(new QuickNodeProvider(network, token));
    } catch (error) {}
  }
  assert2(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  if (providers.length === 1) {
    return providers[0];
  }
  let quorum = Math.floor(providers.length / 2);
  if (quorum > 2) {
    quorum = 2;
  }
  if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
    quorum = 1;
  }
  if (options && options.quorum) {
    quorum = options.quorum;
  }
  return new FallbackProvider(providers, undefined, { quorum });
}
// node_modules/ethers/lib.esm/providers/signer-noncemanager.js
class NonceManager extends AbstractSigner {
  signer;
  #noncePromise;
  #delta;
  constructor(signer) {
    super(signer.provider);
    defineProperties(this, { signer });
    this.#noncePromise = null;
    this.#delta = 0;
  }
  async getAddress() {
    return this.signer.getAddress();
  }
  connect(provider) {
    return new NonceManager(this.signer.connect(provider));
  }
  async getNonce(blockTag) {
    if (blockTag === "pending") {
      if (this.#noncePromise == null) {
        this.#noncePromise = super.getNonce("pending");
      }
      const delta = this.#delta;
      return await this.#noncePromise + delta;
    }
    return super.getNonce(blockTag);
  }
  increment() {
    this.#delta++;
  }
  reset() {
    this.#delta = 0;
    this.#noncePromise = null;
  }
  async sendTransaction(tx) {
    const noncePromise = this.getNonce("pending");
    this.increment();
    tx = await this.signer.populateTransaction(tx);
    tx.nonce = await noncePromise;
    return await this.signer.sendTransaction(tx);
  }
  signTransaction(tx) {
    return this.signer.signTransaction(tx);
  }
  signMessage(message) {
    return this.signer.signMessage(message);
  }
  signTypedData(domain, types2, value) {
    return this.signer.signTypedData(domain, types2, value);
  }
}
// node_modules/ethers/lib.esm/providers/provider-browser.js
class BrowserProvider extends JsonRpcApiPollingProvider {
  #request;
  #providerInfo;
  constructor(ethereum, network, _options) {
    const options = Object.assign({}, _options != null ? _options : {}, { batchMaxCount: 1 });
    assertArgument(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    super(network, options);
    this.#providerInfo = null;
    if (_options && _options.providerInfo) {
      this.#providerInfo = _options.providerInfo;
    }
    this.#request = async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result });
        return result;
      } catch (e) {
        const error = new Error(e.message);
        error.code = e.code;
        error.data = e.data;
        error.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error });
        throw error;
      }
    };
  }
  get providerInfo() {
    return this.#providerInfo;
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result = await this.#request(payload.method, payload.params || []);
      return [{ id: payload.id, result }];
    } catch (e) {
      return [{
        id: payload.id,
        error: { code: e.code, data: e.data, message: e.message }
      }];
    }
  }
  getRpcError(payload, error) {
    error = JSON.parse(JSON.stringify(error));
    switch (error.error.code || -1) {
      case 4001:
        error.error.message = `ethers-user-denied: ${error.error.message}`;
        break;
      case 4200:
        error.error.message = `ethers-unsupported: ${error.error.message}`;
        break;
    }
    return super.getRpcError(payload, error);
  }
  async hasSigner(address) {
    if (address == null) {
      address = 0;
    }
    const accounts = await this.send("eth_accounts", []);
    if (typeof address === "number") {
      return accounts.length > address;
    }
    address = address.toLowerCase();
    return accounts.filter((a) => a.toLowerCase() === address).length !== 0;
  }
  async getSigner(address) {
    if (address == null) {
      address = 0;
    }
    if (!await this.hasSigner(address)) {
      try {
        await this.#request("eth_requestAccounts", []);
      } catch (error) {
        const payload = error.payload;
        throw this.getRpcError(payload, { id: payload.id, error });
      }
    }
    return await super.getSigner(address);
  }
  static async discover(options) {
    if (options == null) {
      options = {};
    }
    if (options.provider) {
      return new BrowserProvider(options.provider);
    }
    const context = options.window ? options.window : typeof window !== "undefined" ? window : null;
    if (context == null) {
      return null;
    }
    const anyProvider = options.anyProvider;
    if (anyProvider && context.ethereum) {
      return new BrowserProvider(context.ethereum);
    }
    if (!(("addEventListener" in context) && ("dispatchEvent" in context) && ("removeEventListener" in context))) {
      return null;
    }
    const timeout = options.timeout ? options.timeout : 300;
    if (timeout === 0) {
      return null;
    }
    return await new Promise((resolve, reject) => {
      let found = [];
      const addProvider = (event) => {
        found.push(event.detail);
        if (anyProvider) {
          finalize();
        }
      };
      const finalize = () => {
        clearTimeout(timer);
        if (found.length) {
          if (options && options.filter) {
            const filtered = options.filter(found.map((i) => Object.assign({}, i.info)));
            if (filtered == null) {
              resolve(null);
            } else if (filtered instanceof BrowserProvider) {
              resolve(filtered);
            } else {
              let match = null;
              if (filtered.uuid) {
                const matches = found.filter((f2) => filtered.uuid === f2.info.uuid);
                match = matches[0];
              }
              if (match) {
                const { provider, info } = match;
                resolve(new BrowserProvider(provider, undefined, {
                  providerInfo: info
                }));
              } else {
                reject(makeError("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                  value: filtered
                }));
              }
            }
          } else {
            const { provider, info } = found[0];
            resolve(new BrowserProvider(provider, undefined, {
              providerInfo: info
            }));
          }
        } else {
          resolve(null);
        }
        context.removeEventListener("eip6963:announceProvider", addProvider);
      };
      const timer = setTimeout(() => {
        finalize();
      }, timeout);
      context.addEventListener("eip6963:announceProvider", addProvider);
      context.dispatchEvent(new Event("eip6963:requestProvider"));
    });
  }
}
// node_modules/ethers/lib.esm/providers/provider-blockscout.js
function getUrl(name) {
  switch (name) {
    case "mainnet":
      return "https://eth.blockscout.com/api/eth-rpc";
    case "sepolia":
      return "https://eth-sepolia.blockscout.com/api/eth-rpc";
    case "holesky":
      return "https://eth-holesky.blockscout.com/api/eth-rpc";
    case "classic":
      return "https://etc.blockscout.com/api/eth-rpc";
    case "arbitrum":
      return "https://arbitrum.blockscout.com/api/eth-rpc";
    case "base":
      return "https://base.blockscout.com/api/eth-rpc";
    case "base-sepolia":
      return "https://base-sepolia.blockscout.com/api/eth-rpc";
    case "matic":
      return "https://polygon.blockscout.com/api/eth-rpc";
    case "optimism":
      return "https://optimism.blockscout.com/api/eth-rpc";
    case "optimism-sepolia":
      return "https://optimism-sepolia.blockscout.com/api/eth-rpc";
    case "xdai":
      return "https://gnosis.blockscout.com/api/eth-rpc";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class BlockscoutProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (apiKey == null) {
      apiKey = null;
    }
    const request = BlockscoutProvider.getRequest(network);
    super(request, network, { staticNetwork: network });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new BlockscoutProvider(chainId, this.apiKey);
    } catch (error) {}
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.apiKey === null;
  }
  getRpcRequest(req) {
    const resp = super.getRpcRequest(req);
    if (resp && resp.method === "eth_estimateGas" && resp.args.length == 1) {
      resp.args = resp.args.slice();
      resp.args.push("latest");
    }
    return resp;
  }
  getRpcError(payload, _error) {
    const error = _error ? _error.error : null;
    if (error && error.code === -32015 && !isHexString(error.data || "", true)) {
      const panicCodes = {
        "assert(false)": "01",
        "arithmetic underflow or overflow": "11",
        "division or modulo by zero": "12",
        "out-of-bounds array access; popping on an empty array": "31",
        "out-of-bounds access of an array or bytesN": "32"
      };
      let panicCode = "";
      if (error.message === "VM execution error.") {
        panicCode = panicCodes[error.data] || "";
      } else if (panicCodes[error.message || ""]) {
        panicCode = panicCodes[error.message || ""];
      }
      if (panicCode) {
        error.message += ` (reverted: ${error.data})`;
        error.data = "0x4e487b7100000000000000000000000000000000000000000000000000000000000000" + panicCode;
      }
    } else if (error && error.code === -32000) {
      if (error.message === "wrong transaction nonce") {
        error.message += " (nonce too low)";
      }
    }
    return super.getRpcError(payload, _error);
  }
  static getRequest(network) {
    const request = new FetchRequest(getUrl(network.name));
    request.allowGzip = true;
    return request;
  }
}
// node_modules/ethers/lib.esm/providers/provider-pocket.js
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
function getHost6(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument(false, "unsupported network", "network", name);
}

class PocketProvider extends JsonRpcProvider {
  applicationId;
  applicationSecret;
  constructor(_network, applicationId, applicationSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network = Network.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    const options = { staticNetwork: network };
    const request = PocketProvider.getRequest(network, applicationId, applicationSecret);
    super(request, network, options);
    defineProperties(this, { applicationId, applicationSecret });
  }
  _getProvider(chainId) {
    try {
      return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
    } catch (error) {}
    return super._getProvider(chainId);
  }
  static getRequest(network, applicationId, applicationSecret) {
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    const request = new FetchRequest(`https://${getHost6(network.name)}/v1/lb/${applicationId}`);
    request.allowGzip = true;
    if (applicationSecret) {
      request.setCredentials("", applicationSecret);
    }
    if (applicationId === defaultApplicationId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("PocketProvider");
        return true;
      };
    }
    return request;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}
// node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js
var IpcSocketProvider = undefined;
// node_modules/ethers/lib.esm/wallet/base-wallet.js
class BaseWallet extends AbstractSigner {
  address;
  #signingKey;
  constructor(privateKey, provider) {
    super(provider);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    this.#signingKey = privateKey;
    const address = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address });
  }
  get signingKey() {
    return this.#signingKey;
  }
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider) {
    return new BaseWallet(this.#signingKey, provider);
  }
  async signTransaction(tx) {
    tx = copyRequest(tx);
    const { to, from } = await resolveProperties({
      to: tx.to ? resolveAddress(tx.to, this) : undefined,
      from: tx.from ? resolveAddress(tx.from, this) : undefined
    });
    if (to != null) {
      tx.to = to;
    }
    if (from != null) {
      tx.from = from;
    }
    if (tx.from != null) {
      assertArgument(getAddress(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
      delete tx.from;
    }
    const btx = Transaction.from(tx);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage(message)).serialized;
  }
  authorizeSync(auth) {
    assertArgument(typeof auth.address === "string", "invalid address for authorizeSync", "auth.address", auth);
    const signature = this.signingKey.sign(hashAuthorization(auth));
    return Object.assign({}, {
      address: getAddress(auth.address),
      nonce: getBigInt(auth.nonce || 0),
      chainId: getBigInt(auth.chainId || 0)
    }, { signature });
  }
  async authorize(auth) {
    auth = Object.assign({}, auth, {
      address: await resolveAddress(auth.address, this)
    });
    return this.authorizeSync(await this.populateAuthorization(auth));
  }
  async signTypedData(domain, types2, value) {
    const populated = await TypedDataEncoder.resolveNames(domain, types2, value, async (name) => {
      assert2(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address = await this.provider.resolveName(name);
      assert2(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types2, populated.value)).serialized;
  }
}
// node_modules/ethers/lib.esm/wordlists/decode-owl.js
var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word = /^[a-z]*$/i;
function unfold(words, sep) {
  let initial = 97;
  return words.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode(data, subs) {
  for (let i = subsChrs.length - 1;i >= 0; i--) {
    data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi);i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data) {
  assertArgument(data[0] === "0", "unsupported auwl data", "data", data);
  return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}

// node_modules/ethers/lib.esm/wordlists/wordlist.js
class Wordlist {
  locale;
  constructor(locale) {
    defineProperties(this, { locale });
  }
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  join(words) {
    return words.join(" ");
  }
}

// node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
class WordlistOwl extends Wordlist {
  #data;
  #checksum;
  constructor(locale, data, checksum) {
    super(locale);
    this.#data = data;
    this.#checksum = checksum;
    this.#words = null;
  }
  get _data() {
    return this.#data;
  }
  _decodeWords() {
    return decodeOwl(this.#data);
  }
  #words;
  #loadWords() {
    if (this.#words == null) {
      const words = this._decodeWords();
      const checksum = id(words.join(`
`) + `
`);
      if (checksum !== this.#checksum) {
        throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
      }
      this.#words = words;
    }
    return this.#words;
  }
  getWord(index) {
    const words = this.#loadWords();
    assertArgument(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
    return words[index];
  }
  getWordIndex(word) {
    return this.#loadWords().indexOf(word);
  }
}

// node_modules/ethers/lib.esm/wordlists/lang-en.js
var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var wordlist = null;

class LangEn extends WordlistOwl {
  constructor() {
    super("en", words, checksum);
  }
  static wordlist() {
    if (wordlist == null) {
      wordlist = new LangEn;
    }
    return wordlist;
  }
}

// node_modules/ethers/lib.esm/wallet/mnemonic.js
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  assertNormalize("NFKD");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const words2 = wordlist2.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset = 0;
  for (let i = 0;i < words2.length; i++) {
    let index = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0;bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist2 == null) {
    wordlist2 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0;i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha2562(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
var _guard5 = {};

class Mnemonic {
  phrase;
  password;
  wordlist;
  entropy;
  constructor(guard, entropy, phrase, password, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard5, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist2, entropy });
  }
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf22(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  static fromPhrase(phrase, password, wordlist2) {
    const entropy = mnemonicToEntropy(phrase, wordlist2);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist2);
    return new Mnemonic(_guard5, entropy, phrase, password, wordlist2);
  }
  static fromEntropy(_entropy, password, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist2);
    return new Mnemonic(_guard5, hexlify(entropy), phrase, password, wordlist2);
  }
  static entropyToPhrase(_entropy, wordlist2) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist2);
  }
  static phraseToEntropy(phrase, wordlist2) {
    return mnemonicToEntropy(phrase, wordlist2);
  }
  static isValidMnemonic(phrase, wordlist2) {
    try {
      mnemonicToEntropy(phrase, wordlist2);
      return true;
    } catch (error) {}
    return false;
  }
}

// node_modules/aes-js/lib.esm/aes.js
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key;
var _AES_Kd;
var _AES_Ke;
var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
var T12 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239000, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998000, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239000, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998000, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
function convertToInt32(bytes2) {
  const result = [];
  for (let i = 0;i < bytes2.length; i += 4) {
    result.push(bytes2[i] << 24 | bytes2[i + 1] << 16 | bytes2[i + 2] << 8 | bytes2[i + 3]);
  }
  return result;
}

class AES {
  get key() {
    return __classPrivateFieldGet(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, undefined);
    _AES_Kd.set(this, undefined);
    _AES_Ke.set(this, undefined);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet(this, _AES_Ke, [], "f");
    __classPrivateFieldSet(this, _AES_Kd, [], "f");
    for (let i = 0;i <= rounds; i++) {
      __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i = 0;i < KC; i++) {
      index = i >> 2;
      __classPrivateFieldGet(this, _AES_Ke, "f")[index][i % 4] = tk[i];
      __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
    }
    let rconpointer = 0;
    let t = KC, tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1;i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      } else {
        for (let i2 = 1;i2 < KC / 2; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1;i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      }
      let i = 0, r, c;
      while (i < KC && t < roundKeyCount) {
        r = t >> 2;
        c = t % 4;
        __classPrivateFieldGet(this, _AES_Ke, "f")[r][c] = tk[i];
        __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r][c] = tk[i++];
        t++;
      }
    }
    for (let r = 1;r < rounds; r++) {
      for (let c = 0;c < 4; c++) {
        tt = __classPrivateFieldGet(this, _AES_Kd, "f")[r][c];
        __classPrivateFieldGet(this, _AES_Kd, "f")[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(plaintext);
    for (let i = 0;i < 4; i++) {
      t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
    }
    for (let r = 1;r < rounds; r++) {
      for (let i = 0;i < 4; i++) {
        a[i] = T12[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0;i < 4; i++) {
      tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(ciphertext);
    for (let i = 0;i < 4; i++) {
      t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
    }
    for (let r = 1;r < rounds; r++) {
      for (let i = 0;i < 4; i++) {
        a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0;i < 4; i++) {
      tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = new WeakMap, _AES_Kd = new WeakMap, _AES_Ke = new WeakMap;

// node_modules/aes-js/lib.esm/mode.js
class ModeOfOperation {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
}

// node_modules/aes-js/lib.esm/mode-cbc.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CBC_iv;
var _CBC_lastBlock;

class CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, CBC);
    _CBC_iv.set(this, undefined);
    _CBC_lastBlock.set(this, undefined);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet2(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet2(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i = 0;i < plaintext.length; i += 16) {
      for (let j = 0;j < 16; j++) {
        __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
      }
      __classPrivateFieldSet2(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet2(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet2(this, _CBC_lastBlock, "f"), i);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i = 0;i < ciphertext.length; i += 16) {
      const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
      for (let j = 0;j < 16; j++) {
        plaintext[i + j] = block[j] ^ __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
      }
    }
    return plaintext;
  }
}
_CBC_iv = new WeakMap, _CBC_lastBlock = new WeakMap;
// node_modules/aes-js/lib.esm/mode-ctr.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining;
var _CTR_remainingIndex;
var _CTR_counter;

class CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, CTR);
    _CTR_remaining.set(this, undefined);
    _CTR_remainingIndex.set(this, undefined);
    _CTR_counter.set(this, undefined);
    __classPrivateFieldSet3(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet3(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet3(this, _CTR_remaining, __classPrivateFieldGet3(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet3(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet3(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15;index >= 0; --index) {
      __classPrivateFieldGet3(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet3(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15;i >= 0; i--) {
      if (__classPrivateFieldGet3(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet3(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet3(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0;i < crypttext.length; i++) {
      if (__classPrivateFieldGet3(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet3(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet3(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet3(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet3(this, _CTR_remaining, "f")[__classPrivateFieldSet3(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet3(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = new WeakMap, _CTR_remainingIndex = new WeakMap, _CTR_counter = new WeakMap;
// node_modules/aes-js/lib.esm/padding.js
function pkcs7Strip(data) {
  if (data.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data.length - padder;
  for (let i = 0;i < padder; i++) {
    if (data[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data.subarray(0, length));
}
// node_modules/ethers/lib.esm/wallet/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object2, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object2;
  for (const comp of path.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path);
  }
  return cur;
}

// node_modules/ethers/lib.esm/wallet/json-keystore.js
var defaultPath = "m/44'/60'/0'/0/0";
function isKeystoreJson(json) {
  try {
    const data = JSON.parse(json);
    const version2 = data.version != null ? parseInt(data.version) : 0;
    if (version2 === 3) {
      return true;
    }
  } catch (error) {}
  return false;
}
function decrypt(data, key, ciphertext) {
  const cipher = spelunk(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert2(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  const account = { address, privateKey };
  const version2 = spelunk(data, "x-ethers.version:string");
  if (version2 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk(data, "x-ethers.path:string") || defaultPath,
      locale: spelunk(data, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data) {
  const kdf = spelunk(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const N2 = spelunk(data, "crypto.kdfparams.n:int!");
      const r = spelunk(data, "crypto.kdfparams.r:int!");
      const p = spelunk(data, "crypto.kdfparams.p:int!");
      assertArgument(N2 > 0 && (N2 & N2 - 1) === 0, "invalid kdf.N", "kdf.N", N2);
      assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N2, r, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf22(password, salt2, count, dkLen2, algorithm);
    return getAccount(data, key2);
  }
  assert2(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key = scryptSync(password, salt, N2, r, p, dkLen);
  return getAccount(data, key);
}
function stall3(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall3(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf22(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall3(0);
    }
    return getAccount(data, key2);
  }
  assert2(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r, p, dkLen } = params;
  const key = await scrypt2(password, salt, N2, r, p, dkLen, progress);
  return getAccount(data, key);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes3(32);
  let N2 = 1 << 17, r = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
  assertArgument(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N2, r, p };
}
function _encryptKeystore(key, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes3(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes3(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak256(concat([macPrefix, ciphertext]));
  const data = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV4(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version}`;
    const path = account.mnemonic.path || defaultPath;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes3(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = new Date;
    const timestamp = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt2(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account, options);
}

// node_modules/ethers/lib.esm/wallet/hdwallet.js
var defaultPath2 = "m/44'/60'/0'/0/0";
var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit = 2147483648;
var N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles2 = "0123456789abcdef";
function zpad2(value, length) {
  let result = "";
  while (value) {
    result = Nibbles2[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value) {
  const value = getBytes(_value);
  const check = dataSlice(sha2562(sha2562(value)), 0, 4);
  const bytes2 = concat([value, check]);
  return encodeBase58(bytes2);
}
var _guard6 = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  const data = new Uint8Array(37);
  if (index & HardenedBit) {
    assert2(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data.set(getBytes(privateKey), 1);
  } else {
    data.set(getBytes(publicKey));
  }
  for (let i = 24;i >= 0; i -= 8) {
    data[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path);
    components.shift();
  }
  let result = node;
  for (let i = 0;i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}

class HDNodeWallet extends BaseWallet {
  publicKey;
  fingerprint;
  parentFingerprint;
  mnemonic;
  chainCode;
  path;
  index;
  depth;
  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
    super(signingKey, provider);
    assertPrivate(guard, _guard6, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd1602(sha2562(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index,
      depth
    });
    defineProperties(this, { mnemonic });
  }
  connect(provider) {
    return new HDNodeWallet(_guard6, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
  }
  #account() {
    const account = { address: this.address, privateKey: this.privateKey };
    const m = this.mnemonic;
    if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
      account.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: m.entropy
      };
    }
    return account;
  }
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(this.#account(), password, { progressCallback });
  }
  encryptSync(password) {
    return encryptKeystoreJsonSync(this.#account(), password);
  }
  get extendedKey() {
    assert2(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  hasPath() {
    return this.path != null;
  }
  neuter() {
    return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N2, 32));
    return new HDNodeWallet(_guard6, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
  }
  derivePath(path) {
    return derivePath(this, path);
  }
  static #fromSeed(_seed, mnemonic) {
    assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
    const seed = getBytes(_seed, "seed");
    assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const I = getBytes(computeHmac("sha512", MasterSecret, seed));
    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
    return new HDNodeWallet(_guard6, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes2 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes2.length === 82 || encodeBase58Check(bytes2.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes2[4];
    const parentFingerprint = hexlify(bytes2.slice(5, 9));
    const index = parseInt(hexlify(bytes2.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes2.slice(13, 45));
    const key = bytes2.slice(45, 78);
    switch (hexlify(bytes2.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard6, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new HDNodeWallet(_guard6, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  static createRandom(password, path, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath2;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromEntropy(randomBytes3(16), password, wordlist2);
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  static fromMnemonic(mnemonic, path) {
    if (!path) {
      path = defaultPath2;
    }
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  static fromPhrase(phrase, password, path, wordlist2) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath2;
    }
    if (wordlist2 == null) {
      wordlist2 = LangEn.wordlist();
    }
    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist2);
    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);
  }
  static fromSeed(seed) {
    return HDNodeWallet.#fromSeed(seed, null);
  }
}

class HDNodeVoidWallet extends VoidSigner {
  publicKey;
  fingerprint;
  parentFingerprint;
  chainCode;
  path;
  index;
  depth;
  constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
    super(address, provider);
    assertPrivate(guard, _guard6, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd1602(sha2562(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index,
      depth
    });
  }
  connect(provider) {
    return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
  }
  get extendedKey() {
    assert2(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  hasPath() {
    return this.path != null;
  }
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address = computeAddress(Ki);
    return new HDNodeVoidWallet(_guard6, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
  }
  derivePath(path) {
    return derivePath(this, path);
  }
}
function getAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/${index}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/0'/0/${index}`;
}
// node_modules/ethers/lib.esm/wallet/json-crowdsale.js
function isCrowdsaleJson(json) {
  try {
    const data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error) {}
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data = JSON.parse(json);
  const password = getPassword(_password);
  const address = getAddress(spelunk(data, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes(pbkdf22(password, password, 2000, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0;i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address, privateKey: id(seedHex) };
}
// node_modules/ethers/lib.esm/wallet/wallet.js
function stall4(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}

class Wallet extends BaseWallet {
  constructor(key, provider) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider);
  }
  connect(provider) {
    return new Wallet(this.signingKey, provider);
  }
  async encrypt(password, progressCallback) {
    const account = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account, password, { progressCallback });
  }
  encryptSync(password) {
    const account = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account, password);
  }
  static #fromAccount(account) {
    assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
      const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
      const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
      if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
        return wallet2;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    const wallet = new Wallet(account.privateKey);
    assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet;
  }
  static async fromEncryptedJson(json, password, progress) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = await decryptKeystoreJson(json, password, progress);
    } else if (isCrowdsaleJson(json)) {
      if (progress) {
        progress(0);
        await stall4(0);
      }
      account = decryptCrowdsaleJson(json, password);
      if (progress) {
        progress(1);
        await stall4(0);
      }
    }
    return Wallet.#fromAccount(account);
  }
  static fromEncryptedJsonSync(json, password) {
    let account = null;
    if (isKeystoreJson(json)) {
      account = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return Wallet.#fromAccount(account);
  }
  static createRandom(provider) {
    const wallet = HDNodeWallet.createRandom();
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
  static fromPhrase(phrase, provider) {
    const wallet = HDNodeWallet.fromPhrase(phrase);
    if (provider) {
      return wallet.connect(provider);
    }
    return wallet;
  }
}
// node_modules/ethers/lib.esm/wordlists/bit-reader.js
var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
function decodeBits(width, data) {
  const maxValue2 = (1 << width) - 1;
  const result = [];
  let accum = 0, bits = 0, flood = 0;
  for (let i = 0;i < data.length; i++) {
    accum = accum << 6 | Base64.indexOf(data[i]);
    bits += 6;
    while (bits >= width) {
      const value = accum >> bits - width;
      accum &= (1 << bits - width) - 1;
      bits -= width;
      if (value === 0) {
        flood += maxValue2;
      } else {
        result.push(value + flood);
        flood = 0;
      }
    }
  }
  return result;
}

// node_modules/ethers/lib.esm/wordlists/decode-owla.js
function decodeOwlA(data, accents) {
  let words2 = decodeOwl(data).join(",");
  accents.split(/,/g).forEach((accent) => {
    const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument(match !== null, "internal error parsing accents", "accents", accents);
    let posOffset = 0;
    const positions = decodeBits(parseInt(match[3]), match[4]);
    const charCode = parseInt(match[2]);
    const regex = new RegExp(`([${match[1]}])`, "g");
    words2 = words2.replace(regex, (all, letter) => {
      const rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words2.split(",");
}

// node_modules/ethers/lib.esm/wordlists/wordlist-owla.js
class WordlistOwlA extends WordlistOwl {
  #accent;
  constructor(locale, data, accent, checksum2) {
    super(locale, data, checksum2);
    this.#accent = accent;
  }
  get _accent() {
    return this.#accent;
  }
  _decodeWords() {
    return decodeOwlA(this._data, this._accent);
  }
}
// node_modules/ethers/lib.esm/wordlists/wordlists-browser.js
var wordlists = {
  en: LangEn.wordlist()
};
// src/utils.ts
var import_node_fetch = __toESM(require_browser(), 1);

// node_modules/@solana/web3.js/lib/index.browser.esm.js
init_buffer();

// node_modules/@noble/hashes/esm/crypto.js
var crypto4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;

// node_modules/@noble/hashes/esm/utils.js
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function u322(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i2 = 0;i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr2(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i2 = 0;i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
  return arr;
}
var swap32IfBE = isLE2 ? (u) => u : byteSwap32;
var hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(bytes2) {
  abytes(bytes2);
  if (hasHexBuiltin)
    return bytes2.toHex();
  let hex = "";
  for (let i2 = 0;i2 < bytes2.length; i2++) {
    hex += hexes2[bytes2[i2]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  abytes(data);
  return data;
}
function concatBytes3(...arrays) {
  let sum2 = 0;
  for (let i2 = 0;i2 < arrays.length; i2++) {
    const a = arrays[i2];
    abytes(a);
    sum2 += a.length;
  }
  const res = new Uint8Array(sum2);
  for (let i2 = 0, pad = 0;i2 < arrays.length; i2++) {
    const a = arrays[i2];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
class Hash2 {
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes4(bytesLength = 32) {
  if (crypto4 && typeof crypto4.getRandomValues === "function") {
    return crypto4.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto4 && typeof crypto4.randomBytes === "function") {
    return Uint8Array.from(crypto4.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
function Chi2(a, b2, c) {
  return a & b2 ^ ~a & c;
}
function Maj2(a, b2, c) {
  return a & b2 ^ a & c ^ b2 & c;
}

class HashMD extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes2(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len2 = data.length;
    for (let pos = 0;pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (;blockLen <= len2 - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos;i2 < blockLen; i2++)
      buffer[i2] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len2 = this.outputLen;
    if (len2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len2 / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0;i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n2 = /* @__PURE__ */ BigInt(32);
function fromBig2(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK642), l: Number(n2 >> _32n2 & U32_MASK642) };
  return { h: Number(n2 >> _32n2 & U32_MASK642) | 0, l: Number(n2 & U32_MASK642) | 0 };
}
function split3(lst, le = false) {
  const len2 = lst.length;
  let Ah = new Uint32Array(len2);
  let Al = new Uint32Array(len2);
  for (let i2 = 0;i2 < len2; i2++) {
    const { h, l } = fromBig2(lst[i2], le);
    [Ah[i2], Al[i2]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH2 = (h, _l, s) => h >>> s;
var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add3(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);

class SHA2562 extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E: E2, F, G, H } = this;
    return [A, B, C, D, E2, F, G, H];
  }
  set(A, B, C, D, E2, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E2 | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0;i2 < 16; i2++, offset += 4)
      SHA256_W2[i2] = view.getUint32(offset, false);
    for (let i2 = 16;i2 < 64; i2++) {
      const W15 = SHA256_W2[i2 - 15];
      const W2 = SHA256_W2[i2 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
    }
    let { A, B, C, D, E: E2, F, G, H } = this;
    for (let i2 = 0;i2 < 64; i2++) {
      const sigma1 = rotr2(E2, 6) ^ rotr2(E2, 11) ^ rotr2(E2, 25);
      const T13 = H + sigma1 + Chi2(E2, F, G) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T22 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E2;
      E2 = D + T13 | 0;
      D = C;
      C = B;
      B = A;
      A = T13 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E2 = E2 + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E2, F, G, H);
  }
  roundClean() {
    clean(SHA256_W2);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
}
var K512 = /* @__PURE__ */ (() => split3([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh2 = /* @__PURE__ */ (() => K512[0])();
var SHA512_Kl2 = /* @__PURE__ */ (() => K512[1])();
var SHA512_W_H2 = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L2 = /* @__PURE__ */ new Uint32Array(80);

class SHA5122 extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0;i2 < 16; i2++, offset += 4) {
      SHA512_W_H2[i2] = view.getUint32(offset);
      SHA512_W_L2[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16;i2 < 80; i2++) {
      const W15h = SHA512_W_H2[i2 - 15] | 0;
      const W15l = SHA512_W_L2[i2 - 15] | 0;
      const s0h = rotrSH2(W15h, W15l, 1) ^ rotrSH2(W15h, W15l, 8) ^ shrSH2(W15h, W15l, 7);
      const s0l = rotrSL2(W15h, W15l, 1) ^ rotrSL2(W15h, W15l, 8) ^ shrSL2(W15h, W15l, 7);
      const W2h = SHA512_W_H2[i2 - 2] | 0;
      const W2l = SHA512_W_L2[i2 - 2] | 0;
      const s1h = rotrSH2(W2h, W2l, 19) ^ rotrBH2(W2h, W2l, 61) ^ shrSH2(W2h, W2l, 6);
      const s1l = rotrSL2(W2h, W2l, 19) ^ rotrBL2(W2h, W2l, 61) ^ shrSL2(W2h, W2l, 6);
      const SUMl = add4L2(s0l, s1l, SHA512_W_L2[i2 - 7], SHA512_W_L2[i2 - 16]);
      const SUMh = add4H2(SUMl, s0h, s1h, SHA512_W_H2[i2 - 7], SHA512_W_H2[i2 - 16]);
      SHA512_W_H2[i2] = SUMh | 0;
      SHA512_W_L2[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0;i2 < 80; i2++) {
      const sigma1h = rotrSH2(Eh, El, 14) ^ rotrSH2(Eh, El, 18) ^ rotrBH2(Eh, El, 41);
      const sigma1l = rotrSL2(Eh, El, 14) ^ rotrSL2(Eh, El, 18) ^ rotrBL2(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L2(Hl, sigma1l, CHIl, SHA512_Kl2[i2], SHA512_W_L2[i2]);
      const T1h = add5H2(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i2], SHA512_W_H2[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH2(Ah, Al, 28) ^ rotrBH2(Ah, Al, 34) ^ rotrBH2(Ah, Al, 39);
      const sigma0l = rotrSL2(Ah, Al, 28) ^ rotrBL2(Ah, Al, 34) ^ rotrBL2(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add3(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L2(T1l, sigma0l, MAJl);
      Ah = add3H2(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add3(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add3(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add3(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add3(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add3(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add3(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add3(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add3(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H2, SHA512_W_L2);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
var sha2563 = /* @__PURE__ */ createHasher(() => new SHA2562);
var sha5123 = /* @__PURE__ */ createHasher(() => new SHA5122);

// node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n7 = /* @__PURE__ */ BigInt(0);
var _1n7 = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded2(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n7 : BigInt("0x" + hex);
}
function bytesToNumberBE2(bytes2) {
  return hexToNumber2(bytesToHex2(bytes2));
}
function bytesToNumberLE2(bytes2) {
  abytes(bytes2);
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE2(n2, len2) {
  return hexToBytes2(n2.toString(16).padStart(len2 * 2, "0"));
}
function numberToBytesLE2(n2, len2) {
  return numberToBytesBE2(n2, len2).reverse();
}
function ensureBytes2(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len2 = res.length;
  if (typeof expectedLength === "number" && len2 !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len2);
  return res;
}
var isPosBig = (n2) => typeof n2 === "bigint" && _0n7 <= n2;
function inRange(n2, min2, max2) {
  return isPosBig(n2) && isPosBig(min2) && isPosBig(max2) && min2 <= n2 && n2 < max2;
}
function aInRange(title, n2, min2, max2) {
  if (!inRange(n2, min2, max2))
    throw new Error("expected valid " + title + ": " + min2 + " <= n < " + max2 + ", got " + n2);
}
function bitLen2(n2) {
  let len2;
  for (len2 = 0;n2 > _0n7; n2 >>= _1n7, len2 += 1)
    ;
  return len2;
}
var bitMask2 = (n2) => (_1n7 << BigInt(n2)) - _1n7;
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n2 = (len2) => new Uint8Array(len2);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed = (seed = u8n2(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen2 = () => {
    if (i2++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len2 = 0;
    const out = [];
    while (len2 < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len2 += v.length;
    }
    return concatBytes3(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function _validateObject(object2, fields2, optFields = {}) {
  if (!object2 || typeof object2 !== "object")
    throw new Error("expected valid options object");
  function checkField2(fieldName, expectedType, isOpt) {
    const val = object2[fieldName];
    if (isOpt && val === undefined)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields2).forEach(([k, v]) => checkField2(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField2(k, v, true));
}
function memoized(fn) {
  const map = new WeakMap;
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== undefined)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n6 = /* @__PURE__ */ BigInt(2);
var _3n3 = /* @__PURE__ */ BigInt(3);
var _4n3 = /* @__PURE__ */ BigInt(4);
var _5n2 = /* @__PURE__ */ BigInt(5);
var _8n2 = /* @__PURE__ */ BigInt(8);
function mod3(a, b2) {
  const result = a % b2;
  return result >= _0n8 ? result : b2 + result;
}
function pow23(x, power, modulo) {
  let res = x;
  while (power-- > _0n8) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number2, modulo) {
  if (number2 === _0n8)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n8)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod3(number2, modulo);
  let b2 = modulo;
  let x = _0n8, y = _1n8, u = _1n8, v = _0n8;
  while (a !== _0n8) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x - u * q;
    const n2 = y - v * q;
    b2 = a, a = r, x = u, y = v, u = m, v = n2;
  }
  const gcd = b2;
  if (gcd !== _1n8)
    throw new Error("invert: does not exist");
  return mod3(x, modulo);
}
function sqrt3mod4(Fp2, n2) {
  const p1div4 = (Fp2.ORDER + _1n8) / _4n3;
  const root = Fp2.pow(n2, p1div4);
  if (!Fp2.eql(Fp2.sqr(root), n2))
    throw new Error("Cannot find square root");
  return root;
}
function sqrt5mod8(Fp2, n2) {
  const p5div8 = (Fp2.ORDER - _5n2) / _8n2;
  const n22 = Fp2.mul(n2, _2n6);
  const v = Fp2.pow(n22, p5div8);
  const nv = Fp2.mul(n2, v);
  const i2 = Fp2.mul(Fp2.mul(nv, _2n6), v);
  const root = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
  if (!Fp2.eql(Fp2.sqr(root), n2))
    throw new Error("Cannot find square root");
  return root;
}
function tonelliShanks2(P2) {
  if (P2 < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let Q = P2 - _1n8;
  let S2 = 0;
  while (Q % _2n6 === _0n8) {
    Q /= _2n6;
    S2++;
  }
  let Z = _2n6;
  const _Fp = Field2(P2);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1000)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S2 === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n8) / _2n6;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.is0(n2))
      return n2;
    if (FpLegendre(Fp2, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S2;
    let c = Fp2.mul(Fp2.ONE, cc);
    let t = Fp2.pow(n2, Q);
    let R = Fp2.pow(n2, Q1div2);
    while (!Fp2.eql(t, Fp2.ONE)) {
      if (Fp2.is0(t))
        return Fp2.ZERO;
      let i2 = 1;
      let t_tmp = Fp2.sqr(t);
      while (!Fp2.eql(t_tmp, Fp2.ONE)) {
        i2++;
        t_tmp = Fp2.sqr(t_tmp);
        if (i2 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n8 << BigInt(M - i2 - 1);
      const b2 = Fp2.pow(c, exponent);
      M = i2;
      c = Fp2.sqr(b2);
      t = Fp2.mul(t, c);
      R = Fp2.mul(R, b2);
    }
    return R;
  };
}
function FpSqrt2(P2) {
  if (P2 % _4n3 === _3n3)
    return sqrt3mod4;
  if (P2 % _8n2 === _5n2)
    return sqrt5mod8;
  return tonelliShanks2(P2);
}
var isNegativeLE = (num, modulo) => (mod3(num, modulo) & _1n8) === _1n8;
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS2.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow2(Fp2, num, power) {
  if (power < _0n8)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n8)
    return Fp2.ONE;
  if (power === _1n8)
    return num;
  let p = Fp2.ONE;
  let d = num;
  while (power > _0n8) {
    if (power & _1n8)
      p = Fp2.mul(p, d);
    d = Fp2.sqr(d);
    power >>= _1n8;
  }
  return p;
}
function FpInvertBatch2(Fp2, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : undefined);
  const multipliedAcc = nums.reduce((acc, num, i2) => {
    if (Fp2.is0(num))
      return acc;
    inverted[i2] = acc;
    return Fp2.mul(acc, num);
  }, Fp2.ONE);
  const invertedAcc = Fp2.inv(multipliedAcc);
  nums.reduceRight((acc, num, i2) => {
    if (Fp2.is0(num))
      return acc;
    inverted[i2] = Fp2.mul(acc, inverted[i2]);
    return Fp2.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp2, n2) {
  const p1mod2 = (Fp2.ORDER - _1n8) / _2n6;
  const powered = Fp2.pow(n2, p1mod2);
  const yes = Fp2.eql(powered, Fp2.ONE);
  const zero = Fp2.eql(powered, Fp2.ZERO);
  const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength2(n2, nBitLength) {
  if (nBitLength !== undefined)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== undefined ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLenOrOpts, isLE3 = false, opts = {}) {
  if (ORDER <= _0n8)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = undefined;
  let _sqrt = undefined;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE3)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE3 = _opts.isLE;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f2 = Object.freeze({
    ORDER,
    isLE: isLE3,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n8,
    ONE: _1n8,
    create: (num) => mod3(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n8 <= num && num < ORDER;
    },
    is0: (num) => num === _0n8,
    isValidNot0: (num) => !f2.is0(num) && f2.isValid(num),
    isOdd: (num) => (num & _1n8) === _1n8,
    neg: (num) => mod3(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod3(num * num, ORDER),
    add: (lhs, rhs) => mod3(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod3(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod3(lhs * rhs, ORDER),
    pow: (num, power) => FpPow2(f2, num, power),
    div: (lhs, rhs) => mod3(lhs * invert2(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert2(num, ORDER),
    sqrt: _sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt2(ORDER);
      return sqrtP(f2, n2);
    }),
    toBytes: (num) => isLE3 ? numberToBytesLE2(num, BYTES) : numberToBytesBE2(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE3 ? bytesToNumberLE2(bytes2) : bytesToNumberBE2(bytes2);
    },
    invertBatch: (lst) => FpInvertBatch2(f2, lst),
    cmov: (a, b2, c) => c ? b2 : a
  });
  return Object.freeze(f2);
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length = getFieldBytesLength2(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField2(key, fieldOrder, isLE3 = false) {
  const len2 = key.length;
  const fieldLen = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len2 < 16 || len2 < minLen || len2 > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len2);
  const num = isLE3 ? bytesToNumberLE2(key) : bytesToNumberBE2(key);
  const reduced = mod3(num, fieldOrder - _1n8) + _1n8;
  return isLE3 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, property, points) {
  const getz = property === "pz" ? (p) => p.pz : (p) => p.ez;
  const toInv = FpInvertBatch2(c.Fp, points.map(getz));
  const affined = points.map((p, i2) => p.toAffine(toInv[i2]));
  return affined.map(c.fromAffine);
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask2 = bitMask2(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask: mask2, maxNumber, shiftBy };
}
function calcOffsets(n2, window2, wOpts) {
  const { windowSize, mask: mask2, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask2);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n9;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i2) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i2) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i2);
  });
}
var pointPrecomputes = new WeakMap;
var pointWindowSizes = new WeakMap;
function getW(P2) {
  return pointWindowSizes.get(P2) || 1;
}
function assert0(n2) {
  if (n2 !== _0n9)
    throw new Error("invalid wNAF");
}
function wNAF2(c, bits) {
  return {
    constTimeNegate: negateCt,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    unsafeLadder(elm, n2, p = c.ZERO) {
      let d = elm;
      while (n2 > _0n9) {
        if (n2 & _1n9)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n9;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i2 = 1;i2 < windowSize; i2++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n2) {
      let p = c.ZERO;
      let f2 = c.BASE;
      const wo = calcWOpts(W, bits);
      for (let window2 = 0;window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt(isNeg, precomputes[offset]));
        }
      }
      assert0(n2);
      return { p, f: f2 };
    },
    wNAFUnsafe(W, precomputes, n2, acc = c.ZERO) {
      const wo = calcWOpts(W, bits);
      for (let window2 = 0;window2 < wo.windows; window2++) {
        if (n2 === _0n9)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n2);
      return acc;
    },
    getPrecomputes(W, P2, transform) {
      let comp = pointPrecomputes.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes.set(P2, comp);
        }
      }
      return comp;
    },
    wNAFCached(P2, n2, transform) {
      const W = getW(P2);
      return this.wNAF(W, this.getPrecomputes(W, P2, transform), n2);
    },
    wNAFCachedUnsafe(P2, n2, transform, prev) {
      const W = getW(P2);
      if (W === 1)
        return this.unsafeLadder(P2, n2, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P2, transform), n2, prev);
    },
    setWindowSize(P2, W) {
      validateW(W, bits);
      pointWindowSizes.set(P2, W);
      pointPrecomputes.delete(P2);
    }
  };
}
function mulEndoUnsafe(c, point, k1, k2) {
  let acc = point;
  let p1 = c.ZERO;
  let p2 = c.ZERO;
  while (k1 > _0n9 || k2 > _0n9) {
    if (k1 & _1n9)
      p1 = p1.add(acc);
    if (k2 & _1n9)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n9;
    k2 >>= _1n9;
  }
  return { p1, p2 };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen2(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask2(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum2 = zero;
  for (let i2 = lastBits;i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero);
    for (let j = 0;j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero;j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum2 = sum2.add(resI);
    if (i2 !== 0)
      for (let j = 0;j < windowSize; j++)
        sum2 = sum2.double();
  }
  return sum2;
}
function createField(order, field) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField2(field);
    return field;
  } else {
    return Field2(order);
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}) {
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n9))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp2 = createField(CURVE.p, curveOpts.Fp);
  const Fn = createField(CURVE.n, curveOpts.Fn);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp2.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  return { Fp: Fp2, Fn };
}

// node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
var _2n7 = BigInt(2);
var _8n3 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function isEdValidXY(Fp2, CURVE, x, y) {
  const x2 = Fp2.sqr(x);
  const y2 = Fp2.sqr(y);
  const left = Fp2.add(Fp2.mul(CURVE.a, x2), y2);
  const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x2, y2)));
  return Fp2.eql(left, right);
}
function edwards(CURVE, curveOpts = {}) {
  const { Fp: Fp2, Fn } = _createCurveFields("edwards", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, { uvRatio: "function" });
  const MASK = _2n7 << BigInt(Fn.BYTES * 8) - _1n10;
  const modP = (n2) => Fp2.create(n2);
  const uvRatio = curveOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(Fp2.div(u, v)) };
    } catch (e) {
      return { isValid: false, value: _0n10 };
    }
  });
  if (!isEdValidXY(Fp2, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min2 = banZero ? _1n10 : _0n10;
    aInRange("coordinate " + title, n2, min2, MASK);
    return n2;
  }
  function aextpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n3 : Fp2.inv(z);
    const ax = modP(x * iz);
    const ay = modP(y * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n10, y: _1n10 };
    if (zz !== _1n10)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });

  class Point2 {
    constructor(ex, ey, ez, et) {
      this.ex = acoord("x", ex);
      this.ey = acoord("y", ey);
      this.ez = acoord("z", ez, true);
      this.et = acoord("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point2(x, y, _1n10, modP(x * y));
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, "ez", points);
    }
    static msm(points, scalars) {
      return pippenger(Point2, Fn, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_2n7);
      return this;
    }
    assertValidity() {
      assertValidMemo(this);
    }
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n7 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E2 = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E2 * F);
      const Y3 = modP(G * H);
      const T32 = modP(E2 * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T32);
    }
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T13 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T22 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T13 * d * T22);
      const D = modP(Z1 * Z2);
      const E2 = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E2 * F);
      const Y3 = modP(G * H);
      const T32 = modP(E2 * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      const n2 = scalar;
      aInRange("scalar", n2, _1n10, CURVE_ORDER);
      const { p, f: f2 } = wnaf.wNAFCached(this, n2, Point2.normalizeZ);
      return Point2.normalizeZ([p, f2])[0];
    }
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      const n2 = scalar;
      aInRange("scalar", n2, _0n10, CURVE_ORDER);
      if (n2 === _0n10)
        return Point2.ZERO;
      if (this.is0() || n2 === _1n10)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n2, Point2.normalizeZ, acc);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    isTorsionFree() {
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n10)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    static fromBytes(bytes2, zip215 = false) {
      abytes(bytes2);
      return this.fromHex(bytes2, zip215);
    }
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len2 = Fp2.BYTES;
      hex = ensureBytes2("pointHex", hex, len2);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len2 - 1];
      normed[len2 - 1] = lastByte & ~128;
      const y = bytesToNumberLE2(normed);
      const max2 = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y, _0n10, max2);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n10);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x & _1n10) === _1n10;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n10 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point2.fromAffine({ x, y });
    }
    static fromPrivateScalar(scalar) {
      return Point2.BASE.multiply(scalar);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes2 = numberToBytesLE2(y, Fp2.BYTES);
      bytes2[bytes2.length - 1] |= x & _1n10 ? 128 : 0;
      return bytes2;
    }
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex2(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n10, modP(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n10, _1n10, _1n10, _0n10);
  Point2.Fp = Fp2;
  Point2.Fn = Fn;
  const wnaf = wNAF2(Point2, Fn.BYTES * 8);
  return Point2;
}
function eddsa(Point2, eddsaOpts) {
  _validateObject(eddsaOpts, {
    hash: "function"
  }, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash, hash: cHash } = eddsaOpts;
  const { BASE: G, Fp: Fp2, Fn } = Point2;
  const CURVE_ORDER = Fn.ORDER;
  const randomBytes_ = eddsaOpts.randomBytes || randomBytes4;
  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN(a) {
    return Fn.create(a);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE2(hash2));
  }
  function getPrivateScalar(key) {
    const len2 = Fp2.BYTES;
    key = ensureBytes2("private key", key, len2);
    const hashed = ensureBytes2("hashed private key", cHash(key), 2 * len2);
    const head = adjustScalarBytes(hashed.slice(0, len2));
    const prefix = hashed.slice(len2, 2 * len2);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head, prefix, scalar } = getPrivateScalar(key);
    const point = G.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes3(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes2("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options = {}) {
    msg = ensureBytes2("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    aInRange("signature.s", s, _0n10, CURVE_ORDER);
    const L = Fp2.BYTES;
    const res = concatBytes3(R, numberToBytesLE2(s, L));
    return ensureBytes2("result", res, L * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len2 = Fp2.BYTES;
    sig = ensureBytes2("signature", sig, 2 * len2);
    msg = ensureBytes2("message", msg);
    publicKey = ensureBytes2("publicKey", publicKey, len2);
    if (zip215 !== undefined)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE2(sig.slice(len2, 2 * len2));
    let A, R, SB;
    try {
      A = Point2.fromHex(publicKey, zip215);
      R = Point2.fromHex(sig.slice(0, len2), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  G.precompute(8);
  const utils = {
    getExtendedPublicKey,
    randomPrivateKey: () => randomBytes_(Fp2.BYTES),
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return { getPublicKey, sign: sign2, verify, utils, Point: Point2 };
}
function _eddsa_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp2 = c.Fp;
  const Fn = Field2(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp2, Fn, uvRatio: c.uvRatio };
  const eddsaOpts = {
    hash: c.hash,
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa2) {
  const legacy = Object.assign({}, eddsa2, { ExtendedPoint: eddsa2.Point, CURVE: c });
  return legacy;
}
function twistedEdwards(c) {
  const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
  const Point2 = edwards(CURVE, curveOpts);
  const EDDSA = eddsa(Point2, eddsaOpts);
  return _eddsa_new_output_to_legacy(c, EDDSA);
}

// node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n11 = BigInt(0);
var _1n11 = BigInt(1);
var _2n8 = BigInt(2);
var _3n4 = BigInt(3);
var _5n3 = BigInt(5);
var _8n4 = BigInt(8);
var ed25519_CURVE = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n4,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P2 = ed25519_CURVE.p;
  const x2 = x * x % P2;
  const b2 = x2 * x % P2;
  const b4 = pow23(b2, _2n8, P2) * b2 % P2;
  const b5 = pow23(b4, _1n11, P2) * x % P2;
  const b10 = pow23(b5, _5n3, P2) * b5 % P2;
  const b20 = pow23(b10, _10n, P2) * b10 % P2;
  const b40 = pow23(b20, _20n, P2) * b20 % P2;
  const b80 = pow23(b40, _40n, P2) * b40 % P2;
  const b160 = pow23(b80, _80n, P2) * b80 % P2;
  const b240 = pow23(b160, _80n, P2) * b80 % P2;
  const b250 = pow23(b240, _10n, P2) * b10 % P2;
  const pow_p_5_8 = pow23(b250, _2n8, P2) * x % P2;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u, v) {
  const P2 = ed25519_CURVE.p;
  const v3 = mod3(v * v * v, P2);
  const v7 = mod3(v3 * v3 * v, P2);
  const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod3(u * v3 * pow3, P2);
  const vx2 = mod3(v * x * x, P2);
  const root1 = x;
  const root2 = mod3(x * ED25519_SQRT_M1, P2);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod3(-u, P2);
  const noRoot = vx2 === mod3(-u * ED25519_SQRT_M1, P2);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P2))
    x = mod3(-x, P2);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var Fp2 = /* @__PURE__ */ (() => Field2(ed25519_CURVE.p, undefined, true))();
var ed25519Defaults = /* @__PURE__ */ (() => ({
  ...ed25519_CURVE,
  Fp: Fp2,
  hash: sha5123,
  adjustScalarBytes,
  uvRatio
}))();
var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_bn = __toESM(require_bn(), 1);
var import_bs58 = __toESM(require_bs58(), 1);

// node_modules/@noble/hashes/esm/sha256.js
var sha2564 = sha2563;

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_borsh = __toESM(require_lib(), 1);
var BufferLayout = __toESM(require_Layout(), 1);
var import_buffer_layout = __toESM(require_Layout(), 1);

// node_modules/@solana/errors/dist/index.browser.mjs
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
var SOLANA_ERROR__INVALID_NONCE = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
var SolanaErrorMessages = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: `This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX = "i";
var TYPE = "t";
function getHumanReadableErrorMessage(code2, context = {}) {
  const messageFormatString = SolanaErrorMessages[code2];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
      fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);
    } else if (state[TYPE] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii) => {
    if (ii === 0) {
      state = {
        [START_INDEX]: 0,
        [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
      };
      return;
    }
    let nextState;
    switch (state[TYPE]) {
      case 0:
        nextState = { [START_INDEX]: ii, [TYPE]: 1 };
        break;
      case 1:
        if (char === "\\") {
          nextState = { [START_INDEX]: ii, [TYPE]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX]: ii, [TYPE]: 2 };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = { [START_INDEX]: ii, [TYPE]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX]: ii, [TYPE]: 2 };
        } else if (!char.match(/\w/)) {
          nextState = { [START_INDEX]: ii, [TYPE]: 1 };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage(code2, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage(code2, context);
  } else {}
}
var SolanaError = class extends Error {
  cause = this.cause;
  context;
  constructor(...[code2, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage(code2, context);
    super(message, errorOptions);
    this.context = {
      __code: code2,
      ...context
    };
    this.name = "SolanaError";
  }
};

// node_modules/@solana/codecs-core/dist/index.browser.mjs
function getEncodedSize(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes2 = new Uint8Array(getEncodedSize(value, encoder));
      encoder.write(value, bytes2, 0);
      return bytes2;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes2, offset = 0) => decoder.read(bytes2, offset)[0]
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec(encoder, decoder) {
  if (isFixedSize(encoder) !== isFixedSize(decoder)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  }
  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes2, offset = 0) {
  if (bytes2.length - offset <= 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes2, offset = 0) {
  const bytesLength = bytes2.length - offset;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}

// node_modules/@solana/codecs-numbers/dist/index.browser.mjs
function assertNumberIsBetweenForCodec(codecDescription, min2, max2, value) {
  if (value < min2 || value > max2) {
    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
      codecDescription,
      max: max2,
      min: min2,
      value
    });
  }
}
function isLittleEndian(config2) {
  return config2?.endian === 1 ? false : true;
}
function numberEncoderFactory(input) {
  return createEncoder({
    fixedSize: input.size,
    write(value, bytes2, offset) {
      if (input.range) {
        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
      bytes2.set(new Uint8Array(arrayBuffer), offset);
      return offset + input.size;
    }
  });
}
function numberDecoderFactory(input) {
  return createDecoder({
    fixedSize: input.size,
    read(bytes2, offset = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes2, offset);
      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes2, offset);
      const view = new DataView(toArrayBuffer(bytes2, offset, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset + input.size];
    }
  });
}
function toArrayBuffer(bytes2, offset, length) {
  const bytesOffset = bytes2.byteOffset + (offset ?? 0);
  const bytesLength = length ?? bytes2.byteLength;
  return bytes2.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder = (config2 = {}) => numberEncoderFactory({
  config: config2,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
  size: 8
});
var getU64Decoder = (config2 = {}) => numberDecoderFactory({
  config: config2,
  get: (view, le) => view.getBigUint64(0, le),
  name: "u64",
  size: 8
});
var getU64Codec = (config2 = {}) => combineCodec(getU64Encoder(config2), getU64Decoder(config2));

// node_modules/superstruct/dist/index.mjs
class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
}
function isIterable(x) {
  return isObject2(x) && typeof x[Symbol.iterator] === "function";
}
function isObject2(x) {
  return typeof x === "object" && x != null;
}
function isNonArrayObject(x) {
  return isObject2(x) && !Array.isArray(x);
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done, value } = input.next();
  return done ? undefined : value;
}
function toFailure(result, context, struct, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type } = struct;
  const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure(r, context, struct, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct, options = {}) {
  const { path = [], branch = [value], coerce = false, mask: mask2 = false } = options;
  const ctx = { path, branch, mask: mask2 };
  if (coerce) {
    value = struct.coercer(value, ctx);
  }
  let status = "valid";
  for (const failure of struct.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, undefined];
  }
  for (let [k, v, s] of struct.entries(value, ctx)) {
    const ts = run(v, s, {
      path: k === undefined ? path : [...path, k],
      branch: k === undefined ? branch : [...branch, v],
      coerce,
      mask: mask2,
      message: options.message
    });
    for (const t of ts) {
      if (t[0]) {
        status = t[0].refinement != null ? "not_refined" : "not_valid";
        yield [t[0], undefined];
      } else if (coerce) {
        v = t[1];
        if (k === undefined) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject2(value)) {
          if (v !== undefined || k in value)
            value[k] = v;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, undefined];
    }
  }
  if (status === "valid") {
    yield [undefined, value];
  }
}

class Struct {
  constructor(props) {
    const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {} } = props;
    this.type = type;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  assert(value, message) {
    return assert3(value, this, message);
  }
  create(value, message) {
    return create3(value, this, message);
  }
  is(value) {
    return is(value, this);
  }
  mask(value, message) {
    return mask2(value, this, message);
  }
  validate(value, options = {}) {
    return validate(value, this, options);
  }
}
function assert3(value, struct, message) {
  const result = validate(value, struct, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create3(value, struct, message) {
  const result = validate(value, struct, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask2(value, struct, message) {
  const result = validate(value, struct, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct) {
  const result = validate(value, struct);
  return !result[0];
}
function validate(value, struct, options = {}) {
  const tuples = run(value, struct, options);
  const tuple = shiftIterator(tuples);
  if (tuple[0]) {
    const error = new StructError(tuple[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, undefined];
  } else {
    const v = tuple[1];
    return [undefined, v];
  }
}
function define2(name, validator) {
  return new Struct({ type: name, schema: null, validator });
}
function any() {
  return define2("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i2, v] of value.entries()) {
          yield [i2, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function boolean() {
  return define2("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance(Class) {
  return define2("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
  });
}
function literal(constant) {
  const description = print(constant);
  const t = typeof constant;
  return new Struct({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct) {
  return new Struct({
    ...struct,
    validator: (value, ctx) => value === null || struct.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
  });
}
function number2() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function optional(struct) {
  return new Struct({
    ...struct,
    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject2(value)) {
        for (const k in value) {
          const v = value[k];
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },
    validator(value) {
      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isNonArrayObject(value) ? { ...value } : value;
    }
  });
}
function string() {
  return define2("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function tuple(Structs) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Structs.length, value.length);
        for (let i2 = 0;i2 < length; i2++) {
          yield [i2, value[i2], Structs[i2] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject2(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isNonArrayObject(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      for (const S2 of Structs) {
        const [error, coerced] = S2.validate(value, {
          coerce: true,
          mask: ctx.mask
        });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run(value, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define2("unknown", () => true);
}
function coerce(struct, condition, coercer) {
  return new Struct({
    ...struct,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
    }
  });
}

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_browser = __toESM(require_browser2(), 1);

// node_modules/rpc-websockets/dist/index.browser.mjs
init_buffer();

// node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs
var import__ = __toESM(require_eventemitter3(), 1);

// node_modules/@noble/hashes/esm/sha3.js
var _0n12 = BigInt(0);
var _1n12 = BigInt(1);
var _2n9 = BigInt(2);
var _7n2 = BigInt(7);
var _256n2 = BigInt(256);
var _0x71n2 = BigInt(113);
var SHA3_PI2 = [];
var SHA3_ROTL2 = [];
var _SHA3_IOTA2 = [];
for (let round2 = 0, R = _1n12, x = 1, y = 0;round2 < 24; round2++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI2.push(2 * (5 * y + x));
  SHA3_ROTL2.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t = _0n12;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n12 ^ (R >> _7n2) * _0x71n2) % _256n2;
    if (R & _2n9)
      t ^= _1n12 << (_1n12 << /* @__PURE__ */ BigInt(j)) - _1n12;
  }
  _SHA3_IOTA2.push(t);
}
var IOTAS = split3(_SHA3_IOTA2, true);
var SHA3_IOTA_H2 = IOTAS[0];
var SHA3_IOTA_L2 = IOTAS[1];
var rotlH2 = (h, l, s) => s > 32 ? rotlBH2(h, l, s) : rotlSH2(h, l, s);
var rotlL2 = (h, l, s) => s > 32 ? rotlBL2(h, l, s) : rotlSL2(h, l, s);
function keccakP2(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds;round2 < 24; round2++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH2(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL2[t];
      const Th = rotlH2(curH, curL, shift);
      const Tl = rotlL2(curH, curL, shift);
      const PI2 = SHA3_PI2[t];
      curH = s[PI2];
      curL = s[PI2 + 1];
      s[PI2] = Th;
      s[PI2 + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H2[round2];
    s[1] ^= SHA3_IOTA_L2[round2];
  }
  clean(B);
}

class Keccak2 extends Hash2 {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u322(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP2(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    data = toBytes2(data);
    abytes(data);
    const { blockLen, state } = this;
    const len2 = data.length;
    for (let pos = 0;pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      for (let i3 = 0;i3 < take; i3++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len2 = out.length;pos < len2; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len2 - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen2 = (suffix, blockLen, outputLen) => createHasher(() => new Keccak2(blockLen, suffix, outputLen));
var keccak_2562 = /* @__PURE__ */ (() => gen2(1, 136, 256 / 8))();

// node_modules/@noble/hashes/esm/hmac.js
class HMAC2 extends Hash2 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash2);
    const key = toBytes2(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i3 = 0;i3 < pad.length; i3++)
      pad[i3] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i3 = 0;i3 < pad.length; i3++)
      pad[i3] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished2;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac2 = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
hmac2.create = (hash2, key) => new HMAC2(hash2, key);

// node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(opts) {
  if (opts.lowS !== undefined)
    abool("lowS", opts.lowS);
  if (opts.prehash !== undefined)
    abool("prehash", opts.prehash);
}

class DERErr2 extends Error {
  constructor(m = "") {
    super(m);
  }
}
var DER2 = {
  Err: DERErr2,
  _tlv: {
    encode: (tag2, data) => {
      const { Err: E2 } = DER2;
      if (tag2 < 0 || tag2 > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E2("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len2 = numberToHexUnpadded2(dataLen);
      if (len2.length / 2 & 128)
        throw new E2("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded2(len2.length / 2 | 128) : "";
      const t = numberToHexUnpadded2(tag2);
      return t + lenLen + len2 + data;
    },
    decode(tag2, data) {
      const { Err: E2 } = DER2;
      let pos = 0;
      if (tag2 < 0 || tag2 > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag2)
        throw new E2("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E2("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E2("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E2("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E2("tlv.decode(long): zero leftmost byte");
        for (const b2 of lengthBytes)
          length = length << 8 | b2;
        pos += lenLen;
        if (length < 128)
          throw new E2("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E2("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  _int: {
    encode(num) {
      const { Err: E2 } = DER2;
      if (num < _0n13)
        throw new E2("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded2(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E2("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E2 } = DER2;
      if (data[0] & 128)
        throw new E2("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E2("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE2(data);
    }
  },
  toSig(hex) {
    const { Err: E2, _int: int, _tlv: tlv } = DER2;
    const data = ensureBytes2("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER2;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n13 = BigInt(0);
var _1n13 = BigInt(1);
var _2n10 = BigInt(2);
var _3n5 = BigInt(3);
var _4n4 = BigInt(4);
function _legacyHelperEquat(Fp3, a, b2) {
  function weierstrassEquation(x) {
    const x2 = Fp3.sqr(x);
    const x3 = Fp3.mul(x2, x);
    return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b2);
  }
  return weierstrassEquation;
}
function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
  const { BYTES: expected } = Fn;
  function normPrivateKeyToScalar(key) {
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else {
      let bytes2 = ensureBytes2("private key", key);
      if (allowedPrivateKeyLengths) {
        if (!allowedPrivateKeyLengths.includes(bytes2.length * 2))
          throw new Error("invalid private key");
        const padded = new Uint8Array(expected);
        padded.set(bytes2, padded.length - bytes2.length);
        bytes2 = padded;
      }
      try {
        num = Fn.fromBytes(bytes2);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (wrapPrivateKey)
      num = Fn.create(num);
    if (!Fn.isValidNot0(num))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num;
  }
  return normPrivateKeyToScalar;
}
function weierstrassN(CURVE, curveOpts = {}) {
  const { Fp: Fp3, Fn } = _createCurveFields("weierstrass", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = curveOpts;
  if (endo) {
    if (!Fp3.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
  }
  function assertCompressionIsSupported() {
    if (!Fp3.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes(_c, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp3.toBytes(x);
    abool("isCompressed", isCompressed);
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp3.isOdd(y);
      return concatBytes3(pprefix(hasEvenY), bx);
    } else {
      return concatBytes3(Uint8Array.of(4), bx, Fp3.toBytes(y));
    }
  }
  function pointFromBytes(bytes2) {
    abytes(bytes2);
    const L = Fp3.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    const length = bytes2.length;
    const head = bytes2[0];
    const tail = bytes2.subarray(1);
    if (length === LC && (head === 2 || head === 3)) {
      const x = Fp3.fromBytes(tail);
      if (!Fp3.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp3.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp3.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp3.neg(y);
      return { x, y };
    } else if (length === LU && head === 4) {
      const x = Fp3.fromBytes(tail.subarray(L * 0, L * 1));
      const y = Fp3.fromBytes(tail.subarray(L * 1, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
    }
  }
  const toBytes3 = curveOpts.toBytes || pointToBytes;
  const fromBytes = curveOpts.fromBytes || pointFromBytes;
  const weierstrassEquation = _legacyHelperEquat(Fp3, CURVE.a, CURVE.b);
  function isValidXY(x, y) {
    const left = Fp3.sqr(y);
    const right = weierstrassEquation(x);
    return Fp3.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp3.mul(Fp3.pow(CURVE.a, _3n5), _4n4);
  const _27b2 = Fp3.mul(Fp3.sqr(CURVE.b), BigInt(27));
  if (Fp3.is0(Fp3.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp3.isValid(n2) || banZero && Fp3.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y, pz: z } = p;
    if (Fp3.eql(z, Fp3.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp3.ONE : Fp3.inv(z);
    const ax = Fp3.mul(x, iz);
    const ay = Fp3.mul(y, iz);
    const zz = Fp3.mul(z, iz);
    if (is0)
      return { x: Fp3.ZERO, y: Fp3.ZERO };
    if (!Fp3.eql(zz, Fp3.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (curveOpts.allowInfinityPoint && !Fp3.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp3.isValid(x) || !Fp3.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp3.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }

  class Point2 {
    constructor(px, py, pz) {
      this.px = acoord("x", px);
      this.py = acoord("y", py, true);
      this.pz = acoord("z", pz);
      Object.freeze(this);
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp3.is0(x) && Fp3.is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp3.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      return normalizeZ(Point2, "pz", points);
    }
    static fromBytes(bytes2) {
      abytes(bytes2);
      return Point2.fromHex(bytes2);
    }
    static fromHex(hex) {
      const P2 = Point2.fromAffine(fromBytes(ensureBytes2("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    static fromPrivateKey(privateKey) {
      const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    static msm(points, scalars) {
      return pippenger(Point2, Fn, points, scalars);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_3n5);
      return this;
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp3.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp3.isOdd(y);
    }
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
      const U22 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
      return U12 && U22;
    }
    negate() {
      return new Point2(this.px, Fp3.neg(this.py), this.pz);
    }
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp3.mul(b2, _3n5);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp3;
      let t0 = Fp3.mul(X1, X1);
      let t1 = Fp3.mul(Y1, Y1);
      let t2 = Fp3.mul(Z1, Z1);
      let t3 = Fp3.mul(X1, Y1);
      t3 = Fp3.add(t3, t3);
      Z3 = Fp3.mul(X1, Z1);
      Z3 = Fp3.add(Z3, Z3);
      X3 = Fp3.mul(a, Z3);
      Y3 = Fp3.mul(b3, t2);
      Y3 = Fp3.add(X3, Y3);
      X3 = Fp3.sub(t1, Y3);
      Y3 = Fp3.add(t1, Y3);
      Y3 = Fp3.mul(X3, Y3);
      X3 = Fp3.mul(t3, X3);
      Z3 = Fp3.mul(b3, Z3);
      t2 = Fp3.mul(a, t2);
      t3 = Fp3.sub(t0, t2);
      t3 = Fp3.mul(a, t3);
      t3 = Fp3.add(t3, Z3);
      Z3 = Fp3.add(t0, t0);
      t0 = Fp3.add(Z3, t0);
      t0 = Fp3.add(t0, t2);
      t0 = Fp3.mul(t0, t3);
      Y3 = Fp3.add(Y3, t0);
      t2 = Fp3.mul(Y1, Z1);
      t2 = Fp3.add(t2, t2);
      t0 = Fp3.mul(t2, t3);
      X3 = Fp3.sub(X3, t0);
      Z3 = Fp3.mul(t2, t1);
      Z3 = Fp3.add(Z3, Z3);
      Z3 = Fp3.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp3;
      const a = CURVE.a;
      const b3 = Fp3.mul(CURVE.b, _3n5);
      let t0 = Fp3.mul(X1, X2);
      let t1 = Fp3.mul(Y1, Y2);
      let t2 = Fp3.mul(Z1, Z2);
      let t3 = Fp3.add(X1, Y1);
      let t4 = Fp3.add(X2, Y2);
      t3 = Fp3.mul(t3, t4);
      t4 = Fp3.add(t0, t1);
      t3 = Fp3.sub(t3, t4);
      t4 = Fp3.add(X1, Z1);
      let t5 = Fp3.add(X2, Z2);
      t4 = Fp3.mul(t4, t5);
      t5 = Fp3.add(t0, t2);
      t4 = Fp3.sub(t4, t5);
      t5 = Fp3.add(Y1, Z1);
      X3 = Fp3.add(Y2, Z2);
      t5 = Fp3.mul(t5, X3);
      X3 = Fp3.add(t1, t2);
      t5 = Fp3.sub(t5, X3);
      Z3 = Fp3.mul(a, t4);
      X3 = Fp3.mul(b3, t2);
      Z3 = Fp3.add(X3, Z3);
      X3 = Fp3.sub(t1, Z3);
      Z3 = Fp3.add(t1, Z3);
      Y3 = Fp3.mul(X3, Z3);
      t1 = Fp3.add(t0, t0);
      t1 = Fp3.add(t1, t0);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.mul(b3, t4);
      t1 = Fp3.add(t1, t2);
      t2 = Fp3.sub(t0, t2);
      t2 = Fp3.mul(a, t2);
      t4 = Fp3.add(t4, t2);
      t0 = Fp3.mul(t1, t4);
      Y3 = Fp3.add(Y3, t0);
      t0 = Fp3.mul(t5, t4);
      X3 = Fp3.mul(t3, X3);
      X3 = Fp3.sub(X3, t0);
      t0 = Fp3.mul(t3, t1);
      Z3 = Fp3.mul(t5, Z3);
      Z3 = Fp3.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    multiply(scalar) {
      const { endo: endo2 } = curveOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul2 = (n2) => wnaf.wNAFCached(this, n2, Point2.normalizeZ);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
        const { p: k1p, f: k1f } = mul2(k1);
        const { p: k2p, f: k2f } = mul2(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f: f3 } = mul2(scalar);
        point = p;
        fake = f3;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    multiplyUnsafe(sc) {
      const { endo: endo2 } = curveOpts;
      const p = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n13 || p.is0())
        return Point2.ZERO;
      if (sc === _1n13)
        return p;
      if (wnaf.hasPrecomputes(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
        const { p1, p2 } = mulEndoUnsafe(Point2, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.wNAFCachedUnsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b2) {
      const sum2 = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b2));
      return sum2.is0() ? undefined : sum2;
    }
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    isTorsionFree() {
      const { isTorsionFree } = curveOpts;
      if (cofactor === _1n13)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = curveOpts;
      if (cofactor === _1n13)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    toBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes3(Point2, this, isCompressed);
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
  Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
  Point2.Fp = Fp3;
  Point2.Fn = Fn;
  const bits = Fn.BITS;
  const wnaf = wNAF2(Point2, curveOpts.endo ? Math.ceil(bits / 2) : bits);
  return Point2;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function ecdsa(Point2, ecdsaOpts, curveOpts = {}) {
  _validateObject(ecdsaOpts, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes4;
  const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac2(ecdsaOpts.hash, key, concatBytes3(...msgs)));
  const { Fp: Fp3, Fn } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n13;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
  }
  function aValidRS(title, num) {
    if (!Fn.isValidNot0(num))
      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
  }

  class Signature2 {
    constructor(r, s, recovery) {
      aValidRS("r", r);
      aValidRS("s", s);
      this.r = r;
      this.s = s;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromCompact(hex) {
      const L = Fn.BYTES;
      const b2 = ensureBytes2("compactSignature", hex, L * 2);
      return new Signature2(Fn.fromBytes(b2.subarray(0, L)), Fn.fromBytes(b2.subarray(L, L * 2)));
    }
    static fromDER(hex) {
      const { r, s } = DER2.toSig(ensureBytes2("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {}
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const FIELD_ORDER = Fp3.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n10 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp3.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp3.toBytes(radj);
      const R = Point2.fromHex(concatBytes3(pprefix((rec & 1) === 0), x));
      const ir = Fn.inv(radj);
      const h = bits2int_modN(ensureBytes2("msgHash", msgHash));
      const u1 = Fn.create(-h * ir);
      const u2 = Fn.create(s * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, Fn.neg(this.s), this.recovery) : this;
    }
    toBytes(format) {
      if (format === "compact")
        return concatBytes3(Fn.toBytes(this.r), Fn.toBytes(this.s));
      if (format === "der")
        return hexToBytes2(DER2.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex2(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex2(this.toBytes("compact"));
    }
  }
  const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const n2 = CURVE_ORDER;
      return mapHashToField2(randomBytes_(getMinHashLength2(n2)), n2);
    },
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point2)
      return true;
    const arr = ensureBytes2("key", item);
    const length = arr.length;
    const L = Fp3.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
      return;
    } else {
      return length === LC || length === LU;
    }
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicB) === false)
      throw new Error("second arg must be public key");
    const b2 = Point2.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
  }
  const bits2int = ecdsaOpts.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE2(bytes2);
    const delta = bytes2.length * 8 - fnBits;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes2) {
    return Fn.create(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask2(fnBits);
  function int2octets(num) {
    aInRange("num < 2^" + fnBits, num, _0n13, ORDER_MASK);
    return Fn.toBytes(num);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2 } = ecdsaOpts;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes_(Fp3.BYTES) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e));
    }
    const seed = concatBytes3(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = Fn.create(q.x);
      if (r === _0n13)
        return;
      const s = Fn.create(ik * Fn.create(m + r * d));
      if (s === _0n13)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n13);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const drbg = createHmacDrbg2(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
    return drbg(seed, k2sig);
  }
  Point2.BASE.precompute(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey = ensureBytes2("publicKey", publicKey);
    validateSigVerOpts(opts);
    const { lowS, prehash, format } = opts;
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== undefined && !["compact", "der", "js"].includes(format))
      throw new Error('format must be "compact", "der" or "js"');
    const isHex2 = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = undefined;
    let P2;
    try {
      if (isObj) {
        if (format === undefined || format === "js") {
          _sig = new Signature2(sg.r, sg.s);
        } else {
          throw new Error("invalid format");
        }
      }
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature2.fromCompact(sg);
      }
      P2 = Point2.fromHex(publicKey);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = ecdsaOpts.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is2 = Fn.inv(s);
    const u1 = Fn.create(h * is2);
    const u2 = Fn.create(r * is2);
    const R = Point2.BASE.multiplyUnsafe(u1).add(P2.multiplyUnsafe(u2));
    if (R.is0())
      return false;
    const v = Fn.create(R.x);
    return v === r;
  }
  return Object.freeze({
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify,
    utils,
    Point: Point2,
    Signature: Signature2
  });
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp3 = c.Fp;
  const Fn = Field2(CURVE.n, c.nBitLength);
  const curveOpts = {
    Fp: Fp3,
    Fn,
    allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    wrapPrivateKey: c.wrapPrivateKey,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hash: c.hash,
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, ecdsa2) {
  return Object.assign({}, ecdsa2, {
    ProjectivePoint: ecdsa2.Point,
    CURVE: c
  });
}
function weierstrass2(c) {
  const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point2 = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point2, ecdsaOpts, curveOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}

// node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function createCurve2(curveDef, defHash) {
  const create4 = (hash2) => weierstrass2({ ...curveDef, hash: hash2 });
  return { ...create4(defHash), create: create4 };
}

// node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var _0n14 = BigInt(0);
var _1n14 = BigInt(1);
var _2n11 = BigInt(2);
var divNearest2 = (a, b2) => (a + b2 / _2n11) / b2;
function sqrtMod2(y) {
  const P2 = secp256k1_CURVE.p;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P2;
  const b3 = b2 * b2 * y % P2;
  const b6 = pow23(b3, _3n6, P2) * b3 % P2;
  const b9 = pow23(b6, _3n6, P2) * b3 % P2;
  const b11 = pow23(b9, _2n11, P2) * b2 % P2;
  const b22 = pow23(b11, _11n, P2) * b11 % P2;
  const b44 = pow23(b22, _22n, P2) * b22 % P2;
  const b88 = pow23(b44, _44n, P2) * b44 % P2;
  const b176 = pow23(b88, _88n, P2) * b88 % P2;
  const b220 = pow23(b176, _44n, P2) * b44 % P2;
  const b223 = pow23(b220, _3n6, P2) * b3 % P2;
  const t1 = pow23(b223, _23n, P2) * b22 % P2;
  const t2 = pow23(t1, _6n, P2) * b2 % P2;
  const root = pow23(t2, _2n11, P2);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field2(secp256k1_CURVE.p, undefined, undefined, { sqrt: sqrtMod2 });
var secp256k12 = createCurve2({
  ...secp256k1_CURVE,
  Fp: Fpk1,
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1_CURVE.n;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n14 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b2 * k, n2);
      const c2 = divNearest2(-b1 * k, n2);
      let k1 = mod3(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod3(-c1 * b1 - c2 * b2, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2563);

// node_modules/@solana/web3.js/lib/index.browser.esm.js
var generatePrivateKey = ed25519.utils.randomPrivateKey;
var generateKeypair = () => {
  const privateScalar = ed25519.utils.randomPrivateKey();
  const publicKey = getPublicKey(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey, 32);
  return {
    publicKey,
    secretKey
  };
};
var getPublicKey = ed25519.getPublicKey;
function isOnCurve(publicKey) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey);
    return true;
  } catch {
    return false;
  }
}
var sign2 = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
var verify = ed25519.verify;
var toBuffer = (arr) => {
  if (Buffer2.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return Buffer2.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return Buffer2.from(arr);
  }
};

class Struct2 {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return Buffer2.from(import_borsh.serialize(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return import_borsh.deserialize(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return import_borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);
  }
}
var SOLANA_SCHEMA = new Map;
var _PublicKey;
var MAX_SEED_LENGTH = 32;
var PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(value) {
  return value._bn !== undefined;
}
var uniquePublicKeyCounter = 1;

class PublicKey extends Struct2 {
  constructor(value) {
    super({});
    this._bn = undefined;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs58.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn.default(decoded);
      } else {
        this._bn = new import_bn.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey(key.toBuffer());
  }
  equals(publicKey) {
    return this._bn.eq(publicKey._bn);
  }
  toBase58() {
    return import_bs58.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  toBuffer() {
    const b2 = this._bn.toArrayLike(Buffer2);
    if (b2.length === PUBLIC_KEY_LENGTH) {
      return b2;
    }
    const zeroPad2 = Buffer2.alloc(32);
    b2.copy(zeroPad2, 32 - b2.length);
    return zeroPad2;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = Buffer2.concat([fromPublicKey.toBuffer(), Buffer2.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha2564(buffer);
    return new PublicKey(publicKeyBytes);
  }
  static createProgramAddressSync(seeds, programId) {
    let buffer = Buffer2.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = Buffer2.concat([buffer, toBuffer(seed)]);
    });
    buffer = Buffer2.concat([buffer, programId.toBuffer(), Buffer2.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha2564(buffer);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(Buffer2.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
}
_PublicKey = PublicKey;
PublicKey.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 127;
var SIGNATURE_LENGTH_IN_BYTES = 64;

class TransactionExpiredBlockheightExceededError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});

class TransactionExpiredTimeoutError extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + "unknown if it succeeded or failed. Check signature " + `${signature} using the Solana Explorer or CLI tools.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});

class TransactionExpiredNonceInvalidError extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});

class MessageAccountKeys {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = undefined;
    this.accountKeysFromLookups = undefined;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = new Map;
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === undefined)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}
var publicKey = (property = "publicKey") => {
  return BufferLayout.blob(32, property);
};
var rustString = (property = "string") => {
  const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
  const _decode2 = rsl.decode.bind(rsl);
  const _encode2 = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b2, offset2) => {
    const data = _decode2(b2, offset2);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b2, offset2) => {
    const data = {
      chars: Buffer2.from(str, "utf8")
    };
    return _encode2(data, b2, offset2);
  };
  rslShim.alloc = (str) => {
    return BufferLayout.u32().span + BufferLayout.u32().span + Buffer2.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized = (property = "authorized") => {
  return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
};
var lockup = (property = "lockup") => {
  return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
};
var voteInit = (property = "voteInit") => {
  return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};
function getAlloc(type2, fields2) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields2[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields2[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc({
        layout: item
      }, fields2[item.property]);
    }
    return 0;
  };
  let alloc2 = 0;
  type2.layout.fields.forEach((item) => {
    alloc2 += getItemAlloc(item);
  });
  return alloc2;
}
function decodeLength(bytes2) {
  let len2 = 0;
  let size = 0;
  for (;; ) {
    let elem = bytes2.shift();
    len2 |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len2;
}
function encodeLength(bytes2, len2) {
  let rem_len = len2;
  for (;; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem);
      break;
    } else {
      elem |= 128;
      bytes2.push(elem);
    }
  }
}
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

class CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = undefined;
    this.keyMetaMap = undefined;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = new Map;
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === undefined) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner ||= accountMeta.isSigner;
        keyMeta.isWritable ||= accountMeta.isWritable;
      }
    }
    return new CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert4(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert4(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert4(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array;
    const drainedKeys = new Array;
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert4(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}
var END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
function guardedShift(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.shift();
}
function guardedSplice(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.splice(...args);
}

class Message {
  constructor(args) {
    this.header = undefined;
    this.accountKeys = undefined;
    this.recentBlockhash = undefined;
    this.instructions = undefined;
    this.indexToProgramIds = new Map;
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs58.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs58.default.encode(ix.data)
    }));
    return new Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs58.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: Buffer2.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: Buffer2.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = Buffer2.alloc(PACKET_DATA_SIZE);
    Buffer2.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: Buffer2.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: Buffer2.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: Buffer2.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: Buffer2.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
      recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
    };
    let signData = Buffer2.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift(byteArray);
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i3 = 0;i3 < accountCount; i3++) {
      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(Buffer2.from(account)));
    }
    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i3 = 0;i3 < instructionCount; i3++) {
      const programIdIndex = guardedShift(byteArray);
      const accountCount2 = decodeLength(byteArray);
      const accounts = guardedSplice(byteArray, 0, accountCount2);
      const dataLength2 = decodeLength(byteArray);
      const dataSlice2 = guardedSplice(byteArray, 0, dataLength2);
      const data = import_bs58.default.encode(Buffer2.from(dataSlice2));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs58.default.encode(Buffer2.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }
}
var DEFAULT_SIGNATURE = Buffer2.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);

class TransactionInstruction {
  constructor(opts) {
    this.keys = undefined;
    this.programId = undefined;
    this.data = Buffer2.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}

class Transaction2 {
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  constructor(opts) {
    this.signatures = [];
    this.feePayer = undefined;
    this.instructions = [];
    this.recentBlockhash = undefined;
    this.lastValidBlockHeight = undefined;
    this.nonceInfo = undefined;
    this.minNonceContextSlot = undefined;
    this._message = undefined;
    this._json = undefined;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey2
      }) => {
        return publicKey2.toJSON();
      })
    };
  }
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i3 = 0;i3 < instructions.length; i3++) {
      if (instructions[i3].programId === undefined) {
        throw new Error(`Transaction instruction index ${i3} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x, y) {
      if (x.isSigner !== y.isSigner) {
        return x.isSigner ? -1 : 1;
      }
      if (x.isWritable !== y.isWritable) {
        return x.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x) => {
      return x.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.equals(signature.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, " + "only the fee payer and instruction signer accounts should sign a transaction. " + "This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs58.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert4(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert4(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid)
        return message;
    }
    this.signatures = signedKeys.map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
    return message;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    this.signatures = signers.filter((publicKey2) => {
      const key = publicKey2.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
  }
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature = sign2(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature));
    });
  }
  addSignature(pubkey, signature) {
    this._compile();
    this._addSignature(pubkey, signature);
  }
  _addSignature(pubkey, signature) {
    assert4(signature.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = Buffer2.from(signature);
  }
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature,
      publicKey: publicKey2
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          (errors.missing ||= []).push(publicKey2);
        }
      } else {
        if (!verify(signature, message, publicKey2.toBytes())) {
          (errors.invalid ||= []).push(publicKey2);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : undefined;
  }
  serialize(config2) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config2);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = Buffer2.alloc(transactionLength);
    assert4(signatures.length < 256);
    Buffer2.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert4(signature.length === 64, `signature has invalid length`);
        Buffer2.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert4(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  get keys() {
    assert4(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  get programId() {
    assert4(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  get data() {
    assert4(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i3 = 0;i3 < signatureCount; i3++) {
      const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(import_bs58.default.encode(Buffer2.from(signature)));
    }
    return Transaction2.populate(Message.from(byteArray), signatures);
  }
  static populate(message, signatures = []) {
    const transaction = new Transaction2;
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs58.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
}
var NUM_TICKS_PER_SECOND = 160;
var DEFAULT_TICKS_PER_SLOT = 64;
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
var MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;
var SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");

class SendTransactionError extends Error {
  constructor({
    action,
    signature,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature} resulted in an error. 
` + `${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${((a) => a)(action)}'`;
      }
    }
    super(message);
    this.signature = undefined;
    this.transactionMessage = undefined;
    this.transactionLogs = undefined;
    this.signature = signature;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : undefined;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined
    };
  }
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
}
async function sendAndConfirmTransaction(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was " + "supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` " + "or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature != null) {
      throw new SendTransactionError({
        action: "send",
        signature,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function encodeData(type2, fields2) {
  const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields2);
  const data = Buffer2.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type2.index
  }, fields2);
  type2.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
function u642(property) {
  const layout = import_buffer_layout.blob(8, property);
  const decode3 = layout.decode.bind(layout);
  const encode2 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec();
  bigIntLayout.decode = (buffer, offset2) => {
    const src = decode3(buffer, offset2);
    return codec.decode(src);
  };
  bigIntLayout.encode = (bigInt, buffer, offset2) => {
    const src = codec.encode(bigInt);
    return encode2(src, buffer, offset2);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});

class SystemProgram {
  constructor() {}
  static createAccount(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type2, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type2, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type2, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type2, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static createAccountWithSeed(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type2, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  static createNonceAccount(params) {
    const transaction = new Transaction2;
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  static nonceInitialize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static nonceAdvance(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type2);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static nonceWithdraw(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type2, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static nonceAuthorize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type2, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;

class Loader {
  constructor() {}
  static getMinNumSignatures(dataLength2) {
    return 2 * (Math.ceil(dataLength2 / Loader.chunkSize) + 1 + 1);
  }
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction2;
          transaction.add(SystemProgram.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction2;
          transaction.add(SystemProgram.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction2;
          transaction.add(SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction2().add(SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
    const chunkSize = Loader.chunkSize;
    let offset2 = 0;
    let array2 = data;
    let transactions = [];
    while (array2.length > 0) {
      const bytes2 = array2.slice(0, chunkSize);
      const data2 = Buffer2.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        offset: offset2,
        bytes: bytes2,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction2().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep(1000 / REQUESTS_PER_SECOND);
      }
      offset2 += chunkSize;
      array2 = array2.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
      const data2 = Buffer2.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
      }, data2);
      const transaction = new Transaction2().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {}
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
      }
    }
    return true;
  }
}
Loader.chunkSize = CHUNK_SIZE;
var BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
var fetchImpl = globalThis.fetch;
var LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout.struct([
    BufferLayout.u32("typeIndex"),
    u642("deactivationSlot"),
    BufferLayout.nu64("lastExtendedSlot"),
    BufferLayout.u8("lastExtendedStartIndex"),
    BufferLayout.u8(),
    BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
  ])
};
var PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
var RawAccountDataResult = tuple([string(), literal("base64")]);
var BufferFromRawAccountData = coerce(instance(Buffer2), RawAccountDataResult, (value) => Buffer2.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create3(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number2()
    }),
    value
  }));
}
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number2()
    }),
    value
  });
}
var GetInflationGovernorResult = type({
  foundation: number2(),
  foundationTerm: number2(),
  initial: number2(),
  taper: number2(),
  terminal: number2()
});
var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number2(),
  effectiveSlot: number2(),
  amount: number2(),
  postBalance: number2(),
  commission: optional(nullable(number2()))
}))));
var GetRecentPrioritizationFeesResult = array(type({
  slot: number2(),
  prioritizationFee: number2()
}));
var GetInflationRateResult = type({
  total: number2(),
  validator: number2(),
  foundation: number2(),
  epoch: number2()
});
var GetEpochInfoResult = type({
  epoch: number2(),
  slotIndex: number2(),
  slotsInEpoch: number2(),
  absoluteSlot: number2(),
  blockHeight: optional(number2()),
  transactionCount: optional(number2())
});
var GetEpochScheduleResult = type({
  slotsPerEpoch: number2(),
  leaderScheduleSlotOffset: number2(),
  warmup: boolean(),
  firstNormalEpoch: number2(),
  firstNormalSlot: number2()
});
var GetLeaderScheduleResult = record(string(), array(number2()));
var TransactionErrorResult = nullable(union([type({}), string()]));
var SignatureStatusResult = type({
  err: TransactionErrorResult
});
var SignatureReceivedResult = literal("receivedSignature");
var VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number2())
});
var ParsedInstructionStruct = type({
  program: string(),
  programId: PublicKeyFromString,
  parsed: unknown()
});
var PartiallyDecodedInstructionStruct = type({
  programId: PublicKeyFromString,
  accounts: array(PublicKeyFromString),
  data: string()
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number2(),
    data: array(string()),
    rentEpoch: optional(number2())
  }))))),
  unitsConsumed: optional(number2()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number2(),
    instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
  }))))
}));
var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number2())),
  range: type({
    firstSlot: number2(),
    lastSlot: number2()
  })
}));
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
var SlotRpcResult = jsonRpcResult(number2());
var GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number2(),
  circulating: number2(),
  nonCirculating: number2(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
var TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number2()),
  decimals: number2(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number2()),
  decimals: number2(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number2(),
    data: BufferFromRawAccountData,
    rentEpoch: number2()
  })
})));
var ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number2()
});
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number2(),
    data: ParsedAccountDataResult,
    rentEpoch: number2()
  })
})));
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number2(),
  address: PublicKeyFromString
})));
var AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number2(),
  data: BufferFromRawAccountData,
  rentEpoch: number2()
});
var KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = coerce(union([instance(Buffer2), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
  if (Array.isArray(value)) {
    return create3(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number2(),
  data: ParsedOrRawAccountData,
  rentEpoch: number2()
});
var KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
var StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number2(),
  inactive: number2()
});
var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number2(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number2()))
})));
var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number2(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number2()))
})));
var AccountNotificationResult = type({
  subscription: number2(),
  result: notificationResultAndContext(AccountInfoResult)
});
var ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ProgramAccountNotificationResult = type({
  subscription: number2(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
var SlotInfoResult = type({
  parent: number2(),
  slot: number2(),
  root: number2()
});
var SlotNotificationResult = type({
  subscription: number2(),
  result: SlotInfoResult
});
var SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number2(),
  timestamp: number2()
}), type({
  type: literal("createdBank"),
  parent: number2(),
  slot: number2(),
  timestamp: number2()
}), type({
  type: literal("frozen"),
  slot: number2(),
  timestamp: number2(),
  stats: type({
    numTransactionEntries: number2(),
    numSuccessfulTransactions: number2(),
    numFailedTransactions: number2(),
    maxTransactionsPerEntry: number2()
  })
}), type({
  type: literal("dead"),
  slot: number2(),
  timestamp: number2(),
  err: string()
})]);
var SlotUpdateNotificationResult = type({
  subscription: number2(),
  result: SlotUpdateResult
});
var SignatureNotificationResult = type({
  subscription: number2(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
var RootNotificationResult = type({
  subscription: number2(),
  result: number2()
});
var ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number2(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number2(), number2(), number2()])),
  commission: number2(),
  lastVote: number2(),
  rootSlot: nullable(number2())
});
var GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
var ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse = type({
  slot: number2(),
  confirmations: nullable(number2()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number2());
var AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number2()),
  readonlyIndexes: array(number2())
});
var ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number2(),
      numReadonlySignedAccounts: number2(),
      numReadonlyUnsignedAccounts: number2()
    }),
    instructions: array(type({
      accounts: array(number2()),
      data: string(),
      programIdIndex: number2()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
var ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
var RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
  if ("accounts" in value) {
    return create3(value, RawInstructionResult);
  } else {
    return create3(value, ParsedInstructionResult);
  }
});
var ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = type({
  accountIndex: number2(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});
var ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number2(),
  innerInstructions: optional(nullable(array(type({
    index: number2(),
    instructions: array(type({
      accounts: array(number2()),
      data: string(),
      programIdIndex: number2()
    }))
  })))),
  preBalances: array(number2()),
  postBalances: array(number2()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number2()),
  costUnits: optional(number2())
});
var ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number2(),
  innerInstructions: optional(nullable(array(type({
    index: number2(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number2()),
  postBalances: array(number2()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number2()),
  costUnits: optional(number2())
});
var TransactionVersionStruct = union([literal(0), literal("legacy")]);
var RewardsResult = type({
  pubkey: string(),
  lamports: number2(),
  postBalance: nullable(number2()),
  rewardType: nullable(string()),
  commission: optional(nullable(number2()))
});
var GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2())
})));
var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  signatures: array(string()),
  blockTime: nullable(number2())
})));
var GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number2(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number2())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number2(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number2())),
  version: optional(TransactionVersionStruct)
})));
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number2()
}));
var IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
var PerfSampleResult = type({
  slot: number2(),
  numTransactions: number2(),
  numSlots: number2(),
  samplePeriodSecs: number2()
});
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number2()
  })
})));
var RequestAirdropRpcResult = jsonRpcResult(string());
var SendTransactionRpcResult = jsonRpcResult(string());
var LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number2()
});
class Keypair {
  constructor(keypair) {
    this._keypair = undefined;
    this._keypair = keypair ?? generateKeypair();
  }
  static generate() {
    return new Keypair(generateKeypair());
  }
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey2 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey(privateScalar);
      for (let ii = 0;ii < 32; ii++) {
        if (publicKey2[ii] !== computedPublicKey[ii]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new Keypair({
      publicKey: publicKey2,
      secretKey
    });
  }
  static fromSeed(seed) {
    const publicKey2 = getPublicKey(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey2, 32);
    return new Keypair({
      publicKey: publicKey2,
      secretKey
    });
  }
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("recentSlot"), BufferLayout.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});
class AddressLookupTableProgram {
  constructor() {}
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder().encode(params.recentSlot)], this.programId);
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
    const data = encodeData(type2, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static extendLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
    const data = encodeData(type2, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static closeLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
}
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), u642("microLamports")])
  }
});

class ComputeBudgetProgram {
  constructor() {}
  static requestUnits(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
    const data = encodeData(type2, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;
var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);

class Ed25519Program {
  constructor() {}
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature,
      instructionIndex
    } = params;
    assert4(publicKey2.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey2.length} bytes`);
    assert4(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey2.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = Buffer2.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey2, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert4(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey2 = keypair.publicKey.toBytes();
      const signature = sign2(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign = (msgHash, privKey) => {
  const signature = secp256k12.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
secp256k12.utils.isValidPrivateKey;
var publicKeyCreate = secp256k12.getPublicKey;
var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);

class Secp256k1Program {
  constructor() {}
  static publicKeyToEthAddress(publicKey2) {
    assert4(publicKey2.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey2.length} bytes`);
    try {
      return Buffer2.from(keccak_2562(toBuffer(publicKey2))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey2,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey2),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = Buffer2.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = Buffer2.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert4(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = Buffer2.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature),
      ethAddress: toBuffer(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert4(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer(pkey);
      const publicKey2 = publicKeyCreate(privateKey, false).slice(1);
      const messageHash = Buffer2.from(keccak_2562(toBuffer(message)));
      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey2,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
var STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
class Lockup {
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = undefined;
    this.epoch = undefined;
    this.custodian = undefined;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
}
_Lockup = Lockup;
Lockup.default = new _Lockup(0, 0, PublicKey.default);
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class StakeProgram {
  constructor() {}
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: maybeLockup
    } = params;
    const lockup2 = maybeLockup || Lockup.default;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type2, {
      authorized: {
        staker: toBuffer(authorized2.staker.toBuffer()),
        withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup2.unixTimestamp,
        epoch: lockup2.epoch,
        custodian: toBuffer(lockup2.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static createAccountWithSeed(params) {
    const transaction = new Transaction2;
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  static createAccount(params) {
    const transaction = new Transaction2;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type2);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type2, {
      lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static split(params, rentExemptReserve) {
    const transaction = new Transaction2;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction2;
    transaction.add(SystemProgram.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type2);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type2);
    return new Transaction2().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
}
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
var VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class VoteProgram {
  constructor() {}
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit2
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type2, {
      voteInit: {
        nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
        commission: voteInit2.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  static createAccount(params) {
    const transaction = new Transaction2;
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return VoteProgram.withdraw(params);
  }
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
    const data = encodeData(type2);
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction2().add({
      keys,
      programId: this.programId,
      data
    });
  }
}
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3762;
var VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
var InfoString = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
var VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
var VoteAccountLayout = BufferLayout.struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  BufferLayout.u8("commission"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
  BufferLayout.u8("rootSlotValid"),
  BufferLayout.nu64("rootSlot"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
  BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
  BufferLayout.nu64(),
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
  BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
]);

// node_modules/base-x/src/esm/index.js
function base(ALPHABET) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0;j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i3 = 0;i3 < ALPHABET.length; i3++) {
    const x = ALPHABET.charAt(i3);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i3;
  }
  const BASE2 = ALPHABET.length;
  const LEADER = ALPHABET.charAt(0);
  const FACTOR = Math.log(BASE2) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode2(source) {
    if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i3 = 0;
      for (let it1 = size - 1;(carry !== 0 || i3 < length) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (;it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array;
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i3 = 0;
      for (let it3 = size - 1;(carry !== 0 || i3 < length) && it3 !== -1; it3--, i3++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i3;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode3(string2) {
    const buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE2 + " character");
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode3
  };
}
var esm_default = base;

// node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// src/utils.ts
init_buffer();
var SESSION_TTL = 60n * 60n * 24n * 30n;
var ZERO_DECIMAL = new Decimal(0);
var MAX_BUFFER_LEN = 1e4;
var MAX_PAYLOAD_SIZE = 100 * 1024;
function panic(message) {
  throw new Error(message);
}
function isRfc3339(s) {
  const REGEX = /^((?:(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}:\d{2}(?:\.\d+)?))(Z|[\+-]\d{2}:\d{2})?)$/;
  return REGEX.test(s);
}
function assert5(predicate, message) {
  if (!predicate)
    panic(message ?? "Assertion violated");
}
function optExpect(value, message) {
  if (value === undefined)
    throw new Error(message);
  return value;
}
async function checkedFetch(url, init2) {
  const resp = await import_node_fetch.default(url, init2);
  assert5(resp.ok, `Request failed with ${resp.status}: ${resp.statusText}`);
  return resp;
}
function makeWalletSignFn(walletKey) {
  const signingKey = new exports_ethers.SigningKey(walletKey);
  return async (message) => signingKey.sign(exports_ethers.hashMessage(message)).serialized;
}
function makeToScaledBigUint(params) {
  const Dec = Decimal.clone({
    precision: params.precision,
    toExpPos: params.exponent,
    toExpNeg: -params.exponent
  });
  const Ten = new Dec(10);
  const Max = new Dec(((1n << BigInt(params.bits)) - 1n).toString());
  return (x, decimals) => {
    const dec = new Dec(x);
    if (dec.isZero()) {
      return 0n;
    }
    if (dec.isNeg()) {
      throw new Error(`Number is negative`);
    }
    const scaled = Ten.pow(decimals).mul(dec).truncated();
    if (scaled.isZero()) {
      throw new Error(`Precision loss when converting ${dec} to scaled integer`);
    }
    if (scaled.greaterThan(Max)) {
      throw new Error(`Integer is out of range: ${scaled} exceeds limit ${Max}`);
    }
    return BigInt(scaled.toString());
  };
}
var toScaledU64 = makeToScaledBigUint({
  bits: 64,
  precision: 20,
  exponent: 28
});
var toScaledU128 = makeToScaledBigUint({
  bits: 128,
  precision: 40,
  exponent: 56
});
function decodeLengthDelimited(bytes2, schema) {
  const peekResult = sizeDelimitedPeek(bytes2);
  if (peekResult.size === null || peekResult.offset === null) {
    throw new Error("Failed to parse size-delimited message");
  }
  if (peekResult.size > MAX_PAYLOAD_SIZE) {
    throw new Error(`Encoded message size (${peekResult.size} bytes) is greater than max payload size (${MAX_PAYLOAD_SIZE} bytes).`);
  }
  if (peekResult.offset + peekResult.size > bytes2.length) {
    throw new Error(`Encoded message size (${peekResult.size} bytes) is greater than remaining buffer size (${bytes2.length - peekResult.offset} bytes).`);
  }
  return fromBinary(schema, bytes2.slice(peekResult.offset, peekResult.offset + peekResult.size));
}
function decodeHex(value) {
  const hex = value.startsWith("0x") ? value.slice(2) : value;
  return Uint8Array.from(Buffer2.from(hex, "hex"));
}
function findMarket(markets, marketId) {
  if (marketId < 0 || markets.length - 1 < marketId) {
    throw new Error(`The market with marketId=${marketId} not found`);
  }
  return markets[marketId];
}
function findToken(tokens, tokenId) {
  if (tokenId < 0 || tokens.length - 1 < tokenId) {
    throw new Error(`The token with tokenId=${tokenId} not found`);
  }
  return tokens[tokenId];
}
function keypairFromPrivateKey(privateKey) {
  if (typeof privateKey === "string") {
    if (!privateKey.startsWith("0x")) {
      return Keypair.fromSecretKey(esm_default2.decode(privateKey));
    }
    const hex = privateKey.startsWith("0x") ? privateKey.slice(2) : privateKey;
    const bytes2 = new Uint8Array(hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    return Keypair.fromSecretKey(bytes2);
  }
  return Keypair.fromSecretKey(privateKey);
}
async function signSolanaTransactionFramedPayload({
  payload,
  user,
  signTransaction
}) {
  const tx = new Transaction2({
    blockhash: esm_default2.encode(new Uint8Array(32)),
    lastValidBlockHeight: 0,
    feePayer: user
  });
  tx.add(new TransactionInstruction({
    keys: [],
    programId: user,
    data: Buffer2.from(payload)
  }));
  const signedTx = await signTransaction(tx);
  const sig = signedTx.signatures[0];
  assert5(sig !== undefined, "signed transaction must have a signature");
  assert5(sig.signature !== null, "signature must be non-null; check your signTransaction function");
  assert5(sig.signature.length === 64, "signature must be 64 bytes");
  assert5(sig.publicKey.equals(user), `signature is for ${sig.publicKey}, expected ${user}`);
  return sig.signature;
}
async function signHexEncodedPayload({
  payload,
  signMessage
}) {
  return await signMessage(new TextEncoder().encode(payload.toHex()));
}

// src/types.ts
var Side2;
((Side3) => {
  Side3["Ask"] = "ask";
  Side3["Bid"] = "bid";
})(Side2 ||= {});
var FillMode2;
((FillMode3) => {
  FillMode3[FillMode3["Limit"] = 0] = "Limit";
  FillMode3[FillMode3["PostOnly"] = 1] = "PostOnly";
  FillMode3[FillMode3["ImmediateOrCancel"] = 2] = "ImmediateOrCancel";
  FillMode3[FillMode3["FillOrKill"] = 3] = "FillOrKill";
})(FillMode2 ||= {});
var TriggerKind2;
((TriggerKind3) => {
  TriggerKind3[TriggerKind3["StopLoss"] = 0] = "StopLoss";
  TriggerKind3[TriggerKind3["TakeProfit"] = 1] = "TakeProfit";
})(TriggerKind2 ||= {});
var TriggerStatus;
((TriggerStatus2) => {
  TriggerStatus2[TriggerStatus2["Active"] = 0] = "Active";
  TriggerStatus2[TriggerStatus2["Success"] = 1] = "Success";
  TriggerStatus2[TriggerStatus2["Cancel"] = 2] = "Cancel";
  TriggerStatus2[TriggerStatus2["Remove"] = 4] = "Remove";
})(TriggerStatus ||= {});
function fillModeToProtoFillMode(x) {
  if (x === 0 /* Limit */)
    return 0 /* LIMIT */;
  if (x === 1 /* PostOnly */)
    return 1 /* POST_ONLY */;
  if (x === 2 /* ImmediateOrCancel */) {
    return 2 /* IMMEDIATE_OR_CANCEL */;
  }
  if (x === 3 /* FillOrKill */)
    return 3 /* FILL_OR_KILL */;
  throw new Error("Invalid fill mode");
}
var WebSocketMessageType;
((WebSocketMessageType2) => {
  WebSocketMessageType2["TradeUpdate"] = "trades";
  WebSocketMessageType2["DeltaUpdate"] = "delta";
  WebSocketMessageType2["AccountUpdate"] = "account";
})(WebSocketMessageType ||= {});

class QuoteSize {
  price;
  size;
  constructor(quotePrice, quoteSize) {
    const p = new decimal_default(quotePrice);
    const s = new decimal_default(quoteSize);
    if (!p.isPositive() || !s.isPositive()) {
      throw new Error("quotePrice and quoteSize must be positive");
    }
    this.price = p;
    this.size = s;
  }
  value() {
    return this.price.mul(this.size);
  }
  toWire(marketPriceDecimals, marketSizeDecimals) {
    return {
      price: toScaledU64(this.price, marketPriceDecimals),
      size: toScaledU64(this.size, marketSizeDecimals)
    };
  }
}
// src/const.ts
var WEBSERVER_PORT = "80";
var DEBUG_KEYS = [
  "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
  "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
  "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a",
  "0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6",
  "0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a",
  "0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba",
  "0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e",
  "0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356",
  "0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97",
  "0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6"
];
var DEV_URL = "http://localhost";
var WEBSERVER_DEV_URL = DEV_URL + ":" + WEBSERVER_PORT;
var DEV_TOKEN_INFOS = [
  {
    address: "0x9a9f2ccfde556a7e9ff0848998aa4a0cfd8863ae",
    precision: 6,
    tokenId: 0,
    name: "usdc"
  }
];
var DEFAULT_FUNDING_AMOUNTS = {
  SOL: ["0.2", 0],
  "0x9a9f2ccfde556a7e9ff0848998aa4a0cfd8863ae": ["10000", 6]
};
// src/error.ts
class NordError extends Error {
  cause;
  statusCode;
  details;
  constructor(message, options = {}) {
    super(message);
    this.name = "NordError";
    this.cause = options.cause;
    this.statusCode = options.statusCode;
    this.details = options.details;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, NordError);
    }
    if (this.cause instanceof Error) {
      this.stack = this.stack + `
Caused by: ` + (this.cause.stack || this.cause.message);
    }
  }
  toString() {
    let result = `${this.name}: ${this.message}`;
    if (this.statusCode) {
      result += `  
status: ${this.statusCode}`;
    }
    if (this.details && Object.keys(this.details).length > 0) {
      result += `  
details: ${JSON.stringify(this.details, null, 2)}`;
    }
    if (this.cause) {
      result += `  
cause: ${this.cause.toString()}`;
    }
    return result;
  }
}
// node:events
var SymbolFor = Symbol.for;
var kCapture = Symbol("kCapture");
var kErrorMonitor = SymbolFor("events.errorMonitor");
var kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
var kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
var kRejection = SymbolFor("nodejs.rejection");
var captureRejectionSymbol = SymbolFor("nodejs.rejection");
var ArrayPrototypeSlice = Array.prototype.slice;
var defaultMaxListeners = 10;
var EventEmitter2 = function(opts) {
  if (this._events === undefined || this._events === this.__proto__._events)
    this._events = { __proto__: null }, this._eventsCount = 0;
  if (this._maxListeners ??= undefined, this[kCapture] = opts?.captureRejections ? Boolean(opts?.captureRejections) : EventEmitterPrototype[kCapture])
    this.emit = emitWithRejectionCapture;
};
var EventEmitterPrototype = EventEmitter2.prototype = {};
EventEmitterPrototype._events = undefined;
EventEmitterPrototype._eventsCount = 0;
EventEmitterPrototype._maxListeners = undefined;
EventEmitterPrototype.setMaxListeners = function(n2) {
  return validateNumber2(n2, "setMaxListeners", 0), this._maxListeners = n2, this;
};
EventEmitterPrototype.constructor = EventEmitter2;
EventEmitterPrototype.getMaxListeners = function() {
  return this?._maxListeners ?? defaultMaxListeners;
};
function emitError(emitter, args) {
  var { _events: events } = emitter;
  if (args[0] ??= Error("Unhandled error."), !events)
    throw args[0];
  var errorMonitor = events[kErrorMonitor];
  if (errorMonitor)
    for (var handler of ArrayPrototypeSlice.call(errorMonitor))
      handler.apply(emitter, args);
  var handlers = events.error;
  if (!handlers)
    throw args[0];
  for (var handler of ArrayPrototypeSlice.call(handlers))
    handler.apply(emitter, args);
  return true;
}
function addCatch(emitter, promise, type2, args) {
  promise.then(undefined, function(err) {
    queueMicrotask(() => emitUnhandledRejectionOrErr(emitter, err, type2, args));
  });
}
function emitUnhandledRejectionOrErr(emitter, err, type2, args) {
  if (typeof emitter[kRejection] === "function")
    emitter[kRejection](err, type2, ...args);
  else
    try {
      emitter[kCapture] = false, emitter.emit("error", err);
    } finally {
      emitter[kCapture] = true;
    }
}
var emitWithoutRejectionCapture = function(type2, ...args) {
  if (type2 === "error")
    return emitError(this, args);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type2];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i3 = 0, { length } = maybeClonedHandlers;i3 < length; i3++) {
    let handler = maybeClonedHandlers[i3];
    switch (args.length) {
      case 0:
        handler.call(this);
        break;
      case 1:
        handler.call(this, args[0]);
        break;
      case 2:
        handler.call(this, args[0], args[1]);
        break;
      case 3:
        handler.call(this, args[0], args[1], args[2]);
        break;
      default:
        handler.apply(this, args);
        break;
    }
  }
  return true;
};
var emitWithRejectionCapture = function(type2, ...args) {
  if (type2 === "error")
    return emitError(this, args);
  var { _events: events } = this;
  if (events === undefined)
    return false;
  var handlers = events[type2];
  if (handlers === undefined)
    return false;
  let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
  for (let i3 = 0, { length } = maybeClonedHandlers;i3 < length; i3++) {
    let handler = maybeClonedHandlers[i3], result;
    switch (args.length) {
      case 0:
        result = handler.call(this);
        break;
      case 1:
        result = handler.call(this, args[0]);
        break;
      case 2:
        result = handler.call(this, args[0], args[1]);
        break;
      case 3:
        result = handler.call(this, args[0], args[1], args[2]);
        break;
      default:
        result = handler.apply(this, args);
        break;
    }
    if (result !== undefined && typeof result?.then === "function" && result.then === Promise.prototype.then)
      addCatch(this, result, type2, args);
  }
  return true;
};
EventEmitterPrototype.emit = emitWithoutRejectionCapture;
EventEmitterPrototype.addListener = function(type2, fn) {
  checkListener(fn);
  var events = this._events;
  if (!events)
    events = this._events = { __proto__: null }, this._eventsCount = 0;
  else if (events.newListener)
    this.emit("newListener", type2, fn.listener ?? fn);
  var handlers = events[type2];
  if (!handlers)
    events[type2] = [fn], this._eventsCount++;
  else {
    handlers.push(fn);
    var m = this._maxListeners ?? defaultMaxListeners;
    if (m > 0 && handlers.length > m && !handlers.warned)
      overflowWarning(this, type2, handlers);
  }
  return this;
};
EventEmitterPrototype.on = EventEmitterPrototype.addListener;
EventEmitterPrototype.prependListener = function(type2, fn) {
  checkListener(fn);
  var events = this._events;
  if (!events)
    events = this._events = { __proto__: null }, this._eventsCount = 0;
  else if (events.newListener)
    this.emit("newListener", type2, fn.listener ?? fn);
  var handlers = events[type2];
  if (!handlers)
    events[type2] = [fn], this._eventsCount++;
  else {
    handlers.unshift(fn);
    var m = this._maxListeners ?? defaultMaxListeners;
    if (m > 0 && handlers.length > m && !handlers.warned)
      overflowWarning(this, type2, handlers);
  }
  return this;
};
function overflowWarning(emitter, type2, handlers) {
  handlers.warned = true;
  let warn = Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type2)} listeners added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);
  warn.name = "MaxListenersExceededWarning", warn.emitter = emitter, warn.type = type2, warn.count = handlers.length, console.warn(warn);
}
function onceWrapper(type2, listener, ...args) {
  this.removeListener(type2, listener), listener.apply(this, args);
}
EventEmitterPrototype.once = function(type2, fn) {
  checkListener(fn);
  let bound = onceWrapper.bind(this, type2, fn);
  return bound.listener = fn, this.addListener(type2, bound), this;
};
EventEmitterPrototype.prependOnceListener = function(type2, fn) {
  checkListener(fn);
  let bound = onceWrapper.bind(this, type2, fn);
  return bound.listener = fn, this.prependListener(type2, bound), this;
};
EventEmitterPrototype.removeListener = function(type2, fn) {
  checkListener(fn);
  var { _events: events } = this;
  if (!events)
    return this;
  var handlers = events[type2];
  if (!handlers)
    return this;
  var length = handlers.length;
  let position = -1;
  for (let i3 = length - 1;i3 >= 0; i3--)
    if (handlers[i3] === fn || handlers[i3].listener === fn) {
      position = i3;
      break;
    }
  if (position < 0)
    return this;
  if (position === 0)
    handlers.shift();
  else
    handlers.splice(position, 1);
  if (handlers.length === 0)
    delete events[type2], this._eventsCount--;
  return this;
};
EventEmitterPrototype.off = EventEmitterPrototype.removeListener;
EventEmitterPrototype.removeAllListeners = function(type2) {
  var { _events: events } = this;
  if (type2 && events) {
    if (events[type2])
      delete events[type2], this._eventsCount--;
  } else
    this._events = { __proto__: null };
  return this;
};
EventEmitterPrototype.listeners = function(type2) {
  var { _events: events } = this;
  if (!events)
    return [];
  var handlers = events[type2];
  if (!handlers)
    return [];
  return handlers.map((x) => x.listener ?? x);
};
EventEmitterPrototype.rawListeners = function(type2) {
  var { _events } = this;
  if (!_events)
    return [];
  var handlers = _events[type2];
  if (!handlers)
    return [];
  return handlers.slice();
};
EventEmitterPrototype.listenerCount = function(type2) {
  var { _events: events } = this;
  if (!events)
    return 0;
  return events[type2]?.length ?? 0;
};
EventEmitterPrototype.eventNames = function() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
EventEmitterPrototype[kCapture] = false;
function once2(emitter, type2, options) {
  var signal = options?.signal;
  if (validateAbortSignal(signal, "options.signal"), signal?.aborted)
    throw new AbortError(undefined, { cause: signal?.reason });
  let { resolve, reject, promise } = $newPromiseCapability(Promise), errorListener = (err) => {
    if (emitter.removeListener(type2, resolver), signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    reject(err);
  }, resolver = (...args) => {
    if (typeof emitter.removeListener === "function")
      emitter.removeListener("error", errorListener);
    if (signal != null)
      eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
    resolve(args);
  };
  if (eventTargetAgnosticAddListener(emitter, type2, resolver, { once: true }), type2 !== "error" && typeof emitter.once === "function")
    emitter.once("error", errorListener);
  function abortListener() {
    eventTargetAgnosticRemoveListener(emitter, type2, resolver), eventTargetAgnosticRemoveListener(emitter, "error", errorListener), reject(new AbortError(undefined, { cause: signal?.reason }));
  }
  if (signal != null)
    eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
  return promise;
}
function getEventListeners(emitter, type2) {
  return emitter.listeners(type2);
}
function setMaxListeners2(n2, ...eventTargets) {
  validateNumber2(n2, "setMaxListeners", 0);
  var length;
  if (eventTargets && (length = eventTargets.length))
    for (let i3 = 0;i3 < length; i3++)
      eventTargets[i3].setMaxListeners(n2);
  else
    defaultMaxListeners = n2;
}
function listenerCount2(emitter, type2) {
  return emitter.listenerCount(type2);
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function")
    emitter.removeListener(name, listener);
  else
    emitter.removeEventListener(name, listener, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function")
    if (flags.once)
      emitter.once(name, listener);
    else
      emitter.on(name, listener);
  else
    emitter.addEventListener(name, listener, flags);
}

class AbortError extends Error {
  constructor(message = "The operation was aborted", options = undefined) {
    if (options !== undefined && typeof options !== "object")
      throw ERR_INVALID_ARG_TYPE2("options", "Object", options);
    super(message, options);
    this.code = "ABORT_ERR", this.name = "AbortError";
  }
}
function ERR_INVALID_ARG_TYPE2(name, type2, value) {
  let err = TypeError(`The "${name}" argument must be of type ${type2}. Received ${value}`);
  return err.code = "ERR_INVALID_ARG_TYPE", err;
}
function ERR_OUT_OF_RANGE2(name, range, value) {
  let err = RangeError(`The "${name}" argument is out of range. It must be ${range}. Received ${value}`);
  return err.code = "ERR_OUT_OF_RANGE", err;
}
function validateAbortSignal(signal, name) {
  if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
    throw ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
}
function validateNumber2(value, name, min2, max2) {
  if (typeof value !== "number")
    throw ERR_INVALID_ARG_TYPE2(name, "number", value);
  if (min2 != null && value < min2 || max2 != null && value > max2 || (min2 != null || max2 != null) && Number.isNaN(value))
    throw ERR_OUT_OF_RANGE2(name, `${min2 != null ? `>= ${min2}` : ""}${min2 != null && max2 != null ? " && " : ""}${max2 != null ? `<= ${max2}` : ""}`, value);
}
function checkListener(listener) {
  if (typeof listener !== "function")
    throw TypeError("The listener must be a function");
}
function validateBoolean(value, name) {
  if (typeof value !== "boolean")
    throw ERR_INVALID_ARG_TYPE2(name, "boolean", value);
}
function getMaxListeners2(emitterOrTarget) {
  return emitterOrTarget?._maxListeners ?? defaultMaxListeners;
}
function addAbortListener(signal, listener) {
  if (signal === undefined)
    throw ERR_INVALID_ARG_TYPE2("signal", "AbortSignal", signal);
  if (validateAbortSignal(signal, "signal"), typeof listener !== "function")
    throw ERR_INVALID_ARG_TYPE2("listener", "function", listener);
  let removeEventListener;
  if (signal.aborted)
    queueMicrotask(() => listener());
  else
    signal.addEventListener("abort", listener, { __proto__: null, once: true }), removeEventListener = () => {
      signal.removeEventListener("abort", listener);
    };
  return { __proto__: null, [Symbol.dispose]() {
    removeEventListener?.();
  } };
}
Object.defineProperties(EventEmitter2, { captureRejections: { get() {
  return EventEmitterPrototype[kCapture];
}, set(value) {
  validateBoolean(value, "EventEmitter.captureRejections"), EventEmitterPrototype[kCapture] = value;
}, enumerable: true }, defaultMaxListeners: { enumerable: true, get: () => {
  return defaultMaxListeners;
}, set: (arg) => {
  validateNumber2(arg, "defaultMaxListeners", 0), defaultMaxListeners = arg;
} }, kMaxEventTargetListeners: { value: kMaxEventTargetListeners, enumerable: false, configurable: false, writable: false }, kMaxEventTargetListenersWarned: { value: kMaxEventTargetListenersWarned, enumerable: false, configurable: false, writable: false } });
Object.assign(EventEmitter2, { once: once2, getEventListeners, getMaxListeners: getMaxListeners2, setMaxListeners: setMaxListeners2, EventEmitter: EventEmitter2, usingDomains: false, captureRejectionSymbol, errorMonitor: kErrorMonitor, addAbortListener, init: EventEmitter2, listenerCount: listenerCount2 });

// src/websocket/NordWebSocketClient.ts
var import_ws2 = __toESM(require_browser3(), 1);
var VALID_STREAM_TYPES = ["trades", "delta", "deltas", "account", "candle"];

class NordWebSocketClient extends EventEmitter2 {
  ws = null;
  url;
  reconnectAttempts = 0;
  maxReconnectAttempts = 5;
  reconnectDelay = 1000;
  pingInterval = null;
  pingTimeout = null;
  isBrowser;
  constructor(url) {
    super();
    this.url = url;
    this.isBrowser = typeof process === "undefined" || !process.versions || !process.versions.node;
  }
  validateStream(stream) {
    const [type2, params] = stream.split("@");
    if (!type2 || !params) {
      throw new Error(`Invalid stream format: ${stream}. Expected format: <type>@<params>`);
    }
    const urlPath = new URL(this.url).pathname;
    const endpoint = urlPath.split("/").pop();
    if (endpoint && type2 !== endpoint) {
      throw new Error(`Stream type '${type2}' doesn't match the connected endpoint '${endpoint}'`);
    }
    if (!VALID_STREAM_TYPES.includes(type2)) {
      throw new Error(`Invalid stream type: ${type2}. Valid types are: ${VALID_STREAM_TYPES.join(", ")}`);
    }
    if (type2 === "account" && !/^\d+$/.test(params)) {
      throw new Error(`Invalid account ID in stream: ${params}. Expected numeric ID`);
    }
  }
  setupHeartbeat() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
    }
    if (this.pingTimeout) {
      clearTimeout(this.pingTimeout);
    }
    if (this.isBrowser) {
      return;
    }
    this.pingInterval = setInterval(() => {
      if (this.ws && !this.isBrowser) {
        this.ws.ping();
        this.pingTimeout = setTimeout(() => {
          this.emit("error", new Error("WebSocket ping timeout"));
          this.close();
          this.reconnect();
        }, 5000);
      }
    }, 30000);
  }
  getWebSocketClass() {
    if (this.isBrowser) {
      if (typeof globalThis !== "undefined" && globalThis.WebSocket) {
        return globalThis.WebSocket;
      }
      throw new Error("WebSocket is not available in this environment");
    } else {
      return import_ws2.default;
    }
  }
  connect() {
    if (this.ws) {
      return;
    }
    try {
      const WebSocketClass = this.getWebSocketClass();
      if (this.isBrowser) {
        this.ws = new WebSocketClass(this.url);
        this.ws.onopen = () => {
          this.emit("connected");
          this.reconnectAttempts = 0;
          this.reconnectDelay = 1000;
        };
        this.ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            this.handleMessage(message);
          } catch (error) {
            this.emit("error", new Error(`Failed to parse message: ${error instanceof Error ? error.message : String(error)}`));
          }
        };
        this.ws.onclose = (_event) => {
          this.emit("disconnected");
          this.reconnect();
        };
        this.ws.onerror = (event) => {
          const errorMsg = `WebSocket error: ${event && event.type ? event.type : "unknown"}`;
          this.emit("error", new Error(errorMsg));
        };
      } else {
        const nodeWs = new WebSocketClass(this.url);
        this.ws = nodeWs;
        nodeWs.on("open", () => {
          this.emit("connected");
          this.reconnectAttempts = 0;
          this.reconnectDelay = 1000;
          this.setupHeartbeat();
        });
        nodeWs.on("message", (data) => {
          try {
            const message = JSON.parse(data.toString());
            this.handleMessage(message);
          } catch (error) {
            this.emit("error", new Error(`Failed to parse message: ${error instanceof Error ? error.message : String(error)}`));
          }
        });
        nodeWs.on("close", (_code, _reason) => {
          this.emit("disconnected");
          if (this.pingInterval) {
            clearInterval(this.pingInterval);
          }
          if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
          }
          this.reconnect();
        });
        nodeWs.on("error", (error) => {
          this.emit("error", error);
        });
        nodeWs.on("pong", () => {
          if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
          }
        });
      }
    } catch (error) {
      const errorMsg = `Failed to initialize WebSocket: ${error instanceof Error ? error.message : String(error)}`;
      this.emit("error", new Error(errorMsg));
    }
  }
  close() {
    if (this.ws) {
      if (this.isBrowser) {
        this.ws.close();
      } else {
        this.ws.close();
      }
      this.ws = null;
    }
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
    if (this.pingTimeout) {
      clearTimeout(this.pingTimeout);
      this.pingTimeout = null;
    }
  }
  handleMessage(message) {
    if (!message || typeof message !== "object") {
      this.emit("error", new Error(`Unexpected message type: ${message}`));
      return;
    }
    const hasOwn = (k) => Object.prototype.hasOwnProperty.call(message, k);
    if (hasOwn("trades")) {
      this.emit("trades", message.trades);
      return;
    }
    if (hasOwn("delta")) {
      this.emit("delta", message.delta);
      return;
    }
    if (hasOwn("account")) {
      this.emit("account", message.account);
      return;
    }
    if (this.isCandleUpdate(message)) {
      this.emit("candle", message);
      return;
    }
    this.emit("error", new Error(`Unexpected message type: ${message}`));
  }
  isCandleUpdate(message) {
    if (!message || typeof message !== "object") {
      return false;
    }
    const candidate = message;
    return typeof candidate.res === "string" && typeof candidate.mid === "number" && typeof candidate.t === "number" && typeof candidate.o === "number" && typeof candidate.h === "number" && typeof candidate.l === "number" && typeof candidate.c === "number" && typeof candidate.v === "number";
  }
  reconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      this.emit("error", new Error("Max reconnection attempts reached"));
      return;
    }
    setTimeout(() => {
      this.reconnectAttempts++;
      this.reconnectDelay *= 2;
      this.connect();
    }, this.reconnectDelay);
  }
}

// src/websocket/Subscriber.ts
class Subscriber {
  streamURL;
  buffer;
  maxBufferLen;
  constructor(config2) {
    this.streamURL = config2.streamURL;
    this.buffer = [];
    this.maxBufferLen = config2.maxBufferLen ?? MAX_BUFFER_LEN;
  }
  subscribe() {}
}

// src/websocket/index.ts
function initWebSocketClient(webServerUrl, subscriptions) {
  try {
    let wsUrl = webServerUrl.replace(/^http/, "ws") + `/ws`;
    if (typeof subscriptions === "string") {
      if (subscriptions === "trades" || subscriptions === "delta" || subscriptions === "account") {
        wsUrl += `/${subscriptions}`;
      } else {
        throw new NordError(`Invalid endpoint: ${subscriptions}. Must be "trades", "deltas", or "account".`);
      }
    } else if (Array.isArray(subscriptions) && subscriptions.length > 0) {
      subscriptions.forEach(validateSubscription);
      wsUrl += `/${subscriptions.join("&")}`;
    } else {
      wsUrl += `/trades`;
    }
    console.log(`Initializing WebSocket client with URL: ${wsUrl}`);
    const ws = new NordWebSocketClient(wsUrl);
    ws.on("error", (error) => {
      console.error("Nord WebSocket error:", error);
    });
    ws.on("connected", () => {
      console.log("Nord WebSocket connected successfully");
    });
    ws.connect();
    return ws;
  } catch (error) {
    console.error("Failed to initialize WebSocket client:", error);
    throw new NordError("Failed to initialize WebSocket client", {
      cause: error
    });
  }
}
function validateSubscription(subscription) {
  const [type2, param] = subscription.split("@");
  if (!type2 || !param || !["trades", "deltas", "account", "candle"].includes(type2)) {
    throw new NordError(`Invalid subscription format: ${subscription}. Expected format: "trades@SYMBOL", "deltas@SYMBOL", "account@ID", or "candle@SYMBOL:RESOLUTION"`);
  }
  if (type2 === "account" && isNaN(Number(param))) {
    throw new NordError(`Invalid account ID in subscription: ${subscription}. Account ID must be a number.`);
  }
  if (type2 === "candle") {
    const [symbol2, resolution] = param.split(":");
    if (!symbol2 || !resolution) {
      throw new NordError(`Invalid candle subscription format: ${subscription}. Expected format: "candle@SYMBOL:RESOLUTION"`);
    }
  }
}
// node_modules/@n1xyz/proton/dist/index.browser.js
var __create2 = Object.create;
var __getProtoOf2 = Object.getPrototypeOf;
var __defProp2 = Object.defineProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod4, isNodeMode, target) => {
  target = mod4 != null ? __create2(__getProtoOf2(mod4)) : {};
  const to = isNodeMode || !mod4 || !mod4.__esModule ? __defProp2(target, "default", { value: mod4, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod4))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, {
        get: () => mod4[key],
        enumerable: true
      });
  return to;
};
var __moduleCache2 = /* @__PURE__ */ new WeakMap;
var __toCommonJS2 = (from2) => {
  var entry = __moduleCache2.get(from2), desc;
  if (entry)
    return entry;
  entry = __defProp2({}, "__esModule", { value: true });
  if (from2 && typeof from2 === "object" || typeof from2 === "function")
    __getOwnPropNames2(from2).map((key) => !__hasOwnProp2.call(entry, key) && __defProp2(entry, key, {
      get: () => from2[key],
      enumerable: !(desc = __getOwnPropDesc2(from2, key)) || desc.enumerable
    }));
  __moduleCache2.set(from2, entry);
  return entry;
};
var __commonJS2 = (cb, mod4) => () => (mod4 || cb((mod4 = { exports: {} }).exports, mod4), mod4.exports);
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm2 = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var exports_buffer2 = {};
__export2(exports_buffer2, {
  transcode: () => at,
  resolveObjectURL: () => lt,
  kStringMaxLength: () => K,
  kMaxLength: () => et,
  isUtf8: () => pt,
  isAscii: () => ct,
  default: () => export_default,
  createObjectURL: () => ft,
  constants: () => st,
  btoa: () => ht,
  atob: () => ut,
  File: () => ot,
  Buffer: () => export_Buffer,
  Blob: () => nt
});
function lt(i3) {
  throw new Error("Not implemented");
}
function at(i3, r, t) {
  throw new Error("Not implemented");
}
var dr;
var $;
var gr;
var mr;
var Ir;
var Fr;
var P2 = (i3, r) => () => (r || i3((r = { exports: {} }).exports, r), r.exports);
var Ar = (i3, r) => {
  for (var t in r)
    $(i3, t, { get: r[t], enumerable: true });
};
var D = (i3, r, t, e) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let n2 of mr(r))
      !Fr.call(i3, n2) && n2 !== t && $(i3, n2, { get: () => r[n2], enumerable: !(e = gr(r, n2)) || e.enumerable });
  return i3;
};
var x = (i3, r, t) => (D(i3, r, "default"), t && D(t, r, "default"));
var Z = (i3, r, t) => (t = i3 != null ? dr(Ir(i3)) : {}, D(r || !i3 || !i3.__esModule ? $(t, "default", { value: i3, enumerable: true }) : t, i3));
var rr;
var tr;
var J;
var w;
var b2;
var K;
var et = 9007199254740991;
var nt;
var ot;
var ut;
var ht;
var ft;
var ct = (i3) => ArrayBuffer.isView(i3) ? i3.every((r) => r < 128) : i3.split("").every((r) => r.charCodeAt(0) < 128);
var pt = (i3) => {
  throw new Error("Not implemented");
};
var st;
var export_Buffer;
var export_default;
var init_buffer2 = __esm2(() => {
  dr = Object.create;
  $ = Object.defineProperty;
  gr = Object.getOwnPropertyDescriptor;
  mr = Object.getOwnPropertyNames;
  Ir = Object.getPrototypeOf;
  Fr = Object.prototype.hasOwnProperty;
  rr = P2((L) => {
    L.byteLength = Rr;
    L.toByteArray = Cr;
    L.fromByteArray = Lr;
    var d = [], B = [], Ur = typeof Uint8Array < "u" ? Uint8Array : Array, O = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (F = 0, Q = O.length;F < Q; ++F)
      d[F] = O[F], B[O.charCodeAt(F)] = F;
    var F, Q;
    B[45] = 62;
    B[95] = 63;
    function v(i3) {
      var r = i3.length;
      if (r % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var t = i3.indexOf("=");
      t === -1 && (t = r);
      var e = t === r ? 0 : 4 - t % 4;
      return [t, e];
    }
    function Rr(i3) {
      var r = v(i3), t = r[0], e = r[1];
      return (t + e) * 3 / 4 - e;
    }
    function Tr(i3, r, t) {
      return (r + t) * 3 / 4 - t;
    }
    function Cr(i3) {
      var r, t = v(i3), e = t[0], n2 = t[1], o = new Ur(Tr(i3, e, n2)), u = 0, f3 = n2 > 0 ? e - 4 : e, c;
      for (c = 0;c < f3; c += 4)
        r = B[i3.charCodeAt(c)] << 18 | B[i3.charCodeAt(c + 1)] << 12 | B[i3.charCodeAt(c + 2)] << 6 | B[i3.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
      return n2 === 2 && (r = B[i3.charCodeAt(c)] << 2 | B[i3.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), n2 === 1 && (r = B[i3.charCodeAt(c)] << 10 | B[i3.charCodeAt(c + 1)] << 4 | B[i3.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function _r(i3) {
      return d[i3 >> 18 & 63] + d[i3 >> 12 & 63] + d[i3 >> 6 & 63] + d[i3 & 63];
    }
    function Sr(i3, r, t) {
      for (var e, n2 = [], o = r;o < t; o += 3)
        e = (i3[o] << 16 & 16711680) + (i3[o + 1] << 8 & 65280) + (i3[o + 2] & 255), n2.push(_r(e));
      return n2.join("");
    }
    function Lr(i3) {
      for (var r, t = i3.length, e = t % 3, n2 = [], o = 16383, u = 0, f3 = t - e;u < f3; u += o)
        n2.push(Sr(i3, u, u + o > f3 ? f3 : u + o));
      return e === 1 ? (r = i3[t - 1], n2.push(d[r >> 2] + d[r << 4 & 63] + "==")) : e === 2 && (r = (i3[t - 2] << 8) + i3[t - 1], n2.push(d[r >> 10] + d[r >> 4 & 63] + d[r << 2 & 63] + "=")), n2.join("");
    }
  });
  tr = P2((G) => {
    G.read = function(i3, r, t, e, n2) {
      var o, u, f3 = n2 * 8 - e - 1, c = (1 << f3) - 1, l = c >> 1, s = -7, p = t ? n2 - 1 : 0, U = t ? -1 : 1, E2 = i3[r + p];
      for (p += U, o = E2 & (1 << -s) - 1, E2 >>= -s, s += f3;s > 0; o = o * 256 + i3[r + p], p += U, s -= 8)
        ;
      for (u = o & (1 << -s) - 1, o >>= -s, s += e;s > 0; u = u * 256 + i3[r + p], p += U, s -= 8)
        ;
      if (o === 0)
        o = 1 - l;
      else {
        if (o === c)
          return u ? NaN : (E2 ? -1 : 1) * (1 / 0);
        u = u + Math.pow(2, e), o = o - l;
      }
      return (E2 ? -1 : 1) * u * Math.pow(2, o - e);
    };
    G.write = function(i3, r, t, e, n2, o) {
      var u, f3, c, l = o * 8 - n2 - 1, s = (1 << l) - 1, p = s >> 1, U = n2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E2 = e ? 0 : o - 1, k = e ? 1 : -1, Er = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
      for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f3 = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += U / c : r += U * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f3 = 0, u = s) : u + p >= 1 ? (f3 = (r * c - 1) * Math.pow(2, n2), u = u + p) : (f3 = r * Math.pow(2, p - 1) * Math.pow(2, n2), u = 0));n2 >= 8; i3[t + E2] = f3 & 255, E2 += k, f3 /= 256, n2 -= 8)
        ;
      for (u = u << n2 | f3, l += n2;l > 0; i3[t + E2] = u & 255, E2 += k, u /= 256, l -= 8)
        ;
      i3[t + E2 - k] |= Er * 128;
    };
  });
  J = P2((_) => {
    var Y = rr(), T = tr(), ir = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    _.Buffer = h;
    _.SlowBuffer = $r;
    _.INSPECT_MAX_BYTES = 50;
    var N3 = 2147483647;
    _.kMaxLength = N3;
    h.TYPED_ARRAY_SUPPORT = Nr();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Nr() {
      try {
        let i3 = new Uint8Array(1), r = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i3, r), i3.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h.prototype, "parent", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h.prototype, "offset", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.byteOffset;
    } });
    function m(i3) {
      if (i3 > N3)
        throw new RangeError('The value "' + i3 + '" is invalid for option "size"');
      let r = new Uint8Array(i3);
      return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i3, r, t) {
      if (typeof i3 == "number") {
        if (typeof r == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return H(i3);
      }
      return ur(i3, r, t);
    }
    h.poolSize = 8192;
    function ur(i3, r, t) {
      if (typeof i3 == "string")
        return br(i3, r);
      if (ArrayBuffer.isView(i3))
        return kr(i3);
      if (i3 == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i3);
      if (g(i3, ArrayBuffer) || i3 && g(i3.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (g(i3, SharedArrayBuffer) || i3 && g(i3.buffer, SharedArrayBuffer)))
        return q(i3, r, t);
      if (typeof i3 == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let e = i3.valueOf && i3.valueOf();
      if (e != null && e !== i3)
        return h.from(e, r, t);
      let n2 = Dr(i3);
      if (n2)
        return n2;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i3[Symbol.toPrimitive] == "function")
        return h.from(i3[Symbol.toPrimitive]("string"), r, t);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i3);
    }
    h.from = function(i3, r, t) {
      return ur(i3, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function hr(i3) {
      if (typeof i3 != "number")
        throw new TypeError('"size" argument must be of type number');
      if (i3 < 0)
        throw new RangeError('The value "' + i3 + '" is invalid for option "size"');
    }
    function Mr(i3, r, t) {
      return hr(i3), i3 <= 0 ? m(i3) : r !== undefined ? typeof t == "string" ? m(i3).fill(r, t) : m(i3).fill(r) : m(i3);
    }
    h.alloc = function(i3, r, t) {
      return Mr(i3, r, t);
    };
    function H(i3) {
      return hr(i3), m(i3 < 0 ? 0 : X(i3) | 0);
    }
    h.allocUnsafe = function(i3) {
      return H(i3);
    };
    h.allocUnsafeSlow = function(i3) {
      return H(i3);
    };
    function br(i3, r) {
      if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r))
        throw new TypeError("Unknown encoding: " + r);
      let t = fr(i3, r) | 0, e = m(t), n2 = e.write(i3, r);
      return n2 !== t && (e = e.slice(0, n2)), e;
    }
    function j(i3) {
      let r = i3.length < 0 ? 0 : X(i3.length) | 0, t = m(r);
      for (let e = 0;e < r; e += 1)
        t[e] = i3[e] & 255;
      return t;
    }
    function kr(i3) {
      if (g(i3, Uint8Array)) {
        let r = new Uint8Array(i3);
        return q(r.buffer, r.byteOffset, r.byteLength);
      }
      return j(i3);
    }
    function q(i3, r, t) {
      if (r < 0 || i3.byteLength < r)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (i3.byteLength < r + (t || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let e;
      return r === undefined && t === undefined ? e = new Uint8Array(i3) : t === undefined ? e = new Uint8Array(i3, r) : e = new Uint8Array(i3, r, t), Object.setPrototypeOf(e, h.prototype), e;
    }
    function Dr(i3) {
      if (h.isBuffer(i3)) {
        let r = X(i3.length) | 0, t = m(r);
        return t.length === 0 || i3.copy(t, 0, 0, r), t;
      }
      if (i3.length !== undefined)
        return typeof i3.length != "number" || z(i3.length) ? m(0) : j(i3);
      if (i3.type === "Buffer" && Array.isArray(i3.data))
        return j(i3.data);
    }
    function X(i3) {
      if (i3 >= N3)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N3.toString(16) + " bytes");
      return i3 | 0;
    }
    function $r(i3) {
      return +i3 != i3 && (i3 = 0), h.alloc(+i3);
    }
    h.isBuffer = function(r) {
      return r != null && r._isBuffer === true && r !== h.prototype;
    };
    h.compare = function(r, t) {
      if (g(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), g(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (r === t)
        return 0;
      let e = r.length, n2 = t.length;
      for (let o = 0, u = Math.min(e, n2);o < u; ++o)
        if (r[o] !== t[o]) {
          e = r[o], n2 = t[o];
          break;
        }
      return e < n2 ? -1 : n2 < e ? 1 : 0;
    };
    h.isEncoding = function(r) {
      switch (String(r).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h.concat = function(r, t) {
      if (!Array.isArray(r))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (r.length === 0)
        return h.alloc(0);
      let e;
      if (t === undefined)
        for (t = 0, e = 0;e < r.length; ++e)
          t += r[e].length;
      let n2 = h.allocUnsafe(t), o = 0;
      for (e = 0;e < r.length; ++e) {
        let u = r[e];
        if (g(u, Uint8Array))
          o + u.length > n2.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(n2, o)) : Uint8Array.prototype.set.call(n2, u, o);
        else if (h.isBuffer(u))
          u.copy(n2, o);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o += u.length;
      }
      return n2;
    };
    function fr(i3, r) {
      if (h.isBuffer(i3))
        return i3.length;
      if (ArrayBuffer.isView(i3) || g(i3, ArrayBuffer))
        return i3.byteLength;
      if (typeof i3 != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i3);
      let t = i3.length, e = arguments.length > 2 && arguments[2] === true;
      if (!e && t === 0)
        return 0;
      let n2 = false;
      for (;; )
        switch (r) {
          case "ascii":
          case "latin1":
          case "binary":
            return t;
          case "utf8":
          case "utf-8":
            return W(i3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return t * 2;
          case "hex":
            return t >>> 1;
          case "base64":
            return Br(i3).length;
          default:
            if (n2)
              return e ? -1 : W(i3).length;
            r = ("" + r).toLowerCase(), n2 = true;
        }
    }
    h.byteLength = fr;
    function Pr(i3, r, t) {
      let e = false;
      if ((r === undefined || r < 0) && (r = 0), r > this.length || ((t === undefined || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
        return "";
      for (i3 || (i3 = "utf8");; )
        switch (i3) {
          case "hex":
            return zr(this, r, t);
          case "utf8":
          case "utf-8":
            return pr(this, r, t);
          case "ascii":
            return Xr(this, r, t);
          case "latin1":
          case "binary":
            return Vr(this, r, t);
          case "base64":
            return Wr(this, r, t);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Jr(this, r, t);
          default:
            if (e)
              throw new TypeError("Unknown encoding: " + i3);
            i3 = (i3 + "").toLowerCase(), e = true;
        }
    }
    h.prototype._isBuffer = true;
    function A(i3, r, t) {
      let e = i3[r];
      i3[r] = i3[t], i3[t] = e;
    }
    h.prototype.swap16 = function() {
      let r = this.length;
      if (r % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let t = 0;t < r; t += 2)
        A(this, t, t + 1);
      return this;
    };
    h.prototype.swap32 = function() {
      let r = this.length;
      if (r % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let t = 0;t < r; t += 4)
        A(this, t, t + 3), A(this, t + 1, t + 2);
      return this;
    };
    h.prototype.swap64 = function() {
      let r = this.length;
      if (r % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t = 0;t < r; t += 8)
        A(this, t, t + 7), A(this, t + 1, t + 6), A(this, t + 2, t + 5), A(this, t + 3, t + 4);
      return this;
    };
    h.prototype.toString = function() {
      let r = this.length;
      return r === 0 ? "" : arguments.length === 0 ? pr(this, 0, r) : Pr.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
      if (!h.isBuffer(r))
        throw new TypeError("Argument must be a Buffer");
      return this === r ? true : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
      let r = "", t = _.INSPECT_MAX_BYTES;
      return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    ir && (h.prototype[ir] = h.prototype.inspect);
    h.prototype.compare = function(r, t, e, n2, o) {
      if (g(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
      if (t === undefined && (t = 0), e === undefined && (e = r ? r.length : 0), n2 === undefined && (n2 = 0), o === undefined && (o = this.length), t < 0 || e > r.length || n2 < 0 || o > this.length)
        throw new RangeError("out of range index");
      if (n2 >= o && t >= e)
        return 0;
      if (n2 >= o)
        return -1;
      if (t >= e)
        return 1;
      if (t >>>= 0, e >>>= 0, n2 >>>= 0, o >>>= 0, this === r)
        return 0;
      let u = o - n2, f3 = e - t, c = Math.min(u, f3), l = this.slice(n2, o), s = r.slice(t, e);
      for (let p = 0;p < c; ++p)
        if (l[p] !== s[p]) {
          u = l[p], f3 = s[p];
          break;
        }
      return u < f3 ? -1 : f3 < u ? 1 : 0;
    };
    function cr(i3, r, t, e, n2) {
      if (i3.length === 0)
        return -1;
      if (typeof t == "string" ? (e = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, z(t) && (t = n2 ? 0 : i3.length - 1), t < 0 && (t = i3.length + t), t >= i3.length) {
        if (n2)
          return -1;
        t = i3.length - 1;
      } else if (t < 0)
        if (n2)
          t = 0;
        else
          return -1;
      if (typeof r == "string" && (r = h.from(r, e)), h.isBuffer(r))
        return r.length === 0 ? -1 : er(i3, r, t, e, n2);
      if (typeof r == "number")
        return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? n2 ? Uint8Array.prototype.indexOf.call(i3, r, t) : Uint8Array.prototype.lastIndexOf.call(i3, r, t) : er(i3, [r], t, e, n2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function er(i3, r, t, e, n2) {
      let o = 1, u = i3.length, f3 = r.length;
      if (e !== undefined && (e = String(e).toLowerCase(), e === "ucs2" || e === "ucs-2" || e === "utf16le" || e === "utf-16le")) {
        if (i3.length < 2 || r.length < 2)
          return -1;
        o = 2, u /= 2, f3 /= 2, t /= 2;
      }
      function c(s, p) {
        return o === 1 ? s[p] : s.readUInt16BE(p * o);
      }
      let l;
      if (n2) {
        let s = -1;
        for (l = t;l < u; l++)
          if (c(i3, l) === c(r, s === -1 ? 0 : l - s)) {
            if (s === -1 && (s = l), l - s + 1 === f3)
              return s * o;
          } else
            s !== -1 && (l -= l - s), s = -1;
      } else
        for (t + f3 > u && (t = u - f3), l = t;l >= 0; l--) {
          let s = true;
          for (let p = 0;p < f3; p++)
            if (c(i3, l + p) !== c(r, p)) {
              s = false;
              break;
            }
          if (s)
            return l;
        }
      return -1;
    }
    h.prototype.includes = function(r, t, e) {
      return this.indexOf(r, t, e) !== -1;
    };
    h.prototype.indexOf = function(r, t, e) {
      return cr(this, r, t, e, true);
    };
    h.prototype.lastIndexOf = function(r, t, e) {
      return cr(this, r, t, e, false);
    };
    function Or(i3, r, t, e) {
      t = Number(t) || 0;
      let n2 = i3.length - t;
      e ? (e = Number(e), e > n2 && (e = n2)) : e = n2;
      let o = r.length;
      e > o / 2 && (e = o / 2);
      let u;
      for (u = 0;u < e; ++u) {
        let f3 = parseInt(r.substr(u * 2, 2), 16);
        if (z(f3))
          return u;
        i3[t + u] = f3;
      }
      return u;
    }
    function Gr(i3, r, t, e) {
      return M(W(r, i3.length - t), i3, t, e);
    }
    function Yr(i3, r, t, e) {
      return M(vr(r), i3, t, e);
    }
    function jr(i3, r, t, e) {
      return M(Br(r), i3, t, e);
    }
    function qr(i3, r, t, e) {
      return M(rt(r, i3.length - t), i3, t, e);
    }
    h.prototype.write = function(r, t, e, n2) {
      if (t === undefined)
        n2 = "utf8", e = this.length, t = 0;
      else if (e === undefined && typeof t == "string")
        n2 = t, e = this.length, t = 0;
      else if (isFinite(t))
        t = t >>> 0, isFinite(e) ? (e = e >>> 0, n2 === undefined && (n2 = "utf8")) : (n2 = e, e = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o = this.length - t;
      if ((e === undefined || e > o) && (e = o), r.length > 0 && (e < 0 || t < 0) || t > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n2 || (n2 = "utf8");
      let u = false;
      for (;; )
        switch (n2) {
          case "hex":
            return Or(this, r, t, e);
          case "utf8":
          case "utf-8":
            return Gr(this, r, t, e);
          case "ascii":
          case "latin1":
          case "binary":
            return Yr(this, r, t, e);
          case "base64":
            return jr(this, r, t, e);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return qr(this, r, t, e);
          default:
            if (u)
              throw new TypeError("Unknown encoding: " + n2);
            n2 = ("" + n2).toLowerCase(), u = true;
        }
    };
    h.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Wr(i3, r, t) {
      return r === 0 && t === i3.length ? Y.fromByteArray(i3) : Y.fromByteArray(i3.slice(r, t));
    }
    function pr(i3, r, t) {
      t = Math.min(i3.length, t);
      let e = [], n2 = r;
      for (;n2 < t; ) {
        let o = i3[n2], u = null, f3 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
        if (n2 + f3 <= t) {
          let c, l, s, p;
          switch (f3) {
            case 1:
              o < 128 && (u = o);
              break;
            case 2:
              c = i3[n2 + 1], (c & 192) === 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
              break;
            case 3:
              c = i3[n2 + 1], l = i3[n2 + 2], (c & 192) === 128 && (l & 192) === 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
              break;
            case 4:
              c = i3[n2 + 1], l = i3[n2 + 2], s = i3[n2 + 3], (c & 192) === 128 && (l & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
          }
        }
        u === null ? (u = 65533, f3 = 1) : u > 65535 && (u -= 65536, e.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), e.push(u), n2 += f3;
      }
      return Hr(e);
    }
    var nr = 4096;
    function Hr(i3) {
      let r = i3.length;
      if (r <= nr)
        return String.fromCharCode.apply(String, i3);
      let t = "", e = 0;
      for (;e < r; )
        t += String.fromCharCode.apply(String, i3.slice(e, e += nr));
      return t;
    }
    function Xr(i3, r, t) {
      let e = "";
      t = Math.min(i3.length, t);
      for (let n2 = r;n2 < t; ++n2)
        e += String.fromCharCode(i3[n2] & 127);
      return e;
    }
    function Vr(i3, r, t) {
      let e = "";
      t = Math.min(i3.length, t);
      for (let n2 = r;n2 < t; ++n2)
        e += String.fromCharCode(i3[n2]);
      return e;
    }
    function zr(i3, r, t) {
      let e = i3.length;
      (!r || r < 0) && (r = 0), (!t || t < 0 || t > e) && (t = e);
      let n2 = "";
      for (let o = r;o < t; ++o)
        n2 += tt[i3[o]];
      return n2;
    }
    function Jr(i3, r, t) {
      let e = i3.slice(r, t), n2 = "";
      for (let o = 0;o < e.length - 1; o += 2)
        n2 += String.fromCharCode(e[o] + e[o + 1] * 256);
      return n2;
    }
    h.prototype.slice = function(r, t) {
      let e = this.length;
      r = ~~r, t = t === undefined ? e : ~~t, r < 0 ? (r += e, r < 0 && (r = 0)) : r > e && (r = e), t < 0 ? (t += e, t < 0 && (t = 0)) : t > e && (t = e), t < r && (t = r);
      let n2 = this.subarray(r, t);
      return Object.setPrototypeOf(n2, h.prototype), n2;
    };
    function a(i3, r, t) {
      if (i3 % 1 !== 0 || i3 < 0)
        throw new RangeError("offset is not uint");
      if (i3 + r > t)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a(r, t, this.length);
      let n2 = this[r], o = 1, u = 0;
      for (;++u < t && (o *= 256); )
        n2 += this[r + u] * o;
      return n2;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a(r, t, this.length);
      let n2 = this[r + --t], o = 1;
      for (;t > 0 && (o *= 256); )
        n2 += this[r + --t] * o;
      return n2;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
      return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
      return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
      return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = I(function(r) {
      r = r >>> 0, C(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S2(r, this.length - 8);
      let n2 = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + e * 2 ** 24;
      return BigInt(n2) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = I(function(r) {
      r = r >>> 0, C(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S2(r, this.length - 8);
      let n2 = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e;
      return (BigInt(n2) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a(r, t, this.length);
      let n2 = this[r], o = 1, u = 0;
      for (;++u < t && (o *= 256); )
        n2 += this[r + u] * o;
      return o *= 128, n2 >= o && (n2 -= Math.pow(2, 8 * t)), n2;
    };
    h.prototype.readIntBE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a(r, t, this.length);
      let n2 = t, o = 1, u = this[r + --n2];
      for (;n2 > 0 && (o *= 256); )
        u += this[r + --n2] * o;
      return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
      return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
      r = r >>> 0, t || a(r, 2, this.length);
      let e = this[r] | this[r + 1] << 8;
      return e & 32768 ? e | 4294901760 : e;
    };
    h.prototype.readInt16BE = function(r, t) {
      r = r >>> 0, t || a(r, 2, this.length);
      let e = this[r + 1] | this[r] << 8;
      return e & 32768 ? e | 4294901760 : e;
    };
    h.prototype.readInt32LE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = I(function(r) {
      r = r >>> 0, C(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S2(r, this.length - 8);
      let n2 = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (e << 24);
      return (BigInt(n2) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = I(function(r) {
      r = r >>> 0, C(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S2(r, this.length - 8);
      let n2 = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
      return (BigInt(n2) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e);
    });
    h.prototype.readFloatLE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), T.read(this, r, true, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), T.read(this, r, false, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
      return r = r >>> 0, t || a(r, 8, this.length), T.read(this, r, true, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
      return r = r >>> 0, t || a(r, 8, this.length), T.read(this, r, false, 52, 8);
    };
    function y(i3, r, t, e, n2, o) {
      if (!h.isBuffer(i3))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (r > n2 || r < o)
        throw new RangeError('"value" argument is out of bounds');
      if (t + e > i3.length)
        throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, e, n2) {
      if (r = +r, t = t >>> 0, e = e >>> 0, !n2) {
        let f3 = Math.pow(2, 8 * e) - 1;
        y(this, r, t, e, f3, 0);
      }
      let o = 1, u = 0;
      for (this[t] = r & 255;++u < e && (o *= 256); )
        this[t + u] = r / o & 255;
      return t + e;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, e, n2) {
      if (r = +r, t = t >>> 0, e = e >>> 0, !n2) {
        let f3 = Math.pow(2, 8 * e) - 1;
        y(this, r, t, e, f3, 0);
      }
      let o = e - 1, u = 1;
      for (this[t + o] = r & 255;--o >= 0 && (u *= 256); )
        this[t + o] = r / u & 255;
      return t + e;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function sr(i3, r, t, e, n2) {
      xr(r, e, n2, i3, t, 7);
      let o = Number(r & BigInt(4294967295));
      i3[t++] = o, o = o >> 8, i3[t++] = o, o = o >> 8, i3[t++] = o, o = o >> 8, i3[t++] = o;
      let u = Number(r >> BigInt(32) & BigInt(4294967295));
      return i3[t++] = u, u = u >> 8, i3[t++] = u, u = u >> 8, i3[t++] = u, u = u >> 8, i3[t++] = u, t;
    }
    function lr(i3, r, t, e, n2) {
      xr(r, e, n2, i3, t, 7);
      let o = Number(r & BigInt(4294967295));
      i3[t + 7] = o, o = o >> 8, i3[t + 6] = o, o = o >> 8, i3[t + 5] = o, o = o >> 8, i3[t + 4] = o;
      let u = Number(r >> BigInt(32) & BigInt(4294967295));
      return i3[t + 3] = u, u = u >> 8, i3[t + 2] = u, u = u >> 8, i3[t + 1] = u, u = u >> 8, i3[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = I(function(r, t = 0) {
      return sr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = I(function(r, t = 0) {
      return lr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, e, n2) {
      if (r = +r, t = t >>> 0, !n2) {
        let c = Math.pow(2, 8 * e - 1);
        y(this, r, t, e, c - 1, -c);
      }
      let o = 0, u = 1, f3 = 0;
      for (this[t] = r & 255;++o < e && (u *= 256); )
        r < 0 && f3 === 0 && this[t + o - 1] !== 0 && (f3 = 1), this[t + o] = (r / u >> 0) - f3 & 255;
      return t + e;
    };
    h.prototype.writeIntBE = function(r, t, e, n2) {
      if (r = +r, t = t >>> 0, !n2) {
        let c = Math.pow(2, 8 * e - 1);
        y(this, r, t, e, c - 1, -c);
      }
      let o = e - 1, u = 1, f3 = 0;
      for (this[t + o] = r & 255;--o >= 0 && (u *= 256); )
        r < 0 && f3 === 0 && this[t + o + 1] !== 0 && (f3 = 1), this[t + o] = (r / u >> 0) - f3 & 255;
      return t + e;
    };
    h.prototype.writeInt8 = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = I(function(r, t = 0) {
      return sr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = I(function(r, t = 0) {
      return lr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ar(i3, r, t, e, n2, o) {
      if (t + e > i3.length)
        throw new RangeError("Index out of range");
      if (t < 0)
        throw new RangeError("Index out of range");
    }
    function yr(i3, r, t, e, n2) {
      return r = +r, t = t >>> 0, n2 || ar(i3, r, t, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), T.write(i3, r, t, e, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, e) {
      return yr(this, r, t, true, e);
    };
    h.prototype.writeFloatBE = function(r, t, e) {
      return yr(this, r, t, false, e);
    };
    function wr(i3, r, t, e, n2) {
      return r = +r, t = t >>> 0, n2 || ar(i3, r, t, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), T.write(i3, r, t, e, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, e) {
      return wr(this, r, t, true, e);
    };
    h.prototype.writeDoubleBE = function(r, t, e) {
      return wr(this, r, t, false, e);
    };
    h.prototype.copy = function(r, t, e, n2) {
      if (!h.isBuffer(r))
        throw new TypeError("argument should be a Buffer");
      if (e || (e = 0), !n2 && n2 !== 0 && (n2 = this.length), t >= r.length && (t = r.length), t || (t = 0), n2 > 0 && n2 < e && (n2 = e), n2 === e || r.length === 0 || this.length === 0)
        return 0;
      if (t < 0)
        throw new RangeError("targetStart out of bounds");
      if (e < 0 || e >= this.length)
        throw new RangeError("Index out of range");
      if (n2 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n2 > this.length && (n2 = this.length), r.length - t < n2 - e && (n2 = r.length - t + e);
      let o = n2 - e;
      return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, e, n2) : Uint8Array.prototype.set.call(r, this.subarray(e, n2), t), o;
    };
    h.prototype.fill = function(r, t, e, n2) {
      if (typeof r == "string") {
        if (typeof t == "string" ? (n2 = t, t = 0, e = this.length) : typeof e == "string" && (n2 = e, e = this.length), n2 !== undefined && typeof n2 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof n2 == "string" && !h.isEncoding(n2))
          throw new TypeError("Unknown encoding: " + n2);
        if (r.length === 1) {
          let u = r.charCodeAt(0);
          (n2 === "utf8" && u < 128 || n2 === "latin1") && (r = u);
        }
      } else
        typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
      if (t < 0 || this.length < t || this.length < e)
        throw new RangeError("Out of range index");
      if (e <= t)
        return this;
      t = t >>> 0, e = e === undefined ? this.length : e >>> 0, r || (r = 0);
      let o;
      if (typeof r == "number")
        for (o = t;o < e; ++o)
          this[o] = r;
      else {
        let u = h.isBuffer(r) ? r : h.from(r, n2), f3 = u.length;
        if (f3 === 0)
          throw new TypeError('The value "' + r + '" is invalid for argument "value"');
        for (o = 0;o < e - t; ++o)
          this[o + t] = u[o % f3];
      }
      return this;
    };
    var R = {};
    function V(i3, r, t) {
      R[i3] = class extends t {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i3}]`, this.stack, delete this.name;
        }
        get code() {
          return i3;
        }
        set code(n2) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n2, writable: true });
        }
        toString() {
          return `${this.name} [${i3}]: ${this.message}`;
        }
      };
    }
    V("ERR_BUFFER_OUT_OF_BOUNDS", function(i3) {
      return i3 ? `${i3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V("ERR_INVALID_ARG_TYPE", function(i3, r) {
      return `The "${i3}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError);
    V("ERR_OUT_OF_RANGE", function(i3, r, t) {
      let e = `The value of "${i3}" is out of range.`, n2 = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? n2 = or(String(t)) : typeof t == "bigint" && (n2 = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (n2 = or(n2)), n2 += "n"), e += ` It must be ${r}. Received ${n2}`, e;
    }, RangeError);
    function or(i3) {
      let r = "", t = i3.length, e = i3[0] === "-" ? 1 : 0;
      for (;t >= e + 4; t -= 3)
        r = `_${i3.slice(t - 3, t)}${r}`;
      return `${i3.slice(0, t)}${r}`;
    }
    function Kr2(i3, r, t) {
      C(r, "offset"), (i3[r] === undefined || i3[r + t] === undefined) && S2(r, i3.length - (t + 1));
    }
    function xr(i3, r, t, e, n2, o) {
      if (i3 > t || i3 < r) {
        let u = typeof r == "bigint" ? "n" : "", f3;
        throw o > 3 ? r === 0 || r === BigInt(0) ? f3 = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : f3 = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}` : f3 = `>= ${r}${u} and <= ${t}${u}`, new R.ERR_OUT_OF_RANGE("value", f3, i3);
      }
      Kr2(e, n2, o);
    }
    function C(i3, r) {
      if (typeof i3 != "number")
        throw new R.ERR_INVALID_ARG_TYPE(r, "number", i3);
    }
    function S2(i3, r, t) {
      throw Math.floor(i3) !== i3 ? (C(i3, t), new R.ERR_OUT_OF_RANGE(t || "offset", "an integer", i3)) : r < 0 ? new R.ERR_BUFFER_OUT_OF_BOUNDS : new R.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i3);
    }
    var Zr = /[^+/0-9A-Za-z-_]/g;
    function Qr(i3) {
      if (i3 = i3.split("=")[0], i3 = i3.trim().replace(Zr, ""), i3.length < 2)
        return "";
      for (;i3.length % 4 !== 0; )
        i3 = i3 + "=";
      return i3;
    }
    function W(i3, r) {
      r = r || 1 / 0;
      let t, e = i3.length, n2 = null, o = [];
      for (let u = 0;u < e; ++u) {
        if (t = i3.charCodeAt(u), t > 55295 && t < 57344) {
          if (!n2) {
            if (t > 56319) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue;
            } else if (u + 1 === e) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            n2 = t;
            continue;
          }
          if (t < 56320) {
            (r -= 3) > -1 && o.push(239, 191, 189), n2 = t;
            continue;
          }
          t = (n2 - 55296 << 10 | t - 56320) + 65536;
        } else
          n2 && (r -= 3) > -1 && o.push(239, 191, 189);
        if (n2 = null, t < 128) {
          if ((r -= 1) < 0)
            break;
          o.push(t);
        } else if (t < 2048) {
          if ((r -= 2) < 0)
            break;
          o.push(t >> 6 | 192, t & 63 | 128);
        } else if (t < 65536) {
          if ((r -= 3) < 0)
            break;
          o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
        } else if (t < 1114112) {
          if ((r -= 4) < 0)
            break;
          o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o;
    }
    function vr(i3) {
      let r = [];
      for (let t = 0;t < i3.length; ++t)
        r.push(i3.charCodeAt(t) & 255);
      return r;
    }
    function rt(i3, r) {
      let t, e, n2, o = [];
      for (let u = 0;u < i3.length && !((r -= 2) < 0); ++u)
        t = i3.charCodeAt(u), e = t >> 8, n2 = t % 256, o.push(n2), o.push(e);
      return o;
    }
    function Br(i3) {
      return Y.toByteArray(Qr(i3));
    }
    function M(i3, r, t, e) {
      let n2;
      for (n2 = 0;n2 < e && !(n2 + t >= r.length || n2 >= i3.length); ++n2)
        r[n2 + t] = i3[n2];
      return n2;
    }
    function g(i3, r) {
      return i3 instanceof r || i3 != null && i3.constructor != null && i3.constructor.name != null && i3.constructor.name === r.name;
    }
    function z(i3) {
      return i3 !== i3;
    }
    var tt = function() {
      let i3 = "0123456789abcdef", r = new Array(256);
      for (let t = 0;t < 16; ++t) {
        let e = t * 16;
        for (let n2 = 0;n2 < 16; ++n2)
          r[e + n2] = i3[t] + i3[n2];
      }
      return r;
    }();
    function I(i3) {
      return typeof BigInt > "u" ? it : i3;
    }
    function it() {
      throw new Error("BigInt not supported");
    }
  });
  w = {};
  Ar(w, { Blob: () => nt, Buffer: () => b2.Buffer, File: () => ot, atob: () => ut, btoa: () => ht, constants: () => st, createObjectURL: () => ft, default: () => b2.Buffer, isAscii: () => ct, isUtf8: () => pt, kMaxLength: () => et, kStringMaxLength: () => K, resolveObjectURL: () => lt, transcode: () => at });
  x(w, Z(J()));
  b2 = Z(J());
  K = 2 ** 32 - 1;
  ({ Blob: nt, File: ot, atob: ut, btoa: ht } = globalThis);
  ({ createObjectURL: ft } = URL);
  st = { __proto__: null, MAX_LENGTH: K, MAX_STRING_LENGTH: K, BYTES_PER_ELEMENT: 1 };
  export_Buffer = b2.Buffer;
  export_default = b2.Buffer;
  /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});
var require_bn2 = __commonJS2((exports, module) => {
  (function(module2, exports2) {
    function assert6(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
    function BN2(number3, base2, endian) {
      if (BN2.isBN(number3)) {
        return number3;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number3 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number3 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer22;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer22 = window.Buffer;
      } else {
        Buffer22 = (init_buffer2(), __toCommonJS2(exports_buffer2)).Buffer;
      }
    } catch (e) {}
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init(number3, base2, endian) {
      if (typeof number3 === "number") {
        return this._initNumber(number3, base2, endian);
      }
      if (typeof number3 === "object") {
        return this._initArray(number3, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert6(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number3 = number3.toString().replace(/\s+/g, "");
      var start = 0;
      if (number3[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number3.length) {
        if (base2 === 16) {
          this._parseHex(number3, start, endian);
        } else {
          this._parseBase(number3, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number3, base2, endian) {
      if (number3 < 0) {
        this.negative = 1;
        number3 = -number3;
      }
      if (number3 < 67108864) {
        this.words = [number3 & 67108863];
        this.length = 1;
      } else if (number3 < 4503599627370496) {
        this.words = [
          number3 & 67108863,
          number3 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert6(number3 < 9007199254740992);
        this.words = [
          number3 & 67108863,
          number3 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number3, base2, endian) {
      assert6(typeof number3.length === "number");
      if (number3.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number3.length / 3);
      this.words = new Array(this.length);
      for (var i3 = 0;i3 < this.length; i3++) {
        this.words[i3] = 0;
      }
      var j, w2;
      var off = 0;
      if (endian === "be") {
        for (i3 = number3.length - 1, j = 0;i3 >= 0; i3 -= 3) {
          w2 = number3[i3] | number3[i3 - 1] << 8 | number3[i3 - 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i3 = 0, j = 0;i3 < number3.length; i3 += 3) {
          w2 = number3[i3] | number3[i3 + 1] << 8 | number3[i3 + 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index) {
      var c = string2.charCodeAt(index);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert6(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index) {
      var r = parseHex4Bits(string2, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string2, index - 1) << 4;
      }
      return r;
    }
    BN2.prototype._parseHex = function _parseHex(number3, start, endian) {
      this.length = Math.ceil((number3.length - start) / 6);
      this.words = new Array(this.length);
      for (var i3 = 0;i3 < this.length; i3++) {
        this.words[i3] = 0;
      }
      var off = 0;
      var j = 0;
      var w2;
      if (endian === "be") {
        for (i3 = number3.length - 1;i3 >= start; i3 -= 2) {
          w2 = parseHexByte(number3, start, i3) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number3.length - start;
        for (i3 = parseLength % 2 === 0 ? start + 1 : start;i3 < number3.length; i3 += 2) {
          w2 = parseHexByte(number3, start, i3) << off;
          this.words[j] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul2) {
      var r = 0;
      var b22 = 0;
      var len2 = Math.min(str.length, end);
      for (var i3 = start;i3 < len2; i3++) {
        var c = str.charCodeAt(i3) - 48;
        r *= mul2;
        if (c >= 49) {
          b22 = c - 49 + 10;
        } else if (c >= 17) {
          b22 = c - 17 + 10;
        } else {
          b22 = c;
        }
        assert6(c >= 0 && b22 < mul2, "Invalid character");
        r += b22;
      }
      return r;
    }
    BN2.prototype._parseBase = function _parseBase(number3, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number3.length - start;
      var mod22 = total % limbLen;
      var end = Math.min(total, total - mod22) + start;
      var word = 0;
      for (var i3 = start;i3 < end; i3 += limbLen) {
        word = parseBase(number3, i3, i3 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod22 !== 0) {
        var pow3 = 1;
        word = parseBase(number3, i3, number3.length, base2);
        for (i3 = 0;i3 < mod22; i3++) {
          pow3 *= base2;
        }
        this.imuln(pow3);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i3 = 0;i3 < this.length; i3++) {
        dest.words[i3] = this.words[i3];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone() {
      var r = new BN2(null);
      this.copy(r);
      return r;
    };
    BN2.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
      } catch (e) {
        BN2.prototype.inspect = inspect;
      }
    } else {
      BN2.prototype.inspect = inspect;
    }
    function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64000000,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      24300000,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i3 = 0;i3 < this.length; i3++) {
          var w2 = this.words[i3];
          var word = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i3--;
          }
          if (carry !== 0 || i3 !== this.length - 1) {
            out = zeros2[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modrn(groupBase).toString(base2);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros2[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert6(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert6(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON() {
      return this.toString(16, 2);
    };
    if (Buffer22) {
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer22, endian, length);
      };
    }
    BN2.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert6(byteLength2 <= reqLength, "byte array longer than desired length");
      assert6(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position = 0;
      var carry = 0;
      for (var i3 = 0, shift = 0;i3 < this.length; i3++) {
        var word = this.words[i3] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position = res.length - 1;
      var carry = 0;
      for (var i3 = 0, shift = 0;i3 < this.length; i3++) {
        var word = this.words[i3] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t = w2;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t = w2;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0;bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i3 = 0;i3 < this.length; i3++) {
        var b22 = this._zeroBits(this.words[i3]);
        r += b22;
        if (b22 !== 26)
          break;
      }
      return r;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i3 = 0;i3 < num.length; i3++) {
        this.words[i3] = this.words[i3] | num.words[i3];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert6((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b22;
      if (this.length > num.length) {
        b22 = num;
      } else {
        b22 = this;
      }
      for (var i3 = 0;i3 < b22.length; i3++) {
        this.words[i3] = this.words[i3] & num.words[i3];
      }
      this.length = b22.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert6((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a;
      var b22;
      if (this.length > num.length) {
        a = this;
        b22 = num;
      } else {
        a = num;
        b22 = this;
      }
      for (var i3 = 0;i3 < b22.length; i3++) {
        this.words[i3] = a.words[i3] ^ b22.words[i3];
      }
      if (this !== a) {
        for (;i3 < a.length; i3++) {
          this.words[i3] = a.words[i3];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert6((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert6(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i3 = 0;i3 < bytesNeeded; i3++) {
        this.words[i3] = ~this.words[i3] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert6(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b22;
      if (this.length > num.length) {
        a = this;
        b22 = num;
      } else {
        a = num;
        b22 = this;
      }
      var carry = 0;
      for (var i3 = 0;i3 < b22.length; i3++) {
        r = (a.words[i3] | 0) + (b22.words[i3] | 0) + carry;
        this.words[i3] = r & 67108863;
        carry = r >>> 26;
      }
      for (;carry !== 0 && i3 < a.length; i3++) {
        r = (a.words[i3] | 0) + carry;
        this.words[i3] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (;i3 < a.length; i3++) {
          this.words[i3] = a.words[i3];
        }
      }
      return this;
    };
    BN2.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b22;
      if (cmp > 0) {
        a = this;
        b22 = num;
      } else {
        a = num;
        b22 = this;
      }
      var carry = 0;
      for (var i3 = 0;i3 < b22.length; i3++) {
        r = (a.words[i3] | 0) - (b22.words[i3] | 0) + carry;
        carry = r >> 26;
        this.words[i3] = r & 67108863;
      }
      for (;carry !== 0 && i3 < a.length; i3++) {
        r = (a.words[i3] | 0) + carry;
        carry = r >> 26;
        this.words[i3] = r & 67108863;
      }
      if (carry === 0 && i3 < a.length && a !== this) {
        for (;i3 < a.length; i3++) {
          this.words[i3] = a.words[i3];
        }
      }
      this.length = Math.max(this.length, i3);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a = self2.words[0] | 0;
      var b22 = num.words[0] | 0;
      var r = a * b22;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1;k < len2; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i3 = k - j | 0;
          a = self2.words[i3] | 0;
          b22 = num.words[j] | 0;
          r = a * b22 + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo(self2, num, out) {
      var a = self2.words;
      var b22 = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b22[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b22[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b222 = b22[2] | 0;
      var bl2 = b222 & 8191;
      var bh2 = b222 >>> 13;
      var b3 = b22[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b22[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b22[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b22[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b22[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b22[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b22[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0;k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i3 = k - j;
          var a = self2.words[i3] | 0;
          var b22 = num.words[j] | 0;
          var r = a * b22;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x2, y) {
      this.x = x2;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N3) {
      var t = new Array(N3);
      var l = BN2.prototype._countBits(N3) - 1;
      for (var i3 = 0;i3 < N3; i3++) {
        t[i3] = this.revBin(i3, l, N3);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x2, l, N3) {
      if (x2 === 0 || x2 === N3 - 1)
        return x2;
      var rb = 0;
      for (var i3 = 0;i3 < l; i3++) {
        rb |= (x2 & 1) << l - i3 - 1;
        x2 >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
      for (var i3 = 0;i3 < N3; i3++) {
        rtws[i3] = rws[rbt[i3]];
        itws[i3] = iws[rbt[i3]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N3);
      for (var s = 1;s < N3; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0;p < N3; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0;j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
      var N3 = Math.max(m, n2) | 1;
      var odd = N3 & 1;
      var i3 = 0;
      for (N3 = N3 / 2 | 0;N3; N3 = N3 >>> 1) {
        i3++;
      }
      return 1 << i3 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
      if (N3 <= 1)
        return;
      for (var i3 = 0;i3 < N3 / 2; i3++) {
        var t = rws[i3];
        rws[i3] = rws[N3 - i3 - 1];
        rws[N3 - i3 - 1] = t;
        t = iws[i3];
        iws[i3] = -iws[N3 - i3 - 1];
        iws[N3 - i3 - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
      var carry = 0;
      for (var i3 = 0;i3 < N3 / 2; i3++) {
        var w2 = Math.round(ws[2 * i3 + 1] / N3) * 8192 + Math.round(ws[2 * i3] / N3) + carry;
        ws[i3] = w2 & 67108863;
        if (w2 < 67108864) {
          carry = 0;
        } else {
          carry = w2 / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N3) {
      var carry = 0;
      for (var i3 = 0;i3 < len2; i3++) {
        carry = carry + (ws[i3] | 0);
        rws[2 * i3] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i3 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i3 = 2 * len2;i3 < N3; ++i3) {
        rws[i3] = 0;
      }
      assert6(carry === 0);
      assert6((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N3) {
      var ph = new Array(N3);
      for (var i3 = 0;i3 < N3; i3++) {
        ph[i3] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x2, y, out) {
      var N3 = 2 * this.guessLen13b(x2.length, y.length);
      var rbt = this.makeRBT(N3);
      var _ = this.stub(N3);
      var rws = new Array(N3);
      var rwst = new Array(N3);
      var iwst = new Array(N3);
      var nrws = new Array(N3);
      var nrwst = new Array(N3);
      var niwst = new Array(N3);
      var rmws = out.words;
      rmws.length = N3;
      this.convert13b(x2.words, x2.length, rws, N3);
      this.convert13b(y.words, y.length, nrws, N3);
      this.transform(rws, _, rwst, iwst, N3, rbt);
      this.transform(nrws, _, nrwst, niwst, N3, rbt);
      for (var i3 = 0;i3 < N3; i3++) {
        var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
        iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
        rwst[i3] = rx;
      }
      this.conjugate(rwst, iwst, N3);
      this.transform(rwst, iwst, rmws, _, N3, rbt);
      this.conjugate(rmws, _, N3);
      this.normalize13b(rmws, N3);
      out.negative = x2.negative ^ y.negative;
      out.length = x2.length + y.length;
      return out._strip();
    };
    BN2.prototype.mul = function mul(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert6(typeof num === "number");
      assert6(num < 67108864);
      var carry = 0;
      for (var i3 = 0;i3 < this.length; i3++) {
        var w2 = (this.words[i3] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i3] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i3] = carry;
        this.length++;
      }
      this.length = num === 0 ? 1 : this.length;
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i3 = 0;i3 < w2.length; i3++, res = res.sqr()) {
        if (w2[i3] !== 0)
          break;
      }
      if (++i3 < w2.length) {
        for (var q = res.sqr();i3 < w2.length; i3++, q = q.sqr()) {
          if (w2[i3] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert6(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i3;
      if (r !== 0) {
        var carry = 0;
        for (i3 = 0;i3 < this.length; i3++) {
          var newCarry = this.words[i3] & carryMask;
          var c = (this.words[i3] | 0) - newCarry << r;
          this.words[i3] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i3] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i3 = this.length - 1;i3 >= 0; i3--) {
          this.words[i3 + s] = this.words[i3];
        }
        for (i3 = 0;i3 < s; i3++) {
          this.words[i3] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert6(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert6(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask3 = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i3 = 0;i3 < s; i3++) {
          maskedWords.words[i3] = this.words[i3];
        }
        maskedWords.length = s;
      }
      if (s === 0) {} else if (this.length > s) {
        this.length -= s;
        for (i3 = 0;i3 < this.length; i3++) {
          this.words[i3] = this.words[i3 + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i3 = this.length - 1;i3 >= 0 && (carry !== 0 || i3 >= h); i3--) {
        var word = this.words[i3] | 0;
        this.words[i3] = carry << 26 - r | word >>> r;
        carry = word & mask3;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert6(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert6(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w2 = this.words[s];
      return !!(w2 & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert6(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert6(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask3 = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask3;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert6(typeof num === "number");
      assert6(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i3 = 0;i3 < this.length && this.words[i3] >= 67108864; i3++) {
        this.words[i3] -= 67108864;
        if (i3 === this.length - 1) {
          this.words[i3 + 1] = 1;
        } else {
          this.words[i3 + 1]++;
        }
      }
      this.length = Math.max(this.length, i3 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert6(typeof num === "number");
      assert6(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i3 = 0;i3 < this.length && this.words[i3] < 0; i3++) {
          this.words[i3] += 67108864;
          this.words[i3 + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul2, shift) {
      var len2 = num.length + shift;
      var i3;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i3 = 0;i3 < num.length; i3++) {
        w2 = (this.words[i3 + shift] | 0) + carry;
        var right = (num.words[i3] | 0) * mul2;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i3 + shift] = w2 & 67108863;
      }
      for (;i3 < this.length - shift; i3++) {
        w2 = (this.words[i3 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i3 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert6(carry === -1);
      carry = 0;
      for (i3 = 0;i3 < this.length; i3++) {
        w2 = -(this.words[i3] | 0) + carry;
        carry = w2 >> 26;
        this.words[i3] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b22 = num;
      var bhi = b22.words[b22.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b22 = b22.ushln(shift);
        a.iushln(shift);
        bhi = b22.words[b22.length - 1] | 0;
      }
      var m = a.length - b22.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i3 = 0;i3 < q.length; i3++) {
          q.words[i3] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b22, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1;j >= 0; j--) {
        var qj = (a.words[b22.length + j] | 0) * 67108864 + (a.words[b22.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b22, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b22, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive) {
      assert6(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div2, mod22, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div2 = res.div.neg();
        }
        if (mode !== "div") {
          mod22 = res.mod.neg();
          if (positive && mod22.negative !== 0) {
            mod22.iadd(num);
          }
        }
        return {
          div: div2,
          mod: mod22
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div2 = res.div.neg();
        }
        return {
          div: div2,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod22 = res.mod.neg();
          if (positive && mod22.negative !== 0) {
            mod22.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod22
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod22 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod22.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert6(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i3 = this.length - 1;i3 >= 0; i3--) {
        acc = (p * acc + (this.words[i3] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert6(num <= 67108863);
      var carry = 0;
      for (var i3 = this.length - 1;i3 >= 0; i3--) {
        var w2 = (this.words[i3] | 0) + carry * 67108864;
        this.words[i3] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p) {
      assert6(p.negative === 0);
      assert6(!p.isZero());
      var x2 = this;
      var y = p.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p);
      } else {
        x2 = x2.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D2 = new BN2(1);
      var g = 0;
      while (x2.isEven() && y.isEven()) {
        x2.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i3 = 0, im = 1;(x2.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
          ;
        if (i3 > 0) {
          x2.iushrn(i3);
          while (i3-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D2.isOdd()) {
              C.iadd(yp);
              D2.isub(xp);
            }
            C.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y) >= 0) {
          x2.isub(y);
          A.isub(C);
          B.isub(D2);
        } else {
          y.isub(x2);
          C.isub(A);
          D2.isub(B);
        }
      }
      return {
        a: C,
        b: D2,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p) {
      assert6(p.negative === 0);
      assert6(!p.isZero());
      var a = this;
      var b22 = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b22.clone();
      while (a.cmpn(1) > 0 && b22.cmpn(1) > 0) {
        for (var i3 = 0, im = 1;(a.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
          ;
        if (i3 > 0) {
          a.iushrn(i3);
          while (i3-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(b22.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b22.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b22) >= 0) {
          a.isub(b22);
          x1.isub(x2);
        } else {
          b22.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b22 = num.clone();
      a.negative = 0;
      b22.negative = 0;
      for (var shift = 0;a.isEven() && b22.isEven(); shift++) {
        a.iushrn(1);
        b22.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b22.isEven()) {
          b22.iushrn(1);
        }
        var r = a.cmp(b22);
        if (r < 0) {
          var t = a;
          a = b22;
          b22 = t;
        } else if (r === 0 || b22.cmpn(1) === 0) {
          break;
        }
        a.isub(b22);
      } while (true);
      return b22.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert6(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i3 = s;carry !== 0 && i3 < this.length; i3++) {
        var w2 = this.words[i3] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i3] = w2;
      }
      if (carry !== 0) {
        this.words[i3] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert6(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i3 = this.length - 1;i3 >= 0; i3--) {
        var a = this.words[i3] | 0;
        var b22 = num.words[i3] | 0;
        if (a === b22)
          continue;
        if (a < b22) {
          res = -1;
        } else if (a > b22) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert6(!this.red, "Already a number in reduction context");
      assert6(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert6(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert6(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert6(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert6(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert6(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert6(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert6(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert6(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert6(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert6(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert6(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert6(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert6(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert6(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert6(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN2(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output2) {
      var mask3 = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i3 = 0;i3 < outLen; i3++) {
        output2.words[i3] = input.words[i3];
      }
      output2.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output2.words[output2.length++] = prev & mask3;
      for (i3 = 10;i3 < input.length; i3++) {
        var next = input.words[i3] | 0;
        input.words[i3 - 10] = (next & mask3) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i3 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i3 = 0;i3 < num.length; i3++) {
        var w2 = num.words[i3] | 0;
        lo += w2 * 977;
        num.words[i3] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i3 = 0;i3 < num.length; i3++) {
        var hi = (num.words[i3] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i3] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === "k256") {
        prime = new K256;
      } else if (name === "p224") {
        prime = new P224;
      } else if (name === "p192") {
        prime = new P192;
      } else if (name === "p25519") {
        prime = new P25519;
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN2._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert6(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert6(a.negative === 0, "red works only with positives");
      assert6(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b22) {
      assert6((a.negative | b22.negative) === 0, "red works only with positives");
      assert6(a.red && a.red === b22.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b22) {
      this._verify2(a, b22);
      var res = a.add(b22);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b22) {
      this._verify2(a, b22);
      var res = a.iadd(b22);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b22) {
      this._verify2(a, b22);
      var res = a.sub(b22);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b22) {
      this._verify2(a, b22);
      var res = a.isub(b22);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b22) {
      this._verify2(a, b22);
      return this.imod(a.imul(b22));
    };
    Red.prototype.mul = function mul(a, b22) {
      this._verify2(a, b22);
      return this.imod(a.mul(b22));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod32 = this.m.andln(3);
      assert6(mod32 % 2 === 1);
      if (mod32 === 3) {
        var pow3 = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a, pow3);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert6(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i3 = 0;tmp.cmp(one) !== 0; i3++) {
          tmp = tmp.redSqr();
        }
        assert6(i3 < m);
        var b22 = this.pow(c, new BN2(1).iushln(m - i3 - 1));
        r = r.redMul(b22);
        c = b22.redSqr();
        t = t.redMul(c);
        m = i3;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a;
      for (var i3 = 2;i3 < wnd.length; i3++) {
        wnd[i3] = this.mul(wnd[i3 - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i3 = num.length - 1;i3 >= 0; i3--) {
        var word = num.words[i3];
        for (var j = start - 1;j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i3 !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b22) {
      if (a.isZero() || b22.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b22);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b22) {
      if (a.isZero() || b22.isZero())
        return new BN2(0)._forceRed(this);
      var t = a.mul(b22);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === "undefined" || module, exports);
});
var require_safe_buffer2 = __commonJS2((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = (init_buffer2(), __toCommonJS2(exports_buffer2));
  var Buffer22 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer22.from && Buffer22.alloc && Buffer22.allocUnsafe && Buffer22.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer22(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer22.prototype);
  copyProps(Buffer22, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer22(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer22(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer22(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});
var require_src3 = __commonJS2((exports, module) => {
  var _Buffer = require_safe_buffer2().Buffer;
  function base2(ALPHABET2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i3 = 0;i3 < ALPHABET2.length; i3++) {
      var x2 = ALPHABET2.charAt(i3);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i3;
    }
    var BASE2 = ALPHABET2.length;
    var LEADER = ALPHABET2.charAt(0);
    var FACTOR = Math.log(BASE2) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE2);
    function encode2(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i22 = 0;
        for (var it1 = size - 1;(carry !== 0 || i22 < length) && it1 !== -1; it1--, i22++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE2 >>> 0;
          carry = carry / BASE2 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i22;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET2.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (psz < source.length) {
        var charCode = source.charCodeAt(psz);
        if (charCode > 255) {
          return;
        }
        var carry = BASE_MAP[charCode];
        if (carry === 255) {
          return;
        }
        var i22 = 0;
        for (var it3 = size - 1;(carry !== 0 || i22 < length) && it3 !== -1; it3--, i22++) {
          carry += BASE2 * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i22;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE2 + " character");
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode3
    };
  }
  module.exports = base2;
});
var require_bs583 = __commonJS2((exports, module) => {
  var basex = require_src3();
  var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET2);
});
var require_src22 = __commonJS2((exports, module) => {
  var _Buffer = require_safe_buffer2().Buffer;
  function base2(ALPHABET2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0;j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i3 = 0;i3 < ALPHABET2.length; i3++) {
      var x2 = ALPHABET2.charAt(i3);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i3;
    }
    var BASE2 = ALPHABET2.length;
    var LEADER = ALPHABET2.charAt(0);
    var FACTOR = Math.log(BASE2) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE2);
    function encode2(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i22 = 0;
        for (var it1 = size - 1;(carry !== 0 || i22 < length) && it1 !== -1; it1--, i22++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE2 >>> 0;
          carry = carry / BASE2 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i22;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (;it2 < size; ++it2) {
        str += ALPHABET2.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (psz < source.length) {
        var charCode = source.charCodeAt(psz);
        if (charCode > 255) {
          return;
        }
        var carry = BASE_MAP[charCode];
        if (carry === 255) {
          return;
        }
        var i22 = 0;
        for (var it3 = size - 1;(carry !== 0 || i22 < length) && it3 !== -1; it3--, i22++) {
          carry += BASE2 * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i22;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode3(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE2 + " character");
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode3
    };
  }
  module.exports = base2;
});
var require_bs5822 = __commonJS2((exports, module) => {
  var basex = require_src22();
  var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  module.exports = basex(ALPHABET2);
});
var exports_encoding2 = {};
__export2(exports_encoding2, {
  TextEncoder: () => TextEncoder22,
  TextDecoder: () => TextDecoder22
});
function inRange22(a, min2, max2) {
  return min2 <= a && a <= max2;
}
function ToDictionary2(o) {
  if (o === undefined)
    return {};
  if (o === Object(o))
    return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints2(string2) {
  var s = String(string2);
  var n2 = s.length;
  var i3 = 0;
  var u = [];
  while (i3 < n2) {
    var c = s.charCodeAt(i3);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i3 === n2 - 1) {
        u.push(65533);
      } else {
        var d = string2.charCodeAt(i3 + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b22 = d & 1023;
          u.push(65536 + (a << 10) + b22);
          i3 += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i3 += 1;
  }
  return u;
}
function codePointsToString2(code_points) {
  var s = "";
  for (var i3 = 0;i3 < code_points.length; ++i3) {
    var cp = code_points[i3];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
    }
  }
  return s;
}
function Stream2(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError2(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function Decoder2() {}
function Encoder2() {}
function TextDecoder22(encoding, options) {
  if (!(this instanceof TextDecoder22)) {
    return new TextDecoder22(encoding, options);
  }
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING2;
  if (encoding !== DEFAULT_ENCODING2) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary2(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder22(encoding, options) {
  if (!(this instanceof TextEncoder22))
    return new TextEncoder22(encoding, options);
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING2;
  if (encoding !== DEFAULT_ENCODING2) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary2(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder2(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream2 && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError2(fatal);
    }
    if (bite === end_of_stream2)
      return finished2;
    if (utf8_bytes_needed === 0) {
      if (inRange22(bite, 0, 127)) {
        return bite;
      }
      if (inRange22(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange22(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange22(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError2(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange22(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError2(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder2(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream2)
      return finished2;
    if (inRange22(code_point, 0, 127))
      return code_point;
    var count, offset2;
    if (inRange22(code_point, 128, 2047)) {
      count = 1;
      offset2 = 192;
    } else if (inRange22(code_point, 2048, 65535)) {
      count = 2;
      offset2 = 224;
    } else if (inRange22(code_point, 65536, 1114111)) {
      count = 3;
      offset2 = 240;
    }
    var bytes2 = [(code_point >> 6 * count) + offset2];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes2.push(128 | temp & 63);
      count -= 1;
    }
    return bytes2;
  };
}
var end_of_stream2 = -1;
var finished2 = -1;
var DEFAULT_ENCODING2 = "utf-8";
var init_encoding2 = __esm2(() => {
  Stream2.prototype = {
    endOfStream: function() {
      return !this.tokens.length;
    },
    read: function() {
      if (!this.tokens.length)
        return end_of_stream2;
      return this.tokens.shift();
    },
    prepend: function(token) {
      if (Array.isArray(token)) {
        var tokens = token;
        while (tokens.length)
          this.tokens.unshift(tokens.pop());
      } else {
        this.tokens.unshift(token);
      }
    },
    push: function(token) {
      if (Array.isArray(token)) {
        var tokens = token;
        while (tokens.length)
          this.tokens.push(tokens.shift());
      } else {
        this.tokens.push(token);
      }
    }
  };
  Decoder2.prototype = {
    handler: function(stream, bite) {}
  };
  Encoder2.prototype = {
    handler: function(stream, code_point) {}
  };
  TextDecoder22.prototype = {
    decode: function decode(input, options) {
      var bytes2;
      if (typeof input === "object" && input instanceof ArrayBuffer) {
        bytes2 = new Uint8Array(input);
      } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
        bytes2 = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
      } else {
        bytes2 = new Uint8Array(0);
      }
      options = ToDictionary2(options);
      if (!this._streaming) {
        this._decoder = new UTF8Decoder2({ fatal: this._fatal });
        this._BOMseen = false;
      }
      this._streaming = Boolean(options["stream"]);
      var input_stream = new Stream2(bytes2);
      var code_points = [];
      var result;
      while (!input_stream.endOfStream()) {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished2)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(code_points, result);
        else
          code_points.push(result);
      }
      if (!this._streaming) {
        do {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished2)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(code_points, result);
          else
            code_points.push(result);
        } while (!input_stream.endOfStream());
        this._decoder = null;
      }
      if (code_points.length) {
        if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
          if (code_points[0] === 65279) {
            this._BOMseen = true;
            code_points.shift();
          } else {
            this._BOMseen = true;
          }
        }
      }
      return codePointsToString2(code_points);
    }
  };
  TextEncoder22.prototype = {
    encode: function encode(opt_string, options) {
      opt_string = opt_string ? String(opt_string) : "";
      options = ToDictionary2(options);
      if (!this._streaming)
        this._encoder = new UTF8Encoder2(this._options);
      this._streaming = Boolean(options["stream"]);
      var bytes2 = [];
      var input_stream = new Stream2(stringToCodePoints2(opt_string));
      var result;
      while (!input_stream.endOfStream()) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished2)
          break;
        if (Array.isArray(result))
          bytes2.push.apply(bytes2, result);
        else
          bytes2.push(result);
      }
      if (!this._streaming) {
        while (true) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished2)
            break;
          if (Array.isArray(result))
            bytes2.push.apply(bytes2, result);
          else
            bytes2.push(result);
        }
        this._encoder = null;
      }
      return new Uint8Array(bytes2);
    }
  };
});
var require_lib2 = __commonJS2((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i3 = decorators.length - 1;i3 >= 0; i3--)
        if (d = decorators[i3])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __importStar = exports && exports.__importStar || function(mod22) {
    if (mod22 && mod22.__esModule)
      return mod22;
    var result = {};
    if (mod22 != null) {
      for (var k in mod22)
        if (k !== "default" && Object.hasOwnProperty.call(mod22, k))
          __createBinding(result, mod22, k);
    }
    __setModuleDefault(result, mod22);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod22) {
    return mod22 && mod22.__esModule ? mod22 : { default: mod22 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = undefined;
  var bn_js_1 = __importDefault(require_bn2());
  var bs58_1 = __importDefault(require_bs5822());
  var encoding = __importStar((init_encoding2(), __toCommonJS2(exports_encoding2)));
  var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
  var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
  function baseEncode(value) {
    if (typeof value === "string") {
      value = Buffer.from(value, "utf8");
    }
    return bs58_1.default.encode(Buffer.from(value));
  }
  exports.baseEncode = baseEncode;
  function baseDecode(value) {
    return Buffer.from(bs58_1.default.decode(value));
  }
  exports.baseDecode = baseDecode;
  var INITIAL_LENGTH = 1024;

  class BorshError extends Error {
    constructor(message) {
      super(message);
      this.fieldPath = [];
      this.originalMessage = message;
    }
    addToFieldPath(fieldName) {
      this.fieldPath.splice(0, 0, fieldName);
      this.message = this.originalMessage + ": " + this.fieldPath.join(".");
    }
  }
  exports.BorshError = BorshError;

  class BinaryWriter2 {
    constructor() {
      this.buf = Buffer.alloc(INITIAL_LENGTH);
      this.length = 0;
    }
    maybeResize() {
      if (this.buf.length < 16 + this.length) {
        this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
      }
    }
    writeU8(value) {
      this.maybeResize();
      this.buf.writeUInt8(value, this.length);
      this.length += 1;
    }
    writeU16(value) {
      this.maybeResize();
      this.buf.writeUInt16LE(value, this.length);
      this.length += 2;
    }
    writeU32(value) {
      this.maybeResize();
      this.buf.writeUInt32LE(value, this.length);
      this.length += 4;
    }
    writeU64(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
    }
    writeU128(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
    }
    writeU256(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
    }
    writeU512(value) {
      this.maybeResize();
      this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
    }
    writeBuffer(buffer) {
      this.buf = Buffer.concat([
        Buffer.from(this.buf.subarray(0, this.length)),
        buffer,
        Buffer.alloc(INITIAL_LENGTH)
      ]);
      this.length += buffer.length;
    }
    writeString(str) {
      this.maybeResize();
      const b22 = Buffer.from(str, "utf8");
      this.writeU32(b22.length);
      this.writeBuffer(b22);
    }
    writeFixedArray(array2) {
      this.writeBuffer(Buffer.from(array2));
    }
    writeArray(array2, fn) {
      this.maybeResize();
      this.writeU32(array2.length);
      for (const elem of array2) {
        this.maybeResize();
        fn(elem);
      }
    }
    toArray() {
      return this.buf.subarray(0, this.length);
    }
  }
  exports.BinaryWriter = BinaryWriter2;
  function handlingRangeError(target, propertyKey, propertyDescriptor) {
    const originalMethod = propertyDescriptor.value;
    propertyDescriptor.value = function(...args) {
      try {
        return originalMethod.apply(this, args);
      } catch (e) {
        if (e instanceof RangeError) {
          const code2 = e.code;
          if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code2) >= 0) {
            throw new BorshError("Reached the end of buffer when deserializing");
          }
        }
        throw e;
      }
    };
  }

  class BinaryReader2 {
    constructor(buf) {
      this.buf = buf;
      this.offset = 0;
    }
    readU8() {
      const value = this.buf.readUInt8(this.offset);
      this.offset += 1;
      return value;
    }
    readU16() {
      const value = this.buf.readUInt16LE(this.offset);
      this.offset += 2;
      return value;
    }
    readU32() {
      const value = this.buf.readUInt32LE(this.offset);
      this.offset += 4;
      return value;
    }
    readU64() {
      const buf = this.readBuffer(8);
      return new bn_js_1.default(buf, "le");
    }
    readU128() {
      const buf = this.readBuffer(16);
      return new bn_js_1.default(buf, "le");
    }
    readU256() {
      const buf = this.readBuffer(32);
      return new bn_js_1.default(buf, "le");
    }
    readU512() {
      const buf = this.readBuffer(64);
      return new bn_js_1.default(buf, "le");
    }
    readBuffer(len2) {
      if (this.offset + len2 > this.buf.length) {
        throw new BorshError(`Expected buffer length ${len2} isn't within bounds`);
      }
      const result = this.buf.slice(this.offset, this.offset + len2);
      this.offset += len2;
      return result;
    }
    readString() {
      const len2 = this.readU32();
      const buf = this.readBuffer(len2);
      try {
        return textDecoder.decode(buf);
      } catch (e) {
        throw new BorshError(`Error decoding UTF-8 string: ${e}`);
      }
    }
    readFixedArray(len2) {
      return new Uint8Array(this.readBuffer(len2));
    }
    readArray(fn) {
      const len2 = this.readU32();
      const result = Array();
      for (let i3 = 0;i3 < len2; ++i3) {
        result.push(fn());
      }
      return result;
    }
  }
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU8", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU16", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU32", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU64", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU128", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU256", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readU512", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readString", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readFixedArray", null);
  __decorate([
    handlingRangeError
  ], BinaryReader2.prototype, "readArray", null);
  exports.BinaryReader = BinaryReader2;
  function capitalizeFirstLetter(string2) {
    return string2.charAt(0).toUpperCase() + string2.slice(1);
  }
  function serializeField(schema, fieldName, value, fieldType, writer) {
    try {
      if (typeof fieldType === "string") {
        writer[`write${capitalizeFirstLetter(fieldType)}`](value);
      } else if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          if (value.length !== fieldType[0]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
          }
          writer.writeFixedArray(value);
        } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
          if (value.length !== fieldType[1]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
          }
          for (let i3 = 0;i3 < fieldType[1]; i3++) {
            serializeField(schema, null, value[i3], fieldType[0], writer);
          }
        } else {
          writer.writeArray(value, (item) => {
            serializeField(schema, fieldName, item, fieldType[0], writer);
          });
        }
      } else if (fieldType.kind !== undefined) {
        switch (fieldType.kind) {
          case "option": {
            if (value === null || value === undefined) {
              writer.writeU8(0);
            } else {
              writer.writeU8(1);
              serializeField(schema, fieldName, value, fieldType.type, writer);
            }
            break;
          }
          case "map": {
            writer.writeU32(value.size);
            value.forEach((val, key) => {
              serializeField(schema, fieldName, key, fieldType.key, writer);
              serializeField(schema, fieldName, val, fieldType.value, writer);
            });
            break;
          }
          default:
            throw new BorshError(`FieldType ${fieldType} unrecognized`);
        }
      } else {
        serializeStruct(schema, value, writer);
      }
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  }
  function serializeStruct(schema, obj, writer) {
    if (typeof obj.borshSerialize === "function") {
      obj.borshSerialize(writer);
      return;
    }
    const structSchema = schema.get(obj.constructor);
    if (!structSchema) {
      throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      structSchema.fields.map(([fieldName, fieldType]) => {
        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
      });
    } else if (structSchema.kind === "enum") {
      const name = obj[structSchema.field];
      for (let idx = 0;idx < structSchema.values.length; ++idx) {
        const [fieldName, fieldType] = structSchema.values[idx];
        if (fieldName === name) {
          writer.writeU8(idx);
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          break;
        }
      }
    } else {
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
    }
  }
  function serialize2(schema, obj, Writer2 = BinaryWriter2) {
    const writer = new Writer2;
    serializeStruct(schema, obj, writer);
    return writer.toArray();
  }
  exports.serialize = serialize2;
  function deserializeField(schema, fieldName, fieldType, reader) {
    try {
      if (typeof fieldType === "string") {
        return reader[`read${capitalizeFirstLetter(fieldType)}`]();
      }
      if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          return reader.readFixedArray(fieldType[0]);
        } else if (typeof fieldType[1] === "number") {
          const arr = [];
          for (let i3 = 0;i3 < fieldType[1]; i3++) {
            arr.push(deserializeField(schema, null, fieldType[0], reader));
          }
          return arr;
        } else {
          return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
        }
      }
      if (fieldType.kind === "option") {
        const option = reader.readU8();
        if (option) {
          return deserializeField(schema, fieldName, fieldType.type, reader);
        }
        return;
      }
      if (fieldType.kind === "map") {
        let map = new Map;
        const length = reader.readU32();
        for (let i3 = 0;i3 < length; i3++) {
          const key = deserializeField(schema, fieldName, fieldType.key, reader);
          const val = deserializeField(schema, fieldName, fieldType.value, reader);
          map.set(key, val);
        }
        return map;
      }
      return deserializeStruct(schema, fieldType, reader);
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  }
  function deserializeStruct(schema, classType, reader) {
    if (typeof classType.borshDeserialize === "function") {
      return classType.borshDeserialize(reader);
    }
    const structSchema = schema.get(classType);
    if (!structSchema) {
      throw new BorshError(`Class ${classType.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      const result = {};
      for (const [fieldName, fieldType] of schema.get(classType).fields) {
        result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
      }
      return new classType(result);
    }
    if (structSchema.kind === "enum") {
      const idx = reader.readU8();
      if (idx >= structSchema.values.length) {
        throw new BorshError(`Enum index: ${idx} is out of range`);
      }
      const [fieldName, fieldType] = structSchema.values[idx];
      const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
      return new classType({ [fieldName]: fieldValue });
    }
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
  }
  function deserialize2(schema, classType, buffer, Reader2 = BinaryReader2) {
    const reader = new Reader2(buffer);
    const result = deserializeStruct(schema, classType, reader);
    if (reader.offset < buffer.length) {
      throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
    }
    return result;
  }
  exports.deserialize = deserialize2;
  function deserializeUnchecked2(schema, classType, buffer, Reader2 = BinaryReader2) {
    const reader = new Reader2(buffer);
    return deserializeStruct(schema, classType, reader);
  }
  exports.deserializeUnchecked = deserializeUnchecked2;
});
var require_Layout2 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = undefined;
  exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = undefined;
  var buffer_1 = (init_buffer2(), __toCommonJS2(exports_buffer2));
  function checkUint8Array(b22) {
    if (!(b22 instanceof Uint8Array)) {
      throw new TypeError("b must be a Uint8Array");
    }
  }
  exports.checkUint8Array = checkUint8Array;
  function uint8ArrayToBuffer(b22) {
    checkUint8Array(b22);
    return buffer_1.Buffer.from(b22.buffer, b22.byteOffset, b22.length);
  }
  exports.uint8ArrayToBuffer = uint8ArrayToBuffer;

  class Layout {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    makeDestinationObject() {
      return {};
    }
    getSpan(b22, offset2) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    fromArray(values) {
      return;
    }
  }
  exports.Layout = Layout;
  function nameWithProperty(name, lo) {
    if (lo.property) {
      return name + "[" + lo.property + "]";
    }
    return name;
  }
  exports.nameWithProperty = nameWithProperty;
  function bindConstructorLayout(Class, layout) {
    if (typeof Class !== "function") {
      throw new TypeError("Class must be constructor");
    }
    if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
      throw new Error("Class is already bound to a layout");
    }
    if (!(layout && layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
      throw new Error("layout is already bound to a constructor");
    }
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = () => new Class;
    Object.defineProperty(Class.prototype, "encode", {
      value(b22, offset2) {
        return layout.encode(this, b22, offset2);
      },
      writable: true
    });
    Object.defineProperty(Class, "decode", {
      value(b22, offset2) {
        return layout.decode(b22, offset2);
      },
      writable: true
    });
  }
  exports.bindConstructorLayout = bindConstructorLayout;

  class ExternalLayout extends Layout {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  exports.ExternalLayout = ExternalLayout;

  class GreedyCount extends ExternalLayout {
    constructor(elementSpan = 1, property) {
      if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
        throw new TypeError("elementSpan must be a (positive) integer");
      }
      super(-1, property);
      this.elementSpan = elementSpan;
    }
    isCount() {
      return true;
    }
    decode(b22, offset2 = 0) {
      checkUint8Array(b22);
      const rem = b22.length - offset2;
      return Math.floor(rem / this.elementSpan);
    }
    encode(src, b22, offset2) {
      return 0;
    }
  }
  exports.GreedyCount = GreedyCount;

  class OffsetLayout extends ExternalLayout {
    constructor(layout, offset2 = 0, property) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (!Number.isInteger(offset2)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset2;
    }
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    decode(b22, offset2 = 0) {
      return this.layout.decode(b22, offset2 + this.offset);
    }
    encode(src, b22, offset2 = 0) {
      return this.layout.encode(src, b22, offset2 + this.offset);
    }
  }
  exports.OffsetLayout = OffsetLayout;

  class UInt extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b22, offset2 = 0) {
      return uint8ArrayToBuffer(b22).readUIntLE(offset2, this.span);
    }
    encode(src, b22, offset2 = 0) {
      uint8ArrayToBuffer(b22).writeUIntLE(src, offset2, this.span);
      return this.span;
    }
  }
  exports.UInt = UInt;

  class UIntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b22, offset2 = 0) {
      return uint8ArrayToBuffer(b22).readUIntBE(offset2, this.span);
    }
    encode(src, b22, offset2 = 0) {
      uint8ArrayToBuffer(b22).writeUIntBE(src, offset2, this.span);
      return this.span;
    }
  }
  exports.UIntBE = UIntBE;

  class Int extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b22, offset2 = 0) {
      return uint8ArrayToBuffer(b22).readIntLE(offset2, this.span);
    }
    encode(src, b22, offset2 = 0) {
      uint8ArrayToBuffer(b22).writeIntLE(src, offset2, this.span);
      return this.span;
    }
  }
  exports.Int = Int;

  class IntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b22, offset2 = 0) {
      return uint8ArrayToBuffer(b22).readIntBE(offset2, this.span);
    }
    encode(src, b22, offset2 = 0) {
      uint8ArrayToBuffer(b22).writeIntBE(src, offset2, this.span);
      return this.span;
    }
  }
  exports.IntBE = IntBE;
  var V2E32 = Math.pow(2, 32);
  function divmodInt64(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return { hi32, lo32 };
  }
  function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  }

  class NearUInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2 = 0) {
      const buffer = uint8ArrayToBuffer(b22);
      const lo32 = buffer.readUInt32LE(offset2);
      const hi32 = buffer.readUInt32LE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b22, offset2 = 0) {
      const split22 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b22);
      buffer.writeUInt32LE(split22.lo32, offset2);
      buffer.writeUInt32LE(split22.hi32, offset2 + 4);
      return 8;
    }
  }
  exports.NearUInt64 = NearUInt64;

  class NearUInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2 = 0) {
      const buffer = uint8ArrayToBuffer(b22);
      const hi32 = buffer.readUInt32BE(offset2);
      const lo32 = buffer.readUInt32BE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b22, offset2 = 0) {
      const split22 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b22);
      buffer.writeUInt32BE(split22.hi32, offset2);
      buffer.writeUInt32BE(split22.lo32, offset2 + 4);
      return 8;
    }
  }
  exports.NearUInt64BE = NearUInt64BE;

  class NearInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2 = 0) {
      const buffer = uint8ArrayToBuffer(b22);
      const lo32 = buffer.readUInt32LE(offset2);
      const hi32 = buffer.readInt32LE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b22, offset2 = 0) {
      const split22 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b22);
      buffer.writeUInt32LE(split22.lo32, offset2);
      buffer.writeInt32LE(split22.hi32, offset2 + 4);
      return 8;
    }
  }
  exports.NearInt64 = NearInt64;

  class NearInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2 = 0) {
      const buffer = uint8ArrayToBuffer(b22);
      const hi32 = buffer.readInt32BE(offset2);
      const lo32 = buffer.readUInt32BE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b22, offset2 = 0) {
      const split22 = divmodInt64(src);
      const buffer = uint8ArrayToBuffer(b22);
      buffer.writeInt32BE(split22.hi32, offset2);
      buffer.writeUInt32BE(split22.lo32, offset2 + 4);
      return 8;
    }
  }
  exports.NearInt64BE = NearInt64BE;

  class Float extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b22, offset2 = 0) {
      return uint8ArrayToBuffer(b22).readFloatLE(offset2);
    }
    encode(src, b22, offset2 = 0) {
      uint8ArrayToBuffer(b22).writeFloatLE(src, offset2);
      return 4;
    }
  }
  exports.Float = Float;

  class FloatBE extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b22, offset2 = 0) {
      return uint8ArrayToBuffer(b22).readFloatBE(offset2);
    }
    encode(src, b22, offset2 = 0) {
      uint8ArrayToBuffer(b22).writeFloatBE(src, offset2);
      return 4;
    }
  }
  exports.FloatBE = FloatBE;

  class Double extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2 = 0) {
      return uint8ArrayToBuffer(b22).readDoubleLE(offset2);
    }
    encode(src, b22, offset2 = 0) {
      uint8ArrayToBuffer(b22).writeDoubleLE(src, offset2);
      return 8;
    }
  }
  exports.Double = Double;

  class DoubleBE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2 = 0) {
      return uint8ArrayToBuffer(b22).readDoubleBE(offset2);
    }
    encode(src, b22, offset2 = 0) {
      uint8ArrayToBuffer(b22).writeDoubleBE(src, offset2);
      return 8;
    }
  }
  exports.DoubleBE = DoubleBE;

  class Sequence extends Layout {
    constructor(elementLayout, count, property) {
      if (!(elementLayout instanceof Layout)) {
        throw new TypeError("elementLayout must be a Layout");
      }
      if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
        throw new TypeError("count must be non-negative integer " + "or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
        span = count * elementLayout.span;
      }
      super(span, property);
      this.elementLayout = elementLayout;
      this.count = count;
    }
    getSpan(b22, offset2 = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b22, offset2);
      }
      if (0 < this.elementLayout.span) {
        span = count * this.elementLayout.span;
      } else {
        let idx = 0;
        while (idx < count) {
          span += this.elementLayout.getSpan(b22, offset2 + span);
          ++idx;
        }
      }
      return span;
    }
    decode(b22, offset2 = 0) {
      const rv = [];
      let i3 = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b22, offset2);
      }
      while (i3 < count) {
        rv.push(this.elementLayout.decode(b22, offset2));
        offset2 += this.elementLayout.getSpan(b22, offset2);
        i3 += 1;
      }
      return rv;
    }
    encode(src, b22, offset2 = 0) {
      const elo = this.elementLayout;
      const span = src.reduce((span2, v) => {
        return span2 + elo.encode(v, b22, offset2 + span2);
      }, 0);
      if (this.count instanceof ExternalLayout) {
        this.count.encode(src.length, b22, offset2);
      }
      return span;
    }
  }
  exports.Sequence = Sequence;

  class Structure extends Layout {
    constructor(fields2, property, decodePrefixes) {
      if (!(Array.isArray(fields2) && fields2.reduce((acc, v) => acc && v instanceof Layout, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if (typeof property === "boolean" && decodePrefixes === undefined) {
        decodePrefixes = property;
        property = undefined;
      }
      for (const fd of fields2) {
        if (0 > fd.span && fd.property === undefined) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields2.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e) {}
      super(span, property);
      this.fields = fields2;
      this.decodePrefixes = !!decodePrefixes;
    }
    getSpan(b22, offset2 = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b22, offset2);
          offset2 += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    decode(b22, offset2 = 0) {
      checkUint8Array(b22);
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b22, offset2);
        }
        offset2 += fd.getSpan(b22, offset2);
        if (this.decodePrefixes && b22.length === offset2) {
          break;
        }
      }
      return dest;
    }
    encode(src, b22, offset2 = 0) {
      const firstOffset = offset2;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            lastWrote = fd.encode(fv, b22, offset2);
            if (0 > span) {
              span = fd.getSpan(b22, offset2);
            }
          }
        }
        lastOffset = offset2;
        offset2 += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    layoutFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return;
    }
    offsetOf(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      let offset2 = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset2;
        }
        if (0 > fd.span) {
          offset2 = -1;
        } else if (0 <= offset2) {
          offset2 += fd.span;
        }
      }
      return;
    }
  }
  exports.Structure = Structure;

  class UnionDiscriminator {
    constructor(property) {
      this.property = property;
    }
    decode(b22, offset2) {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode(src, b22, offset2) {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  exports.UnionDiscriminator = UnionDiscriminator;

  class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    decode(b22, offset2) {
      return this.layout.decode(b22, offset2);
    }
    encode(src, b22, offset2) {
      return this.layout.encode(src, b22, offset2);
    }
  }
  exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;

  class Union extends Layout {
    constructor(discr, defaultLayout, property) {
      let discriminator;
      if (discr instanceof UInt || discr instanceof UIntBE) {
        discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discriminator = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator " + "or an unsigned integer layout");
      } else {
        discriminator = discr;
      }
      if (defaultLayout === undefined) {
        defaultLayout = null;
      }
      if (!(defaultLayout === null || defaultLayout instanceof Layout)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (defaultLayout !== null) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (defaultLayout.property === undefined) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
          span += discriminator.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discriminator;
      this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src) {
        return boundGetSourceVariant(src);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    getSpan(b22, offset2 = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      const vlo = this.getVariant(b22, offset2);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b22, offset2);
    }
    defaultGetSourceVariant(src) {
      if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
          return;
        }
        const vlo = this.registry[src[this.discriminator.property]];
        if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag2 in this.registry) {
          const vlo = this.registry[tag2];
          if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    decode(b22, offset2 = 0) {
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b22, offset2);
      const clo = this.registry[discr];
      if (clo === undefined) {
        const defaultLayout = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[defaultLayout.property] = defaultLayout.decode(b22, offset2 + contentOffset);
      } else {
        dest = clo.decode(b22, offset2);
      }
      return dest;
    }
    encode(src, b22, offset2 = 0) {
      const vlo = this.getSourceVariant(src);
      if (vlo === undefined) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src[dlo.property], b22, offset2);
        return contentOffset + clo.encode(src[clo.property], b22, offset2 + contentOffset);
      }
      return vlo.encode(src, b22, offset2);
    }
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    getVariant(vb, offset2 = 0) {
      let variant;
      if (vb instanceof Uint8Array) {
        variant = this.discriminator.decode(vb, offset2);
      } else {
        variant = vb;
      }
      return this.registry[variant];
    }
  }
  exports.Union = Union;

  class VariantLayout extends Layout {
    constructor(union2, variant, layout, property) {
      if (!(union2 instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if (typeof layout === "string" && property === undefined) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (union2.defaultLayout !== null && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if (typeof property !== "string") {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union2.span;
      if (0 > union2.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union2.usesPrefixDiscriminator) {
          span += union2.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union2;
      this.variant = variant;
      this.layout = layout || null;
    }
    getSpan(b22, offset2 = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      let span = 0;
      if (this.layout) {
        span = this.layout.getSpan(b22, offset2 + contentOffset);
      }
      return contentOffset + span;
    }
    decode(b22, offset2 = 0) {
      const dest = this.makeDestinationObject();
      if (this !== this.union.getVariant(b22, offset2)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b22, offset2 + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    encode(src, b22, offset2 = 0) {
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b22, offset2);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src[this.property], b22, offset2 + contentOffset);
        span += this.layout.getSpan(b22, offset2 + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
      return;
    }
  }
  exports.VariantLayout = VariantLayout;
  function fixBitwiseResult(v) {
    if (0 > v) {
      v += 4294967296;
    }
    return v;
  }

  class BitStructure extends Layout {
    constructor(word, msb, property) {
      if (!(word instanceof UInt || word instanceof UIntBE)) {
        throw new TypeError("word must be a UInt or UIntBE layout");
      }
      if (typeof msb === "string" && property === undefined) {
        property = msb;
        msb = false;
      }
      if (4 < word.span) {
        throw new RangeError("word cannot exceed 32 bits");
      }
      super(word.span, property);
      this.word = word;
      this.msb = !!msb;
      this.fields = [];
      let value = 0;
      this._packedSetValue = function(v) {
        value = fixBitwiseResult(v);
        return this;
      };
      this._packedGetValue = function() {
        return value;
      };
    }
    decode(b22, offset2 = 0) {
      const dest = this.makeDestinationObject();
      const value = this.word.decode(b22, offset2);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b22);
        }
      }
      return dest;
    }
    encode(src, b22, offset2 = 0) {
      const value = this.word.decode(b22, offset2);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            fd.encode(fv);
          }
        }
      }
      return this.word.encode(this._packedGetValue(), b22, offset2);
    }
    addField(bits, property) {
      const bf = new BitField(this, bits, property);
      this.fields.push(bf);
      return bf;
    }
    addBoolean(property) {
      const bf = new Boolean2(this, property);
      this.fields.push(bf);
      return bf;
    }
    fieldFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return;
    }
  }
  exports.BitStructure = BitStructure;

  class BitField {
    constructor(container, bits, property) {
      if (!(container instanceof BitStructure)) {
        throw new TypeError("container must be a BitStructure");
      }
      if (!Number.isInteger(bits) || 0 >= bits) {
        throw new TypeError("bits must be positive integer");
      }
      const totalBits = 8 * container.span;
      const usedBits = container.fields.reduce((sum2, fd) => sum2 + fd.bits, 0);
      if (bits + usedBits > totalBits) {
        throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
      }
      this.container = container;
      this.bits = bits;
      this.valueMask = (1 << bits) - 1;
      if (bits === 32) {
        this.valueMask = 4294967295;
      }
      this.start = usedBits;
      if (this.container.msb) {
        this.start = totalBits - usedBits - bits;
      }
      this.wordMask = fixBitwiseResult(this.valueMask << this.start);
      this.property = property;
    }
    decode(b22, offset2) {
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(word & this.wordMask);
      const value = wordValue >>> this.start;
      return value;
    }
    encode(value) {
      if (typeof value !== "number" || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
        throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
      }
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(value << this.start);
      this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
    }
  }
  exports.BitField = BitField;

  class Boolean2 extends BitField {
    constructor(container, property) {
      super(container, 1, property);
    }
    decode(b22, offset2) {
      return !!super.decode(b22, offset2);
    }
    encode(value) {
      if (typeof value === "boolean") {
        value = +value;
      }
      super.encode(value);
    }
  }
  exports.Boolean = Boolean2;

  class Blob22 extends Layout {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer " + "or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    getSpan(b22, offset2) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b22, offset2);
      }
      return span;
    }
    decode(b22, offset2 = 0) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b22, offset2);
      }
      return uint8ArrayToBuffer(b22).slice(offset2, offset2 + span);
    }
    encode(src, b22, offset2) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src.length;
      }
      if (!(src instanceof Uint8Array && span === src.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
      }
      if (offset2 + span > b22.length) {
        throw new RangeError("encoding overruns Uint8Array");
      }
      const srcBuffer = uint8ArrayToBuffer(src);
      uint8ArrayToBuffer(b22).write(srcBuffer.toString("hex"), offset2, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b22, offset2);
      }
      return span;
    }
  }
  exports.Blob = Blob22;

  class CString extends Layout {
    constructor(property) {
      super(-1, property);
    }
    getSpan(b22, offset2 = 0) {
      checkUint8Array(b22);
      let idx = offset2;
      while (idx < b22.length && b22[idx] !== 0) {
        idx += 1;
      }
      return 1 + idx - offset2;
    }
    decode(b22, offset2 = 0) {
      const span = this.getSpan(b22, offset2);
      return uint8ArrayToBuffer(b22).slice(offset2, offset2 + span - 1).toString("utf-8");
    }
    encode(src, b22, offset2 = 0) {
      if (typeof src !== "string") {
        src = String(src);
      }
      const srcb = buffer_1.Buffer.from(src, "utf8");
      const span = srcb.length;
      if (offset2 + span > b22.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      const buffer = uint8ArrayToBuffer(b22);
      srcb.copy(buffer, offset2);
      buffer[offset2 + span] = 0;
      return span + 1;
    }
  }
  exports.CString = CString;

  class UTF8 extends Layout {
    constructor(maxSpan, property) {
      if (typeof maxSpan === "string" && property === undefined) {
        property = maxSpan;
        maxSpan = undefined;
      }
      if (maxSpan === undefined) {
        maxSpan = -1;
      } else if (!Number.isInteger(maxSpan)) {
        throw new TypeError("maxSpan must be an integer");
      }
      super(-1, property);
      this.maxSpan = maxSpan;
    }
    getSpan(b22, offset2 = 0) {
      checkUint8Array(b22);
      return b22.length - offset2;
    }
    decode(b22, offset2 = 0) {
      const span = this.getSpan(b22, offset2);
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      return uint8ArrayToBuffer(b22).slice(offset2, offset2 + span).toString("utf-8");
    }
    encode(src, b22, offset2 = 0) {
      if (typeof src !== "string") {
        src = String(src);
      }
      const srcb = buffer_1.Buffer.from(src, "utf8");
      const span = srcb.length;
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      if (offset2 + span > b22.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      srcb.copy(uint8ArrayToBuffer(b22), offset2);
      return span;
    }
  }
  exports.UTF8 = UTF8;

  class Constant extends Layout {
    constructor(value, property) {
      super(0, property);
      this.value = value;
    }
    decode(b22, offset2) {
      return this.value;
    }
    encode(src, b22, offset2) {
      return 0;
    }
  }
  exports.Constant = Constant;
  exports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
  exports.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
  exports.u8 = (property) => new UInt(1, property);
  exports.u16 = (property) => new UInt(2, property);
  exports.u24 = (property) => new UInt(3, property);
  exports.u32 = (property) => new UInt(4, property);
  exports.u40 = (property) => new UInt(5, property);
  exports.u48 = (property) => new UInt(6, property);
  exports.nu64 = (property) => new NearUInt64(property);
  exports.u16be = (property) => new UIntBE(2, property);
  exports.u24be = (property) => new UIntBE(3, property);
  exports.u32be = (property) => new UIntBE(4, property);
  exports.u40be = (property) => new UIntBE(5, property);
  exports.u48be = (property) => new UIntBE(6, property);
  exports.nu64be = (property) => new NearUInt64BE(property);
  exports.s8 = (property) => new Int(1, property);
  exports.s16 = (property) => new Int(2, property);
  exports.s24 = (property) => new Int(3, property);
  exports.s32 = (property) => new Int(4, property);
  exports.s40 = (property) => new Int(5, property);
  exports.s48 = (property) => new Int(6, property);
  exports.ns64 = (property) => new NearInt64(property);
  exports.s16be = (property) => new IntBE(2, property);
  exports.s24be = (property) => new IntBE(3, property);
  exports.s32be = (property) => new IntBE(4, property);
  exports.s40be = (property) => new IntBE(5, property);
  exports.s48be = (property) => new IntBE(6, property);
  exports.ns64be = (property) => new NearInt64BE(property);
  exports.f32 = (property) => new Float(property);
  exports.f32be = (property) => new FloatBE(property);
  exports.f64 = (property) => new Double(property);
  exports.f64be = (property) => new DoubleBE(property);
  exports.struct = (fields2, property, decodePrefixes) => new Structure(fields2, property, decodePrefixes);
  exports.bits = (word, msb, property) => new BitStructure(word, msb, property);
  exports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
  exports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
  exports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
  exports.blob = (length, property) => new Blob22(length, property);
  exports.cstr = (property) => new CString(property);
  exports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
  exports.constant = (value, property) => new Constant(value, property);
});
function rng2() {
  if (!getRandomValues2) {
    getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues2(rnds82);
}
var getRandomValues2;
var rnds82;
var init_rng2 = __esm2(() => {
  rnds82 = new Uint8Array(16);
});
var regex_default2;
var init_regex2 = __esm2(() => {
  regex_default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
});
function validate22(uuid) {
  return typeof uuid === "string" && regex_default2.test(uuid);
}
var validate_default2;
var init_validate2 = __esm2(() => {
  init_regex2();
  validate_default2 = validate22;
});
function stringify4(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var uuid = (byteToHex2[arr[offset2 + 0]] + byteToHex2[arr[offset2 + 1]] + byteToHex2[arr[offset2 + 2]] + byteToHex2[arr[offset2 + 3]] + "-" + byteToHex2[arr[offset2 + 4]] + byteToHex2[arr[offset2 + 5]] + "-" + byteToHex2[arr[offset2 + 6]] + byteToHex2[arr[offset2 + 7]] + "-" + byteToHex2[arr[offset2 + 8]] + byteToHex2[arr[offset2 + 9]] + "-" + byteToHex2[arr[offset2 + 10]] + byteToHex2[arr[offset2 + 11]] + byteToHex2[arr[offset2 + 12]] + byteToHex2[arr[offset2 + 13]] + byteToHex2[arr[offset2 + 14]] + byteToHex2[arr[offset2 + 15]]).toLowerCase();
  if (!validate_default2(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex2;
var i3;
var stringify_default2;
var init_stringify2 = __esm2(() => {
  init_validate2();
  byteToHex2 = [];
  for (i3 = 0;i3 < 256; ++i3) {
    byteToHex2.push((i3 + 256).toString(16).substr(1));
  }
  stringify_default2 = stringify4;
});
function v12(options, buf, offset2) {
  var i22 = buf && offset2 || 0;
  var b22 = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId2;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq2;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng2)();
    if (node == null) {
      node = _nodeId2 = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq2 = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== undefined ? options.msecs : Date.now();
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs2 + 1;
  var dt = msecs - _lastMSecs2 + (nsecs - _lastNSecs2) / 1e4;
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs2) && options.nsecs === undefined) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs2 = msecs;
  _lastNSecs2 = nsecs;
  _clockseq2 = clockseq;
  msecs += 12219292800000;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b22[i22++] = tl >>> 24 & 255;
  b22[i22++] = tl >>> 16 & 255;
  b22[i22++] = tl >>> 8 & 255;
  b22[i22++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b22[i22++] = tmh >>> 8 & 255;
  b22[i22++] = tmh & 255;
  b22[i22++] = tmh >>> 24 & 15 | 16;
  b22[i22++] = tmh >>> 16 & 255;
  b22[i22++] = clockseq >>> 8 | 128;
  b22[i22++] = clockseq & 255;
  for (var n2 = 0;n2 < 6; ++n2) {
    b22[i22 + n2] = node[n2];
  }
  return buf || stringify_default2(b22);
}
var _nodeId2;
var _clockseq2;
var _lastMSecs2 = 0;
var _lastNSecs2 = 0;
var v1_default2;
var init_v12 = __esm2(() => {
  init_rng2();
  init_stringify2();
  v1_default2 = v12;
});
function parse2(uuid) {
  if (!validate_default2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default2;
var init_parse2 = __esm2(() => {
  init_validate2();
  parse_default2 = parse2;
});
function stringToBytes2(str) {
  str = unescape(encodeURIComponent(str));
  var bytes2 = [];
  for (var i22 = 0;i22 < str.length; ++i22) {
    bytes2.push(str.charCodeAt(i22));
  }
  return bytes2;
}
function v35_default2(name, version3, hashfunc) {
  function generateUUID(value, namespace, buf, offset2) {
    if (typeof value === "string") {
      value = stringToBytes2(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default2(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version3;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (var i22 = 0;i22 < 16; ++i22) {
        buf[offset2 + i22] = bytes2[i22];
      }
      return buf;
    }
    return stringify_default2(bytes2);
  }
  try {
    generateUUID.name = name;
  } catch (err) {}
  generateUUID.DNS = DNS2;
  generateUUID.URL = URL22;
  return generateUUID;
}
var DNS2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL22 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
var init_v352 = __esm2(() => {
  init_stringify2();
  init_parse2();
});
function md52(bytes2) {
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (var i22 = 0;i22 < msg.length; ++i22) {
      bytes2[i22] = msg.charCodeAt(i22);
    }
  }
  return md5ToHexEncodedArray2(wordsToMd52(bytesToWords2(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray2(input) {
  var output2 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i22 = 0;i22 < length32; i22 += 8) {
    var x2 = input[i22 >> 5] >>> i22 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output2.push(hex);
  }
  return output2;
}
function getOutputLength2(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd52(x2, len2) {
  x2[len2 >> 5] |= 128 << len2 % 32;
  x2[getOutputLength2(len2) - 1] = len2;
  var a = 1732584193;
  var b22 = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i22 = 0;i22 < x2.length; i22 += 16) {
    var olda = a;
    var oldb = b22;
    var oldc = c;
    var oldd = d;
    a = md5ff2(a, b22, c, d, x2[i22], 7, -680876936);
    d = md5ff2(d, a, b22, c, x2[i22 + 1], 12, -389564586);
    c = md5ff2(c, d, a, b22, x2[i22 + 2], 17, 606105819);
    b22 = md5ff2(b22, c, d, a, x2[i22 + 3], 22, -1044525330);
    a = md5ff2(a, b22, c, d, x2[i22 + 4], 7, -176418897);
    d = md5ff2(d, a, b22, c, x2[i22 + 5], 12, 1200080426);
    c = md5ff2(c, d, a, b22, x2[i22 + 6], 17, -1473231341);
    b22 = md5ff2(b22, c, d, a, x2[i22 + 7], 22, -45705983);
    a = md5ff2(a, b22, c, d, x2[i22 + 8], 7, 1770035416);
    d = md5ff2(d, a, b22, c, x2[i22 + 9], 12, -1958414417);
    c = md5ff2(c, d, a, b22, x2[i22 + 10], 17, -42063);
    b22 = md5ff2(b22, c, d, a, x2[i22 + 11], 22, -1990404162);
    a = md5ff2(a, b22, c, d, x2[i22 + 12], 7, 1804603682);
    d = md5ff2(d, a, b22, c, x2[i22 + 13], 12, -40341101);
    c = md5ff2(c, d, a, b22, x2[i22 + 14], 17, -1502002290);
    b22 = md5ff2(b22, c, d, a, x2[i22 + 15], 22, 1236535329);
    a = md5gg2(a, b22, c, d, x2[i22 + 1], 5, -165796510);
    d = md5gg2(d, a, b22, c, x2[i22 + 6], 9, -1069501632);
    c = md5gg2(c, d, a, b22, x2[i22 + 11], 14, 643717713);
    b22 = md5gg2(b22, c, d, a, x2[i22], 20, -373897302);
    a = md5gg2(a, b22, c, d, x2[i22 + 5], 5, -701558691);
    d = md5gg2(d, a, b22, c, x2[i22 + 10], 9, 38016083);
    c = md5gg2(c, d, a, b22, x2[i22 + 15], 14, -660478335);
    b22 = md5gg2(b22, c, d, a, x2[i22 + 4], 20, -405537848);
    a = md5gg2(a, b22, c, d, x2[i22 + 9], 5, 568446438);
    d = md5gg2(d, a, b22, c, x2[i22 + 14], 9, -1019803690);
    c = md5gg2(c, d, a, b22, x2[i22 + 3], 14, -187363961);
    b22 = md5gg2(b22, c, d, a, x2[i22 + 8], 20, 1163531501);
    a = md5gg2(a, b22, c, d, x2[i22 + 13], 5, -1444681467);
    d = md5gg2(d, a, b22, c, x2[i22 + 2], 9, -51403784);
    c = md5gg2(c, d, a, b22, x2[i22 + 7], 14, 1735328473);
    b22 = md5gg2(b22, c, d, a, x2[i22 + 12], 20, -1926607734);
    a = md5hh2(a, b22, c, d, x2[i22 + 5], 4, -378558);
    d = md5hh2(d, a, b22, c, x2[i22 + 8], 11, -2022574463);
    c = md5hh2(c, d, a, b22, x2[i22 + 11], 16, 1839030562);
    b22 = md5hh2(b22, c, d, a, x2[i22 + 14], 23, -35309556);
    a = md5hh2(a, b22, c, d, x2[i22 + 1], 4, -1530992060);
    d = md5hh2(d, a, b22, c, x2[i22 + 4], 11, 1272893353);
    c = md5hh2(c, d, a, b22, x2[i22 + 7], 16, -155497632);
    b22 = md5hh2(b22, c, d, a, x2[i22 + 10], 23, -1094730640);
    a = md5hh2(a, b22, c, d, x2[i22 + 13], 4, 681279174);
    d = md5hh2(d, a, b22, c, x2[i22], 11, -358537222);
    c = md5hh2(c, d, a, b22, x2[i22 + 3], 16, -722521979);
    b22 = md5hh2(b22, c, d, a, x2[i22 + 6], 23, 76029189);
    a = md5hh2(a, b22, c, d, x2[i22 + 9], 4, -640364487);
    d = md5hh2(d, a, b22, c, x2[i22 + 12], 11, -421815835);
    c = md5hh2(c, d, a, b22, x2[i22 + 15], 16, 530742520);
    b22 = md5hh2(b22, c, d, a, x2[i22 + 2], 23, -995338651);
    a = md5ii2(a, b22, c, d, x2[i22], 6, -198630844);
    d = md5ii2(d, a, b22, c, x2[i22 + 7], 10, 1126891415);
    c = md5ii2(c, d, a, b22, x2[i22 + 14], 15, -1416354905);
    b22 = md5ii2(b22, c, d, a, x2[i22 + 5], 21, -57434055);
    a = md5ii2(a, b22, c, d, x2[i22 + 12], 6, 1700485571);
    d = md5ii2(d, a, b22, c, x2[i22 + 3], 10, -1894986606);
    c = md5ii2(c, d, a, b22, x2[i22 + 10], 15, -1051523);
    b22 = md5ii2(b22, c, d, a, x2[i22 + 1], 21, -2054922799);
    a = md5ii2(a, b22, c, d, x2[i22 + 8], 6, 1873313359);
    d = md5ii2(d, a, b22, c, x2[i22 + 15], 10, -30611744);
    c = md5ii2(c, d, a, b22, x2[i22 + 6], 15, -1560198380);
    b22 = md5ii2(b22, c, d, a, x2[i22 + 13], 21, 1309151649);
    a = md5ii2(a, b22, c, d, x2[i22 + 4], 6, -145523070);
    d = md5ii2(d, a, b22, c, x2[i22 + 11], 10, -1120210379);
    c = md5ii2(c, d, a, b22, x2[i22 + 2], 15, 718787259);
    b22 = md5ii2(b22, c, d, a, x2[i22 + 9], 21, -343485551);
    a = safeAdd2(a, olda);
    b22 = safeAdd2(b22, oldb);
    c = safeAdd2(c, oldc);
    d = safeAdd2(d, oldd);
  }
  return [a, b22, c, d];
}
function bytesToWords2(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output2 = new Uint32Array(getOutputLength2(length8));
  for (var i22 = 0;i22 < length8; i22 += 8) {
    output2[i22 >> 5] |= (input[i22 / 8] & 255) << i22 % 32;
  }
  return output2;
}
function safeAdd2(x2, y) {
  var lsw = (x2 & 65535) + (y & 65535);
  var msw = (x2 >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft2(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn2(q, a, b22, x2, s, t) {
  return safeAdd2(bitRotateLeft2(safeAdd2(safeAdd2(a, q), safeAdd2(x2, t)), s), b22);
}
function md5ff2(a, b22, c, d, x2, s, t) {
  return md5cmn2(b22 & c | ~b22 & d, a, b22, x2, s, t);
}
function md5gg2(a, b22, c, d, x2, s, t) {
  return md5cmn2(b22 & d | c & ~d, a, b22, x2, s, t);
}
function md5hh2(a, b22, c, d, x2, s, t) {
  return md5cmn2(b22 ^ c ^ d, a, b22, x2, s, t);
}
function md5ii2(a, b22, c, d, x2, s, t) {
  return md5cmn2(c ^ (b22 | ~d), a, b22, x2, s, t);
}
var md5_default2;
var init_md52 = __esm2(() => {
  md5_default2 = md52;
});
var v32;
var v3_default2;
var init_v32 = __esm2(() => {
  init_v352();
  init_md52();
  v32 = v35_default2("v3", 48, md5_default2);
  v3_default2 = v32;
});
function v42(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng2)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i22 = 0;i22 < 16; ++i22) {
      buf[offset2 + i22] = rnds[i22];
    }
    return buf;
  }
  return stringify_default2(rnds);
}
var v4_default2;
var init_v42 = __esm2(() => {
  init_rng2();
  init_stringify2();
  v4_default2 = v42;
});
function f3(s, x2, y, z) {
  switch (s) {
    case 0:
      return x2 & y ^ ~x2 & z;
    case 1:
      return x2 ^ y ^ z;
    case 2:
      return x2 & y ^ x2 & z ^ y & z;
    case 3:
      return x2 ^ y ^ z;
  }
}
function ROTL2(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function sha12(bytes2) {
  var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (var i22 = 0;i22 < msg.length; ++i22) {
      bytes2.push(msg.charCodeAt(i22));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  var l = bytes2.length / 4 + 2;
  var N3 = Math.ceil(l / 16);
  var M = new Array(N3);
  for (var _i = 0;_i < N3; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0;j < 16; ++j) {
      arr[j] = bytes2[_i * 64 + j * 4] << 24 | bytes2[_i * 64 + j * 4 + 1] << 16 | bytes2[_i * 64 + j * 4 + 2] << 8 | bytes2[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N3 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M[N3 - 1][14] = Math.floor(M[N3 - 1][14]);
  M[N3 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (var _i2 = 0;_i2 < N3; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0;t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16;_t < 80; ++_t) {
      W[_t] = ROTL2(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b22 = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0;_t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL2(a, 5) + f3(s, b22, c, d) + e + K2[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL2(b22, 30) >>> 0;
      b22 = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b22 >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default2;
var init_sha12 = __esm2(() => {
  sha1_default2 = sha12;
});
var v52;
var v5_default2;
var init_v52 = __esm2(() => {
  init_v352();
  init_sha12();
  v52 = v35_default2("v5", 80, sha1_default2);
  v5_default2 = v52;
});
var nil_default2 = "00000000-0000-0000-0000-000000000000";
function version3(uuid) {
  if (!validate_default2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default2;
var init_version2 = __esm2(() => {
  init_validate2();
  version_default2 = version3;
});
var exports_esm_browser2 = {};
__export2(exports_esm_browser2, {
  version: () => version_default2,
  validate: () => validate_default2,
  v5: () => v5_default2,
  v4: () => v4_default2,
  v3: () => v3_default2,
  v1: () => v1_default2,
  stringify: () => stringify_default2,
  parse: () => parse_default2,
  NIL: () => nil_default2
});
var init_esm_browser2 = __esm2(() => {
  init_v12();
  init_v32();
  init_v42();
  init_v52();
  init_version2();
  init_validate2();
  init_stringify2();
  init_parse2();
});
var require_generateRequest2 = __commonJS2((exports, module) => {
  var uuid = (init_esm_browser2(), __toCommonJS2(exports_esm_browser2)).v4;
  var generateRequest = function(method, params, id2, options) {
    if (typeof method !== "string") {
      throw new TypeError(method + " must be a string");
    }
    options = options || {};
    const version22 = typeof options.version === "number" ? options.version : 2;
    if (version22 !== 1 && version22 !== 2) {
      throw new TypeError(version22 + " must be 1 or 2");
    }
    const request = {
      method
    };
    if (version22 === 2) {
      request.jsonrpc = "2.0";
    }
    if (params) {
      if (typeof params !== "object" && !Array.isArray(params)) {
        throw new TypeError(params + " must be an object, array or omitted");
      }
      request.params = params;
    }
    if (typeof id2 === "undefined") {
      const generator = typeof options.generator === "function" ? options.generator : function() {
        return uuid();
      };
      request.id = generator(request, options);
    } else if (version22 === 2 && id2 === null) {
      if (options.notificationIdNull) {
        request.id = null;
      }
    } else {
      request.id = id2;
    }
    return request;
  };
  module.exports = generateRequest;
});
var require_browser4 = __commonJS2((exports, module) => {
  var uuid = (init_esm_browser2(), __toCommonJS2(exports_esm_browser2)).v4;
  var generateRequest = require_generateRequest2();
  var ClientBrowser = function(callServer, options) {
    if (!(this instanceof ClientBrowser)) {
      return new ClientBrowser(callServer, options);
    }
    if (!options) {
      options = {};
    }
    this.options = {
      reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
      replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
      generator: typeof options.generator !== "undefined" ? options.generator : function() {
        return uuid();
      },
      version: typeof options.version !== "undefined" ? options.version : 2,
      notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
    };
    this.callServer = callServer;
  };
  module.exports = ClientBrowser;
  ClientBrowser.prototype.request = function(method, params, id2, callback) {
    const self2 = this;
    let request = null;
    const isBatch = Array.isArray(method) && typeof params === "function";
    if (this.options.version === 1 && isBatch) {
      throw new TypeError("JSON-RPC 1.0 does not support batching");
    }
    const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
    if (isBatch || isRaw) {
      callback = params;
      request = method;
    } else {
      if (typeof id2 === "function") {
        callback = id2;
        id2 = undefined;
      }
      const hasCallback = typeof callback === "function";
      try {
        request = generateRequest(method, params, id2, {
          generator: this.options.generator,
          version: this.options.version,
          notificationIdNull: this.options.notificationIdNull
        });
      } catch (err) {
        if (hasCallback) {
          return callback(err);
        }
        throw err;
      }
      if (!hasCallback) {
        return request;
      }
    }
    let message;
    try {
      message = JSON.stringify(request, this.options.replacer);
    } catch (err) {
      return callback(err);
    }
    this.callServer(message, function(err, response) {
      self2._parseResponse(err, response, callback);
    });
    return request;
  };
  ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
    if (err) {
      callback(err);
      return;
    }
    if (!responseText) {
      return callback();
    }
    let response;
    try {
      response = JSON.parse(responseText, this.options.reviver);
    } catch (err2) {
      return callback(err2);
    }
    if (callback.length === 3) {
      if (Array.isArray(response)) {
        const isError2 = function(res) {
          return typeof res.error !== "undefined";
        };
        const isNotError = function(res) {
          return !isError2(res);
        };
        return callback(null, response.filter(isError2), response.filter(isNotError));
      } else {
        return callback(null, response.error, response.result);
      }
    }
    callback(null, response);
  };
});
var require_eventemitter32 = __commonJS2((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter3() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  EventEmitter3.prototype.eventNames = function eventNames() {
    var names2 = [], events, name;
    if (this._eventsCount === 0)
      return names2;
    for (name in events = this._events) {
      if (has.call(events, name))
        names2.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events));
    }
    return names2;
  };
  EventEmitter3.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i22 = 0, l = handlers.length, ee = new Array(l);i22 < l; i22++) {
      ee[i22] = handlers[i22].fn;
    }
    return ee;
  };
  EventEmitter3.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len2 = arguments.length, args, i22;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len2) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i22 = 1, args = new Array(len2 - 1);i22 < len2; i22++) {
        args[i22 - 1] = arguments[i22];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i22 = 0;i22 < length; i22++) {
        if (listeners[i22].once)
          this.removeListener(event, listeners[i22].fn, undefined, true);
        switch (len2) {
          case 1:
            listeners[i22].fn.call(listeners[i22].context);
            break;
          case 2:
            listeners[i22].fn.call(listeners[i22].context, a1);
            break;
          case 3:
            listeners[i22].fn.call(listeners[i22].context, a1, a2);
            break;
          case 4:
            listeners[i22].fn.call(listeners[i22].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len2 - 1);j < len2; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i22].fn.apply(listeners[i22].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter3.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter3.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i22 = 0, events = [], length = listeners.length;i22 < length; i22++) {
        if (listeners[i22].fn !== fn || once && !listeners[i22].once || context && listeners[i22].context !== context) {
          events.push(listeners[i22]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
  EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
  EventEmitter3.prefixed = prefix;
  EventEmitter3.EventEmitter = EventEmitter3;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter3;
  }
});
var require_camelcase = __commonJS2((exports, module) => {
  var UPPERCASE = /[\p{Lu}]/u;
  var LOWERCASE = /[\p{Ll}]/u;
  var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
  var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
  var SEPARATORS = /[_.\- ]+/;
  var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
  var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
  var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
  var preserveCamelCase = (string2, toLowerCase, toUpperCase) => {
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    for (let i22 = 0;i22 < string2.length; i22++) {
      const character = string2[i22];
      if (isLastCharLower && UPPERCASE.test(character)) {
        string2 = string2.slice(0, i22) + "-" + string2.slice(i22);
        isLastCharLower = false;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = true;
        i22++;
      } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
        string2 = string2.slice(0, i22 - 1) + "-" + string2.slice(i22 - 1);
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = false;
        isLastCharLower = true;
      } else {
        isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
      }
    }
    return string2;
  };
  var preserveConsecutiveUppercase = (input, toLowerCase) => {
    LEADING_CAPITAL.lastIndex = 0;
    return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
  };
  var postProcess = (input, toUpperCase) => {
    SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
    NUMBERS_AND_IDENTIFIER.lastIndex = 0;
    return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
  };
  var camelCase = (input, options) => {
    if (!(typeof input === "string" || Array.isArray(input))) {
      throw new TypeError("Expected the input to be `string | string[]`");
    }
    options = {
      pascalCase: false,
      preserveConsecutiveUppercase: false,
      ...options
    };
    if (Array.isArray(input)) {
      input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-");
    } else {
      input = input.trim();
    }
    if (input.length === 0) {
      return "";
    }
    const toLowerCase = options.locale === false ? (string2) => string2.toLowerCase() : (string2) => string2.toLocaleLowerCase(options.locale);
    const toUpperCase = options.locale === false ? (string2) => string2.toUpperCase() : (string2) => string2.toLocaleUpperCase(options.locale);
    if (input.length === 1) {
      return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
    }
    const hasUpperCase = input !== toLowerCase(input);
    if (hasUpperCase) {
      input = preserveCamelCase(input, toLowerCase, toUpperCase);
    }
    input = input.replace(LEADING_SEPARATORS, "");
    if (options.preserveConsecutiveUppercase) {
      input = preserveConsecutiveUppercase(input, toLowerCase);
    } else {
      input = toLowerCase(input);
    }
    if (options.pascalCase) {
      input = toUpperCase(input.charAt(0)) + input.slice(1);
    }
    return postProcess(input, toUpperCase);
  };
  module.exports = camelCase;
  module.exports.default = camelCase;
});
var require_Layout22 = __commonJS2((exports) => {

  class Layout {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    makeDestinationObject() {
      return {};
    }
    decode(b22, offset2) {
      throw new Error("Layout is abstract");
    }
    encode(src, b22, offset2) {
      throw new Error("Layout is abstract");
    }
    getSpan(b22, offset2) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    fromArray(values) {
      return;
    }
  }
  exports.Layout = Layout;
  function nameWithProperty(name, lo) {
    if (lo.property) {
      return name + "[" + lo.property + "]";
    }
    return name;
  }
  exports.nameWithProperty = nameWithProperty;
  function bindConstructorLayout(Class, layout) {
    if (typeof Class !== "function") {
      throw new TypeError("Class must be constructor");
    }
    if (Class.hasOwnProperty("layout_")) {
      throw new Error("Class is already bound to a layout");
    }
    if (!(layout && layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (layout.hasOwnProperty("boundConstructor_")) {
      throw new Error("layout is already bound to a constructor");
    }
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = () => new Class;
    Object.defineProperty(Class.prototype, "encode", {
      value: function(b22, offset2) {
        return layout.encode(this, b22, offset2);
      },
      writable: true
    });
    Object.defineProperty(Class, "decode", {
      value: function(b22, offset2) {
        return layout.decode(b22, offset2);
      },
      writable: true
    });
  }
  exports.bindConstructorLayout = bindConstructorLayout;

  class ExternalLayout extends Layout {
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }

  class GreedyCount extends ExternalLayout {
    constructor(elementSpan, property) {
      if (elementSpan === undefined) {
        elementSpan = 1;
      }
      if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
        throw new TypeError("elementSpan must be a (positive) integer");
      }
      super(-1, property);
      this.elementSpan = elementSpan;
    }
    isCount() {
      return true;
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const rem = b22.length - offset2;
      return Math.floor(rem / this.elementSpan);
    }
    encode(src, b22, offset2) {
      return 0;
    }
  }

  class OffsetLayout extends ExternalLayout {
    constructor(layout, offset2, property) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (offset2 === undefined) {
        offset2 = 0;
      } else if (!Number.isInteger(offset2)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset2;
    }
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return this.layout.decode(b22, offset2 + this.offset);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return this.layout.encode(src, b22, offset2 + this.offset);
    }
  }

  class UInt extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.readUIntLE(offset2, this.span);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      b22.writeUIntLE(src, offset2, this.span);
      return this.span;
    }
  }

  class UIntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.readUIntBE(offset2, this.span);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      b22.writeUIntBE(src, offset2, this.span);
      return this.span;
    }
  }

  class Int extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.readIntLE(offset2, this.span);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      b22.writeIntLE(src, offset2, this.span);
      return this.span;
    }
  }

  class IntBE extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.readIntBE(offset2, this.span);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      b22.writeIntBE(src, offset2, this.span);
      return this.span;
    }
  }
  var V2E32 = Math.pow(2, 32);
  function divmodInt64(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return { hi32, lo32 };
  }
  function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  }

  class NearUInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const lo32 = b22.readUInt32LE(offset2);
      const hi32 = b22.readUInt32LE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const split22 = divmodInt64(src);
      b22.writeUInt32LE(split22.lo32, offset2);
      b22.writeUInt32LE(split22.hi32, offset2 + 4);
      return 8;
    }
  }

  class NearUInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const hi32 = b22.readUInt32BE(offset2);
      const lo32 = b22.readUInt32BE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const split22 = divmodInt64(src);
      b22.writeUInt32BE(split22.hi32, offset2);
      b22.writeUInt32BE(split22.lo32, offset2 + 4);
      return 8;
    }
  }

  class NearInt64 extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const lo32 = b22.readUInt32LE(offset2);
      const hi32 = b22.readInt32LE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const split22 = divmodInt64(src);
      b22.writeUInt32LE(split22.lo32, offset2);
      b22.writeInt32LE(split22.hi32, offset2 + 4);
      return 8;
    }
  }

  class NearInt64BE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const hi32 = b22.readInt32BE(offset2);
      const lo32 = b22.readUInt32BE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const split22 = divmodInt64(src);
      b22.writeInt32BE(split22.hi32, offset2);
      b22.writeUInt32BE(split22.lo32, offset2 + 4);
      return 8;
    }
  }

  class Float extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.readFloatLE(offset2);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      b22.writeFloatLE(src, offset2);
      return 4;
    }
  }

  class FloatBE extends Layout {
    constructor(property) {
      super(4, property);
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.readFloatBE(offset2);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      b22.writeFloatBE(src, offset2);
      return 4;
    }
  }

  class Double extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.readDoubleLE(offset2);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      b22.writeDoubleLE(src, offset2);
      return 8;
    }
  }

  class DoubleBE extends Layout {
    constructor(property) {
      super(8, property);
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.readDoubleBE(offset2);
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      b22.writeDoubleBE(src, offset2);
      return 8;
    }
  }

  class Sequence extends Layout {
    constructor(elementLayout, count, property) {
      if (!(elementLayout instanceof Layout)) {
        throw new TypeError("elementLayout must be a Layout");
      }
      if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
        throw new TypeError("count must be non-negative integer " + "or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
        span = count * elementLayout.span;
      }
      super(span, property);
      this.elementLayout = elementLayout;
      this.count = count;
    }
    getSpan(b22, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let span = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b22, offset2);
      }
      if (0 < this.elementLayout.span) {
        span = count * this.elementLayout.span;
      } else {
        let idx = 0;
        while (idx < count) {
          span += this.elementLayout.getSpan(b22, offset2 + span);
          ++idx;
        }
      }
      return span;
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const rv = [];
      let i22 = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b22, offset2);
      }
      while (i22 < count) {
        rv.push(this.elementLayout.decode(b22, offset2));
        offset2 += this.elementLayout.getSpan(b22, offset2);
        i22 += 1;
      }
      return rv;
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const elo = this.elementLayout;
      const span = src.reduce((span2, v) => {
        return span2 + elo.encode(v, b22, offset2 + span2);
      }, 0);
      if (this.count instanceof ExternalLayout) {
        this.count.encode(src.length, b22, offset2);
      }
      return span;
    }
  }

  class Structure extends Layout {
    constructor(fields2, property, decodePrefixes) {
      if (!(Array.isArray(fields2) && fields2.reduce((acc, v) => acc && v instanceof Layout, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if (typeof property === "boolean" && decodePrefixes === undefined) {
        decodePrefixes = property;
        property = undefined;
      }
      for (const fd of fields2) {
        if (0 > fd.span && fd.property === undefined) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields2.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e) {}
      super(span, property);
      this.fields = fields2;
      this.decodePrefixes = !!decodePrefixes;
    }
    getSpan(b22, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b22, offset2);
          offset2 += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(b22, offset2);
        }
        offset2 += fd.getSpan(b22, offset2);
        if (this.decodePrefixes && b22.length === offset2) {
          break;
        }
      }
      return dest;
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const firstOffset = offset2;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            lastWrote = fd.encode(fv, b22, offset2);
            if (0 > span) {
              span = fd.getSpan(b22, offset2);
            }
          }
        }
        lastOffset = offset2;
        offset2 += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (fd.property !== undefined && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    layoutFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
    }
    offsetOf(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      let offset2 = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset2;
        }
        if (0 > fd.span) {
          offset2 = -1;
        } else if (0 <= offset2) {
          offset2 += fd.span;
        }
      }
    }
  }

  class UnionDiscriminator {
    constructor(property) {
      this.property = property;
    }
    decode() {
      throw new Error("UnionDiscriminator is abstract");
    }
    encode() {
      throw new Error("UnionDiscriminator is abstract");
    }
  }

  class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    decode(b22, offset2) {
      return this.layout.decode(b22, offset2);
    }
    encode(src, b22, offset2) {
      return this.layout.encode(src, b22, offset2);
    }
  }

  class Union extends Layout {
    constructor(discr, defaultLayout, property) {
      const upv = discr instanceof UInt || discr instanceof UIntBE;
      if (upv) {
        discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discr = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator " + "or an unsigned integer layout");
      }
      if (defaultLayout === undefined) {
        defaultLayout = null;
      }
      if (!(defaultLayout === null || defaultLayout instanceof Layout)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (defaultLayout !== null) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (defaultLayout.property === undefined) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && upv) {
          span += discr.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discr;
      this.usesPrefixDiscriminator = upv;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src) {
        return boundGetSourceVariant(src);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    getSpan(b22, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const vlo = this.getVariant(b22, offset2);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b22, offset2);
    }
    defaultGetSourceVariant(src) {
      if (src.hasOwnProperty(this.discriminator.property)) {
        if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
          return;
        }
        const vlo = this.registry[src[this.discriminator.property]];
        if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag2 in this.registry) {
          const vlo = this.registry[tag2];
          if (src.hasOwnProperty(vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b22, offset2);
      let clo = this.registry[discr];
      if (clo === undefined) {
        let contentOffset = 0;
        clo = this.defaultLayout;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[clo.property] = this.defaultLayout.decode(b22, offset2 + contentOffset);
      } else {
        dest = clo.decode(b22, offset2);
      }
      return dest;
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const vlo = this.getSourceVariant(src);
      if (vlo === undefined) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src[dlo.property], b22, offset2);
        return contentOffset + clo.encode(src[clo.property], b22, offset2 + contentOffset);
      }
      return vlo.encode(src, b22, offset2);
    }
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    getVariant(vb, offset2) {
      let variant = vb;
      if (Buffer.isBuffer(vb)) {
        if (offset2 === undefined) {
          offset2 = 0;
        }
        variant = this.discriminator.decode(vb, offset2);
      }
      return this.registry[variant];
    }
  }

  class VariantLayout extends Layout {
    constructor(union2, variant, layout, property) {
      if (!(union2 instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if (typeof layout === "string" && property === undefined) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (union2.defaultLayout !== null && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if (typeof property !== "string") {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union2.span;
      if (0 > union2.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union2.usesPrefixDiscriminator) {
          span += union2.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union2;
      this.variant = variant;
      this.layout = layout || null;
    }
    getSpan(b22, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      return contentOffset + this.layout.getSpan(b22, offset2 + contentOffset);
    }
    decode(b22, offset2) {
      const dest = this.makeDestinationObject();
      if (offset2 === undefined) {
        offset2 = 0;
      }
      if (this !== this.union.getVariant(b22, offset2)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b22, offset2 + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !src.hasOwnProperty(this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b22, offset2);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src[this.property], b22, offset2 + contentOffset);
        span += this.layout.getSpan(b22, offset2 + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
    }
  }
  function fixBitwiseResult(v) {
    if (0 > v) {
      v += 4294967296;
    }
    return v;
  }

  class BitStructure extends Layout {
    constructor(word, msb, property) {
      if (!(word instanceof UInt || word instanceof UIntBE)) {
        throw new TypeError("word must be a UInt or UIntBE layout");
      }
      if (typeof msb === "string" && property === undefined) {
        property = msb;
        msb = undefined;
      }
      if (4 < word.span) {
        throw new RangeError("word cannot exceed 32 bits");
      }
      super(word.span, property);
      this.word = word;
      this.msb = !!msb;
      this.fields = [];
      let value = 0;
      this._packedSetValue = function(v) {
        value = fixBitwiseResult(v);
        return this;
      };
      this._packedGetValue = function() {
        return value;
      };
    }
    decode(b22, offset2) {
      const dest = this.makeDestinationObject();
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const value = this.word.decode(b22, offset2);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          dest[fd.property] = fd.decode(value);
        }
      }
      return dest;
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      const value = this.word.decode(b22, offset2);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (fd.property !== undefined) {
          const fv = src[fd.property];
          if (fv !== undefined) {
            fd.encode(fv);
          }
        }
      }
      return this.word.encode(this._packedGetValue(), b22, offset2);
    }
    addField(bits, property) {
      const bf = new BitField(this, bits, property);
      this.fields.push(bf);
      return bf;
    }
    addBoolean(property) {
      const bf = new Boolean2(this, property);
      this.fields.push(bf);
      return bf;
    }
    fieldFor(property) {
      if (typeof property !== "string") {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
    }
  }

  class BitField {
    constructor(container, bits, property) {
      if (!(container instanceof BitStructure)) {
        throw new TypeError("container must be a BitStructure");
      }
      if (!Number.isInteger(bits) || 0 >= bits) {
        throw new TypeError("bits must be positive integer");
      }
      const totalBits = 8 * container.span;
      const usedBits = container.fields.reduce((sum2, fd) => sum2 + fd.bits, 0);
      if (bits + usedBits > totalBits) {
        throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
      }
      this.container = container;
      this.bits = bits;
      this.valueMask = (1 << bits) - 1;
      if (bits === 32) {
        this.valueMask = 4294967295;
      }
      this.start = usedBits;
      if (this.container.msb) {
        this.start = totalBits - usedBits - bits;
      }
      this.wordMask = fixBitwiseResult(this.valueMask << this.start);
      this.property = property;
    }
    decode() {
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(word & this.wordMask);
      const value = wordValue >>> this.start;
      return value;
    }
    encode(value) {
      if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
        throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
      }
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(value << this.start);
      this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
    }
  }

  class Boolean2 extends BitField {
    constructor(container, property) {
      super(container, 1, property);
    }
    decode(b22, offset2) {
      return !!BitField.prototype.decode.call(this, b22, offset2);
    }
    encode(value) {
      if (typeof value === "boolean") {
        value = +value;
      }
      return BitField.prototype.encode.call(this, value);
    }
  }

  class Blob22 extends Layout {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer " + "or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    getSpan(b22, offset2) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b22, offset2);
      }
      return span;
    }
    decode(b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b22, offset2);
      }
      return b22.slice(offset2, offset2 + span);
    }
    encode(src, b22, offset2) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src.length;
      }
      if (!(Buffer.isBuffer(src) && span === src.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
      }
      if (offset2 + span > b22.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      b22.write(src.toString("hex"), offset2, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b22, offset2);
      }
      return span;
    }
  }

  class CString extends Layout {
    constructor(property) {
      super(-1, property);
    }
    getSpan(b22, offset2) {
      if (!Buffer.isBuffer(b22)) {
        throw new TypeError("b must be a Buffer");
      }
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let idx = offset2;
      while (idx < b22.length && b22[idx] !== 0) {
        idx += 1;
      }
      return 1 + idx - offset2;
    }
    decode(b22, offset2, dest) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let span = this.getSpan(b22, offset2);
      return b22.slice(offset2, offset2 + span - 1).toString("utf-8");
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      if (typeof src !== "string") {
        src = src.toString();
      }
      const srcb = new Buffer(src, "utf8");
      const span = srcb.length;
      if (offset2 + span > b22.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      srcb.copy(b22, offset2);
      b22[offset2 + span] = 0;
      return span + 1;
    }
  }

  class UTF8 extends Layout {
    constructor(maxSpan, property) {
      if (typeof maxSpan === "string" && property === undefined) {
        property = maxSpan;
        maxSpan = undefined;
      }
      if (maxSpan === undefined) {
        maxSpan = -1;
      } else if (!Number.isInteger(maxSpan)) {
        throw new TypeError("maxSpan must be an integer");
      }
      super(-1, property);
      this.maxSpan = maxSpan;
    }
    getSpan(b22, offset2) {
      if (!Buffer.isBuffer(b22)) {
        throw new TypeError("b must be a Buffer");
      }
      if (offset2 === undefined) {
        offset2 = 0;
      }
      return b22.length - offset2;
    }
    decode(b22, offset2, dest) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      let span = this.getSpan(b22, offset2);
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      return b22.slice(offset2, offset2 + span).toString("utf-8");
    }
    encode(src, b22, offset2) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      if (typeof src !== "string") {
        src = src.toString();
      }
      const srcb = new Buffer(src, "utf8");
      const span = srcb.length;
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      if (offset2 + span > b22.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      srcb.copy(b22, offset2);
      return span;
    }
  }

  class Constant extends Layout {
    constructor(value, property) {
      super(0, property);
      this.value = value;
    }
    decode(b22, offset2, dest) {
      return this.value;
    }
    encode(src, b22, offset2) {
      return 0;
    }
  }
  exports.ExternalLayout = ExternalLayout;
  exports.GreedyCount = GreedyCount;
  exports.OffsetLayout = OffsetLayout;
  exports.UInt = UInt;
  exports.UIntBE = UIntBE;
  exports.Int = Int;
  exports.IntBE = IntBE;
  exports.Float = Float;
  exports.FloatBE = FloatBE;
  exports.Double = Double;
  exports.DoubleBE = DoubleBE;
  exports.Sequence = Sequence;
  exports.Structure = Structure;
  exports.UnionDiscriminator = UnionDiscriminator;
  exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
  exports.Union = Union;
  exports.VariantLayout = VariantLayout;
  exports.BitStructure = BitStructure;
  exports.BitField = BitField;
  exports.Boolean = Boolean2;
  exports.Blob = Blob22;
  exports.CString = CString;
  exports.UTF8 = UTF8;
  exports.Constant = Constant;
  exports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
  exports.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
  exports.u8 = (property) => new UInt(1, property);
  exports.u16 = (property) => new UInt(2, property);
  exports.u24 = (property) => new UInt(3, property);
  exports.u32 = (property) => new UInt(4, property);
  exports.u40 = (property) => new UInt(5, property);
  exports.u48 = (property) => new UInt(6, property);
  exports.nu64 = (property) => new NearUInt64(property);
  exports.u16be = (property) => new UIntBE(2, property);
  exports.u24be = (property) => new UIntBE(3, property);
  exports.u32be = (property) => new UIntBE(4, property);
  exports.u40be = (property) => new UIntBE(5, property);
  exports.u48be = (property) => new UIntBE(6, property);
  exports.nu64be = (property) => new NearUInt64BE(property);
  exports.s8 = (property) => new Int(1, property);
  exports.s16 = (property) => new Int(2, property);
  exports.s24 = (property) => new Int(3, property);
  exports.s32 = (property) => new Int(4, property);
  exports.s40 = (property) => new Int(5, property);
  exports.s48 = (property) => new Int(6, property);
  exports.ns64 = (property) => new NearInt64(property);
  exports.s16be = (property) => new IntBE(2, property);
  exports.s24be = (property) => new IntBE(3, property);
  exports.s32be = (property) => new IntBE(4, property);
  exports.s40be = (property) => new IntBE(5, property);
  exports.s48be = (property) => new IntBE(6, property);
  exports.ns64be = (property) => new NearInt64BE(property);
  exports.f32 = (property) => new Float(property);
  exports.f32be = (property) => new FloatBE(property);
  exports.f64 = (property) => new Double(property);
  exports.f64be = (property) => new DoubleBE(property);
  exports.struct = (fields2, property, decodePrefixes) => new Structure(fields2, property, decodePrefixes);
  exports.bits = (word, msb, property) => new BitStructure(word, msb, property);
  exports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
  exports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
  exports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
  exports.blob = (length, property) => new Blob22(length, property);
  exports.cstr = (property) => new CString(property);
  exports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
  exports.const = (value, property) => new Constant(value, property);
});
var require_crypto = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = undefined;
  exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
});
var require_utils = __commonJS2((exports) => {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = undefined;
  exports.isBytes = isBytes2;
  exports.anumber = anumber2;
  exports.abytes = abytes2;
  exports.ahash = ahash2;
  exports.aexists = aexists2;
  exports.aoutput = aoutput2;
  exports.u8 = u82;
  exports.u32 = u3232;
  exports.clean = clean2;
  exports.createView = createView22;
  exports.rotr = rotr22;
  exports.rotl = rotl3;
  exports.byteSwap = byteSwap2;
  exports.byteSwap32 = byteSwap322;
  exports.bytesToHex = bytesToHex22;
  exports.hexToBytes = hexToBytes22;
  exports.asyncLoop = asyncLoop2;
  exports.utf8ToBytes = utf8ToBytes22;
  exports.bytesToUtf8 = bytesToUtf82;
  exports.toBytes = toBytes22;
  exports.kdfInputToBytes = kdfInputToBytes;
  exports.concatBytes = concatBytes22;
  exports.checkOpts = checkOpts2;
  exports.createHasher = createHasher2;
  exports.createOptHasher = createOptHasher;
  exports.createXOFer = createXOFer2;
  exports.randomBytes = randomBytes22;
  var crypto_1 = require_crypto();
  function isBytes2(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber2(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error("positive integer expected, got " + n2);
  }
  function abytes2(b22, ...lengths) {
    if (!isBytes2(b22))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b22.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b22.length);
  }
  function ahash2(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash should be wrapped by utils.createHasher");
    anumber2(h.outputLen);
    anumber2(h.blockLen);
  }
  function aexists2(instance2, checkFinished = true) {
    if (instance2.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance2.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput2(out, instance2) {
    abytes2(out);
    const min2 = instance2.outputLen;
    if (out.length < min2) {
      throw new Error("digestInto() expects output buffer of length at least " + min2);
    }
  }
  function u82(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function u3232(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean2(...arrays) {
    for (let i22 = 0;i22 < arrays.length; i22++) {
      arrays[i22].fill(0);
    }
  }
  function createView22(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr22(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function rotl3(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  }
  exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function byteSwap2(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  exports.swap8IfBE = exports.isLE ? (n2) => n2 : (n2) => byteSwap2(n2);
  exports.byteSwapIfBE = exports.swap8IfBE;
  function byteSwap322(arr) {
    for (let i22 = 0;i22 < arr.length; i22++) {
      arr[i22] = byteSwap2(arr[i22]);
    }
    return arr;
  }
  exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap322;
  var hasHexBuiltin2 = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
  var hexes22 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i22) => i22.toString(16).padStart(2, "0"));
  function bytesToHex22(bytes2) {
    abytes2(bytes2);
    if (hasHexBuiltin2)
      return bytes2.toHex();
    let hex = "";
    for (let i22 = 0;i22 < bytes2.length; i22++) {
      hex += hexes22[bytes2[i22]];
    }
    return hex;
  }
  var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase162(ch) {
    if (ch >= asciis2._0 && ch <= asciis2._9)
      return ch - asciis2._0;
    if (ch >= asciis2.A && ch <= asciis2.F)
      return ch - (asciis2.A - 10);
    if (ch >= asciis2.a && ch <= asciis2.f)
      return ch - (asciis2.a - 10);
    return;
  }
  function hexToBytes22(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin2)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array2 = new Uint8Array(al);
    for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
      const n1 = asciiToBase162(hex.charCodeAt(hi));
      const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
      if (n1 === undefined || n2 === undefined) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array2[ai] = n1 * 16 + n2;
    }
    return array2;
  }
  var nextTick2 = async () => {};
  exports.nextTick = nextTick2;
  async function asyncLoop2(iters, tick, cb) {
    let ts = Date.now();
    for (let i22 = 0;i22 < iters; i22++) {
      cb(i22);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  function utf8ToBytes22(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bytesToUtf82(bytes2) {
    return new TextDecoder().decode(bytes2);
  }
  function toBytes22(data) {
    if (typeof data === "string")
      data = utf8ToBytes22(data);
    abytes2(data);
    return data;
  }
  function kdfInputToBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes22(data);
    abytes2(data);
    return data;
  }
  function concatBytes22(...arrays) {
    let sum2 = 0;
    for (let i22 = 0;i22 < arrays.length; i22++) {
      const a = arrays[i22];
      abytes2(a);
      sum2 += a.length;
    }
    const res = new Uint8Array(sum2);
    for (let i22 = 0, pad = 0;i22 < arrays.length; i22++) {
      const a = arrays[i22];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function checkOpts2(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== "[object Object]")
      throw new Error("options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }

  class Hash22 {
  }
  exports.Hash = Hash22;
  function createHasher2(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes22(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes22(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function createXOFer2(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes22(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  exports.wrapConstructor = createHasher2;
  exports.wrapConstructorWithOpts = createOptHasher;
  exports.wrapXOFConstructorWithOpts = createXOFer2;
  function randomBytes22(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
      return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
      return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
});
var require__md = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = undefined;
  exports.setBigUint64 = setBigUint6422;
  exports.Chi = Chi22;
  exports.Maj = Maj22;
  var utils_ts_1 = require_utils();
  function setBigUint6422(view, byteOffset, value, isLE22) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE22);
    const _32n22 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n22 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE22 ? 4 : 0;
    const l = isLE22 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE22);
    view.setUint32(byteOffset + l, wl, isLE22);
  }
  function Chi22(a, b22, c) {
    return a & b22 ^ ~a & c;
  }
  function Maj22(a, b22, c) {
    return a & b22 ^ a & c ^ b22 & c;
  }

  class HashMD2 extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE22) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE22;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
      (0, utils_ts_1.aexists)(this);
      data = (0, utils_ts_1.toBytes)(data);
      (0, utils_ts_1.abytes)(data);
      const { view, buffer, blockLen } = this;
      const len2 = data.length;
      for (let pos = 0;pos < len2; ) {
        const take = Math.min(blockLen - this.pos, len2 - pos);
        if (take === blockLen) {
          const dataView = (0, utils_ts_1.createView)(data);
          for (;blockLen <= len2 - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1.aexists)(this);
      (0, utils_ts_1.aoutput)(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE22 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      (0, utils_ts_1.clean)(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i22 = pos;i22 < blockLen; i22++)
        buffer[i22] = 0;
      setBigUint6422(view, blockLen - 8, BigInt(this.length * 8), isLE22);
      this.process(view, 0);
      const oview = (0, utils_ts_1.createView)(out);
      const len2 = this.outputLen;
      if (len2 % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len2 / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i22 = 0;i22 < outLen; i22++)
        oview.setUint32(4 * i22, state[i22], isLE22);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length, finished: finished22, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished22;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  }
  exports.HashMD = HashMD2;
  exports.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  exports.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]);
  exports.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]);
  exports.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);
});
var require__u64 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = undefined;
  exports.add = add22;
  exports.fromBig = fromBig22;
  exports.split = split22;
  var U32_MASK6422 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n22 = /* @__PURE__ */ BigInt(32);
  function fromBig22(n2, le = false) {
    if (le)
      return { h: Number(n2 & U32_MASK6422), l: Number(n2 >> _32n22 & U32_MASK6422) };
    return { h: Number(n2 >> _32n22 & U32_MASK6422) | 0, l: Number(n2 & U32_MASK6422) | 0 };
  }
  function split22(lst, le = false) {
    const len2 = lst.length;
    let Ah = new Uint32Array(len2);
    let Al = new Uint32Array(len2);
    for (let i22 = 0;i22 < len2; i22++) {
      const { h, l } = fromBig22(lst[i22], le);
      [Ah[i22], Al[i22]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig2 = (h, l) => BigInt(h >>> 0) << _32n22 | BigInt(l >>> 0);
  exports.toBig = toBig2;
  var shrSH22 = (h, _l, s) => h >>> s;
  exports.shrSH = shrSH22;
  var shrSL22 = (h, l, s) => h << 32 - s | l >>> s;
  exports.shrSL = shrSL22;
  var rotrSH22 = (h, l, s) => h >>> s | l << 32 - s;
  exports.rotrSH = rotrSH22;
  var rotrSL22 = (h, l, s) => h << 32 - s | l >>> s;
  exports.rotrSL = rotrSL22;
  var rotrBH22 = (h, l, s) => h << 64 - s | l >>> s - 32;
  exports.rotrBH = rotrBH22;
  var rotrBL22 = (h, l, s) => h >>> s - 32 | l << 64 - s;
  exports.rotrBL = rotrBL22;
  var rotr32H2 = (_h, l) => l;
  exports.rotr32H = rotr32H2;
  var rotr32L2 = (h, _l) => h;
  exports.rotr32L = rotr32L2;
  var rotlSH22 = (h, l, s) => h << s | l >>> 32 - s;
  exports.rotlSH = rotlSH22;
  var rotlSL22 = (h, l, s) => l << s | h >>> 32 - s;
  exports.rotlSL = rotlSL22;
  var rotlBH22 = (h, l, s) => l << s - 32 | h >>> 64 - s;
  exports.rotlBH = rotlBH22;
  var rotlBL22 = (h, l, s) => h << s - 32 | l >>> 64 - s;
  exports.rotlBL = rotlBL22;
  function add22(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L22 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  exports.add3L = add3L22;
  var add3H22 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  exports.add3H = add3H22;
  var add4L22 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  exports.add4L = add4L22;
  var add4H22 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  exports.add4H = add4H22;
  var add5L22 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  exports.add5L = add5L22;
  var add5H22 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  exports.add5H = add5H22;
  var u6422 = {
    fromBig: fromBig22,
    split: split22,
    toBig: toBig2,
    shrSH: shrSH22,
    shrSL: shrSL22,
    rotrSH: rotrSH22,
    rotrSL: rotrSL22,
    rotrBH: rotrBH22,
    rotrBL: rotrBL22,
    rotr32H: rotr32H2,
    rotr32L: rotr32L2,
    rotlSH: rotlSH22,
    rotlSL: rotlSL22,
    rotlBH: rotlBH22,
    rotlBL: rotlBL22,
    add: add22,
    add3L: add3L22,
    add3H: add3H22,
    add4L: add4L22,
    add4H: add4H22,
    add5H: add5H22,
    add5L: add5L22
  };
  exports.default = u6422;
});
var require_sha2 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = undefined;
  var _md_ts_1 = require__md();
  var u6422 = require__u64();
  var utils_ts_1 = require_utils();
  var SHA256_K22 = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W22 = /* @__PURE__ */ new Uint32Array(64);

  class SHA25622 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = _md_ts_1.SHA256_IV[0] | 0;
      this.B = _md_ts_1.SHA256_IV[1] | 0;
      this.C = _md_ts_1.SHA256_IV[2] | 0;
      this.D = _md_ts_1.SHA256_IV[3] | 0;
      this.E = _md_ts_1.SHA256_IV[4] | 0;
      this.F = _md_ts_1.SHA256_IV[5] | 0;
      this.G = _md_ts_1.SHA256_IV[6] | 0;
      this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D: D2, E: E2, F, G, H } = this;
      return [A, B, C, D2, E2, F, G, H];
    }
    set(A, B, C, D2, E2, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D2 | 0;
      this.E = E2 | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset2) {
      for (let i22 = 0;i22 < 16; i22++, offset2 += 4)
        SHA256_W22[i22] = view.getUint32(offset2, false);
      for (let i22 = 16;i22 < 64; i22++) {
        const W15 = SHA256_W22[i22 - 15];
        const W2 = SHA256_W22[i22 - 2];
        const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W22[i22] = s1 + SHA256_W22[i22 - 7] + s0 + SHA256_W22[i22 - 16] | 0;
      }
      let { A, B, C, D: D2, E: E2, F, G, H } = this;
      for (let i22 = 0;i22 < 64; i22++) {
        const sigma1 = (0, utils_ts_1.rotr)(E2, 6) ^ (0, utils_ts_1.rotr)(E2, 11) ^ (0, utils_ts_1.rotr)(E2, 25);
        const T13 = H + sigma1 + (0, _md_ts_1.Chi)(E2, F, G) + SHA256_K22[i22] + SHA256_W22[i22] | 0;
        const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
        const T22 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
        H = G;
        G = F;
        F = E2;
        E2 = D2 + T13 | 0;
        D2 = C;
        C = B;
        B = A;
        A = T13 + T22 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D2 = D2 + this.D | 0;
      E2 = E2 + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D2, E2, F, G, H);
    }
    roundClean() {
      (0, utils_ts_1.clean)(SHA256_W22);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      (0, utils_ts_1.clean)(this.buffer);
    }
  }
  exports.SHA256 = SHA25622;

  class SHA2242 extends SHA25622 {
    constructor() {
      super(28);
      this.A = _md_ts_1.SHA224_IV[0] | 0;
      this.B = _md_ts_1.SHA224_IV[1] | 0;
      this.C = _md_ts_1.SHA224_IV[2] | 0;
      this.D = _md_ts_1.SHA224_IV[3] | 0;
      this.E = _md_ts_1.SHA224_IV[4] | 0;
      this.F = _md_ts_1.SHA224_IV[5] | 0;
      this.G = _md_ts_1.SHA224_IV[6] | 0;
      this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
  }
  exports.SHA224 = SHA2242;
  var K5122 = /* @__PURE__ */ (() => u6422.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n2) => BigInt(n2))))();
  var SHA512_Kh22 = /* @__PURE__ */ (() => K5122[0])();
  var SHA512_Kl22 = /* @__PURE__ */ (() => K5122[1])();
  var SHA512_W_H22 = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L22 = /* @__PURE__ */ new Uint32Array(80);

  class SHA51222 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = _md_ts_1.SHA512_IV[0] | 0;
      this.Al = _md_ts_1.SHA512_IV[1] | 0;
      this.Bh = _md_ts_1.SHA512_IV[2] | 0;
      this.Bl = _md_ts_1.SHA512_IV[3] | 0;
      this.Ch = _md_ts_1.SHA512_IV[4] | 0;
      this.Cl = _md_ts_1.SHA512_IV[5] | 0;
      this.Dh = _md_ts_1.SHA512_IV[6] | 0;
      this.Dl = _md_ts_1.SHA512_IV[7] | 0;
      this.Eh = _md_ts_1.SHA512_IV[8] | 0;
      this.El = _md_ts_1.SHA512_IV[9] | 0;
      this.Fh = _md_ts_1.SHA512_IV[10] | 0;
      this.Fl = _md_ts_1.SHA512_IV[11] | 0;
      this.Gh = _md_ts_1.SHA512_IV[12] | 0;
      this.Gl = _md_ts_1.SHA512_IV[13] | 0;
      this.Hh = _md_ts_1.SHA512_IV[14] | 0;
      this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset2) {
      for (let i22 = 0;i22 < 16; i22++, offset2 += 4) {
        SHA512_W_H22[i22] = view.getUint32(offset2);
        SHA512_W_L22[i22] = view.getUint32(offset2 += 4);
      }
      for (let i22 = 16;i22 < 80; i22++) {
        const W15h = SHA512_W_H22[i22 - 15] | 0;
        const W15l = SHA512_W_L22[i22 - 15] | 0;
        const s0h = u6422.rotrSH(W15h, W15l, 1) ^ u6422.rotrSH(W15h, W15l, 8) ^ u6422.shrSH(W15h, W15l, 7);
        const s0l = u6422.rotrSL(W15h, W15l, 1) ^ u6422.rotrSL(W15h, W15l, 8) ^ u6422.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H22[i22 - 2] | 0;
        const W2l = SHA512_W_L22[i22 - 2] | 0;
        const s1h = u6422.rotrSH(W2h, W2l, 19) ^ u6422.rotrBH(W2h, W2l, 61) ^ u6422.shrSH(W2h, W2l, 6);
        const s1l = u6422.rotrSL(W2h, W2l, 19) ^ u6422.rotrBL(W2h, W2l, 61) ^ u6422.shrSL(W2h, W2l, 6);
        const SUMl = u6422.add4L(s0l, s1l, SHA512_W_L22[i22 - 7], SHA512_W_L22[i22 - 16]);
        const SUMh = u6422.add4H(SUMl, s0h, s1h, SHA512_W_H22[i22 - 7], SHA512_W_H22[i22 - 16]);
        SHA512_W_H22[i22] = SUMh | 0;
        SHA512_W_L22[i22] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i22 = 0;i22 < 80; i22++) {
        const sigma1h = u6422.rotrSH(Eh, El, 14) ^ u6422.rotrSH(Eh, El, 18) ^ u6422.rotrBH(Eh, El, 41);
        const sigma1l = u6422.rotrSL(Eh, El, 14) ^ u6422.rotrSL(Eh, El, 18) ^ u6422.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u6422.add5L(Hl, sigma1l, CHIl, SHA512_Kl22[i22], SHA512_W_L22[i22]);
        const T1h = u6422.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh22[i22], SHA512_W_H22[i22]);
        const T1l = T1ll | 0;
        const sigma0h = u6422.rotrSH(Ah, Al, 28) ^ u6422.rotrBH(Ah, Al, 34) ^ u6422.rotrBH(Ah, Al, 39);
        const sigma0l = u6422.rotrSL(Ah, Al, 28) ^ u6422.rotrBL(Ah, Al, 34) ^ u6422.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u6422.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u6422.add3L(T1l, sigma0l, MAJl);
        Ah = u6422.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u6422.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u6422.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u6422.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u6422.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u6422.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u6422.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u6422.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u6422.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      (0, utils_ts_1.clean)(SHA512_W_H22, SHA512_W_L22);
    }
    destroy() {
      (0, utils_ts_1.clean)(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  exports.SHA512 = SHA51222;

  class SHA384 extends SHA51222 {
    constructor() {
      super(48);
      this.Ah = _md_ts_1.SHA384_IV[0] | 0;
      this.Al = _md_ts_1.SHA384_IV[1] | 0;
      this.Bh = _md_ts_1.SHA384_IV[2] | 0;
      this.Bl = _md_ts_1.SHA384_IV[3] | 0;
      this.Ch = _md_ts_1.SHA384_IV[4] | 0;
      this.Cl = _md_ts_1.SHA384_IV[5] | 0;
      this.Dh = _md_ts_1.SHA384_IV[6] | 0;
      this.Dl = _md_ts_1.SHA384_IV[7] | 0;
      this.Eh = _md_ts_1.SHA384_IV[8] | 0;
      this.El = _md_ts_1.SHA384_IV[9] | 0;
      this.Fh = _md_ts_1.SHA384_IV[10] | 0;
      this.Fl = _md_ts_1.SHA384_IV[11] | 0;
      this.Gh = _md_ts_1.SHA384_IV[12] | 0;
      this.Gl = _md_ts_1.SHA384_IV[13] | 0;
      this.Hh = _md_ts_1.SHA384_IV[14] | 0;
      this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
  }
  exports.SHA384 = SHA384;
  var T224_IV = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]);
  var T256_IV = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);

  class SHA512_224 extends SHA51222 {
    constructor() {
      super(28);
      this.Ah = T224_IV[0] | 0;
      this.Al = T224_IV[1] | 0;
      this.Bh = T224_IV[2] | 0;
      this.Bl = T224_IV[3] | 0;
      this.Ch = T224_IV[4] | 0;
      this.Cl = T224_IV[5] | 0;
      this.Dh = T224_IV[6] | 0;
      this.Dl = T224_IV[7] | 0;
      this.Eh = T224_IV[8] | 0;
      this.El = T224_IV[9] | 0;
      this.Fh = T224_IV[10] | 0;
      this.Fl = T224_IV[11] | 0;
      this.Gh = T224_IV[12] | 0;
      this.Gl = T224_IV[13] | 0;
      this.Hh = T224_IV[14] | 0;
      this.Hl = T224_IV[15] | 0;
    }
  }
  exports.SHA512_224 = SHA512_224;

  class SHA512_256 extends SHA51222 {
    constructor() {
      super(32);
      this.Ah = T256_IV[0] | 0;
      this.Al = T256_IV[1] | 0;
      this.Bh = T256_IV[2] | 0;
      this.Bl = T256_IV[3] | 0;
      this.Ch = T256_IV[4] | 0;
      this.Cl = T256_IV[5] | 0;
      this.Dh = T256_IV[6] | 0;
      this.Dl = T256_IV[7] | 0;
      this.Eh = T256_IV[8] | 0;
      this.El = T256_IV[9] | 0;
      this.Fh = T256_IV[10] | 0;
      this.Fl = T256_IV[11] | 0;
      this.Gh = T256_IV[12] | 0;
      this.Gl = T256_IV[13] | 0;
      this.Hh = T256_IV[14] | 0;
      this.Hl = T256_IV[15] | 0;
    }
  }
  exports.SHA512_256 = SHA512_256;
  exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA25622);
  exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA2242);
  exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA51222);
  exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384);
  exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256);
  exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224);
});
var require_utils2 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = undefined;
  exports.abool = abool2;
  exports.numberToHexUnpadded = numberToHexUnpadded22;
  exports.hexToNumber = hexToNumber22;
  exports.bytesToNumberBE = bytesToNumberBE22;
  exports.bytesToNumberLE = bytesToNumberLE22;
  exports.numberToBytesBE = numberToBytesBE22;
  exports.numberToBytesLE = numberToBytesLE22;
  exports.numberToVarBytesBE = numberToVarBytesBE2;
  exports.ensureBytes = ensureBytes22;
  exports.equalBytes = equalBytes2;
  exports.inRange = inRange3;
  exports.aInRange = aInRange2;
  exports.bitLen = bitLen22;
  exports.bitGet = bitGet2;
  exports.bitSet = bitSet2;
  exports.createHmacDrbg = createHmacDrbg22;
  exports.validateObject = validateObject22;
  exports.isHash = isHash;
  exports._validateObject = _validateObject2;
  exports.memoized = memoized2;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var utils_js_1 = require_utils();
  var utils_js_2 = require_utils();
  Object.defineProperty(exports, "abytes", { enumerable: true, get: function() {
    return utils_js_2.abytes;
  } });
  Object.defineProperty(exports, "anumber", { enumerable: true, get: function() {
    return utils_js_2.anumber;
  } });
  Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
    return utils_js_2.bytesToHex;
  } });
  Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
    return utils_js_2.bytesToUtf8;
  } });
  Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
    return utils_js_2.concatBytes;
  } });
  Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
    return utils_js_2.hexToBytes;
  } });
  Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
    return utils_js_2.isBytes;
  } });
  Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
    return utils_js_2.randomBytes;
  } });
  Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
    return utils_js_2.utf8ToBytes;
  } });
  var _0n92 = /* @__PURE__ */ BigInt(0);
  var _1n92 = /* @__PURE__ */ BigInt(1);
  function abool2(title, value) {
    if (typeof value !== "boolean")
      throw new Error(title + " boolean expected, got " + value);
  }
  function numberToHexUnpadded22(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber22(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n92 : BigInt("0x" + hex);
  }
  function bytesToNumberBE22(bytes2) {
    return hexToNumber22((0, utils_js_1.bytesToHex)(bytes2));
  }
  function bytesToNumberLE22(bytes2) {
    (0, utils_js_1.abytes)(bytes2);
    return hexToNumber22((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE22(n2, len2) {
    return (0, utils_js_1.hexToBytes)(n2.toString(16).padStart(len2 * 2, "0"));
  }
  function numberToBytesLE22(n2, len2) {
    return numberToBytesBE22(n2, len2).reverse();
  }
  function numberToVarBytesBE2(n2) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded22(n2));
  }
  function ensureBytes22(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = (0, utils_js_1.hexToBytes)(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if ((0, utils_js_1.isBytes)(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len2 = res.length;
    if (typeof expectedLength === "number" && len2 !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len2);
    return res;
  }
  function equalBytes2(a, b22) {
    if (a.length !== b22.length)
      return false;
    let diff = 0;
    for (let i22 = 0;i22 < a.length; i22++)
      diff |= a[i22] ^ b22[i22];
    return diff === 0;
  }
  var isPosBig2 = (n2) => typeof n2 === "bigint" && _0n92 <= n2;
  function inRange3(n2, min2, max2) {
    return isPosBig2(n2) && isPosBig2(min2) && isPosBig2(max2) && min2 <= n2 && n2 < max2;
  }
  function aInRange2(title, n2, min2, max2) {
    if (!inRange3(n2, min2, max2))
      throw new Error("expected valid " + title + ": " + min2 + " <= n < " + max2 + ", got " + n2);
  }
  function bitLen22(n2) {
    let len2;
    for (len2 = 0;n2 > _0n92; n2 >>= _1n92, len2 += 1)
      ;
    return len2;
  }
  function bitGet2(n2, pos) {
    return n2 >> BigInt(pos) & _1n92;
  }
  function bitSet2(n2, pos, value) {
    return n2 | (value ? _1n92 : _0n92) << BigInt(pos);
  }
  var bitMask22 = (n2) => (_1n92 << BigInt(n2)) - _1n92;
  exports.bitMask = bitMask22;
  function createHmacDrbg22(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n2 = (len2) => new Uint8Array(len2);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n2(hashLen);
    let k = u8n2(hashLen);
    let i22 = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i22 = 0;
    };
    const h = (...b22) => hmacFn(k, v, ...b22);
    const reseed = (seed = u8n2(0)) => {
      k = h(u8of(0), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8of(1), seed);
      v = h();
    };
    const gen22 = () => {
      if (i22++ >= 1000)
        throw new Error("drbg: tried 1000 values");
      let len2 = 0;
      const out = [];
      while (len2 < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len2 += v.length;
      }
      return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = undefined;
      while (!(res = pred(gen22())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  var validatorFns2 = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object2) => object2.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject22(object2, validators, optValidators = {}) {
    const checkField2 = (fieldName, type2, isOptional) => {
      const checkVal = validatorFns2[type2];
      if (typeof checkVal !== "function")
        throw new Error("invalid validator function");
      const val = object2[fieldName];
      if (isOptional && val === undefined)
        return;
      if (!checkVal(val, object2)) {
        throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
      }
    };
    for (const [fieldName, type2] of Object.entries(validators))
      checkField2(fieldName, type2, false);
    for (const [fieldName, type2] of Object.entries(optValidators))
      checkField2(fieldName, type2, true);
    return object2;
  }
  function isHash(val) {
    return typeof val === "function" && Number.isSafeInteger(val.outputLen);
  }
  function _validateObject2(object2, fields2, optFields = {}) {
    if (!object2 || typeof object2 !== "object")
      throw new Error("expected valid options object");
    function checkField2(fieldName, expectedType, isOpt) {
      const val = object2[fieldName];
      if (isOpt && val === undefined)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields2).forEach(([k, v]) => checkField2(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField2(k, v, true));
  }
  var notImplemented = () => {
    throw new Error("not implemented");
  };
  exports.notImplemented = notImplemented;
  function memoized2(fn) {
    const map = new WeakMap;
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== undefined)
        return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }
});
var require_modular = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNegativeLE = undefined;
  exports.mod = mod22;
  exports.pow = pow3;
  exports.pow2 = pow222;
  exports.invert = invert22;
  exports.tonelliShanks = tonelliShanks22;
  exports.FpSqrt = FpSqrt22;
  exports.validateField = validateField22;
  exports.FpPow = FpPow22;
  exports.FpInvertBatch = FpInvertBatch22;
  exports.FpDiv = FpDiv;
  exports.FpLegendre = FpLegendre2;
  exports.FpIsSquare = FpIsSquare;
  exports.nLength = nLength22;
  exports.Field = Field22;
  exports.FpSqrtOdd = FpSqrtOdd;
  exports.FpSqrtEven = FpSqrtEven2;
  exports.hashToPrivateScalar = hashToPrivateScalar;
  exports.getFieldBytesLength = getFieldBytesLength22;
  exports.getMinHashLength = getMinHashLength22;
  exports.mapHashToField = mapHashToField22;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var utils_ts_1 = require_utils2();
  var _0n92 = BigInt(0);
  var _1n92 = BigInt(1);
  var _2n72 = /* @__PURE__ */ BigInt(2);
  var _3n42 = /* @__PURE__ */ BigInt(3);
  var _4n32 = /* @__PURE__ */ BigInt(4);
  var _5n32 = /* @__PURE__ */ BigInt(5);
  var _8n42 = /* @__PURE__ */ BigInt(8);
  function mod22(a, b22) {
    const result = a % b22;
    return result >= _0n92 ? result : b22 + result;
  }
  function pow3(num, power, modulo) {
    return FpPow22(Field22(modulo), num, power);
  }
  function pow222(x2, power, modulo) {
    let res = x2;
    while (power-- > _0n92) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert22(number22, modulo) {
    if (number22 === _0n92)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n92)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod22(number22, modulo);
    let b22 = modulo;
    let x2 = _0n92, y = _1n92, u = _1n92, v = _0n92;
    while (a !== _0n92) {
      const q = b22 / a;
      const r = b22 % a;
      const m = x2 - u * q;
      const n2 = y - v * q;
      b22 = a, a = r, x2 = u, y = v, u = m, v = n2;
    }
    const gcd = b22;
    if (gcd !== _1n92)
      throw new Error("invert: does not exist");
    return mod22(x2, modulo);
  }
  function sqrt3mod42(Fp22, n2) {
    const p1div4 = (Fp22.ORDER + _1n92) / _4n32;
    const root = Fp22.pow(n2, p1div4);
    if (!Fp22.eql(Fp22.sqr(root), n2))
      throw new Error("Cannot find square root");
    return root;
  }
  function sqrt5mod82(Fp22, n2) {
    const p5div8 = (Fp22.ORDER - _5n32) / _8n42;
    const n22 = Fp22.mul(n2, _2n72);
    const v = Fp22.pow(n22, p5div8);
    const nv = Fp22.mul(n2, v);
    const i22 = Fp22.mul(Fp22.mul(nv, _2n72), v);
    const root = Fp22.mul(nv, Fp22.sub(i22, Fp22.ONE));
    if (!Fp22.eql(Fp22.sqr(root), n2))
      throw new Error("Cannot find square root");
    return root;
  }
  function tonelliShanks22(P22) {
    if (P22 < BigInt(3))
      throw new Error("sqrt is not defined for small field");
    let Q = P22 - _1n92;
    let S2 = 0;
    while (Q % _2n72 === _0n92) {
      Q /= _2n72;
      S2++;
    }
    let Z2 = _2n72;
    const _Fp = Field22(P22);
    while (FpLegendre2(_Fp, Z2) === 1) {
      if (Z2++ > 1000)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S2 === 1)
      return sqrt3mod42;
    let cc = _Fp.pow(Z2, Q);
    const Q1div2 = (Q + _1n92) / _2n72;
    return function tonelliSlow(Fp22, n2) {
      if (Fp22.is0(n2))
        return n2;
      if (FpLegendre2(Fp22, n2) !== 1)
        throw new Error("Cannot find square root");
      let M = S2;
      let c = Fp22.mul(Fp22.ONE, cc);
      let t = Fp22.pow(n2, Q);
      let R = Fp22.pow(n2, Q1div2);
      while (!Fp22.eql(t, Fp22.ONE)) {
        if (Fp22.is0(t))
          return Fp22.ZERO;
        let i22 = 1;
        let t_tmp = Fp22.sqr(t);
        while (!Fp22.eql(t_tmp, Fp22.ONE)) {
          i22++;
          t_tmp = Fp22.sqr(t_tmp);
          if (i22 === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n92 << BigInt(M - i22 - 1);
        const b22 = Fp22.pow(c, exponent);
        M = i22;
        c = Fp22.sqr(b22);
        t = Fp22.mul(t, c);
        R = Fp22.mul(R, b22);
      }
      return R;
    };
  }
  function FpSqrt22(P22) {
    if (P22 % _4n32 === _3n42)
      return sqrt3mod42;
    if (P22 % _8n42 === _5n32)
      return sqrt5mod82;
    return tonelliShanks22(P22);
  }
  var isNegativeLE2 = (num, modulo) => (mod22(num, modulo) & _1n92) === _1n92;
  exports.isNegativeLE = isNegativeLE2;
  var FIELD_FIELDS22 = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField22(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS22.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    (0, utils_ts_1._validateObject)(field, opts);
    return field;
  }
  function FpPow22(Fp22, num, power) {
    if (power < _0n92)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n92)
      return Fp22.ONE;
    if (power === _1n92)
      return num;
    let p = Fp22.ONE;
    let d = num;
    while (power > _0n92) {
      if (power & _1n92)
        p = Fp22.mul(p, d);
      d = Fp22.sqr(d);
      power >>= _1n92;
    }
    return p;
  }
  function FpInvertBatch22(Fp22, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp22.ZERO : undefined);
    const multipliedAcc = nums.reduce((acc, num, i22) => {
      if (Fp22.is0(num))
        return acc;
      inverted[i22] = acc;
      return Fp22.mul(acc, num);
    }, Fp22.ONE);
    const invertedAcc = Fp22.inv(multipliedAcc);
    nums.reduceRight((acc, num, i22) => {
      if (Fp22.is0(num))
        return acc;
      inverted[i22] = Fp22.mul(acc, inverted[i22]);
      return Fp22.mul(acc, num);
    }, invertedAcc);
    return inverted;
  }
  function FpDiv(Fp22, lhs, rhs) {
    return Fp22.mul(lhs, typeof rhs === "bigint" ? invert22(rhs, Fp22.ORDER) : Fp22.inv(rhs));
  }
  function FpLegendre2(Fp22, n2) {
    const p1mod2 = (Fp22.ORDER - _1n92) / _2n72;
    const powered = Fp22.pow(n2, p1mod2);
    const yes = Fp22.eql(powered, Fp22.ONE);
    const zero = Fp22.eql(powered, Fp22.ZERO);
    const no = Fp22.eql(powered, Fp22.neg(Fp22.ONE));
    if (!yes && !zero && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero ? 0 : -1;
  }
  function FpIsSquare(Fp22, n2) {
    const l = FpLegendre2(Fp22, n2);
    return l === 1;
  }
  function nLength22(n2, nBitLength) {
    if (nBitLength !== undefined)
      (0, utils_ts_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n2.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field22(ORDER, bitLenOrOpts, isLE22 = false, opts = {}) {
    if (ORDER <= _0n92)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE22)
        throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS)
        _nbitLength = _opts.BITS;
      if (_opts.sqrt)
        _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean")
        isLE22 = _opts.isLE;
    } else {
      if (typeof bitLenOrOpts === "number")
        _nbitLength = bitLenOrOpts;
      if (opts.sqrt)
        _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength22(ORDER, _nbitLength);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f22 = Object.freeze({
      ORDER,
      isLE: isLE22,
      BITS,
      BYTES,
      MASK: (0, utils_ts_1.bitMask)(BITS),
      ZERO: _0n92,
      ONE: _1n92,
      create: (num) => mod22(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num);
        return _0n92 <= num && num < ORDER;
      },
      is0: (num) => num === _0n92,
      isValidNot0: (num) => !f22.is0(num) && f22.isValid(num),
      isOdd: (num) => (num & _1n92) === _1n92,
      neg: (num) => mod22(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod22(num * num, ORDER),
      add: (lhs, rhs) => mod22(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod22(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod22(lhs * rhs, ORDER),
      pow: (num, power) => FpPow22(f22, num, power),
      div: (lhs, rhs) => mod22(lhs * invert22(rhs, ORDER), ORDER),
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert22(num, ORDER),
      sqrt: _sqrt || ((n2) => {
        if (!sqrtP)
          sqrtP = FpSqrt22(ORDER);
        return sqrtP(f22, n2);
      }),
      toBytes: (num) => isLE22 ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
        return isLE22 ? (0, utils_ts_1.bytesToNumberLE)(bytes2) : (0, utils_ts_1.bytesToNumberBE)(bytes2);
      },
      invertBatch: (lst) => FpInvertBatch22(f22, lst),
      cmov: (a, b22, c) => c ? b22 : a
    });
    return Object.freeze(f22);
  }
  function FpSqrtOdd(Fp22, elm) {
    if (!Fp22.isOdd)
      throw new Error("Field doesn't have isOdd");
    const root = Fp22.sqrt(elm);
    return Fp22.isOdd(root) ? root : Fp22.neg(root);
  }
  function FpSqrtEven2(Fp22, elm) {
    if (!Fp22.isOdd)
      throw new Error("Field doesn't have isOdd");
    const root = Fp22.sqrt(elm);
    return Fp22.isOdd(root) ? Fp22.neg(root) : root;
  }
  function hashToPrivateScalar(hash2, groupOrder, isLE22 = false) {
    hash2 = (0, utils_ts_1.ensureBytes)("privateHash", hash2);
    const hashLen = hash2.length;
    const minLen = nLength22(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
      throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
    const num = isLE22 ? (0, utils_ts_1.bytesToNumberLE)(hash2) : (0, utils_ts_1.bytesToNumberBE)(hash2);
    return mod22(num, groupOrder - _1n92) + _1n92;
  }
  function getFieldBytesLength22(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength22(fieldOrder) {
    const length = getFieldBytesLength22(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField22(key, fieldOrder, isLE22 = false) {
    const len2 = key.length;
    const fieldLen = getFieldBytesLength22(fieldOrder);
    const minLen = getMinHashLength22(fieldOrder);
    if (len2 < 16 || len2 < minLen || len2 > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len2);
    const num = isLE22 ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    const reduced = mod22(num, fieldOrder - _1n92) + _1n92;
    return isLE22 ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
  }
});
var require_curve = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.negateCt = negateCt2;
  exports.normalizeZ = normalizeZ2;
  exports.wNAF = wNAF22;
  exports.mulEndoUnsafe = mulEndoUnsafe2;
  exports.pippenger = pippenger2;
  exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
  exports.validateBasic = validateBasic2;
  exports._createCurveFields = _createCurveFields2;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var utils_ts_1 = require_utils2();
  var modular_ts_1 = require_modular();
  var _0n92 = BigInt(0);
  var _1n92 = BigInt(1);
  function negateCt2(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ2(c, property, points) {
    const getz = property === "pz" ? (p) => p.pz : (p) => p.ez;
    const toInv = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map(getz));
    const affined = points.map((p, i22) => p.toAffine(toInv[i22]));
    return affined.map(c.fromAffine);
  }
  function validateW2(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts2(W, scalarBits) {
    validateW2(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask22 = (0, utils_ts_1.bitMask)(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask: mask22, maxNumber, shiftBy };
  }
  function calcOffsets2(n2, window2, wOpts) {
    const { windowSize, mask: mask22, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n2 & mask22);
    let nextN = n2 >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n92;
    }
    const offsetStart = window2 * windowSize;
    const offset2 = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints2(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i22) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i22);
    });
  }
  function validateMSMScalars2(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s, i22) => {
      if (!field.isValid(s))
        throw new Error("invalid scalar at index " + i22);
    });
  }
  var pointPrecomputes2 = new WeakMap;
  var pointWindowSizes2 = new WeakMap;
  function getW2(P22) {
    return pointWindowSizes2.get(P22) || 1;
  }
  function assert02(n2) {
    if (n2 !== _0n92)
      throw new Error("invalid wNAF");
  }
  function wNAF22(c, bits) {
    return {
      constTimeNegate: negateCt2,
      hasPrecomputes(elm) {
        return getW2(elm) !== 1;
      },
      unsafeLadder(elm, n2, p = c.ZERO) {
        let d = elm;
        while (n2 > _0n92) {
          if (n2 & _1n92)
            p = p.add(d);
          d = d.double();
          n2 >>= _1n92;
        }
        return p;
      },
      precomputeWindow(elm, W) {
        const { windows, windowSize } = calcWOpts2(W, bits);
        const points = [];
        let p = elm;
        let base2 = p;
        for (let window2 = 0;window2 < windows; window2++) {
          base2 = p;
          points.push(base2);
          for (let i22 = 1;i22 < windowSize; i22++) {
            base2 = base2.add(p);
            points.push(base2);
          }
          p = base2.double();
        }
        return points;
      },
      wNAF(W, precomputes, n2) {
        let p = c.ZERO;
        let f22 = c.BASE;
        const wo = calcWOpts2(W, bits);
        for (let window2 = 0;window2 < wo.windows; window2++) {
          const { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF } = calcOffsets2(n2, window2, wo);
          n2 = nextN;
          if (isZero) {
            f22 = f22.add(negateCt2(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(negateCt2(isNeg, precomputes[offset2]));
          }
        }
        assert02(n2);
        return { p, f: f22 };
      },
      wNAFUnsafe(W, precomputes, n2, acc = c.ZERO) {
        const wo = calcWOpts2(W, bits);
        for (let window2 = 0;window2 < wo.windows; window2++) {
          if (n2 === _0n92)
            break;
          const { nextN, offset: offset2, isZero, isNeg } = calcOffsets2(n2, window2, wo);
          n2 = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset2];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert02(n2);
        return acc;
      },
      getPrecomputes(W, P22, transform) {
        let comp = pointPrecomputes2.get(P22);
        if (!comp) {
          comp = this.precomputeWindow(P22, W);
          if (W !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes2.set(P22, comp);
          }
        }
        return comp;
      },
      wNAFCached(P22, n2, transform) {
        const W = getW2(P22);
        return this.wNAF(W, this.getPrecomputes(W, P22, transform), n2);
      },
      wNAFCachedUnsafe(P22, n2, transform, prev) {
        const W = getW2(P22);
        if (W === 1)
          return this.unsafeLadder(P22, n2, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, P22, transform), n2, prev);
      },
      setWindowSize(P22, W) {
        validateW2(W, bits);
        pointWindowSizes2.set(P22, W);
        pointPrecomputes2.delete(P22);
      }
    };
  }
  function mulEndoUnsafe2(c, point, k1, k2) {
    let acc = point;
    let p1 = c.ZERO;
    let p2 = c.ZERO;
    while (k1 > _0n92 || k2 > _0n92) {
      if (k1 & _1n92)
        p1 = p1.add(acc);
      if (k2 & _1n92)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n92;
      k2 >>= _1n92;
    }
    return { p1, p2 };
  }
  function pippenger2(c, fieldN, points, scalars) {
    validateMSMPoints2(points, c);
    validateMSMScalars2(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
      throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12)
      windowSize = wbits - 3;
    else if (wbits > 4)
      windowSize = wbits - 2;
    else if (wbits > 0)
      windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum2 = zero;
    for (let i22 = lastBits;i22 >= 0; i22 -= windowSize) {
      buckets.fill(zero);
      for (let j = 0;j < slength; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i22) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero;j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum2 = sum2.add(resI);
      if (i22 !== 0)
        for (let j = 0;j < windowSize; j++)
          sum2 = sum2.double();
    }
    return sum2;
  }
  function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    validateW2(windowSize, fieldN.BITS);
    validateMSMPoints2(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1;
    const chunks = Math.ceil(fieldN.BITS / windowSize);
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p) => {
      const res = [];
      for (let i22 = 0, acc = p;i22 < tableSize; i22++) {
        res.push(acc);
        acc = acc.add(p);
      }
      return res;
    });
    return (scalars) => {
      validateMSMScalars2(scalars, fieldN);
      if (scalars.length > points.length)
        throw new Error("array of scalars must be smaller than array of points");
      let res = zero;
      for (let i22 = 0;i22 < chunks; i22++) {
        if (res !== zero)
          for (let j = 0;j < windowSize; j++)
            res = res.double();
        const shiftBy = BigInt(chunks * windowSize - (i22 + 1) * windowSize);
        for (let j = 0;j < scalars.length; j++) {
          const n2 = scalars[j];
          const curr = Number(n2 >> shiftBy & MASK);
          if (!curr)
            continue;
          res = res.add(tables[j][curr - 1]);
        }
      }
      return res;
    };
  }
  function validateBasic2(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }
  function createField2(order, field) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      (0, modular_ts_1.validateField)(field);
      return field;
    } else {
      return (0, modular_ts_1.Field)(order);
    }
  }
  function _createCurveFields2(type2, CURVE, curveOpts = {}) {
    if (!CURVE || typeof CURVE !== "object")
      throw new Error(`expected valid ${type2} CURVE object`);
    for (const p of ["p", "n", "h"]) {
      const val = CURVE[p];
      if (!(typeof val === "bigint" && val > _0n92))
        throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp22 = createField2(CURVE.p, curveOpts.Fp);
    const Fn = createField2(CURVE.n, curveOpts.Fn);
    const _b = type2 === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b];
    for (const p of params) {
      if (!Fp22.isValid(CURVE[p]))
        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    return { Fp: Fp22, Fn };
  }
});
var require_edwards = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.edwards = edwards2;
  exports.eddsa = eddsa2;
  exports.twistedEdwards = twistedEdwards2;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var utils_ts_1 = require_utils2();
  var curve_ts_1 = require_curve();
  var modular_ts_1 = require_modular();
  var _0n92 = BigInt(0);
  var _1n92 = BigInt(1);
  var _2n72 = BigInt(2);
  var _8n42 = BigInt(8);
  var VERIFY_DEFAULT2 = { zip215: true };
  function isEdValidXY2(Fp22, CURVE, x2, y) {
    const x22 = Fp22.sqr(x2);
    const y2 = Fp22.sqr(y);
    const left = Fp22.add(Fp22.mul(CURVE.a, x22), y2);
    const right = Fp22.add(Fp22.ONE, Fp22.mul(CURVE.d, Fp22.mul(x22, y2)));
    return Fp22.eql(left, right);
  }
  function edwards2(CURVE, curveOpts = {}) {
    const { Fp: Fp22, Fn } = (0, curve_ts_1._createCurveFields)("edwards", CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(curveOpts, {}, { uvRatio: "function" });
    const MASK = _2n72 << BigInt(Fn.BYTES * 8) - _1n92;
    const modP = (n2) => Fp22.create(n2);
    const uvRatio2 = curveOpts.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp22.sqrt(Fp22.div(u, v)) };
      } catch (e) {
        return { isValid: false, value: _0n92 };
      }
    });
    if (!isEdValidXY2(Fp22, CURVE, CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    function acoord(title, n2, banZero = false) {
      const min2 = banZero ? _1n92 : _0n92;
      (0, utils_ts_1.aInRange)("coordinate " + title, n2, min2, MASK);
      return n2;
    }
    function aextpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
      const { ex: x2, ey: y, ez: z } = p;
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? _8n42 : Fp22.inv(z);
      const ax = modP(x2 * iz);
      const ay = modP(y * iz);
      const zz = modP(z * iz);
      if (is0)
        return { x: _0n92, y: _1n92 };
      if (zz !== _1n92)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
      const { a, d } = CURVE;
      if (p.is0())
        throw new Error("bad point: ZERO");
      const { ex: X, ey: Y, ez: Z2, et: T } = p;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z22 = modP(Z2 * Z2);
      const Z4 = modP(Z22 * Z22);
      const aX2 = modP(X2 * a);
      const left = modP(Z22 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z2 * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });

    class Point2 {
      constructor(ex, ey, ez, et2) {
        this.ex = acoord("x", ex);
        this.ey = acoord("y", ey);
        this.ez = acoord("z", ez, true);
        this.et = acoord("t", et2);
        Object.freeze(this);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point2)
          throw new Error("extended point not allowed");
        const { x: x2, y } = p || {};
        acoord("x", x2);
        acoord("y", y);
        return new Point2(x2, y, _1n92, modP(x2 * y));
      }
      static normalizeZ(points) {
        return (0, curve_ts_1.normalizeZ)(Point2, "ez", points);
      }
      static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(Point2, Fn, points, scalars);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      precompute(windowSize = 8, isLazy = true) {
        wnaf.setWindowSize(this, windowSize);
        if (!isLazy)
          this.multiply(_2n72);
        return this;
      }
      assertValidity() {
        assertValidMemo(this);
      }
      equals(other) {
        aextpoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      negate() {
        return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n72 * modP(Z1 * Z1));
        const D2 = modP(a * A);
        const x1y1 = X1 + Y1;
        const E2 = modP(modP(x1y1 * x1y1) - A - B);
        const G = D2 + B;
        const F = G - C;
        const H = D2 - B;
        const X3 = modP(E2 * F);
        const Y3 = modP(G * H);
        const T32 = modP(E2 * H);
        const Z3 = modP(F * G);
        return new Point2(X3, Y3, Z3, T32);
      }
      add(other) {
        aextpoint(other);
        const { a, d } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T13 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T22 } = other;
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T13 * d * T22);
        const D2 = modP(Z1 * Z2);
        const E2 = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D2 - C;
        const G = D2 + C;
        const H = modP(B - a * A);
        const X3 = modP(E2 * F);
        const Y3 = modP(G * H);
        const T32 = modP(E2 * H);
        const Z3 = modP(F * G);
        return new Point2(X3, Y3, Z3, T32);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        const n2 = scalar;
        (0, utils_ts_1.aInRange)("scalar", n2, _1n92, CURVE_ORDER);
        const { p, f: f22 } = wnaf.wNAFCached(this, n2, Point2.normalizeZ);
        return Point2.normalizeZ([p, f22])[0];
      }
      multiplyUnsafe(scalar, acc = Point2.ZERO) {
        const n2 = scalar;
        (0, utils_ts_1.aInRange)("scalar", n2, _0n92, CURVE_ORDER);
        if (n2 === _0n92)
          return Point2.ZERO;
        if (this.is0() || n2 === _1n92)
          return this;
        return wnaf.wNAFCachedUnsafe(this, n2, Point2.normalizeZ, acc);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      isTorsionFree() {
        return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
      }
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      clearCofactor() {
        if (cofactor === _1n92)
          return this;
        return this.multiplyUnsafe(cofactor);
      }
      static fromBytes(bytes2, zip215 = false) {
        (0, utils_ts_1.abytes)(bytes2);
        return this.fromHex(bytes2, zip215);
      }
      static fromHex(hex, zip215 = false) {
        const { d, a } = CURVE;
        const len2 = Fp22.BYTES;
        hex = (0, utils_ts_1.ensureBytes)("pointHex", hex, len2);
        (0, utils_ts_1.abool)("zip215", zip215);
        const normed = hex.slice();
        const lastByte = hex[len2 - 1];
        normed[len2 - 1] = lastByte & ~128;
        const y = (0, utils_ts_1.bytesToNumberLE)(normed);
        const max2 = zip215 ? MASK : Fp22.ORDER;
        (0, utils_ts_1.aInRange)("pointHex.y", y, _0n92, max2);
        const y2 = modP(y * y);
        const u = modP(y2 - _1n92);
        const v = modP(d * y2 - a);
        let { isValid, value: x2 } = uvRatio2(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x2 & _1n92) === _1n92;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x2 === _0n92 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x2 = modP(-x2);
        return Point2.fromAffine({ x: x2, y });
      }
      static fromPrivateScalar(scalar) {
        return Point2.BASE.multiply(scalar);
      }
      toBytes() {
        const { x: x2, y } = this.toAffine();
        const bytes2 = (0, utils_ts_1.numberToBytesLE)(y, Fp22.BYTES);
        bytes2[bytes2.length - 1] |= x2 & _1n92 ? 128 : 0;
        return bytes2;
      }
      toRawBytes() {
        return this.toBytes();
      }
      toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n92, modP(CURVE.Gx * CURVE.Gy));
    Point2.ZERO = new Point2(_0n92, _1n92, _1n92, _0n92);
    Point2.Fp = Fp22;
    Point2.Fn = Fn;
    const wnaf = (0, curve_ts_1.wNAF)(Point2, Fn.BYTES * 8);
    return Point2;
  }
  function eddsa2(Point2, eddsaOpts) {
    (0, utils_ts_1._validateObject)(eddsaOpts, {
      hash: "function"
    }, {
      adjustScalarBytes: "function",
      randomBytes: "function",
      domain: "function",
      prehash: "function",
      mapToCurve: "function"
    });
    const { prehash, hash: cHash } = eddsaOpts;
    const { BASE: G, Fp: Fp22, Fn } = Point2;
    const CURVE_ORDER = Fn.ORDER;
    const randomBytes_ = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
    const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
      (0, utils_ts_1.abool)("phflag", phflag);
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function modN(a) {
      return Fn.create(a);
    }
    function modN_LE(hash2) {
      return modN((0, utils_ts_1.bytesToNumberLE)(hash2));
    }
    function getPrivateScalar(key) {
      const len2 = Fp22.BYTES;
      key = (0, utils_ts_1.ensureBytes)("private key", key, len2);
      const hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len2);
      const head = adjustScalarBytes2(hashed.slice(0, len2));
      const prefix = hashed.slice(len2, 2 * len2);
      const scalar = modN_LE(head);
      return { head, prefix, scalar };
    }
    function getExtendedPublicKey(key) {
      const { head, prefix, scalar } = getPrivateScalar(key);
      const point = G.multiply(scalar);
      const pointBytes = point.toBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey2(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = (0, utils_ts_1.concatBytes)(...msgs);
      return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
    }
    function sign22(msg, privKey, options = {}) {
      msg = (0, utils_ts_1.ensureBytes)("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = G.multiply(r).toBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s = modN(r + k * scalar);
      (0, utils_ts_1.aInRange)("signature.s", s, _0n92, CURVE_ORDER);
      const L = Fp22.BYTES;
      const res = (0, utils_ts_1.concatBytes)(R, (0, utils_ts_1.numberToBytesLE)(s, L));
      return (0, utils_ts_1.ensureBytes)("result", res, L * 2);
    }
    const verifyOpts = VERIFY_DEFAULT2;
    function verify2(sig, msg, publicKey2, options = verifyOpts) {
      const { context, zip215 } = options;
      const len2 = Fp22.BYTES;
      sig = (0, utils_ts_1.ensureBytes)("signature", sig, 2 * len2);
      msg = (0, utils_ts_1.ensureBytes)("message", msg);
      publicKey2 = (0, utils_ts_1.ensureBytes)("publicKey", publicKey2, len2);
      if (zip215 !== undefined)
        (0, utils_ts_1.abool)("zip215", zip215);
      if (prehash)
        msg = prehash(msg);
      const s = (0, utils_ts_1.bytesToNumberLE)(sig.slice(len2, 2 * len2));
      let A, R, SB;
      try {
        A = Point2.fromHex(publicKey2, zip215);
        R = Point2.fromHex(sig.slice(0, len2), zip215);
        SB = G.multiplyUnsafe(s);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().is0();
    }
    G.precompute(8);
    const utils = {
      getExtendedPublicKey,
      randomPrivateKey: () => randomBytes_(Fp22.BYTES),
      precompute(windowSize = 8, point = Point2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return { getPublicKey: getPublicKey2, sign: sign22, verify: verify2, utils, Point: Point2 };
  }
  function _eddsa_legacy_opts_to_new2(c) {
    const CURVE = {
      a: c.a,
      d: c.d,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp22 = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
    const curveOpts = { Fp: Fp22, Fn, uvRatio: c.uvRatio };
    const eddsaOpts = {
      hash: c.hash,
      randomBytes: c.randomBytes,
      adjustScalarBytes: c.adjustScalarBytes,
      domain: c.domain,
      prehash: c.prehash,
      mapToCurve: c.mapToCurve
    };
    return { CURVE, curveOpts, eddsaOpts };
  }
  function _eddsa_new_output_to_legacy2(c, eddsa3) {
    const legacy = Object.assign({}, eddsa3, { ExtendedPoint: eddsa3.Point, CURVE: c });
    return legacy;
  }
  function twistedEdwards2(c) {
    const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new2(c);
    const Point2 = edwards2(CURVE, curveOpts);
    const EDDSA = eddsa2(Point2, eddsaOpts);
    return _eddsa_new_output_to_legacy2(c, EDDSA);
  }
});
var require_hash_to_curve = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.expand_message_xmd = expand_message_xmd;
  exports.expand_message_xof = expand_message_xof;
  exports.hash_to_field = hash_to_field;
  exports.isogenyMap = isogenyMap;
  exports.createHasher = createHasher2;
  var utils_ts_1 = require_utils2();
  var modular_ts_1 = require_modular();
  var os2ip = utils_ts_1.bytesToNumberBE;
  function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << 8 * length)
      throw new Error("invalid I2OSP input: " + value);
    const res = Array.from({ length }).fill(0);
    for (let i22 = length - 1;i22 >= 0; i22--) {
      res[i22] = value & 255;
      value >>>= 8;
    }
    return new Uint8Array(res);
  }
  function strxor(a, b22) {
    const arr = new Uint8Array(a.length);
    for (let i22 = 0;i22 < a.length; i22++) {
      arr[i22] = a[i22] ^ b22[i22];
    }
    return arr;
  }
  function anum(item) {
    if (!Number.isSafeInteger(item))
      throw new Error("number expected");
  }
  function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    (0, utils_ts_1.abytes)(DST);
    anum(lenInBytes);
    if (DST.length > 255)
      DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
      throw new Error("expand_message_xmd: invalid lenInBytes");
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b22 = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b22[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i22 = 1;i22 <= ell; i22++) {
      const args = [strxor(b_0, b22[i22 - 1]), i2osp(i22 + 1, 1), DST_prime];
      b22[i22] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b22);
    return pseudo_random_bytes.slice(0, lenInBytes);
  }
  function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    (0, utils_ts_1.abytes)(DST);
    anum(lenInBytes);
    if (DST.length > 255) {
      const dkLen = Math.ceil(2 * k / 8);
      DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
      throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
  }
  function hash_to_field(msg, count, options) {
    (0, utils_ts_1._validateObject)(options, {
      p: "bigint",
      m: "number",
      k: "number",
      hash: "function"
    });
    const { p, k, m, hash: hash2, expand, DST: _DST } = options;
    if (!(0, utils_ts_1.isBytes)(_DST) && typeof _DST !== "string")
      throw new Error("DST must be string or uint8array");
    if (!(0, utils_ts_1.isHash)(options.hash))
      throw new Error("expected valid hash");
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const DST = typeof _DST === "string" ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8);
    const len_in_bytes = count * m * L;
    let prb;
    if (expand === "xmd") {
      prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
    } else if (expand === "xof") {
      prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
    } else if (expand === "_internal_pass") {
      prb = msg;
    } else {
      throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i22 = 0;i22 < count; i22++) {
      const e = new Array(m);
      for (let j = 0;j < m; j++) {
        const elm_offset = L * (j + i22 * m);
        const tv = prb.subarray(elm_offset, elm_offset + L);
        e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
      }
      u[i22] = e;
    }
    return u;
  }
  function isogenyMap(field, map) {
    const coeff = map.map((i22) => Array.from(i22).reverse());
    return (x2, y) => {
      const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i22) => field.add(field.mul(acc, x2), i22)));
      const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
      x2 = field.mul(xn, xd_inv);
      y = field.mul(y, field.mul(yn, yd_inv));
      return { x: x2, y };
    };
  }
  function createHasher2(Point2, mapToCurve, defaults) {
    if (typeof mapToCurve !== "function")
      throw new Error("mapToCurve() must be defined");
    function map(num) {
      return Point2.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
      const P22 = initial.clearCofactor();
      if (P22.equals(Point2.ZERO))
        return Point2.ZERO;
      P22.assertValidity();
      return P22;
    }
    return {
      defaults,
      hashToCurve(msg, options) {
        const dst = defaults.DST ? defaults.DST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 2, opts);
        const u0 = map(u[0]);
        const u1 = map(u[1]);
        return clear(u0.add(u1));
      },
      encodeToCurve(msg, options) {
        const dst = defaults.encodeDST ? defaults.encodeDST : {};
        const opts = Object.assign({}, defaults, dst, options);
        const u = hash_to_field(msg, 1, opts);
        return clear(map(u[0]));
      },
      mapToCurve(scalars) {
        if (!Array.isArray(scalars))
          throw new Error("expected array of bigints");
        for (const i22 of scalars)
          if (typeof i22 !== "bigint")
            throw new Error("expected array of bigints");
        return clear(map(scalars));
      }
    };
  }
});
var require_montgomery = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.montgomery = montgomery;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var utils_ts_1 = require_utils2();
  var modular_ts_1 = require_modular();
  var _0n92 = BigInt(0);
  var _1n92 = BigInt(1);
  var _2n72 = BigInt(2);
  function validateOpts2(curve) {
    (0, utils_ts_1._validateObject)(curve, {
      adjustScalarBytes: "function",
      powPminus2: "function"
    });
    return Object.freeze({ ...curve });
  }
  function montgomery(curveDef) {
    const CURVE = validateOpts2(curveDef);
    const { P: P22, type: type2, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type2 === "x25519";
    if (!is25519 && type2 !== "x448")
      throw new Error("invalid type");
    const randomBytes_ = rand || utils_ts_1.randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    const minScalar = is25519 ? _2n72 ** BigInt(254) : _2n72 ** BigInt(447);
    const maxAdded = is25519 ? BigInt(8) * _2n72 ** BigInt(251) - _1n92 : BigInt(4) * _2n72 ** BigInt(445) - _1n92;
    const maxScalar = minScalar + maxAdded + _1n92;
    const modP = (n2) => (0, modular_ts_1.mod)(n2, P22);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
      return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
    }
    function decodeU(u) {
      const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);
      if (is25519)
        _u[31] &= 127;
      return modP((0, utils_ts_1.bytesToNumberLE)(_u));
    }
    function decodeScalar(scalar) {
      return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes2((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
      const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
      if (pu === _0n92)
        throw new Error("invalid private or public key received");
      return encodeU(pu);
    }
    function scalarMultBase(scalar) {
      return scalarMult(scalar, GuBytes);
    }
    function cswap(swap2, x_2, x_3) {
      const dummy = modP(swap2 * (x_2 - x_3));
      x_2 = modP(x_2 - dummy);
      x_3 = modP(x_3 + dummy);
      return { x_2, x_3 };
    }
    function montgomeryLadder(u, scalar) {
      (0, utils_ts_1.aInRange)("u", u, _0n92, P22);
      (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
      const k = scalar;
      const x_1 = u;
      let x_2 = _1n92;
      let z_2 = _0n92;
      let x_3 = u;
      let z_3 = _1n92;
      let swap2 = _0n92;
      for (let t = BigInt(montgomeryBits - 1);t >= _0n92; t--) {
        const k_t = k >> t & _1n92;
        swap2 ^= k_t;
        ({ x_2, x_3 } = cswap(swap2, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap2, z_2, z_3));
        swap2 = k_t;
        const A = x_2 + z_2;
        const AA = modP(A * A);
        const B = x_2 - z_2;
        const BB = modP(B * B);
        const E2 = AA - BB;
        const C = x_3 + z_3;
        const D2 = x_3 - z_3;
        const DA = modP(D2 * A);
        const CB = modP(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = modP(dacb * dacb);
        z_3 = modP(x_1 * modP(da_cb * da_cb));
        x_2 = modP(AA * BB);
        z_2 = modP(E2 * (AA + modP(a24 * E2)));
      }
      ({ x_2, x_3 } = cswap(swap2, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap2, z_2, z_3));
      const z2 = powPminus2(z_2);
      return modP(x_2 * z2);
    }
    return {
      scalarMult,
      scalarMultBase,
      getSharedSecret: (privateKey, publicKey2) => scalarMult(privateKey, publicKey2),
      getPublicKey: (privateKey) => scalarMultBase(privateKey),
      utils: { randomPrivateKey: () => randomBytes_(fieldLen) },
      GuBytes: GuBytes.slice()
    };
  }
});
var require_ed25519 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.ed25519_hasher = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = undefined;
  exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
  exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var sha2_js_1 = require_sha2();
  var utils_js_1 = require_utils();
  var curve_ts_1 = require_curve();
  var edwards_ts_1 = require_edwards();
  var hash_to_curve_ts_1 = require_hash_to_curve();
  var modular_ts_1 = require_modular();
  var montgomery_ts_1 = require_montgomery();
  var utils_ts_1 = require_utils2();
  var _0n92 = BigInt(0);
  var _1n92 = BigInt(1);
  var _2n72 = BigInt(2);
  var _3n42 = BigInt(3);
  var _5n32 = BigInt(5);
  var _8n42 = BigInt(8);
  var ed25519_CURVE2 = {
    p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n42,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  };
  function ed25519_pow_2_252_32(x2) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P22 = ed25519_CURVE2.p;
    const x22 = x2 * x2 % P22;
    const b22 = x22 * x2 % P22;
    const b4 = (0, modular_ts_1.pow2)(b22, _2n72, P22) * b22 % P22;
    const b5 = (0, modular_ts_1.pow2)(b4, _1n92, P22) * x2 % P22;
    const b10 = (0, modular_ts_1.pow2)(b5, _5n32, P22) * b5 % P22;
    const b20 = (0, modular_ts_1.pow2)(b10, _10n, P22) * b10 % P22;
    const b40 = (0, modular_ts_1.pow2)(b20, _20n, P22) * b20 % P22;
    const b80 = (0, modular_ts_1.pow2)(b40, _40n, P22) * b40 % P22;
    const b160 = (0, modular_ts_1.pow2)(b80, _80n, P22) * b80 % P22;
    const b240 = (0, modular_ts_1.pow2)(b160, _80n, P22) * b80 % P22;
    const b250 = (0, modular_ts_1.pow2)(b240, _10n, P22) * b10 % P22;
    const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n72, P22) * x2 % P22;
    return { pow_p_5_8, b2: b22 };
  }
  function adjustScalarBytes2(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  var ED25519_SQRT_M12 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  function uvRatio2(u, v) {
    const P22 = ed25519_CURVE2.p;
    const v322 = (0, modular_ts_1.mod)(v * v * v, P22);
    const v7 = (0, modular_ts_1.mod)(v322 * v322 * v, P22);
    const pow3 = ed25519_pow_2_252_32(u * v7).pow_p_5_8;
    let x2 = (0, modular_ts_1.mod)(u * v322 * pow3, P22);
    const vx2 = (0, modular_ts_1.mod)(v * x2 * x2, P22);
    const root1 = x2;
    const root2 = (0, modular_ts_1.mod)(x2 * ED25519_SQRT_M12, P22);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P22);
    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M12, P22);
    if (useRoot1)
      x2 = root1;
    if (useRoot2 || noRoot)
      x2 = root2;
    if ((0, modular_ts_1.isNegativeLE)(x2, P22))
      x2 = (0, modular_ts_1.mod)(-x2, P22);
    return { isValid: useRoot1 || useRoot2, value: x2 };
  }
  exports.ED25519_TORSION_SUBGROUP = [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ];
  var Fp22 = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE2.p, undefined, true))();
  var ed25519Defaults2 = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE2,
    Fp: Fp22,
    hash: sha2_js_1.sha512,
    adjustScalarBytes: adjustScalarBytes2,
    uvRatio: uvRatio2
  }))();
  exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults2))();
  function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
      throw new Error("Context is too big");
    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
  }
  exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
    ...ed25519Defaults2,
    domain: ed25519_domain
  }))();
  exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults2, {
    domain: ed25519_domain,
    prehash: sha2_js_1.sha512
  })))();
  exports.x25519 = (() => {
    const P22 = ed25519_CURVE2.p;
    return (0, montgomery_ts_1.montgomery)({
      P: P22,
      type: "x25519",
      powPminus2: (x2) => {
        const { pow_p_5_8, b2: b22 } = ed25519_pow_2_252_32(x2);
        return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n42, P22) * b22, P22);
      },
      adjustScalarBytes: adjustScalarBytes2
    });
  })();
  function edwardsToMontgomeryPub(edwardsPub) {
    const bpub = (0, utils_ts_1.ensureBytes)("pub", edwardsPub);
    const { y } = exports.ed25519.Point.fromHex(bpub);
    const _1n102 = BigInt(1);
    return Fp22.toBytes(Fp22.create((_1n102 + y) * Fp22.inv(_1n102 - y)));
  }
  exports.edwardsToMontgomery = edwardsToMontgomeryPub;
  function edwardsToMontgomeryPriv(edwardsPriv) {
    const hashed = ed25519Defaults2.hash(edwardsPriv.subarray(0, 32));
    return ed25519Defaults2.adjustScalarBytes(hashed).subarray(0, 32);
  }
  var ELL2_C1 = /* @__PURE__ */ (() => (Fp22.ORDER + _3n42) / _8n42)();
  var ELL2_C2 = /* @__PURE__ */ (() => Fp22.pow(_2n72, ELL2_C1))();
  var ELL2_C3 = /* @__PURE__ */ (() => Fp22.sqrt(Fp22.neg(Fp22.ONE)))();
  function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (Fp22.ORDER - _5n32) / _8n42;
    const ELL2_J = BigInt(486662);
    let tv1 = Fp22.sqr(u);
    tv1 = Fp22.mul(tv1, _2n72);
    let xd = Fp22.add(tv1, Fp22.ONE);
    let x1n = Fp22.neg(ELL2_J);
    let tv2 = Fp22.sqr(xd);
    let gxd = Fp22.mul(tv2, xd);
    let gx1 = Fp22.mul(tv1, ELL2_J);
    gx1 = Fp22.mul(gx1, x1n);
    gx1 = Fp22.add(gx1, tv2);
    gx1 = Fp22.mul(gx1, x1n);
    let tv3 = Fp22.sqr(gxd);
    tv2 = Fp22.sqr(tv3);
    tv3 = Fp22.mul(tv3, gxd);
    tv3 = Fp22.mul(tv3, gx1);
    tv2 = Fp22.mul(tv2, tv3);
    let y11 = Fp22.pow(tv2, ELL2_C4);
    y11 = Fp22.mul(y11, tv3);
    let y12 = Fp22.mul(y11, ELL2_C3);
    tv2 = Fp22.sqr(y11);
    tv2 = Fp22.mul(tv2, gxd);
    let e1 = Fp22.eql(tv2, gx1);
    let y1 = Fp22.cmov(y12, y11, e1);
    let x2n = Fp22.mul(x1n, tv1);
    let y21 = Fp22.mul(y11, u);
    y21 = Fp22.mul(y21, ELL2_C2);
    let y22 = Fp22.mul(y21, ELL2_C3);
    let gx2 = Fp22.mul(gx1, tv1);
    tv2 = Fp22.sqr(y21);
    tv2 = Fp22.mul(tv2, gxd);
    let e2 = Fp22.eql(tv2, gx2);
    let y2 = Fp22.cmov(y22, y21, e2);
    tv2 = Fp22.sqr(y1);
    tv2 = Fp22.mul(tv2, gxd);
    let e3 = Fp22.eql(tv2, gx1);
    let xn = Fp22.cmov(x2n, x1n, e3);
    let y = Fp22.cmov(y2, y1, e3);
    let e4 = Fp22.isOdd(y);
    y = Fp22.cmov(y, Fp22.neg(y), e3 !== e4);
    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n92 };
  }
  var ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp22, Fp22.neg(BigInt(486664))))();
  function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
    let xn = Fp22.mul(xMn, yMd);
    xn = Fp22.mul(xn, ELL2_C1_EDWARDS);
    let xd = Fp22.mul(xMd, yMn);
    let yn = Fp22.sub(xMn, xMd);
    let yd = Fp22.add(xMn, xMd);
    let tv1 = Fp22.mul(xd, yd);
    let e = Fp22.eql(tv1, Fp22.ZERO);
    xn = Fp22.cmov(xn, Fp22.ZERO, e);
    xd = Fp22.cmov(xd, Fp22.ONE, e);
    yn = Fp22.cmov(yn, Fp22.ONE, e);
    yd = Fp22.cmov(yd, Fp22.ONE, e);
    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp22, [xd, yd], true);
    return { x: Fp22.mul(xn, xd_inv), y: Fp22.mul(yn, yd_inv) };
  }
  exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
    encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
    p: Fp22.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha2_js_1.sha512
  }))();
  exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
  exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
  function aristp(other) {
    if (!(other instanceof RistPoint))
      throw new Error("RistrettoPoint expected");
  }
  var SQRT_M1 = ED25519_SQRT_M12;
  var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  var invertSqrt = (number22) => uvRatio2(_1n92, number22);
  var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var bytes255ToNumberLE = (bytes2) => exports.ed25519.CURVE.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes2) & MAX_255B);
  function calcElligatorRistrettoMap(r0) {
    const { d } = exports.ed25519.CURVE;
    const P22 = exports.ed25519.CURVE.Fp.ORDER;
    const mod22 = exports.ed25519.CURVE.Fp.create;
    const r = mod22(SQRT_M1 * r0 * r0);
    const Ns = mod22((r + _1n92) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D2 = mod22((c - d * r) * mod22(r + d));
    let { isValid: Ns_D_is_sq, value: s } = uvRatio2(Ns, D2);
    let s_ = mod22(s * r0);
    if (!(0, modular_ts_1.isNegativeLE)(s_, P22))
      s_ = mod22(-s_);
    if (!Ns_D_is_sq)
      s = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod22(c * (r - _1n92) * D_MINUS_ONE_SQ - D2);
    const s2 = s * s;
    const W0 = mod22((s + s) * D2);
    const W1 = mod22(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod22(_1n92 - s2);
    const W3 = mod22(_1n92 + s2);
    return new exports.ed25519.Point(mod22(W0 * W3), mod22(W2 * W1), mod22(W1 * W3), mod22(W0 * W2));
  }

  class RistPoint {
    constructor(ep) {
      this.ep = ep;
    }
    static fromAffine(ap) {
      return new RistPoint(exports.ed25519.Point.fromAffine(ap));
    }
    static hashToCurve(hex) {
      hex = (0, utils_ts_1.ensureBytes)("ristrettoHash", hex, 64);
      const r1 = bytes255ToNumberLE(hex.slice(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(hex.slice(32, 64));
      const R2 = calcElligatorRistrettoMap(r2);
      return new RistPoint(R1.add(R2));
    }
    static fromBytes(bytes2) {
      (0, utils_js_1.abytes)(bytes2);
      return this.fromHex(bytes2);
    }
    static fromHex(hex) {
      hex = (0, utils_ts_1.ensureBytes)("ristrettoHex", hex, 32);
      const { a, d } = exports.ed25519.CURVE;
      const P22 = Fp22.ORDER;
      const mod22 = Fp22.create;
      const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
      const s = bytes255ToNumberLE(hex);
      if (!(0, utils_ts_1.equalBytes)((0, utils_ts_1.numberToBytesLE)(s, 32), hex) || (0, modular_ts_1.isNegativeLE)(s, P22))
        throw new Error(emsg);
      const s2 = mod22(s * s);
      const u1 = mod22(_1n92 + a * s2);
      const u2 = mod22(_1n92 - a * s2);
      const u1_2 = mod22(u1 * u1);
      const u2_2 = mod22(u2 * u2);
      const v = mod22(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod22(v * u2_2));
      const Dx = mod22(I * u2);
      const Dy = mod22(I * Dx * v);
      let x2 = mod22((s + s) * Dx);
      if ((0, modular_ts_1.isNegativeLE)(x2, P22))
        x2 = mod22(-x2);
      const y = mod22(u1 * Dy);
      const t = mod22(x2 * y);
      if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P22) || y === _0n92)
        throw new Error(emsg);
      return new RistPoint(new exports.ed25519.Point(x2, y, _1n92, t));
    }
    static msm(points, scalars) {
      const Fn = (0, modular_ts_1.Field)(exports.ed25519.CURVE.n, exports.ed25519.CURVE.nBitLength);
      return (0, curve_ts_1.pippenger)(RistPoint, Fn, points, scalars);
    }
    toBytes() {
      let { ex: x2, ey: y, ez: z, et: t } = this.ep;
      const P22 = Fp22.ORDER;
      const mod22 = Fp22.create;
      const u1 = mod22(mod22(z + y) * mod22(z - y));
      const u2 = mod22(x2 * y);
      const u2sq = mod22(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod22(u1 * u2sq));
      const D1 = mod22(invsqrt * u1);
      const D2 = mod22(invsqrt * u2);
      const zInv = mod22(D1 * D2 * t);
      let D3;
      if ((0, modular_ts_1.isNegativeLE)(t * zInv, P22)) {
        let _x = mod22(y * SQRT_M1);
        let _y = mod22(x2 * SQRT_M1);
        x2 = _x;
        y = _y;
        D3 = mod22(D1 * INVSQRT_A_MINUS_D);
      } else {
        D3 = D2;
      }
      if ((0, modular_ts_1.isNegativeLE)(x2 * zInv, P22))
        y = mod22(-y);
      let s = mod22((z - y) * D3);
      if ((0, modular_ts_1.isNegativeLE)(s, P22))
        s = mod22(-s);
      return (0, utils_ts_1.numberToBytesLE)(s, 32);
    }
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return (0, utils_ts_1.bytesToHex)(this.toBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(other) {
      aristp(other);
      const { ex: X1, ey: Y1 } = this.ep;
      const { ex: X2, ey: Y2 } = other.ep;
      const mod22 = Fp22.create;
      const one = mod22(X1 * Y2) === mod22(Y1 * X2);
      const two = mod22(Y1 * Y2) === mod22(X1 * X2);
      return one || two;
    }
    add(other) {
      aristp(other);
      return new RistPoint(this.ep.add(other.ep));
    }
    subtract(other) {
      aristp(other);
      return new RistPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
      return new RistPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
      return new RistPoint(this.ep.multiplyUnsafe(scalar));
    }
    double() {
      return new RistPoint(this.ep.double());
    }
    negate() {
      return new RistPoint(this.ep.negate());
    }
  }
  exports.RistrettoPoint = (() => {
    if (!RistPoint.BASE)
      RistPoint.BASE = new RistPoint(exports.ed25519.Point.BASE);
    if (!RistPoint.ZERO)
      RistPoint.ZERO = new RistPoint(exports.ed25519.Point.ZERO);
    return RistPoint;
  })();
  var hashToRistretto255 = (msg, options) => {
    const d = options.DST;
    const DST = typeof d === "string" ? (0, utils_js_1.utf8ToBytes)(d) : d;
    const uniform_bytes = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
    const P22 = RistPoint.hashToCurve(uniform_bytes);
    return P22;
  };
  exports.hashToRistretto255 = hashToRistretto255;
  exports.hash_to_ristretto255 = exports.hashToRistretto255;
});
var require_sha256 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = undefined;
  var sha2_ts_1 = require_sha2();
  exports.SHA256 = sha2_ts_1.SHA256;
  exports.sha256 = sha2_ts_1.sha256;
  exports.SHA224 = sha2_ts_1.SHA224;
  exports.sha224 = sha2_ts_1.sha224;
});
var require_index_browser = __commonJS2((exports) => {
  var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2 = 1;
  var SOLANA_ERROR__INVALID_NONCE2 = 2;
  var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2 = 3;
  var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2 = 4;
  var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2 = 5;
  var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2 = 6;
  var SOLANA_ERROR__MALFORMED_BIGINT_STRING2 = 7;
  var SOLANA_ERROR__MALFORMED_NUMBER_STRING2 = 8;
  var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2 = 9;
  var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2 = 10;
  var SOLANA_ERROR__JSON_RPC__PARSE_ERROR2 = -32700;
  var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2 = -32603;
  var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2 = -32602;
  var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2 = -32601;
  var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2 = -32600;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2 = -32016;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2 = -32015;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2 = -32014;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2 = -32013;
  var SOLANA_ERROR__JSON_RPC__SCAN_ERROR2 = -32012;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2 = -32011;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2 = -32010;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2 = -32009;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2 = -32008;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2 = -32007;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2 = -32006;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2 = -32005;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2 = -32004;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2 = -32003;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2 = -32002;
  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2 = -32001;
  var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2 = 2800000;
  var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2 = 2800001;
  var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2 = 2800002;
  var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2 = 2800003;
  var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2 = 2800004;
  var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2 = 2800005;
  var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2 = 2800006;
  var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2 = 2800007;
  var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2 = 2800008;
  var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2 = 2800009;
  var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2 = 2800010;
  var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2 = 2800011;
  var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2 = 3230000;
  var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2 = 32300001;
  var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2 = 3230002;
  var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2 = 3230003;
  var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2 = 3230004;
  var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2 = 3610000;
  var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2 = 3610001;
  var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2 = 3610002;
  var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2 = 3610003;
  var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2 = 3610004;
  var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2 = 3610005;
  var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2 = 3610006;
  var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2 = 3610007;
  var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2 = 3611000;
  var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2 = 3704000;
  var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2 = 3704001;
  var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2 = 3704002;
  var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2 = 3704003;
  var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2 = 3704004;
  var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2 = 4128000;
  var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2 = 4128001;
  var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2 = 4128002;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2 = 4615000;
  var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2 = 4615001;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2 = 4615002;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2 = 4615003;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2 = 4615004;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2 = 4615005;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2 = 4615006;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2 = 4615007;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2 = 4615008;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2 = 4615009;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2 = 4615010;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2 = 4615011;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2 = 4615012;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2 = 4615013;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2 = 4615014;
  var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2 = 4615015;
  var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2 = 4615016;
  var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2 = 4615017;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2 = 4615018;
  var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2 = 4615019;
  var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2 = 4615020;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2 = 4615021;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2 = 4615022;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2 = 4615023;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2 = 4615024;
  var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2 = 4615025;
  var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2 = 4615026;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2 = 4615027;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2 = 4615028;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2 = 4615029;
  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2 = 4615030;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2 = 4615031;
  var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2 = 4615032;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2 = 4615033;
  var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2 = 4615034;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2 = 4615035;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2 = 4615036;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2 = 4615037;
  var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2 = 4615038;
  var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2 = 4615039;
  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2 = 4615040;
  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2 = 4615041;
  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2 = 4615042;
  var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2 = 4615043;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2 = 4615044;
  var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2 = 4615045;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2 = 4615046;
  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2 = 4615047;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2 = 4615048;
  var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2 = 4615049;
  var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2 = 4615050;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2 = 4615051;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2 = 4615052;
  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2 = 4615053;
  var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2 = 4615054;
  var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2 = 5508000;
  var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2 = 5508001;
  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2 = 5508002;
  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2 = 5508003;
  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2 = 5508004;
  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2 = 5508005;
  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2 = 5508006;
  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2 = 5508007;
  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2 = 5508008;
  var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2 = 5508009;
  var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2 = 5508010;
  var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2 = 5508011;
  var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2 = 5663000;
  var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2 = 5663001;
  var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2 = 5663002;
  var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2 = 5663003;
  var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2 = 5663004;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2 = 5663005;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2 = 5663006;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2 = 5663007;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2 = 5663008;
  var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2 = 5663009;
  var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2 = 5663010;
  var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2 = 5663011;
  var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2 = 5663012;
  var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2 = 5663013;
  var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2 = 5663014;
  var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2 = 5663015;
  var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2 = 5663016;
  var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2 = 5663017;
  var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2 = 5663018;
  var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2 = 5663019;
  var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2 = 5663020;
  var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2 = 7050000;
  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2 = 7050001;
  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2 = 7050002;
  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2 = 7050003;
  var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2 = 7050004;
  var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2 = 7050005;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2 = 7050006;
  var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2 = 7050007;
  var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2 = 7050008;
  var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2 = 7050009;
  var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2 = 7050010;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2 = 7050011;
  var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2 = 7050012;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2 = 7050013;
  var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2 = 7050014;
  var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2 = 7050015;
  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2 = 7050016;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2 = 7050017;
  var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2 = 7050018;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2 = 7050019;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2 = 7050020;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2 = 7050021;
  var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2 = 7050022;
  var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2 = 7050023;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2 = 7050024;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2 = 7050025;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2 = 7050026;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2 = 7050027;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2 = 7050028;
  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2 = 7050029;
  var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2 = 7050030;
  var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2 = 7050031;
  var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2 = 7050032;
  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2 = 7050033;
  var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2 = 7050034;
  var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2 = 7050035;
  var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2 = 7050036;
  var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2 = 8078000;
  var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2 = 8078001;
  var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2 = 8078002;
  var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2 = 8078003;
  var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2 = 8078004;
  var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2 = 8078005;
  var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2 = 8078006;
  var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2 = 8078007;
  var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2 = 8078008;
  var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2 = 8078009;
  var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2 = 8078010;
  var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2 = 8078011;
  var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2 = 8078012;
  var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2 = 8078013;
  var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2 = 8078014;
  var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2 = 8078015;
  var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2 = 8078016;
  var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2 = 8078017;
  var SOLANA_ERROR__CODECS__INVALID_CONSTANT2 = 8078018;
  var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2 = 8078019;
  var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2 = 8078020;
  var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2 = 8078021;
  var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2 = 8078022;
  var SOLANA_ERROR__RPC__INTEGER_OVERFLOW2 = 8100000;
  var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2 = 8100001;
  var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2 = 8100002;
  var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2 = 8100003;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2 = 8190000;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2 = 8190001;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2 = 8190002;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2 = 8190003;
  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2 = 8190004;
  var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2 = 9900000;
  var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2 = 9900001;
  var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2 = 9900002;
  var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2 = 9900003;
  var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2 = 9900004;
  var SolanaErrorMessages2 = {
    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2]: "Account not found at address: $address",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2]: "Expected decoded account at address: $address",
    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2]: "Failed to decode account data at address: $address",
    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2]: "Accounts not found at addresses: $addresses",
    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2]: "Unable to find a viable program address bump seed.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2]: "$putativeAddress is not a base58-encoded address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2]: "The `CryptoKey` must be an `Ed25519` public key.",
    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2]: "Invalid seeds; point must fall off the Ed25519 curve.",
    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2]: "Program address cannot end with PDA marker.",
    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2]: "The network has progressed past the last block for which this transaction could have been committed.",
    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2]: "Codec [$codecDescription] cannot decode empty byte arrays.",
    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2]: "Encoder and decoder must either both be fixed-size or variable-size.",
    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2]: "Expected a fixed-size codec, got a variable-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2]: "Expected a variable-size codec, got a fixed-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
    [SOLANA_ERROR__CODECS__INVALID_CONSTANT2]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2]: "Invalid literal union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2]: "Expected [$codecDescription] to have $expected items, got $actual.",
    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2]: "Invalid value $value for base $base with alphabet $alphabet.",
    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2]: "No random values implementation could be found.",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2]: "instruction requires an uninitialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2]: "instruction tries to borrow reference for an account which is already borrowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2]: "instruction left account with an outstanding borrowed reference",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2]: "program other than the account's owner changed the size of the account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2]: "account data too small for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2]: "instruction expected an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2]: "An account does not have enough lamports to be rent-exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2]: "Program arithmetic overflowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2]: "Failed to serialize or deserialize account data: $encodedData",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2]: "Builtin programs must consume compute units",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2]: "Cross-program invocation call depth too deep",
    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2]: "Computational budget exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2]: "custom program error: #$code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2]: "instruction contains duplicate accounts",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2]: "instruction modifications of multiply-passed account differ",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2]: "executable accounts must be rent exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2]: "instruction changed executable accounts data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2]: "instruction changed the balance of an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2]: "instruction changed executable bit of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2]: "instruction modified data of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2]: "instruction spent from the balance of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2]: "generic instruction error",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2]: "Provided owner is not allowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2]: "Account is immutable",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2]: "Incorrect authority provided",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2]: "incorrect program id for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2]: "insufficient funds for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2]: "invalid account data for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2]: "Invalid account owner",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2]: "invalid program argument",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2]: "program returned invalid error code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2]: "invalid instruction data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2]: "Failed to reallocate account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2]: "Provided seeds do not result in a valid address",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2]: "Accounts data allocations exceeded the maximum allowed per transaction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2]: "Max accounts exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2]: "Max instruction trace length exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2]: "Length of the seed is too long for address generation",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2]: "An account required by the instruction is missing",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2]: "missing required signature for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2]: "instruction illegally modified the program id of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2]: "insufficient account keys for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2]: "Cross-program invocation with unauthorized signer or writable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2]: "Failed to create program execution environment",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2]: "Program failed to compile",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2]: "Program failed to complete",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2]: "instruction modified data of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2]: "instruction changed the balance of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2]: "Cross-program invocation reentrancy not allowed for this instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2]: "instruction modified rent epoch of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2]: "sum of account balances before and after instruction do not match",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2]: "instruction requires an initialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2]: "",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2]: "Unsupported program id",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2]: "Unsupported sysvar",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2]: "The instruction does not have any accounts.",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2]: "The instruction does not have any data.",
    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__INVALID_NONCE2]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR2]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2]: "Minimum context slot has not been reached",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2]: "Node is unhealthy; behind by $numSlotsBehind slots",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2]: "No snapshot",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2]: "Transaction simulation failed",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2]: "Transaction history is not available from this node",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2]: "Transaction signature length mismatch",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2]: "Transaction signature verification failure",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2]: "$__serverMessage",
    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2]: "Key pair bytes must be of length 64, got $byteLength.",
    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2]: "Expected private key bytes with length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2]: "The provided private key does not match the provided public key.",
    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2]: "Lamports value must be in the range [0, 2e64-1]",
    [SOLANA_ERROR__MALFORMED_BIGINT_STRING2]: "`$value` cannot be parsed as a `BigInt`",
    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2]: "$message",
    [SOLANA_ERROR__MALFORMED_NUMBER_STRING2]: "`$value` cannot be parsed as a `Number`",
    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2]: "No nonce account could be found at address `$nonceAccountAddress`",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2]: "WebSocket was closed before payload could be added to the send buffer",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2]: "WebSocket connection closed",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2]: "WebSocket failed to connect",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2]: "Failed to obtain a subscription id from the server",
    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2]: "Could not find an API plan for RPC method: `$method`",
    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW2]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2]: "HTTP error ($statusCode): $message",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2]: "The provided value does not implement the `KeyPairSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2]: "The provided value does not implement the `MessageModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2]: "The provided value does not implement the `MessagePartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2]: "The provided value does not implement any of the `MessageSigner` interfaces",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2]: "The provided value does not implement the `TransactionModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2]: "The provided value does not implement the `TransactionPartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2]: "The provided value does not implement the `TransactionSendingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2]: "The provided value does not implement any of the `TransactionSigner` interfaces",
    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2]: "More than one `TransactionSendingSigner` was identified.",
    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2]: "Cannot export a non-extractable key.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2]: "No digest implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2]: `This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,
    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2]: "No signature verification implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2]: "No key generation implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2]: "No signing implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2]: "No key export implementation could be found.",
    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2]: "Transaction processing left an account with an outstanding borrowed reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2]: "Account in use",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2]: "Account loaded twice",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2]: "Attempt to debit an account but found no record of a prior credit.",
    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2]: "Transaction loads an address table account that doesn't exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2]: "This transaction has already been processed",
    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2]: "Blockhash not found",
    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2]: "Loader call chain is too deep",
    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2]: "Transactions are currently disabled due to cluster maintenance",
    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2]: "Transaction contains a duplicate instruction ($index) that is not allowed",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2]: "Insufficient funds for fee",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2]: "This account may not be used to pay transaction fees",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2]: "Transaction contains an invalid account reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2]: "Transaction loads an address table account with invalid data",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2]: "Transaction address table lookup uses an invalid index",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2]: "Transaction loads an address table account with an invalid owner",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2]: "This program may not be used for executing instructions",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2]: "Transaction loads a writable account that cannot be written",
    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2]: "Transaction exceeded max loaded accounts data size cap",
    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2]: "Transaction requires a fee but has no signature present",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2]: "Attempt to load a program that does not exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2]: "ResanitizationNeeded",
    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2]: "Transaction failed to sanitize accounts offsets correctly",
    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2]: "Transaction did not pass signature verification",
    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2]: "Transaction locked too many accounts",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2]: "Sum of account balances before and after transaction do not match",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2]: "The transaction failed with the error `$errorName`",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2]: "Transaction version is unsupported",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2]: "Transaction would exceed account data limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2]: "Transaction would exceed total account data limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2]: "Transaction would exceed max account limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2]: "Transaction would exceed max Block Cost Limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2]: "Transaction would exceed max Vote Cost Limit",
    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2]: "Attempted to sign a transaction with an address that is not a signer for it",
    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2]: "Transaction is missing an address at index: $index.",
    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2]: "Transaction has no expected signers therefore it cannot be encoded",
    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2]: "Transaction does not have a blockhash lifetime",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2]: "Transaction is not a durable nonce transaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2]: "No fee payer set in CompiledTransaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2]: "Could not find program address at index $index",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2]: "Transaction is missing a fee payer.",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2]: "Transaction first instruction is not advance nonce account instruction.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2]: "Transaction with no instructions cannot be durable nonce transaction.",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2]: "Transaction is missing signatures for addresses: $addresses.",
    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
  };
  var START_INDEX2 = "i";
  var TYPE2 = "t";
  function getHumanReadableErrorMessage2(code2, context = {}) {
    const messageFormatString = SolanaErrorMessages2[code2];
    if (messageFormatString.length === 0) {
      return "";
    }
    let state;
    function commitStateUpTo(endIndex) {
      if (state[TYPE2] === 2) {
        const variableName = messageFormatString.slice(state[START_INDEX2] + 1, endIndex);
        fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);
      } else if (state[TYPE2] === 1) {
        fragments.push(messageFormatString.slice(state[START_INDEX2], endIndex));
      }
    }
    const fragments = [];
    messageFormatString.split("").forEach((char, ii) => {
      if (ii === 0) {
        state = {
          [START_INDEX2]: 0,
          [TYPE2]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        };
        return;
      }
      let nextState;
      switch (state[TYPE2]) {
        case 0:
          nextState = { [START_INDEX2]: ii, [TYPE2]: 1 };
          break;
        case 1:
          if (char === "\\") {
            nextState = { [START_INDEX2]: ii, [TYPE2]: 0 };
          } else if (char === "$") {
            nextState = { [START_INDEX2]: ii, [TYPE2]: 2 };
          }
          break;
        case 2:
          if (char === "\\") {
            nextState = { [START_INDEX2]: ii, [TYPE2]: 0 };
          } else if (char === "$") {
            nextState = { [START_INDEX2]: ii, [TYPE2]: 2 };
          } else if (!char.match(/\w/)) {
            nextState = { [START_INDEX2]: ii, [TYPE2]: 1 };
          }
          break;
      }
      if (nextState) {
        if (state !== nextState) {
          commitStateUpTo(ii);
        }
        state = nextState;
      }
    });
    commitStateUpTo();
    return fragments.join("");
  }
  function getErrorMessage2(code2, context = {}) {
    if (true) {
      return getHumanReadableErrorMessage2(code2, context);
    } else {}
  }
  function isSolanaError(e, code2) {
    const isSolanaError2 = e instanceof Error && e.name === "SolanaError";
    if (isSolanaError2) {
      if (code2 !== undefined) {
        return e.context.__code === code2;
      }
      return true;
    }
    return false;
  }
  var SolanaError2 = class extends Error {
    cause = this.cause;
    context;
    constructor(...[code2, contextAndErrorOptions]) {
      let context;
      let errorOptions;
      if (contextAndErrorOptions) {
        const { cause, ...contextRest } = contextAndErrorOptions;
        if (cause) {
          errorOptions = { cause };
        }
        if (Object.keys(contextRest).length > 0) {
          context = contextRest;
        }
      }
      const message = getErrorMessage2(code2, context);
      super(message, errorOptions);
      this.context = {
        __code: code2,
        ...context
      };
      this.name = "SolanaError";
    }
  };
  function safeCaptureStackTrace(...args) {
    if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(...args);
    }
  }
  function getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {
    let rpcErrorName;
    let rpcErrorContext;
    if (typeof rpcEnumError === "string") {
      rpcErrorName = rpcEnumError;
    } else {
      rpcErrorName = Object.keys(rpcEnumError)[0];
      rpcErrorContext = rpcEnumError[rpcErrorName];
    }
    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);
    const errorCode = errorCodeBaseOffset + codeOffset;
    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);
    const err = new SolanaError2(errorCode, errorContext);
    safeCaptureStackTrace(err, constructorOpt);
    return err;
  }
  var ORDERED_ERROR_NAMES = [
    "GenericError",
    "InvalidArgument",
    "InvalidInstructionData",
    "InvalidAccountData",
    "AccountDataTooSmall",
    "InsufficientFunds",
    "IncorrectProgramId",
    "MissingRequiredSignature",
    "AccountAlreadyInitialized",
    "UninitializedAccount",
    "UnbalancedInstruction",
    "ModifiedProgramId",
    "ExternalAccountLamportSpend",
    "ExternalAccountDataModified",
    "ReadonlyLamportChange",
    "ReadonlyDataModified",
    "DuplicateAccountIndex",
    "ExecutableModified",
    "RentEpochModified",
    "NotEnoughAccountKeys",
    "AccountDataSizeChanged",
    "AccountNotExecutable",
    "AccountBorrowFailed",
    "AccountBorrowOutstanding",
    "DuplicateAccountOutOfSync",
    "Custom",
    "InvalidError",
    "ExecutableDataModified",
    "ExecutableLamportChange",
    "ExecutableAccountNotRentExempt",
    "UnsupportedProgramId",
    "CallDepth",
    "MissingAccount",
    "ReentrancyNotAllowed",
    "MaxSeedLengthExceeded",
    "InvalidSeeds",
    "InvalidRealloc",
    "ComputationalBudgetExceeded",
    "PrivilegeEscalation",
    "ProgramEnvironmentSetupFailure",
    "ProgramFailedToComplete",
    "ProgramFailedToCompile",
    "Immutable",
    "IncorrectAuthority",
    "BorshIoError",
    "AccountNotRentExempt",
    "InvalidAccountOwner",
    "ArithmeticOverflow",
    "UnsupportedSysvar",
    "IllegalOwner",
    "MaxAccountsDataAllocationsExceeded",
    "MaxAccountsExceeded",
    "MaxInstructionTraceLengthExceeded",
    "BuiltinProgramsMustConsumeComputeUnits"
  ];
  function getSolanaErrorFromInstructionError(index, instructionError) {
    const numberIndex = Number(index);
    return getSolanaErrorFromRpcError({
      errorCodeBaseOffset: 4615001,
      getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
        if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2) {
          return {
            errorName: rpcErrorName,
            index: numberIndex,
            ...rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null
          };
        } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2) {
          return {
            code: Number(rpcErrorContext),
            index: numberIndex
          };
        } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2) {
          return {
            encodedData: rpcErrorContext,
            index: numberIndex
          };
        }
        return { index: numberIndex };
      },
      orderedErrorNames: ORDERED_ERROR_NAMES,
      rpcEnumError: instructionError
    }, getSolanaErrorFromInstructionError);
  }
  var ORDERED_ERROR_NAMES2 = [
    "AccountInUse",
    "AccountLoadedTwice",
    "AccountNotFound",
    "ProgramAccountNotFound",
    "InsufficientFundsForFee",
    "InvalidAccountForFee",
    "AlreadyProcessed",
    "BlockhashNotFound",
    "CallChainTooDeep",
    "MissingSignatureForFee",
    "InvalidAccountIndex",
    "SignatureFailure",
    "InvalidProgramForExecution",
    "SanitizeFailure",
    "ClusterMaintenance",
    "AccountBorrowOutstanding",
    "WouldExceedMaxBlockCostLimit",
    "UnsupportedVersion",
    "InvalidWritableAccount",
    "WouldExceedMaxAccountCostLimit",
    "WouldExceedAccountDataBlockLimit",
    "TooManyAccountLocks",
    "AddressLookupTableNotFound",
    "InvalidAddressLookupTableOwner",
    "InvalidAddressLookupTableData",
    "InvalidAddressLookupTableIndex",
    "InvalidRentPayingAccount",
    "WouldExceedMaxVoteCostLimit",
    "WouldExceedAccountDataTotalLimit",
    "DuplicateInstruction",
    "InsufficientFundsForRent",
    "MaxLoadedAccountsDataSizeExceeded",
    "InvalidLoadedAccountsDataSizeLimit",
    "ResanitizationNeeded",
    "ProgramExecutionTemporarilyRestricted",
    "UnbalancedTransaction"
  ];
  function getSolanaErrorFromTransactionError(transactionError) {
    if (typeof transactionError === "object" && "InstructionError" in transactionError) {
      return getSolanaErrorFromInstructionError(...transactionError.InstructionError);
    }
    return getSolanaErrorFromRpcError({
      errorCodeBaseOffset: 7050001,
      getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
        if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2) {
          return {
            errorName: rpcErrorName,
            ...rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null
          };
        } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2) {
          return {
            index: Number(rpcErrorContext)
          };
        } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2 || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2) {
          return {
            accountIndex: Number(rpcErrorContext.account_index)
          };
        }
      },
      orderedErrorNames: ORDERED_ERROR_NAMES2,
      rpcEnumError: transactionError
    }, getSolanaErrorFromTransactionError);
  }
  function getSolanaErrorFromJsonRpcError(putativeErrorResponse) {
    let out;
    if (isRpcErrorResponse(putativeErrorResponse)) {
      const { code: rawCode, data, message } = putativeErrorResponse;
      const code2 = Number(rawCode);
      if (code2 === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2) {
        const { err, ...preflightErrorContext } = data;
        const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;
        out = new SolanaError2(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2, {
          ...preflightErrorContext,
          ...causeObject
        });
      } else {
        let errorContext;
        switch (code2) {
          case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2:
          case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2:
          case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2:
          case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2:
          case SOLANA_ERROR__JSON_RPC__PARSE_ERROR2:
          case SOLANA_ERROR__JSON_RPC__SCAN_ERROR2:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2:
            errorContext = { __serverMessage: message };
            break;
          default:
            if (typeof data === "object" && !Array.isArray(data)) {
              errorContext = data;
            }
        }
        out = new SolanaError2(code2, errorContext);
      }
    } else {
      const message = typeof putativeErrorResponse === "object" && putativeErrorResponse !== null && "message" in putativeErrorResponse && typeof putativeErrorResponse.message === "string" ? putativeErrorResponse.message : "Malformed JSON-RPC error with no message attribute";
      out = new SolanaError2(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2, { error: putativeErrorResponse, message });
    }
    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);
    return out;
  }
  function isRpcErrorResponse(value) {
    return typeof value === "object" && value !== null && "code" in value && "message" in value && (typeof value.code === "number" || typeof value.code === "bigint") && typeof value.message === "string";
  }
  exports.SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2;
  exports.SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2;
  exports.SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2;
  exports.SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2;
  exports.SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2;
  exports.SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2;
  exports.SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2;
  exports.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2;
  exports.SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2;
  exports.SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2;
  exports.SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2;
  exports.SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2;
  exports.SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2;
  exports.SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2;
  exports.SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2;
  exports.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2;
  exports.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2;
  exports.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2;
  exports.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2;
  exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2;
  exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2;
  exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2;
  exports.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2;
  exports.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2;
  exports.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2;
  exports.SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2;
  exports.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2;
  exports.SOLANA_ERROR__CODECS__INVALID_CONSTANT = SOLANA_ERROR__CODECS__INVALID_CONSTANT2;
  exports.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2;
  exports.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2;
  exports.SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2;
  exports.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2;
  exports.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2;
  exports.SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2;
  exports.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2;
  exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2;
  exports.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2;
  exports.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2;
  exports.SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2;
  exports.SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2;
  exports.SOLANA_ERROR__INVALID_NONCE = SOLANA_ERROR__INVALID_NONCE2;
  exports.SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2;
  exports.SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2;
  exports.SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2;
  exports.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2;
  exports.SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2;
  exports.SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2;
  exports.SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2;
  exports.SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2;
  exports.SOLANA_ERROR__JSON_RPC__PARSE_ERROR = SOLANA_ERROR__JSON_RPC__PARSE_ERROR2;
  exports.SOLANA_ERROR__JSON_RPC__SCAN_ERROR = SOLANA_ERROR__JSON_RPC__SCAN_ERROR2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2;
  exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2;
  exports.SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2;
  exports.SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2;
  exports.SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2;
  exports.SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2;
  exports.SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__MALFORMED_BIGINT_STRING = SOLANA_ERROR__MALFORMED_BIGINT_STRING2;
  exports.SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2;
  exports.SOLANA_ERROR__MALFORMED_NUMBER_STRING = SOLANA_ERROR__MALFORMED_NUMBER_STRING2;
  exports.SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2;
  exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2;
  exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2;
  exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2;
  exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2;
  exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2;
  exports.SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2;
  exports.SOLANA_ERROR__RPC__INTEGER_OVERFLOW = SOLANA_ERROR__RPC__INTEGER_OVERFLOW2;
  exports.SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2;
  exports.SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2;
  exports.SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2;
  exports.SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2;
  exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2;
  exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2;
  exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2;
  exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2;
  exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2;
  exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2;
  exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2;
  exports.SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2;
  exports.SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2;
  exports.SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2;
  exports.SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2;
  exports.SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2;
  exports.SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2;
  exports.SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2;
  exports.SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2;
  exports.SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2;
  exports.SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2;
  exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2;
  exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2;
  exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2;
  exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2;
  exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2;
  exports.SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2;
  exports.SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2;
  exports.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2;
  exports.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2;
  exports.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2;
  exports.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2;
  exports.SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2;
  exports.SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2;
  exports.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2;
  exports.SolanaError = SolanaError2;
  exports.getSolanaErrorFromInstructionError = getSolanaErrorFromInstructionError;
  exports.getSolanaErrorFromJsonRpcError = getSolanaErrorFromJsonRpcError;
  exports.getSolanaErrorFromTransactionError = getSolanaErrorFromTransactionError;
  exports.isSolanaError = isSolanaError;
  exports.safeCaptureStackTrace = safeCaptureStackTrace;
});
var require_index_browser2 = __commonJS2((exports) => {
  var errors = require_index_browser();
  var mergeBytes = (byteArrays) => {
    const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);
    if (nonEmptyByteArrays.length === 0) {
      return byteArrays.length ? byteArrays[0] : new Uint8Array;
    }
    if (nonEmptyByteArrays.length === 1) {
      return nonEmptyByteArrays[0];
    }
    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset2 = 0;
    nonEmptyByteArrays.forEach((arr) => {
      result.set(arr, offset2);
      offset2 += arr.length;
    });
    return result;
  };
  var padBytes = (bytes2, length) => {
    if (bytes2.length >= length)
      return bytes2;
    const paddedBytes = new Uint8Array(length).fill(0);
    paddedBytes.set(bytes2);
    return paddedBytes;
  };
  var fixBytes = (bytes2, length) => padBytes(bytes2.length <= length ? bytes2 : bytes2.slice(0, length), length);
  function containsBytes(data, bytes2, offset2) {
    const slice = offset2 === 0 && data.length === bytes2.length ? data : data.slice(offset2, offset2 + bytes2.length);
    if (slice.length !== bytes2.length)
      return false;
    return bytes2.every((b22, i22) => b22 === slice[i22]);
  }
  function getEncodedSize2(value, encoder) {
    return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
  }
  function createEncoder2(encoder) {
    return Object.freeze({
      ...encoder,
      encode: (value) => {
        const bytes2 = new Uint8Array(getEncodedSize2(value, encoder));
        encoder.write(value, bytes2, 0);
        return bytes2;
      }
    });
  }
  function createDecoder2(decoder) {
    return Object.freeze({
      ...decoder,
      decode: (bytes2, offset2 = 0) => decoder.read(bytes2, offset2)[0]
    });
  }
  function createCodec(codec) {
    return Object.freeze({
      ...codec,
      decode: (bytes2, offset2 = 0) => codec.read(bytes2, offset2)[0],
      encode: (value) => {
        const bytes2 = new Uint8Array(getEncodedSize2(value, codec));
        codec.write(value, bytes2, 0);
        return bytes2;
      }
    });
  }
  function isFixedSize2(codec) {
    return "fixedSize" in codec && typeof codec.fixedSize === "number";
  }
  function assertIsFixedSize(codec) {
    if (!isFixedSize2(codec)) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);
    }
  }
  function isVariableSize(codec) {
    return !isFixedSize2(codec);
  }
  function assertIsVariableSize(codec) {
    if (!isVariableSize(codec)) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);
    }
  }
  function combineCodec2(encoder, decoder) {
    if (isFixedSize2(encoder) !== isFixedSize2(decoder)) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
    }
    if (isFixedSize2(encoder) && isFixedSize2(decoder) && encoder.fixedSize !== decoder.fixedSize) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
        decoderFixedSize: decoder.fixedSize,
        encoderFixedSize: encoder.fixedSize
      });
    }
    if (!isFixedSize2(encoder) && !isFixedSize2(decoder) && encoder.maxSize !== decoder.maxSize) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
        decoderMaxSize: decoder.maxSize,
        encoderMaxSize: encoder.maxSize
      });
    }
    return {
      ...decoder,
      ...encoder,
      decode: decoder.decode,
      encode: encoder.encode,
      read: decoder.read,
      write: encoder.write
    };
  }
  function addEncoderSentinel(encoder, sentinel) {
    const write2 = (value, bytes2, offset2) => {
      const encoderBytes = encoder.encode(value);
      if (findSentinelIndex(encoderBytes, sentinel) >= 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {
          encodedBytes: encoderBytes,
          hexEncodedBytes: hexBytes(encoderBytes),
          hexSentinel: hexBytes(sentinel),
          sentinel
        });
      }
      bytes2.set(encoderBytes, offset2);
      offset2 += encoderBytes.length;
      bytes2.set(sentinel, offset2);
      offset2 += sentinel.length;
      return offset2;
    };
    if (isFixedSize2(encoder)) {
      return createEncoder2({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write: write2 });
    }
    return createEncoder2({
      ...encoder,
      ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},
      getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,
      write: write2
    });
  }
  function addDecoderSentinel(decoder, sentinel) {
    const read2 = (bytes2, offset2) => {
      const candidateBytes = offset2 === 0 ? bytes2 : bytes2.slice(offset2);
      const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);
      if (sentinelIndex === -1) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {
          decodedBytes: candidateBytes,
          hexDecodedBytes: hexBytes(candidateBytes),
          hexSentinel: hexBytes(sentinel),
          sentinel
        });
      }
      const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);
      return [decoder.decode(preSentinelBytes), offset2 + preSentinelBytes.length + sentinel.length];
    };
    if (isFixedSize2(decoder)) {
      return createDecoder2({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read: read2 });
    }
    return createDecoder2({
      ...decoder,
      ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},
      read: read2
    });
  }
  function addCodecSentinel(codec, sentinel) {
    return combineCodec2(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));
  }
  function findSentinelIndex(bytes2, sentinel) {
    return bytes2.findIndex((byte, index, arr) => {
      if (sentinel.length === 1)
        return byte === sentinel[0];
      return containsBytes(arr, sentinel, index);
    });
  }
  function hexBytes(bytes2) {
    return bytes2.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  }
  function assertByteArrayIsNotEmptyForCodec2(codecDescription, bytes2, offset2 = 0) {
    if (bytes2.length - offset2 <= 0) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
        codecDescription
      });
    }
  }
  function assertByteArrayHasEnoughBytesForCodec2(codecDescription, expected, bytes2, offset2 = 0) {
    const bytesLength = bytes2.length - offset2;
    if (bytesLength < expected) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
        bytesLength,
        codecDescription,
        expected
      });
    }
  }
  function assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset2, bytesLength) {
    if (offset2 < 0 || offset2 > bytesLength) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {
        bytesLength,
        codecDescription,
        offset: offset2
      });
    }
  }
  function addEncoderSizePrefix(encoder, prefix) {
    const write2 = (value, bytes2, offset2) => {
      const encoderBytes = encoder.encode(value);
      offset2 = prefix.write(encoderBytes.length, bytes2, offset2);
      bytes2.set(encoderBytes, offset2);
      return offset2 + encoderBytes.length;
    };
    if (isFixedSize2(prefix) && isFixedSize2(encoder)) {
      return createEncoder2({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write: write2 });
    }
    const prefixMaxSize = isFixedSize2(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
    const encoderMaxSize = isFixedSize2(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;
    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;
    return createEncoder2({
      ...encoder,
      ...maxSize !== null ? { maxSize } : {},
      getSizeFromValue: (value) => {
        const encoderSize = getEncodedSize2(value, encoder);
        return getEncodedSize2(encoderSize, prefix) + encoderSize;
      },
      write: write2
    });
  }
  function addDecoderSizePrefix(decoder, prefix) {
    const read2 = (bytes2, offset2) => {
      const [bigintSize, decoderOffset] = prefix.read(bytes2, offset2);
      const size = Number(bigintSize);
      offset2 = decoderOffset;
      if (offset2 > 0 || bytes2.length > size) {
        bytes2 = bytes2.slice(offset2, offset2 + size);
      }
      assertByteArrayHasEnoughBytesForCodec2("addDecoderSizePrefix", size, bytes2);
      return [decoder.decode(bytes2), offset2 + size];
    };
    if (isFixedSize2(prefix) && isFixedSize2(decoder)) {
      return createDecoder2({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read: read2 });
    }
    const prefixMaxSize = isFixedSize2(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
    const decoderMaxSize = isFixedSize2(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;
    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;
    return createDecoder2({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read: read2 });
  }
  function addCodecSizePrefix(codec, prefix) {
    return combineCodec2(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));
  }
  function fixEncoderSize(encoder, fixedBytes) {
    return createEncoder2({
      fixedSize: fixedBytes,
      write: (value, bytes2, offset2) => {
        const variableByteArray = encoder.encode(value);
        const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
        bytes2.set(fixedByteArray, offset2);
        return offset2 + fixedBytes;
      }
    });
  }
  function fixDecoderSize(decoder, fixedBytes) {
    return createDecoder2({
      fixedSize: fixedBytes,
      read: (bytes2, offset2) => {
        assertByteArrayHasEnoughBytesForCodec2("fixCodecSize", fixedBytes, bytes2, offset2);
        if (offset2 > 0 || bytes2.length > fixedBytes) {
          bytes2 = bytes2.slice(offset2, offset2 + fixedBytes);
        }
        if (isFixedSize2(decoder)) {
          bytes2 = fixBytes(bytes2, decoder.fixedSize);
        }
        const [value] = decoder.read(bytes2, 0);
        return [value, offset2 + fixedBytes];
      }
    });
  }
  function fixCodecSize(codec, fixedBytes) {
    return combineCodec2(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));
  }
  function offsetEncoder(encoder, config2) {
    return createEncoder2({
      ...encoder,
      write: (value, bytes2, preOffset) => {
        const wrapBytes = (offset2) => modulo(offset2, bytes2.length);
        const newPreOffset = config2.preOffset ? config2.preOffset({ bytes: bytes2, preOffset, wrapBytes }) : preOffset;
        assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPreOffset, bytes2.length);
        const postOffset = encoder.write(value, bytes2, newPreOffset);
        const newPostOffset = config2.postOffset ? config2.postOffset({ bytes: bytes2, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
        assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPostOffset, bytes2.length);
        return newPostOffset;
      }
    });
  }
  function offsetDecoder(decoder, config2) {
    return createDecoder2({
      ...decoder,
      read: (bytes2, preOffset) => {
        const wrapBytes = (offset2) => modulo(offset2, bytes2.length);
        const newPreOffset = config2.preOffset ? config2.preOffset({ bytes: bytes2, preOffset, wrapBytes }) : preOffset;
        assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPreOffset, bytes2.length);
        const [value, postOffset] = decoder.read(bytes2, newPreOffset);
        const newPostOffset = config2.postOffset ? config2.postOffset({ bytes: bytes2, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
        assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPostOffset, bytes2.length);
        return [value, newPostOffset];
      }
    });
  }
  function offsetCodec(codec, config2) {
    return combineCodec2(offsetEncoder(codec, config2), offsetDecoder(codec, config2));
  }
  function modulo(dividend, divisor) {
    if (divisor === 0)
      return 0;
    return (dividend % divisor + divisor) % divisor;
  }
  function resizeEncoder(encoder, resize) {
    if (isFixedSize2(encoder)) {
      const fixedSize = resize(encoder.fixedSize);
      if (fixedSize < 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
          bytesLength: fixedSize,
          codecDescription: "resizeEncoder"
        });
      }
      return createEncoder2({ ...encoder, fixedSize });
    }
    return createEncoder2({
      ...encoder,
      getSizeFromValue: (value) => {
        const newSize = resize(encoder.getSizeFromValue(value));
        if (newSize < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
            bytesLength: newSize,
            codecDescription: "resizeEncoder"
          });
        }
        return newSize;
      }
    });
  }
  function resizeDecoder(decoder, resize) {
    if (isFixedSize2(decoder)) {
      const fixedSize = resize(decoder.fixedSize);
      if (fixedSize < 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
          bytesLength: fixedSize,
          codecDescription: "resizeDecoder"
        });
      }
      return createDecoder2({ ...decoder, fixedSize });
    }
    return decoder;
  }
  function resizeCodec(codec, resize) {
    return combineCodec2(resizeEncoder(codec, resize), resizeDecoder(codec, resize));
  }
  function padLeftEncoder(encoder, offset2) {
    return offsetEncoder(resizeEncoder(encoder, (size) => size + offset2), { preOffset: ({ preOffset }) => preOffset + offset2 });
  }
  function padRightEncoder(encoder, offset2) {
    return offsetEncoder(resizeEncoder(encoder, (size) => size + offset2), { postOffset: ({ postOffset }) => postOffset + offset2 });
  }
  function padLeftDecoder(decoder, offset2) {
    return offsetDecoder(resizeDecoder(decoder, (size) => size + offset2), { preOffset: ({ preOffset }) => preOffset + offset2 });
  }
  function padRightDecoder(decoder, offset2) {
    return offsetDecoder(resizeDecoder(decoder, (size) => size + offset2), { postOffset: ({ postOffset }) => postOffset + offset2 });
  }
  function padLeftCodec(codec, offset2) {
    return combineCodec2(padLeftEncoder(codec, offset2), padLeftDecoder(codec, offset2));
  }
  function padRightCodec(codec, offset2) {
    return combineCodec2(padRightEncoder(codec, offset2), padRightDecoder(codec, offset2));
  }
  function copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {
    while (sourceOffset < --sourceLength) {
      const leftValue = source[sourceOffset];
      target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];
      target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;
      sourceOffset++;
    }
    if (sourceOffset === sourceLength) {
      target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];
    }
  }
  function reverseEncoder(encoder) {
    assertIsFixedSize(encoder);
    return createEncoder2({
      ...encoder,
      write: (value, bytes2, offset2) => {
        const newOffset = encoder.write(value, bytes2, offset2);
        copySourceToTargetInReverse(bytes2, bytes2, offset2, offset2 + encoder.fixedSize);
        return newOffset;
      }
    });
  }
  function reverseDecoder(decoder) {
    assertIsFixedSize(decoder);
    return createDecoder2({
      ...decoder,
      read: (bytes2, offset2) => {
        const reversedBytes = bytes2.slice();
        copySourceToTargetInReverse(bytes2, reversedBytes, offset2, offset2 + decoder.fixedSize);
        return decoder.read(reversedBytes, offset2);
      }
    });
  }
  function reverseCodec(codec) {
    return combineCodec2(reverseEncoder(codec), reverseDecoder(codec));
  }
  function transformEncoder(encoder, unmap) {
    return createEncoder2({
      ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,
      write: (value, bytes2, offset2) => encoder.write(unmap(value), bytes2, offset2)
    });
  }
  function transformDecoder(decoder, map) {
    return createDecoder2({
      ...decoder,
      read: (bytes2, offset2) => {
        const [value, newOffset] = decoder.read(bytes2, offset2);
        return [map(value, bytes2, offset2), newOffset];
      }
    });
  }
  function transformCodec(codec, unmap, map) {
    return createCodec({
      ...transformEncoder(codec, unmap),
      read: map ? transformDecoder(codec, map).read : codec.read
    });
  }
  exports.addCodecSentinel = addCodecSentinel;
  exports.addCodecSizePrefix = addCodecSizePrefix;
  exports.addDecoderSentinel = addDecoderSentinel;
  exports.addDecoderSizePrefix = addDecoderSizePrefix;
  exports.addEncoderSentinel = addEncoderSentinel;
  exports.addEncoderSizePrefix = addEncoderSizePrefix;
  exports.assertByteArrayHasEnoughBytesForCodec = assertByteArrayHasEnoughBytesForCodec2;
  exports.assertByteArrayIsNotEmptyForCodec = assertByteArrayIsNotEmptyForCodec2;
  exports.assertByteArrayOffsetIsNotOutOfRange = assertByteArrayOffsetIsNotOutOfRange;
  exports.assertIsFixedSize = assertIsFixedSize;
  exports.assertIsVariableSize = assertIsVariableSize;
  exports.combineCodec = combineCodec2;
  exports.containsBytes = containsBytes;
  exports.createCodec = createCodec;
  exports.createDecoder = createDecoder2;
  exports.createEncoder = createEncoder2;
  exports.fixBytes = fixBytes;
  exports.fixCodecSize = fixCodecSize;
  exports.fixDecoderSize = fixDecoderSize;
  exports.fixEncoderSize = fixEncoderSize;
  exports.getEncodedSize = getEncodedSize2;
  exports.isFixedSize = isFixedSize2;
  exports.isVariableSize = isVariableSize;
  exports.mergeBytes = mergeBytes;
  exports.offsetCodec = offsetCodec;
  exports.offsetDecoder = offsetDecoder;
  exports.offsetEncoder = offsetEncoder;
  exports.padBytes = padBytes;
  exports.padLeftCodec = padLeftCodec;
  exports.padLeftDecoder = padLeftDecoder;
  exports.padLeftEncoder = padLeftEncoder;
  exports.padRightCodec = padRightCodec;
  exports.padRightDecoder = padRightDecoder;
  exports.padRightEncoder = padRightEncoder;
  exports.resizeCodec = resizeCodec;
  exports.resizeDecoder = resizeDecoder;
  exports.resizeEncoder = resizeEncoder;
  exports.reverseCodec = reverseCodec;
  exports.reverseDecoder = reverseDecoder;
  exports.reverseEncoder = reverseEncoder;
  exports.transformCodec = transformCodec;
  exports.transformDecoder = transformDecoder;
  exports.transformEncoder = transformEncoder;
});
var require_index_browser3 = __commonJS2((exports) => {
  var errors = require_index_browser();
  var codecsCore = require_index_browser2();
  function assertNumberIsBetweenForCodec2(codecDescription, min2, max2, value) {
    if (value < min2 || value > max2) {
      throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
        codecDescription,
        max: max2,
        min: min2,
        value
      });
    }
  }
  var Endian = /* @__PURE__ */ ((Endian2) => {
    Endian2[Endian2["Little"] = 0] = "Little";
    Endian2[Endian2["Big"] = 1] = "Big";
    return Endian2;
  })(Endian || {});
  function isLittleEndian2(config2) {
    return config2?.endian === 1 ? false : true;
  }
  function numberEncoderFactory2(input) {
    return codecsCore.createEncoder({
      fixedSize: input.size,
      write(value, bytes2, offset2) {
        if (input.range) {
          assertNumberIsBetweenForCodec2(input.name, input.range[0], input.range[1], value);
        }
        const arrayBuffer = new ArrayBuffer(input.size);
        input.set(new DataView(arrayBuffer), value, isLittleEndian2(input.config));
        bytes2.set(new Uint8Array(arrayBuffer), offset2);
        return offset2 + input.size;
      }
    });
  }
  function numberDecoderFactory2(input) {
    return codecsCore.createDecoder({
      fixedSize: input.size,
      read(bytes2, offset2 = 0) {
        codecsCore.assertByteArrayIsNotEmptyForCodec(input.name, bytes2, offset2);
        codecsCore.assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes2, offset2);
        const view = new DataView(toArrayBuffer2(bytes2, offset2, input.size));
        return [input.get(view, isLittleEndian2(input.config)), offset2 + input.size];
      }
    });
  }
  function toArrayBuffer2(bytes2, offset2, length) {
    const bytesOffset = bytes2.byteOffset + (offset2 ?? 0);
    const bytesLength = length ?? bytes2.byteLength;
    return bytes2.buffer.slice(bytesOffset, bytesOffset + bytesLength);
  }
  var getF32Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "f32",
    set: (view, value, le) => view.setFloat32(0, Number(value), le),
    size: 4
  });
  var getF32Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => view.getFloat32(0, le),
    name: "f32",
    size: 4
  });
  var getF32Codec = (config2 = {}) => codecsCore.combineCodec(getF32Encoder(config2), getF32Decoder(config2));
  var getF64Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "f64",
    set: (view, value, le) => view.setFloat64(0, Number(value), le),
    size: 8
  });
  var getF64Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => view.getFloat64(0, le),
    name: "f64",
    size: 8
  });
  var getF64Codec = (config2 = {}) => codecsCore.combineCodec(getF64Encoder(config2), getF64Decoder(config2));
  var getI128Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "i128",
    range: [-BigInt("0x7fffffffffffffffffffffffffffffff") - 1n, BigInt("0x7fffffffffffffffffffffffffffffff")],
    set: (view, value, le) => {
      const leftOffset = le ? 8 : 0;
      const rightOffset = le ? 0 : 8;
      const rightMask = 0xffffffffffffffffn;
      view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);
      view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
    },
    size: 16
  });
  var getI128Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => {
      const leftOffset = le ? 8 : 0;
      const rightOffset = le ? 0 : 8;
      const left = view.getBigInt64(leftOffset, le);
      const right = view.getBigUint64(rightOffset, le);
      return (left << 64n) + right;
    },
    name: "i128",
    size: 16
  });
  var getI128Codec = (config2 = {}) => codecsCore.combineCodec(getI128Encoder(config2), getI128Decoder(config2));
  var getI16Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "i16",
    range: [-Number("0x7fff") - 1, Number("0x7fff")],
    set: (view, value, le) => view.setInt16(0, Number(value), le),
    size: 2
  });
  var getI16Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => view.getInt16(0, le),
    name: "i16",
    size: 2
  });
  var getI16Codec = (config2 = {}) => codecsCore.combineCodec(getI16Encoder(config2), getI16Decoder(config2));
  var getI32Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "i32",
    range: [-Number("0x7fffffff") - 1, Number("0x7fffffff")],
    set: (view, value, le) => view.setInt32(0, Number(value), le),
    size: 4
  });
  var getI32Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => view.getInt32(0, le),
    name: "i32",
    size: 4
  });
  var getI32Codec = (config2 = {}) => codecsCore.combineCodec(getI32Encoder(config2), getI32Decoder(config2));
  var getI64Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "i64",
    range: [-BigInt("0x7fffffffffffffff") - 1n, BigInt("0x7fffffffffffffff")],
    set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),
    size: 8
  });
  var getI64Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => view.getBigInt64(0, le),
    name: "i64",
    size: 8
  });
  var getI64Codec = (config2 = {}) => codecsCore.combineCodec(getI64Encoder(config2), getI64Decoder(config2));
  var getI8Encoder = () => numberEncoderFactory2({
    name: "i8",
    range: [-Number("0x7f") - 1, Number("0x7f")],
    set: (view, value) => view.setInt8(0, Number(value)),
    size: 1
  });
  var getI8Decoder = () => numberDecoderFactory2({
    get: (view) => view.getInt8(0),
    name: "i8",
    size: 1
  });
  var getI8Codec = () => codecsCore.combineCodec(getI8Encoder(), getI8Decoder());
  var getShortU16Encoder = () => codecsCore.createEncoder({
    getSizeFromValue: (value) => {
      if (value <= 127)
        return 1;
      if (value <= 16383)
        return 2;
      return 3;
    },
    maxSize: 3,
    write: (value, bytes2, offset2) => {
      assertNumberIsBetweenForCodec2("shortU16", 0, 65535, value);
      const shortU16Bytes = [0];
      for (let ii = 0;; ii += 1) {
        const alignedValue = Number(value) >> ii * 7;
        if (alignedValue === 0) {
          break;
        }
        const nextSevenBits = 127 & alignedValue;
        shortU16Bytes[ii] = nextSevenBits;
        if (ii > 0) {
          shortU16Bytes[ii - 1] |= 128;
        }
      }
      bytes2.set(shortU16Bytes, offset2);
      return offset2 + shortU16Bytes.length;
    }
  });
  var getShortU16Decoder = () => codecsCore.createDecoder({
    maxSize: 3,
    read: (bytes2, offset2) => {
      let value = 0;
      let byteCount = 0;
      while (++byteCount) {
        const byteIndex = byteCount - 1;
        const currentByte = bytes2[offset2 + byteIndex];
        const nextSevenBits = 127 & currentByte;
        value |= nextSevenBits << byteIndex * 7;
        if ((currentByte & 128) === 0) {
          break;
        }
      }
      return [value, offset2 + byteCount];
    }
  });
  var getShortU16Codec = () => codecsCore.combineCodec(getShortU16Encoder(), getShortU16Decoder());
  var getU128Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "u128",
    range: [0n, BigInt("0xffffffffffffffffffffffffffffffff")],
    set: (view, value, le) => {
      const leftOffset = le ? 8 : 0;
      const rightOffset = le ? 0 : 8;
      const rightMask = 0xffffffffffffffffn;
      view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);
      view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
    },
    size: 16
  });
  var getU128Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => {
      const leftOffset = le ? 8 : 0;
      const rightOffset = le ? 0 : 8;
      const left = view.getBigUint64(leftOffset, le);
      const right = view.getBigUint64(rightOffset, le);
      return (left << 64n) + right;
    },
    name: "u128",
    size: 16
  });
  var getU128Codec = (config2 = {}) => codecsCore.combineCodec(getU128Encoder(config2), getU128Decoder(config2));
  var getU16Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "u16",
    range: [0, Number("0xffff")],
    set: (view, value, le) => view.setUint16(0, Number(value), le),
    size: 2
  });
  var getU16Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => view.getUint16(0, le),
    name: "u16",
    size: 2
  });
  var getU16Codec = (config2 = {}) => codecsCore.combineCodec(getU16Encoder(config2), getU16Decoder(config2));
  var getU32Encoder = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "u32",
    range: [0, Number("0xffffffff")],
    set: (view, value, le) => view.setUint32(0, Number(value), le),
    size: 4
  });
  var getU32Decoder = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => view.getUint32(0, le),
    name: "u32",
    size: 4
  });
  var getU32Codec = (config2 = {}) => codecsCore.combineCodec(getU32Encoder(config2), getU32Decoder(config2));
  var getU64Encoder2 = (config2 = {}) => numberEncoderFactory2({
    config: config2,
    name: "u64",
    range: [0n, BigInt("0xffffffffffffffff")],
    set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
    size: 8
  });
  var getU64Decoder2 = (config2 = {}) => numberDecoderFactory2({
    config: config2,
    get: (view, le) => view.getBigUint64(0, le),
    name: "u64",
    size: 8
  });
  var getU64Codec2 = (config2 = {}) => codecsCore.combineCodec(getU64Encoder2(config2), getU64Decoder2(config2));
  var getU8Encoder = () => numberEncoderFactory2({
    name: "u8",
    range: [0, Number("0xff")],
    set: (view, value) => view.setUint8(0, Number(value)),
    size: 1
  });
  var getU8Decoder = () => numberDecoderFactory2({
    get: (view) => view.getUint8(0),
    name: "u8",
    size: 1
  });
  var getU8Codec = () => codecsCore.combineCodec(getU8Encoder(), getU8Decoder());
  exports.Endian = Endian;
  exports.assertNumberIsBetweenForCodec = assertNumberIsBetweenForCodec2;
  exports.getF32Codec = getF32Codec;
  exports.getF32Decoder = getF32Decoder;
  exports.getF32Encoder = getF32Encoder;
  exports.getF64Codec = getF64Codec;
  exports.getF64Decoder = getF64Decoder;
  exports.getF64Encoder = getF64Encoder;
  exports.getI128Codec = getI128Codec;
  exports.getI128Decoder = getI128Decoder;
  exports.getI128Encoder = getI128Encoder;
  exports.getI16Codec = getI16Codec;
  exports.getI16Decoder = getI16Decoder;
  exports.getI16Encoder = getI16Encoder;
  exports.getI32Codec = getI32Codec;
  exports.getI32Decoder = getI32Decoder;
  exports.getI32Encoder = getI32Encoder;
  exports.getI64Codec = getI64Codec;
  exports.getI64Decoder = getI64Decoder;
  exports.getI64Encoder = getI64Encoder;
  exports.getI8Codec = getI8Codec;
  exports.getI8Decoder = getI8Decoder;
  exports.getI8Encoder = getI8Encoder;
  exports.getShortU16Codec = getShortU16Codec;
  exports.getShortU16Decoder = getShortU16Decoder;
  exports.getShortU16Encoder = getShortU16Encoder;
  exports.getU128Codec = getU128Codec;
  exports.getU128Decoder = getU128Decoder;
  exports.getU128Encoder = getU128Encoder;
  exports.getU16Codec = getU16Codec;
  exports.getU16Decoder = getU16Decoder;
  exports.getU16Encoder = getU16Encoder;
  exports.getU32Codec = getU32Codec;
  exports.getU32Decoder = getU32Decoder;
  exports.getU32Encoder = getU32Encoder;
  exports.getU64Codec = getU64Codec2;
  exports.getU64Decoder = getU64Decoder2;
  exports.getU64Encoder = getU64Encoder2;
  exports.getU8Codec = getU8Codec;
  exports.getU8Decoder = getU8Decoder;
  exports.getU8Encoder = getU8Encoder;
});
var require_dist = __commonJS2((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Superstruct = {}));
  })(exports, function(exports2) {

    class StructError2 extends TypeError {
      constructor(failure, failures) {
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path } = failure;
        const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
        super(explanation ?? msg);
        if (explanation != null)
          this.cause = msg;
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = () => {
          return cached ?? (cached = [failure, ...failures()]);
        };
      }
    }
    function isIterable2(x2) {
      return isObject22(x2) && typeof x2[Symbol.iterator] === "function";
    }
    function isObject22(x2) {
      return typeof x2 === "object" && x2 != null;
    }
    function isNonArrayObject2(x2) {
      return isObject22(x2) && !Array.isArray(x2);
    }
    function isPlainObject(x2) {
      if (Object.prototype.toString.call(x2) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(x2);
      return prototype === null || prototype === Object.prototype;
    }
    function print2(value) {
      if (typeof value === "symbol") {
        return value.toString();
      }
      return typeof value === "string" ? JSON.stringify(value) : `${value}`;
    }
    function shiftIterator2(input) {
      const { done, value } = input.next();
      return done ? undefined : value;
    }
    function toFailure2(result, context, struct3, value) {
      if (result === true) {
        return;
      } else if (result === false) {
        result = {};
      } else if (typeof result === "string") {
        result = { message: result };
      }
      const { path, branch } = context;
      const { type: type3 } = struct3;
      const { refinement, message = `Expected a value of type \`${type3}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print2(value)}\`` } = result;
      return {
        value,
        type: type3,
        refinement,
        key: path[path.length - 1],
        path,
        branch,
        ...result,
        message
      };
    }
    function* toFailures2(result, context, struct3, value) {
      if (!isIterable2(result)) {
        result = [result];
      }
      for (const r of result) {
        const failure = toFailure2(r, context, struct3, value);
        if (failure) {
          yield failure;
        }
      }
    }
    function* run2(value, struct3, options = {}) {
      const { path = [], branch = [value], coerce: coerce3 = false, mask: mask3 = false } = options;
      const ctx = { path, branch, mask: mask3 };
      if (coerce3) {
        value = struct3.coercer(value, ctx);
      }
      let status = "valid";
      for (const failure of struct3.validator(value, ctx)) {
        failure.explanation = options.message;
        status = "not_valid";
        yield [failure, undefined];
      }
      for (let [k, v, s] of struct3.entries(value, ctx)) {
        const ts = run2(v, s, {
          path: k === undefined ? path : [...path, k],
          branch: k === undefined ? branch : [...branch, v],
          coerce: coerce3,
          mask: mask3,
          message: options.message
        });
        for (const t of ts) {
          if (t[0]) {
            status = t[0].refinement != null ? "not_refined" : "not_valid";
            yield [t[0], undefined];
          } else if (coerce3) {
            v = t[1];
            if (k === undefined) {
              value = v;
            } else if (value instanceof Map) {
              value.set(k, v);
            } else if (value instanceof Set) {
              value.add(v);
            } else if (isObject22(value)) {
              if (v !== undefined || k in value)
                value[k] = v;
            }
          }
        }
      }
      if (status !== "not_valid") {
        for (const failure of struct3.refiner(value, ctx)) {
          failure.explanation = options.message;
          status = "not_refined";
          yield [failure, undefined];
        }
      }
      if (status === "valid") {
        yield [undefined, value];
      }
    }

    class Struct3 {
      constructor(props) {
        const { type: type3, schema, validator, refiner, coercer = (value) => value, entries = function* () {} } = props;
        this.type = type3;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
          this.validator = (value, context) => {
            const result = validator(value, context);
            return toFailures2(result, context, this, value);
          };
        } else {
          this.validator = () => [];
        }
        if (refiner) {
          this.refiner = (value, context) => {
            const result = refiner(value, context);
            return toFailures2(result, context, this, value);
          };
        } else {
          this.refiner = () => [];
        }
      }
      assert(value, message) {
        return assert32(value, this, message);
      }
      create(value, message) {
        return create22(value, this, message);
      }
      is(value) {
        return is2(value, this);
      }
      mask(value, message) {
        return mask22(value, this, message);
      }
      validate(value, options = {}) {
        return validate3(value, this, options);
      }
    }
    function assert32(value, struct3, message) {
      const result = validate3(value, struct3, { message });
      if (result[0]) {
        throw result[0];
      }
    }
    function create22(value, struct3, message) {
      const result = validate3(value, struct3, { coerce: true, message });
      if (result[0]) {
        throw result[0];
      } else {
        return result[1];
      }
    }
    function mask22(value, struct3, message) {
      const result = validate3(value, struct3, { coerce: true, mask: true, message });
      if (result[0]) {
        throw result[0];
      } else {
        return result[1];
      }
    }
    function is2(value, struct3) {
      const result = validate3(value, struct3);
      return !result[0];
    }
    function validate3(value, struct3, options = {}) {
      const tuples = run2(value, struct3, options);
      const tuple3 = shiftIterator2(tuples);
      if (tuple3[0]) {
        const error = new StructError2(tuple3[0], function* () {
          for (const t of tuples) {
            if (t[0]) {
              yield t[0];
            }
          }
        });
        return [error, undefined];
      } else {
        const v = tuple3[1];
        return [undefined, v];
      }
    }
    function assign(...Structs) {
      const isType = Structs[0].type === "type";
      const schemas = Structs.map((s) => s.schema);
      const schema = Object.assign({}, ...schemas);
      return isType ? type2(schema) : object2(schema);
    }
    function define3(name, validator) {
      return new Struct3({ type: name, schema: null, validator });
    }
    function deprecated(struct3, log3) {
      return new Struct3({
        ...struct3,
        refiner: (value, ctx) => value === undefined || struct3.refiner(value, ctx),
        validator(value, ctx) {
          if (value === undefined) {
            return true;
          } else {
            log3(value, ctx);
            return struct3.validator(value, ctx);
          }
        }
      });
    }
    function dynamic(fn) {
      return new Struct3({
        type: "dynamic",
        schema: null,
        *entries(value, ctx) {
          const struct3 = fn(value, ctx);
          yield* struct3.entries(value, ctx);
        },
        validator(value, ctx) {
          const struct3 = fn(value, ctx);
          return struct3.validator(value, ctx);
        },
        coercer(value, ctx) {
          const struct3 = fn(value, ctx);
          return struct3.coercer(value, ctx);
        },
        refiner(value, ctx) {
          const struct3 = fn(value, ctx);
          return struct3.refiner(value, ctx);
        }
      });
    }
    function lazy(fn) {
      let struct3;
      return new Struct3({
        type: "lazy",
        schema: null,
        *entries(value, ctx) {
          struct3 ?? (struct3 = fn());
          yield* struct3.entries(value, ctx);
        },
        validator(value, ctx) {
          struct3 ?? (struct3 = fn());
          return struct3.validator(value, ctx);
        },
        coercer(value, ctx) {
          struct3 ?? (struct3 = fn());
          return struct3.coercer(value, ctx);
        },
        refiner(value, ctx) {
          struct3 ?? (struct3 = fn());
          return struct3.refiner(value, ctx);
        }
      });
    }
    function omit(struct3, keys) {
      const { schema } = struct3;
      const subschema = { ...schema };
      for (const key of keys) {
        delete subschema[key];
      }
      switch (struct3.type) {
        case "type":
          return type2(subschema);
        default:
          return object2(subschema);
      }
    }
    function partial(struct3) {
      const isStruct = struct3 instanceof Struct3;
      const schema = isStruct ? { ...struct3.schema } : { ...struct3 };
      for (const key in schema) {
        schema[key] = optional2(schema[key]);
      }
      if (isStruct && struct3.type === "type") {
        return type2(schema);
      }
      return object2(schema);
    }
    function pick(struct3, keys) {
      const { schema } = struct3;
      const subschema = {};
      for (const key of keys) {
        subschema[key] = schema[key];
      }
      switch (struct3.type) {
        case "type":
          return type2(subschema);
        default:
          return object2(subschema);
      }
    }
    function struct2(name, validator) {
      console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
      return define3(name, validator);
    }
    function any2() {
      return define3("any", () => true);
    }
    function array2(Element) {
      return new Struct3({
        type: "array",
        schema: Element,
        *entries(value) {
          if (Element && Array.isArray(value)) {
            for (const [i22, v] of value.entries()) {
              yield [i22, v, Element];
            }
          }
        },
        coercer(value) {
          return Array.isArray(value) ? value.slice() : value;
        },
        validator(value) {
          return Array.isArray(value) || `Expected an array value, but received: ${print2(value)}`;
        }
      });
    }
    function bigint() {
      return define3("bigint", (value) => {
        return typeof value === "bigint";
      });
    }
    function boolean2() {
      return define3("boolean", (value) => {
        return typeof value === "boolean";
      });
    }
    function date() {
      return define3("date", (value) => {
        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print2(value)}`;
      });
    }
    function enums(values) {
      const schema = {};
      const description = values.map((v) => print2(v)).join();
      for (const key of values) {
        schema[key] = key;
      }
      return new Struct3({
        type: "enums",
        schema,
        validator(value) {
          return values.includes(value) || `Expected one of \`${description}\`, but received: ${print2(value)}`;
        }
      });
    }
    function func() {
      return define3("func", (value) => {
        return typeof value === "function" || `Expected a function, but received: ${print2(value)}`;
      });
    }
    function instance2(Class) {
      return define3("instance", (value) => {
        return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print2(value)}`;
      });
    }
    function integer() {
      return define3("integer", (value) => {
        return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print2(value)}`;
      });
    }
    function intersection(Structs) {
      return new Struct3({
        type: "intersection",
        schema: null,
        *entries(value, ctx) {
          for (const S2 of Structs) {
            yield* S2.entries(value, ctx);
          }
        },
        *validator(value, ctx) {
          for (const S2 of Structs) {
            yield* S2.validator(value, ctx);
          }
        },
        *refiner(value, ctx) {
          for (const S2 of Structs) {
            yield* S2.refiner(value, ctx);
          }
        }
      });
    }
    function literal2(constant) {
      const description = print2(constant);
      const t = typeof constant;
      return new Struct3({
        type: "literal",
        schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
        validator(value) {
          return value === constant || `Expected the literal \`${description}\`, but received: ${print2(value)}`;
        }
      });
    }
    function map(Key, Value) {
      return new Struct3({
        type: "map",
        schema: null,
        *entries(value) {
          if (Key && Value && value instanceof Map) {
            for (const [k, v] of value.entries()) {
              yield [k, k, Key];
              yield [k, v, Value];
            }
          }
        },
        coercer(value) {
          return value instanceof Map ? new Map(value) : value;
        },
        validator(value) {
          return value instanceof Map || `Expected a \`Map\` object, but received: ${print2(value)}`;
        }
      });
    }
    function never2() {
      return define3("never", () => false);
    }
    function nullable2(struct3) {
      return new Struct3({
        ...struct3,
        validator: (value, ctx) => value === null || struct3.validator(value, ctx),
        refiner: (value, ctx) => value === null || struct3.refiner(value, ctx)
      });
    }
    function number22() {
      return define3("number", (value) => {
        return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print2(value)}`;
      });
    }
    function object2(schema) {
      const knowns = schema ? Object.keys(schema) : [];
      const Never = never2();
      return new Struct3({
        type: "object",
        schema: schema ? schema : null,
        *entries(value) {
          if (schema && isObject22(value)) {
            const unknowns = new Set(Object.keys(value));
            for (const key of knowns) {
              unknowns.delete(key);
              yield [key, value[key], schema[key]];
            }
            for (const key of unknowns) {
              yield [key, value[key], Never];
            }
          }
        },
        validator(value) {
          return isNonArrayObject2(value) || `Expected an object, but received: ${print2(value)}`;
        },
        coercer(value, ctx) {
          if (!isNonArrayObject2(value)) {
            return value;
          }
          const coerced = { ...value };
          if (ctx.mask && schema) {
            for (const key in coerced) {
              if (schema[key] === undefined) {
                delete coerced[key];
              }
            }
          }
          return coerced;
        }
      });
    }
    function optional2(struct3) {
      return new Struct3({
        ...struct3,
        validator: (value, ctx) => value === undefined || struct3.validator(value, ctx),
        refiner: (value, ctx) => value === undefined || struct3.refiner(value, ctx)
      });
    }
    function record2(Key, Value) {
      return new Struct3({
        type: "record",
        schema: null,
        *entries(value) {
          if (isObject22(value)) {
            for (const k in value) {
              const v = value[k];
              yield [k, k, Key];
              yield [k, v, Value];
            }
          }
        },
        validator(value) {
          return isNonArrayObject2(value) || `Expected an object, but received: ${print2(value)}`;
        },
        coercer(value) {
          return isNonArrayObject2(value) ? { ...value } : value;
        }
      });
    }
    function regexp() {
      return define3("regexp", (value) => {
        return value instanceof RegExp;
      });
    }
    function set(Element) {
      return new Struct3({
        type: "set",
        schema: null,
        *entries(value) {
          if (Element && value instanceof Set) {
            for (const v of value) {
              yield [v, v, Element];
            }
          }
        },
        coercer(value) {
          return value instanceof Set ? new Set(value) : value;
        },
        validator(value) {
          return value instanceof Set || `Expected a \`Set\` object, but received: ${print2(value)}`;
        }
      });
    }
    function string2() {
      return define3("string", (value) => {
        return typeof value === "string" || `Expected a string, but received: ${print2(value)}`;
      });
    }
    function tuple2(Structs) {
      const Never = never2();
      return new Struct3({
        type: "tuple",
        schema: null,
        *entries(value) {
          if (Array.isArray(value)) {
            const length = Math.max(Structs.length, value.length);
            for (let i22 = 0;i22 < length; i22++) {
              yield [i22, value[i22], Structs[i22] || Never];
            }
          }
        },
        validator(value) {
          return Array.isArray(value) || `Expected an array, but received: ${print2(value)}`;
        },
        coercer(value) {
          return Array.isArray(value) ? value.slice() : value;
        }
      });
    }
    function type2(schema) {
      const keys = Object.keys(schema);
      return new Struct3({
        type: "type",
        schema,
        *entries(value) {
          if (isObject22(value)) {
            for (const k of keys) {
              yield [k, value[k], schema[k]];
            }
          }
        },
        validator(value) {
          return isNonArrayObject2(value) || `Expected an object, but received: ${print2(value)}`;
        },
        coercer(value) {
          return isNonArrayObject2(value) ? { ...value } : value;
        }
      });
    }
    function union2(Structs) {
      const description = Structs.map((s) => s.type).join(" | ");
      return new Struct3({
        type: "union",
        schema: null,
        coercer(value, ctx) {
          for (const S2 of Structs) {
            const [error, coerced] = S2.validate(value, {
              coerce: true,
              mask: ctx.mask
            });
            if (!error) {
              return coerced;
            }
          }
          return value;
        },
        validator(value, ctx) {
          const failures = [];
          for (const S2 of Structs) {
            const [...tuples] = run2(value, S2, ctx);
            const [first] = tuples;
            if (!first[0]) {
              return [];
            } else {
              for (const [failure] of tuples) {
                if (failure) {
                  failures.push(failure);
                }
              }
            }
          }
          return [
            `Expected the value to satisfy a union of \`${description}\`, but received: ${print2(value)}`,
            ...failures
          ];
        }
      });
    }
    function unknown2() {
      return define3("unknown", () => true);
    }
    function coerce2(struct3, condition, coercer) {
      return new Struct3({
        ...struct3,
        coercer: (value, ctx) => {
          return is2(value, condition) ? struct3.coercer(coercer(value, ctx), ctx) : struct3.coercer(value, ctx);
        }
      });
    }
    function defaulted(struct3, fallback, options = {}) {
      return coerce2(struct3, unknown2(), (x2) => {
        const f22 = typeof fallback === "function" ? fallback() : fallback;
        if (x2 === undefined) {
          return f22;
        }
        if (!options.strict && isPlainObject(x2) && isPlainObject(f22)) {
          const ret = { ...x2 };
          let changed = false;
          for (const key in f22) {
            if (ret[key] === undefined) {
              ret[key] = f22[key];
              changed = true;
            }
          }
          if (changed) {
            return ret;
          }
        }
        return x2;
      });
    }
    function trimmed(struct3) {
      return coerce2(struct3, string2(), (x2) => x2.trim());
    }
    function empty2(struct3) {
      return refine(struct3, "empty", (value) => {
        const size2 = getSize(value);
        return size2 === 0 || `Expected an empty ${struct3.type} but received one with a size of \`${size2}\``;
      });
    }
    function getSize(value) {
      if (value instanceof Map || value instanceof Set) {
        return value.size;
      } else {
        return value.length;
      }
    }
    function max2(struct3, threshold, options = {}) {
      const { exclusive } = options;
      return refine(struct3, "max", (value) => {
        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct3.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
      });
    }
    function min2(struct3, threshold, options = {}) {
      const { exclusive } = options;
      return refine(struct3, "min", (value) => {
        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct3.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
      });
    }
    function nonempty(struct3) {
      return refine(struct3, "nonempty", (value) => {
        const size2 = getSize(value);
        return size2 > 0 || `Expected a nonempty ${struct3.type} but received an empty one`;
      });
    }
    function pattern(struct3, regexp2) {
      return refine(struct3, "pattern", (value) => {
        return regexp2.test(value) || `Expected a ${struct3.type} matching \`/${regexp2.source}/\` but received "${value}"`;
      });
    }
    function size(struct3, min22, max22 = min22) {
      const expected = `Expected a ${struct3.type}`;
      const of = min22 === max22 ? `of \`${min22}\`` : `between \`${min22}\` and \`${max22}\``;
      return refine(struct3, "size", (value) => {
        if (typeof value === "number" || value instanceof Date) {
          return min22 <= value && value <= max22 || `${expected} ${of} but received \`${value}\``;
        } else if (value instanceof Map || value instanceof Set) {
          const { size: size2 } = value;
          return min22 <= size2 && size2 <= max22 || `${expected} with a size ${of} but received one with a size of \`${size2}\``;
        } else {
          const { length } = value;
          return min22 <= length && length <= max22 || `${expected} with a length ${of} but received one with a length of \`${length}\``;
        }
      });
    }
    function refine(struct3, name, refiner) {
      return new Struct3({
        ...struct3,
        *refiner(value, ctx) {
          yield* struct3.refiner(value, ctx);
          const result = refiner(value, ctx);
          const failures = toFailures2(result, ctx, struct3, value);
          for (const failure of failures) {
            yield { ...failure, refinement: name };
          }
        }
      });
    }
    exports2.Struct = Struct3;
    exports2.StructError = StructError2;
    exports2.any = any2;
    exports2.array = array2;
    exports2.assert = assert32;
    exports2.assign = assign;
    exports2.bigint = bigint;
    exports2.boolean = boolean2;
    exports2.coerce = coerce2;
    exports2.create = create22;
    exports2.date = date;
    exports2.defaulted = defaulted;
    exports2.define = define3;
    exports2.deprecated = deprecated;
    exports2.dynamic = dynamic;
    exports2.empty = empty2;
    exports2.enums = enums;
    exports2.func = func;
    exports2.instance = instance2;
    exports2.integer = integer;
    exports2.intersection = intersection;
    exports2.is = is2;
    exports2.lazy = lazy;
    exports2.literal = literal2;
    exports2.map = map;
    exports2.mask = mask22;
    exports2.max = max2;
    exports2.min = min2;
    exports2.never = never2;
    exports2.nonempty = nonempty;
    exports2.nullable = nullable2;
    exports2.number = number22;
    exports2.object = object2;
    exports2.omit = omit;
    exports2.optional = optional2;
    exports2.partial = partial;
    exports2.pattern = pattern;
    exports2.pick = pick;
    exports2.record = record2;
    exports2.refine = refine;
    exports2.regexp = regexp;
    exports2.set = set;
    exports2.size = size;
    exports2.string = string2;
    exports2.struct = struct2;
    exports2.trimmed = trimmed;
    exports2.tuple = tuple2;
    exports2.type = type2;
    exports2.union = union2;
    exports2.unknown = unknown2;
    exports2.validate = validate3;
  });
});
var require_index_browser4 = __commonJS2((exports) => {
  var buffer = (init_buffer2(), __toCommonJS2(exports_buffer2));
  var eventemitter3 = require_eventemitter32();
  var WebSocketBrowserImpl = class extends eventemitter3.EventEmitter {
    socket;
    constructor(address, options, protocols) {
      super();
      this.socket = new window.WebSocket(address, protocols);
      this.socket.onopen = () => this.emit("open");
      this.socket.onmessage = (event) => this.emit("message", event.data);
      this.socket.onerror = (error) => this.emit("error", error);
      this.socket.onclose = (event) => {
        this.emit("close", event.code, event.reason);
      };
    }
    send(data, optionsOrCallback, callback) {
      const cb = callback || optionsOrCallback;
      try {
        this.socket.send(data);
        cb();
      } catch (error) {
        cb(error);
      }
    }
    close(code2, reason) {
      this.socket.close(code2, reason);
    }
    addEventListener(type2, listener, options) {
      this.socket.addEventListener(type2, listener, options);
    }
  };
  function WebSocket22(address, options) {
    return new WebSocketBrowserImpl(address, options);
  }
  var DefaultDataPack = class {
    encode(value) {
      return JSON.stringify(value);
    }
    decode(value) {
      return JSON.parse(value);
    }
  };
  var CommonClient2 = class extends eventemitter3.EventEmitter {
    address;
    rpc_id;
    queue;
    options;
    autoconnect;
    ready;
    reconnect;
    reconnect_timer_id;
    reconnect_interval;
    max_reconnects;
    rest_options;
    current_reconnects;
    generate_request_id;
    socket;
    webSocketFactory;
    dataPack;
    constructor(webSocketFactory, address = "ws://localhost:8080", {
      autoconnect = true,
      reconnect = true,
      reconnect_interval = 1000,
      max_reconnects = 5,
      ...rest_options
    } = {}, generate_request_id, dataPack) {
      super();
      this.webSocketFactory = webSocketFactory;
      this.queue = {};
      this.rpc_id = 0;
      this.address = address;
      this.autoconnect = autoconnect;
      this.ready = false;
      this.reconnect = reconnect;
      this.reconnect_timer_id = undefined;
      this.reconnect_interval = reconnect_interval;
      this.max_reconnects = max_reconnects;
      this.rest_options = rest_options;
      this.current_reconnects = 0;
      this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === "number" ? ++this.rpc_id : Number(this.rpc_id) + 1);
      if (!dataPack)
        this.dataPack = new DefaultDataPack;
      else
        this.dataPack = dataPack;
      if (this.autoconnect)
        this._connect(this.address, {
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects,
          ...this.rest_options
        });
    }
    connect() {
      if (this.socket)
        return;
      this._connect(this.address, {
        autoconnect: this.autoconnect,
        reconnect: this.reconnect,
        reconnect_interval: this.reconnect_interval,
        max_reconnects: this.max_reconnects,
        ...this.rest_options
      });
    }
    call(method, params, timeout, ws_opts) {
      if (!ws_opts && typeof timeout === "object") {
        ws_opts = timeout;
        timeout = null;
      }
      return new Promise((resolve, reject) => {
        if (!this.ready)
          return reject(new Error("socket not ready"));
        const rpc_id = this.generate_request_id(method, params);
        const message = {
          jsonrpc: "2.0",
          method,
          params: params || undefined,
          id: rpc_id
        };
        this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {
          if (error)
            return reject(error);
          this.queue[rpc_id] = { promise: [resolve, reject] };
          if (timeout) {
            this.queue[rpc_id].timeout = setTimeout(() => {
              delete this.queue[rpc_id];
              reject(new Error("reply timeout"));
            }, timeout);
          }
        });
      });
    }
    async login(params) {
      const resp = await this.call("rpc.login", params);
      if (!resp)
        throw new Error("authentication failed");
      return resp;
    }
    async listMethods() {
      return await this.call("__listMethods");
    }
    notify(method, params) {
      return new Promise((resolve, reject) => {
        if (!this.ready)
          return reject(new Error("socket not ready"));
        const message = {
          jsonrpc: "2.0",
          method,
          params
        };
        this.socket.send(this.dataPack.encode(message), (error) => {
          if (error)
            return reject(error);
          resolve();
        });
      });
    }
    async subscribe(event) {
      if (typeof event === "string")
        event = [event];
      const result = await this.call("rpc.on", event);
      if (typeof event === "string" && result[event] !== "ok")
        throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
      return result;
    }
    async unsubscribe(event) {
      if (typeof event === "string")
        event = [event];
      const result = await this.call("rpc.off", event);
      if (typeof event === "string" && result[event] !== "ok")
        throw new Error("Failed unsubscribing from an event with: " + result);
      return result;
    }
    close(code2, data) {
      this.socket.close(code2 || 1000, data);
    }
    setAutoReconnect(reconnect) {
      this.reconnect = reconnect;
    }
    setReconnectInterval(interval) {
      this.reconnect_interval = interval;
    }
    setMaxReconnects(max_reconnects) {
      this.max_reconnects = max_reconnects;
    }
    _connect(address, options) {
      clearTimeout(this.reconnect_timer_id);
      this.socket = this.webSocketFactory(address, options);
      this.socket.addEventListener("open", () => {
        this.ready = true;
        this.emit("open");
        this.current_reconnects = 0;
      });
      this.socket.addEventListener("message", ({ data: message }) => {
        if (message instanceof ArrayBuffer)
          message = buffer.Buffer.from(message).toString();
        try {
          message = this.dataPack.decode(message);
        } catch (error) {
          return;
        }
        if (message.notification && this.listeners(message.notification).length) {
          if (!Object.keys(message.params).length)
            return this.emit(message.notification);
          const args = [message.notification];
          if (message.params.constructor === Object)
            args.push(message.params);
          else
            for (let i22 = 0;i22 < message.params.length; i22++)
              args.push(message.params[i22]);
          return Promise.resolve().then(() => {
            this.emit.apply(this, args);
          });
        }
        if (!this.queue[message.id]) {
          if (message.method) {
            return Promise.resolve().then(() => {
              this.emit(message.method, message?.params);
            });
          }
          return;
        }
        if ("error" in message === "result" in message)
          this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));
        if (this.queue[message.id].timeout)
          clearTimeout(this.queue[message.id].timeout);
        if (message.error)
          this.queue[message.id].promise[1](message.error);
        else
          this.queue[message.id].promise[0](message.result);
        delete this.queue[message.id];
      });
      this.socket.addEventListener("error", (error) => this.emit("error", error));
      this.socket.addEventListener("close", ({ code: code2, reason }) => {
        if (this.ready)
          setTimeout(() => this.emit("close", code2, reason), 0);
        this.ready = false;
        this.socket = undefined;
        if (code2 === 1000)
          return;
        this.current_reconnects++;
        if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))
          this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);
      });
    }
  };
  var Client = class extends CommonClient2 {
    constructor(address = "ws://localhost:8080", {
      autoconnect = true,
      reconnect = true,
      reconnect_interval = 1000,
      max_reconnects = 5
    } = {}, generate_request_id) {
      super(WebSocket22, address, {
        autoconnect,
        reconnect,
        reconnect_interval,
        max_reconnects
      }, generate_request_id);
    }
  };
  exports.Client = Client;
  exports.CommonClient = CommonClient2;
  exports.DefaultDataPack = DefaultDataPack;
  exports.WebSocket = WebSocket22;
});
var require_sha3 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = undefined;
  exports.keccakP = keccakP22;
  var _u64_ts_1 = require__u64();
  var utils_ts_1 = require_utils();
  var _0n92 = BigInt(0);
  var _1n92 = BigInt(1);
  var _2n72 = BigInt(2);
  var _7n22 = BigInt(7);
  var _256n22 = BigInt(256);
  var _0x71n22 = BigInt(113);
  var SHA3_PI22 = [];
  var SHA3_ROTL22 = [];
  var _SHA3_IOTA22 = [];
  for (let round2 = 0, R = _1n92, x2 = 1, y = 0;round2 < 24; round2++) {
    [x2, y] = [y, (2 * x2 + 3 * y) % 5];
    SHA3_PI22.push(2 * (5 * y + x2));
    SHA3_ROTL22.push((round2 + 1) * (round2 + 2) / 2 % 64);
    let t = _0n92;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n92 ^ (R >> _7n22) * _0x71n22) % _256n22;
      if (R & _2n72)
        t ^= _1n92 << (_1n92 << /* @__PURE__ */ BigInt(j)) - _1n92;
    }
    _SHA3_IOTA22.push(t);
  }
  var IOTAS2 = (0, _u64_ts_1.split)(_SHA3_IOTA22, true);
  var SHA3_IOTA_H22 = IOTAS2[0];
  var SHA3_IOTA_L22 = IOTAS2[1];
  var rotlH22 = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
  var rotlL22 = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
  function keccakP22(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round2 = 24 - rounds;round2 < 24; round2++) {
      for (let x2 = 0;x2 < 10; x2++)
        B[x2] = s[x2] ^ s[x2 + 10] ^ s[x2 + 20] ^ s[x2 + 30] ^ s[x2 + 40];
      for (let x2 = 0;x2 < 10; x2 += 2) {
        const idx1 = (x2 + 8) % 10;
        const idx0 = (x2 + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH22(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL22(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0;y < 50; y += 10) {
          s[x2 + y] ^= Th;
          s[x2 + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0;t < 24; t++) {
        const shift = SHA3_ROTL22[t];
        const Th = rotlH22(curH, curL, shift);
        const Tl = rotlL22(curH, curL, shift);
        const PI2 = SHA3_PI22[t];
        curH = s[PI2];
        curL = s[PI2 + 1];
        s[PI2] = Th;
        s[PI2 + 1] = Tl;
      }
      for (let y = 0;y < 50; y += 10) {
        for (let x2 = 0;x2 < 10; x2++)
          B[x2] = s[y + x2];
        for (let x2 = 0;x2 < 10; x2++)
          s[y + x2] ^= ~B[(x2 + 2) % 10] & B[(x2 + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H22[round2];
      s[1] ^= SHA3_IOTA_L22[round2];
    }
    (0, utils_ts_1.clean)(B);
  }

  class Keccak22 extends utils_ts_1.Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      this.enableXOF = false;
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      (0, utils_ts_1.anumber)(outputLen);
      if (!(0 < blockLen && blockLen < 200))
        throw new Error("only keccak-f1600 function is supported");
      this.state = new Uint8Array(200);
      this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
      return this._cloneInto();
    }
    keccak() {
      (0, utils_ts_1.swap32IfBE)(this.state32);
      keccakP22(this.state32, this.rounds);
      (0, utils_ts_1.swap32IfBE)(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      (0, utils_ts_1.aexists)(this);
      data = (0, utils_ts_1.toBytes)(data);
      (0, utils_ts_1.abytes)(data);
      const { blockLen, state } = this;
      const len2 = data.length;
      for (let pos = 0;pos < len2; ) {
        const take = Math.min(blockLen - this.pos, len2 - pos);
        for (let i22 = 0;i22 < take; i22++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      (0, utils_ts_1.aexists)(this, false);
      (0, utils_ts_1.abytes)(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len2 = out.length;pos < len2; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len2 - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      (0, utils_ts_1.anumber)(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      (0, utils_ts_1.aoutput)(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak22(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  }
  exports.Keccak = Keccak22;
  var gen22 = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak22(blockLen, suffix, outputLen));
  exports.sha3_224 = (() => gen22(6, 144, 224 / 8))();
  exports.sha3_256 = (() => gen22(6, 136, 256 / 8))();
  exports.sha3_384 = (() => gen22(6, 104, 384 / 8))();
  exports.sha3_512 = (() => gen22(6, 72, 512 / 8))();
  exports.keccak_224 = (() => gen22(1, 144, 224 / 8))();
  exports.keccak_256 = (() => gen22(1, 136, 256 / 8))();
  exports.keccak_384 = (() => gen22(1, 104, 384 / 8))();
  exports.keccak_512 = (() => gen22(1, 72, 512 / 8))();
  var genShake2 = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak22(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
  exports.shake128 = (() => genShake2(31, 168, 128 / 8))();
  exports.shake256 = (() => genShake2(31, 136, 256 / 8))();
});
var require_hmac = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmac = exports.HMAC = undefined;
  var utils_ts_1 = require_utils();

  class HMAC22 extends utils_ts_1.Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      (0, utils_ts_1.ahash)(hash2);
      const key = (0, utils_ts_1.toBytes)(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i22 = 0;i22 < pad.length; i22++)
        pad[i22] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i22 = 0;i22 < pad.length; i22++)
        pad[i22] ^= 54 ^ 92;
      this.oHash.update(pad);
      (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
      (0, utils_ts_1.aexists)(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      (0, utils_ts_1.aexists)(this);
      (0, utils_ts_1.abytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished: finished22, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished22;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }
  exports.HMAC = HMAC22;
  var hmac22 = (hash2, key, message) => new HMAC22(hash2, key).update(message).digest();
  exports.hmac = hmac22;
  exports.hmac.create = (hash2, key) => new HMAC22(hash2, key);
});
var require_weierstrass = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DER = exports.DERErr = undefined;
  exports._legacyHelperEquat = _legacyHelperEquat2;
  exports._legacyHelperNormPriv = _legacyHelperNormPriv2;
  exports.weierstrassN = weierstrassN2;
  exports.weierstrassPoints = weierstrassPoints2;
  exports.ecdsa = ecdsa2;
  exports.weierstrass = weierstrass22;
  exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
  exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var hmac_js_1 = require_hmac();
  var utils_ts_1 = require_utils2();
  var curve_ts_1 = require_curve();
  var modular_ts_1 = require_modular();
  function validateSigVerOpts2(opts) {
    if (opts.lowS !== undefined)
      (0, utils_ts_1.abool)("lowS", opts.lowS);
    if (opts.prehash !== undefined)
      (0, utils_ts_1.abool)("prehash", opts.prehash);
  }

  class DERErr22 extends Error {
    constructor(m = "") {
      super(m);
    }
  }
  exports.DERErr = DERErr22;
  exports.DER = {
    Err: DERErr22,
    _tlv: {
      encode: (tag2, data) => {
        const { Err: E2 } = exports.DER;
        if (tag2 < 0 || tag2 > 256)
          throw new E2("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E2("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len2 = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
        if (len2.length / 2 & 128)
          throw new E2("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len2.length / 2 | 128) : "";
        const t = (0, utils_ts_1.numberToHexUnpadded)(tag2);
        return t + lenLen + len2 + data;
      },
      decode(tag2, data) {
        const { Err: E2 } = exports.DER;
        let pos = 0;
        if (tag2 < 0 || tag2 > 256)
          throw new E2("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag2)
          throw new E2("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong)
          length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E2("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E2("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E2("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E2("tlv.decode(long): zero leftmost byte");
          for (const b22 of lengthBytes)
            length = length << 8 | b22;
          pos += lenLen;
          if (length < 128)
            throw new E2("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length);
        if (v.length !== length)
          throw new E2("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length) };
      }
    },
    _int: {
      encode(num) {
        const { Err: E2 } = exports.DER;
        if (num < _0n92)
          throw new E2("integer: negative integers are not allowed");
        let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E2("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E2 } = exports.DER;
        if (data[0] & 128)
          throw new E2("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E2("invalid signature integer: unnecessary leading zero");
        return (0, utils_ts_1.bytesToNumberBE)(data);
      }
    },
    toSig(hex) {
      const { Err: E2, _int: int, _tlv: tlv } = exports.DER;
      const data = (0, utils_ts_1.ensureBytes)("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E2("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E2("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = exports.DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq2 = rs + ss;
      return tlv.encode(48, seq2);
    }
  };
  var _0n92 = BigInt(0);
  var _1n92 = BigInt(1);
  var _2n72 = BigInt(2);
  var _3n42 = BigInt(3);
  var _4n32 = BigInt(4);
  function _legacyHelperEquat2(Fp22, a, b22) {
    function weierstrassEquation(x2) {
      const x22 = Fp22.sqr(x2);
      const x3 = Fp22.mul(x22, x2);
      return Fp22.add(Fp22.add(x3, Fp22.mul(x2, a)), b22);
    }
    return weierstrassEquation;
  }
  function _legacyHelperNormPriv2(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
    const { BYTES: expected } = Fn;
    function normPrivateKeyToScalar(key) {
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else {
        let bytes2 = (0, utils_ts_1.ensureBytes)("private key", key);
        if (allowedPrivateKeyLengths) {
          if (!allowedPrivateKeyLengths.includes(bytes2.length * 2))
            throw new Error("invalid private key");
          const padded = new Uint8Array(expected);
          padded.set(bytes2, padded.length - bytes2.length);
          bytes2 = padded;
        }
        try {
          num = Fn.fromBytes(bytes2);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (wrapPrivateKey)
        num = Fn.create(num);
      if (!Fn.isValidNot0(num))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num;
    }
    return normPrivateKeyToScalar;
  }
  function weierstrassN2(CURVE, curveOpts = {}) {
    const { Fp: Fp22, Fn } = (0, curve_ts_1._createCurveFields)("weierstrass", CURVE, curveOpts);
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(curveOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo } = curveOpts;
    if (endo) {
      if (!Fp22.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
      }
    }
    function assertCompressionIsSupported() {
      if (!Fp22.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes(_c, point, isCompressed) {
      const { x: x2, y } = point.toAffine();
      const bx = Fp22.toBytes(x2);
      (0, utils_ts_1.abool)("isCompressed", isCompressed);
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp22.isOdd(y);
        return (0, utils_ts_1.concatBytes)(pprefix2(hasEvenY), bx);
      } else {
        return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp22.toBytes(y));
      }
    }
    function pointFromBytes(bytes2) {
      (0, utils_ts_1.abytes)(bytes2);
      const L = Fp22.BYTES;
      const LC = L + 1;
      const LU = 2 * L + 1;
      const length = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (length === LC && (head === 2 || head === 3)) {
        const x2 = Fp22.fromBytes(tail);
        if (!Fp22.isValid(x2))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x2);
        let y;
        try {
          y = Fp22.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp22.isOdd(y);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp22.neg(y);
        return { x: x2, y };
      } else if (length === LU && head === 4) {
        const x2 = Fp22.fromBytes(tail.subarray(L * 0, L * 1));
        const y = Fp22.fromBytes(tail.subarray(L * 1, L * 2));
        if (!isValidXY(x2, y))
          throw new Error("bad point: is not on curve");
        return { x: x2, y };
      } else {
        throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
      }
    }
    const toBytes22 = curveOpts.toBytes || pointToBytes;
    const fromBytes = curveOpts.fromBytes || pointFromBytes;
    const weierstrassEquation = _legacyHelperEquat2(Fp22, CURVE.a, CURVE.b);
    function isValidXY(x2, y) {
      const left = Fp22.sqr(y);
      const right = weierstrassEquation(x2);
      return Fp22.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp22.mul(Fp22.pow(CURVE.a, _3n42), _4n32);
    const _27b2 = Fp22.mul(Fp22.sqr(CURVE.b), BigInt(27));
    if (Fp22.is0(Fp22.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n2, banZero = false) {
      if (!Fp22.isValid(n2) || banZero && Fp22.is0(n2))
        throw new Error(`bad point coordinate ${title}`);
      return n2;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point2))
        throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
      const { px: x2, py: y, pz: z } = p;
      if (Fp22.eql(z, Fp22.ONE))
        return { x: x2, y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp22.ONE : Fp22.inv(z);
      const ax = Fp22.mul(x2, iz);
      const ay = Fp22.mul(y, iz);
      const zz = Fp22.mul(z, iz);
      if (is0)
        return { x: Fp22.ZERO, y: Fp22.ZERO };
      if (!Fp22.eql(zz, Fp22.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
      if (p.is0()) {
        if (curveOpts.allowInfinityPoint && !Fp22.is0(p.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x2, y } = p.toAffine();
      if (!Fp22.isValid(x2) || !Fp22.isValid(y))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x2, y))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point2(Fp22.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
      k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
      k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
      return k1p.add(k2p);
    }

    class Point2 {
      constructor(px, py, pz) {
        this.px = acoord("x", px);
        this.py = acoord("y", py, true);
        this.pz = acoord("z", pz);
        Object.freeze(this);
      }
      static fromAffine(p) {
        const { x: x2, y } = p || {};
        if (!p || !Fp22.isValid(x2) || !Fp22.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point2)
          throw new Error("projective point not allowed");
        if (Fp22.is0(x2) && Fp22.is0(y))
          return Point2.ZERO;
        return new Point2(x2, y, Fp22.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        return (0, curve_ts_1.normalizeZ)(Point2, "pz", points);
      }
      static fromBytes(bytes2) {
        (0, utils_ts_1.abytes)(bytes2);
        return Point2.fromHex(bytes2);
      }
      static fromHex(hex) {
        const P22 = Point2.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex)));
        P22.assertValidity();
        return P22;
      }
      static fromPrivateKey(privateKey) {
        const normPrivateKeyToScalar = _legacyHelperNormPriv2(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(Point2, Fn, points, scalars);
      }
      precompute(windowSize = 8, isLazy = true) {
        wnaf.setWindowSize(this, windowSize);
        if (!isLazy)
          this.multiply(_3n42);
        return this;
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp22.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp22.isOdd(y);
      }
      equals(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U12 = Fp22.eql(Fp22.mul(X1, Z2), Fp22.mul(X2, Z1));
        const U22 = Fp22.eql(Fp22.mul(Y1, Z2), Fp22.mul(Y2, Z1));
        return U12 && U22;
      }
      negate() {
        return new Point2(this.px, Fp22.neg(this.py), this.pz);
      }
      double() {
        const { a, b: b22 } = CURVE;
        const b3 = Fp22.mul(b22, _3n42);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp22;
        let t0 = Fp22.mul(X1, X1);
        let t1 = Fp22.mul(Y1, Y1);
        let t2 = Fp22.mul(Z1, Z1);
        let t3 = Fp22.mul(X1, Y1);
        t3 = Fp22.add(t3, t3);
        Z3 = Fp22.mul(X1, Z1);
        Z3 = Fp22.add(Z3, Z3);
        X3 = Fp22.mul(a, Z3);
        Y3 = Fp22.mul(b3, t2);
        Y3 = Fp22.add(X3, Y3);
        X3 = Fp22.sub(t1, Y3);
        Y3 = Fp22.add(t1, Y3);
        Y3 = Fp22.mul(X3, Y3);
        X3 = Fp22.mul(t3, X3);
        Z3 = Fp22.mul(b3, Z3);
        t2 = Fp22.mul(a, t2);
        t3 = Fp22.sub(t0, t2);
        t3 = Fp22.mul(a, t3);
        t3 = Fp22.add(t3, Z3);
        Z3 = Fp22.add(t0, t0);
        t0 = Fp22.add(Z3, t0);
        t0 = Fp22.add(t0, t2);
        t0 = Fp22.mul(t0, t3);
        Y3 = Fp22.add(Y3, t0);
        t2 = Fp22.mul(Y1, Z1);
        t2 = Fp22.add(t2, t2);
        t0 = Fp22.mul(t2, t3);
        X3 = Fp22.sub(X3, t0);
        Z3 = Fp22.mul(t2, t1);
        Z3 = Fp22.add(Z3, Z3);
        Z3 = Fp22.add(Z3, Z3);
        return new Point2(X3, Y3, Z3);
      }
      add(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp22;
        const a = CURVE.a;
        const b3 = Fp22.mul(CURVE.b, _3n42);
        let t0 = Fp22.mul(X1, X2);
        let t1 = Fp22.mul(Y1, Y2);
        let t2 = Fp22.mul(Z1, Z2);
        let t3 = Fp22.add(X1, Y1);
        let t4 = Fp22.add(X2, Y2);
        t3 = Fp22.mul(t3, t4);
        t4 = Fp22.add(t0, t1);
        t3 = Fp22.sub(t3, t4);
        t4 = Fp22.add(X1, Z1);
        let t5 = Fp22.add(X2, Z2);
        t4 = Fp22.mul(t4, t5);
        t5 = Fp22.add(t0, t2);
        t4 = Fp22.sub(t4, t5);
        t5 = Fp22.add(Y1, Z1);
        X3 = Fp22.add(Y2, Z2);
        t5 = Fp22.mul(t5, X3);
        X3 = Fp22.add(t1, t2);
        t5 = Fp22.sub(t5, X3);
        Z3 = Fp22.mul(a, t4);
        X3 = Fp22.mul(b3, t2);
        Z3 = Fp22.add(X3, Z3);
        X3 = Fp22.sub(t1, Z3);
        Z3 = Fp22.add(t1, Z3);
        Y3 = Fp22.mul(X3, Z3);
        t1 = Fp22.add(t0, t0);
        t1 = Fp22.add(t1, t0);
        t2 = Fp22.mul(a, t2);
        t4 = Fp22.mul(b3, t4);
        t1 = Fp22.add(t1, t2);
        t2 = Fp22.sub(t0, t2);
        t2 = Fp22.mul(a, t2);
        t4 = Fp22.add(t4, t2);
        t0 = Fp22.mul(t1, t4);
        Y3 = Fp22.add(Y3, t0);
        t0 = Fp22.mul(t5, t4);
        X3 = Fp22.mul(t3, X3);
        X3 = Fp22.sub(X3, t0);
        t0 = Fp22.mul(t3, t1);
        Z3 = Fp22.mul(t5, Z3);
        Z3 = Fp22.add(Z3, t0);
        return new Point2(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point2.ZERO);
      }
      multiply(scalar) {
        const { endo: endo2 } = curveOpts;
        if (!Fn.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul2 = (n2) => wnaf.wNAFCached(this, n2, Point2.normalizeZ);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
          const { p: k1p, f: k1f } = mul2(k1);
          const { p: k2p, f: k2f } = mul2(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f: f22 } = mul2(scalar);
          point = p;
          fake = f22;
        }
        return Point2.normalizeZ([point, fake])[0];
      }
      multiplyUnsafe(sc) {
        const { endo: endo2 } = curveOpts;
        const p = this;
        if (!Fn.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n92 || p.is0())
          return Point2.ZERO;
        if (sc === _1n92)
          return p;
        if (wnaf.hasPrecomputes(this))
          return this.multiply(sc);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
          const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point2, p, k1, k2);
          return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
        } else {
          return wnaf.wNAFCachedUnsafe(p, sc);
        }
      }
      multiplyAndAddUnsafe(Q, a, b22) {
        const sum2 = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b22));
        return sum2.is0() ? undefined : sum2;
      }
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      isTorsionFree() {
        const { isTorsionFree } = curveOpts;
        if (cofactor === _1n92)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point2, this);
        return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = curveOpts;
        if (cofactor === _1n92)
          return this;
        if (clearCofactor)
          return clearCofactor(Point2, this);
        return this.multiplyUnsafe(cofactor);
      }
      toBytes(isCompressed = true) {
        (0, utils_ts_1.abool)("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes22(Point2, this, isCompressed);
      }
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      toHex(isCompressed = true) {
        return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
    }
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp22.ONE);
    Point2.ZERO = new Point2(Fp22.ZERO, Fp22.ONE, Fp22.ZERO);
    Point2.Fp = Fp22;
    Point2.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = (0, curve_ts_1.wNAF)(Point2, curveOpts.endo ? Math.ceil(bits / 2) : bits);
    return Point2;
  }
  function weierstrassPoints2(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new2(c);
    const Point2 = weierstrassN2(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point2);
  }
  function pprefix2(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function ecdsa2(Point2, ecdsaOpts, curveOpts = {}) {
    (0, utils_ts_1._validateObject)(ecdsaOpts, { hash: "function" }, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes_ = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
    const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(ecdsaOpts.hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
    const { Fp: Fp22, Fn } = Point2;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    function isBiggerThanHalfOrder(number22) {
      const HALF = CURVE_ORDER >> _1n92;
      return number22 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
    }
    function aValidRS(title, num) {
      if (!Fn.isValidNot0(num))
        throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
    }

    class Signature2 {
      constructor(r, s, recovery) {
        aValidRS("r", r);
        aValidRS("s", s);
        this.r = r;
        this.s = s;
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      static fromCompact(hex) {
        const L = Fn.BYTES;
        const b22 = (0, utils_ts_1.ensureBytes)("compactSignature", hex, L * 2);
        return new Signature2(Fn.fromBytes(b22.subarray(0, L)), Fn.fromBytes(b22.subarray(L, L * 2)));
      }
      static fromDER(hex) {
        const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)("DER", hex));
        return new Signature2(r, s);
      }
      assertValidity() {}
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const FIELD_ORDER = Fp22.ORDER;
        const { r, s, recovery: rec } = this;
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n72 < FIELD_ORDER;
        if (hasCofactor && rec > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp22.isValid(radj))
          throw new Error("recovery id 2 or 3 invalid");
        const x2 = Fp22.toBytes(radj);
        const R = Point2.fromHex((0, utils_ts_1.concatBytes)(pprefix2((rec & 1) === 0), x2));
        const ir = Fn.inv(radj);
        const h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", msgHash));
        const u1 = Fn.create(-h * ir);
        const u2 = Fn.create(s * ir);
        const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, Fn.neg(this.s), this.recovery) : this;
      }
      toBytes(format) {
        if (format === "compact")
          return (0, utils_ts_1.concatBytes)(Fn.toBytes(this.r), Fn.toBytes(this.s));
        if (format === "der")
          return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
        throw new Error("invalid format");
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
      }
    }
    const normPrivateKeyToScalar = _legacyHelperNormPriv2(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const n2 = CURVE_ORDER;
        return (0, modular_ts_1.mapHashToField)(randomBytes_((0, modular_ts_1.getMinHashLength)(n2)), n2);
      },
      precompute(windowSize = 8, point = Point2.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    function getPublicKey2(privateKey, isCompressed = true) {
      return Point2.fromPrivateKey(privateKey).toBytes(isCompressed);
    }
    function isProbPub(item) {
      if (typeof item === "bigint")
        return false;
      if (item instanceof Point2)
        return true;
      const arr = (0, utils_ts_1.ensureBytes)("key", item);
      const length = arr.length;
      const L = Fp22.BYTES;
      const LC = L + 1;
      const LU = 2 * L + 1;
      if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
        return;
      } else {
        return length === LC || length === LU;
      }
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicB) === false)
        throw new Error("second arg must be public key");
      const b22 = Point2.fromHex(publicB);
      return b22.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
    }
    const bits2int = ecdsaOpts.bits2int || function(bytes2) {
      if (bytes2.length > 8192)
        throw new Error("input is too large");
      const num = (0, utils_ts_1.bytesToNumberBE)(bytes2);
      const delta = bytes2.length * 8 - fnBits;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes2) {
      return Fn.create(bits2int(bytes2));
    };
    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
    function int2octets(num) {
      (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n92, ORDER_MASK);
      return Fn.toBytes(num);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => (k in opts)))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2 } = ecdsaOpts;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = (0, utils_ts_1.ensureBytes)("msgHash", msgHash);
      validateSigVerOpts2(opts);
      if (prehash)
        msgHash = (0, utils_ts_1.ensureBytes)("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes_(Fp22.BYTES) : ent;
        seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
      }
      const seed = (0, utils_ts_1.concatBytes)(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn.isValidNot0(k))
          return;
        const ik = Fn.inv(k);
        const q = Point2.BASE.multiply(k).toAffine();
        const r = Fn.create(q.x);
        if (r === _0n92)
          return;
        const s = Fn.create(ik * Fn.create(m + r * d));
        if (s === _0n92)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n92);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
    function sign22(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const drbg = (0, utils_ts_1.createHmacDrbg)(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
      return drbg(seed, k2sig);
    }
    Point2.BASE.precompute(8);
    function verify2(signature, msgHash, publicKey2, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = (0, utils_ts_1.ensureBytes)("msgHash", msgHash);
      publicKey2 = (0, utils_ts_1.ensureBytes)("publicKey", publicKey2);
      validateSigVerOpts2(opts);
      const { lowS, prehash, format } = opts;
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      if (format !== undefined && !["compact", "der", "js"].includes(format))
        throw new Error('format must be "compact", "der" or "js"');
      const isHex2 = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
      const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex2 && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      let _sig = undefined;
      let P22;
      try {
        if (isObj) {
          if (format === undefined || format === "js") {
            _sig = new Signature2(sg.r, sg.s);
          } else {
            throw new Error("invalid format");
          }
        }
        if (isHex2) {
          try {
            if (format !== "compact")
              _sig = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err))
              throw derError;
          }
          if (!_sig && format !== "der")
            _sig = Signature2.fromCompact(sg);
        }
        P22 = Point2.fromHex(publicKey2);
      } catch (error) {
        return false;
      }
      if (!_sig)
        return false;
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = ecdsaOpts.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is2 = Fn.inv(s);
      const u1 = Fn.create(h * is2);
      const u2 = Fn.create(r * is2);
      const R = Point2.BASE.multiplyUnsafe(u1).add(P22.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn.create(R.x);
      return v === r;
    }
    return Object.freeze({
      getPublicKey: getPublicKey2,
      getSharedSecret,
      sign: sign22,
      verify: verify2,
      utils,
      Point: Point2,
      Signature: Signature2
    });
  }
  function _weierstrass_legacy_opts_to_new2(c) {
    const CURVE = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp22 = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength);
    const curveOpts = {
      Fp: Fp22,
      Fn,
      allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      wrapPrivateKey: c.wrapPrivateKey,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return { CURVE, curveOpts };
  }
  function _ecdsa_legacy_opts_to_new2(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new2(c);
    const ecdsaOpts = {
      hash: c.hash,
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return { CURVE, curveOpts, ecdsaOpts };
  }
  function _weierstrass_new_output_to_legacy(c, Point2) {
    const { Fp: Fp22, Fn } = Point2;
    function isWithinCurveOrder(num) {
      return (0, utils_ts_1.inRange)(num, _1n92, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat2(Fp22, c.a, c.b);
    const normPrivateKeyToScalar = _legacyHelperNormPriv2(Fn, c.allowedPrivateKeyLengths, c.wrapPrivateKey);
    return Object.assign({}, {
      CURVE: c,
      Point: Point2,
      ProjectivePoint: Point2,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    });
  }
  function _ecdsa_new_output_to_legacy2(c, ecdsa3) {
    return Object.assign({}, ecdsa3, {
      ProjectivePoint: ecdsa3.Point,
      CURVE: c
    });
  }
  function weierstrass22(c) {
    const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new2(c);
    const Point2 = weierstrassN2(CURVE, curveOpts);
    const signs = ecdsa2(Point2, ecdsaOpts, curveOpts);
    return _ecdsa_new_output_to_legacy2(c, signs);
  }
  function SWUFpSqrtRatio(Fp22, Z2) {
    const q = Fp22.ORDER;
    let l = _0n92;
    for (let o = q - _1n92;o % _2n72 === _0n92; o /= _2n72)
      l += _1n92;
    const c1 = l;
    const _2n_pow_c1_1 = _2n72 << c1 - _1n92 - _1n92;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n72;
    const c2 = (q - _1n92) / _2n_pow_c1;
    const c3 = (c2 - _1n92) / _2n72;
    const c4 = _2n_pow_c1 - _1n92;
    const c5 = _2n_pow_c1_1;
    const c6 = Fp22.pow(Z2, c2);
    const c7 = Fp22.pow(Z2, (c2 + _1n92) / _2n72);
    let sqrtRatio = (u, v) => {
      let tv1 = c6;
      let tv2 = Fp22.pow(v, c4);
      let tv3 = Fp22.sqr(tv2);
      tv3 = Fp22.mul(tv3, v);
      let tv5 = Fp22.mul(u, tv3);
      tv5 = Fp22.pow(tv5, c3);
      tv5 = Fp22.mul(tv5, tv2);
      tv2 = Fp22.mul(tv5, v);
      tv3 = Fp22.mul(tv5, u);
      let tv4 = Fp22.mul(tv3, tv2);
      tv5 = Fp22.pow(tv4, c5);
      let isQR = Fp22.eql(tv5, Fp22.ONE);
      tv2 = Fp22.mul(tv3, c7);
      tv5 = Fp22.mul(tv4, tv1);
      tv3 = Fp22.cmov(tv2, tv3, isQR);
      tv4 = Fp22.cmov(tv5, tv4, isQR);
      for (let i22 = c1;i22 > _1n92; i22--) {
        let tv52 = i22 - _2n72;
        tv52 = _2n72 << tv52 - _1n92;
        let tvv5 = Fp22.pow(tv4, tv52);
        const e1 = Fp22.eql(tvv5, Fp22.ONE);
        tv2 = Fp22.mul(tv3, tv1);
        tv1 = Fp22.mul(tv1, tv1);
        tvv5 = Fp22.mul(tv4, tv1);
        tv3 = Fp22.cmov(tv2, tv3, e1);
        tv4 = Fp22.cmov(tvv5, tv4, e1);
      }
      return { isValid: isQR, value: tv3 };
    };
    if (Fp22.ORDER % _4n32 === _3n42) {
      const c12 = (Fp22.ORDER - _3n42) / _4n32;
      const c22 = Fp22.sqrt(Fp22.neg(Z2));
      sqrtRatio = (u, v) => {
        let tv1 = Fp22.sqr(v);
        const tv2 = Fp22.mul(u, v);
        tv1 = Fp22.mul(tv1, tv2);
        let y1 = Fp22.pow(tv1, c12);
        y1 = Fp22.mul(y1, tv2);
        const y2 = Fp22.mul(y1, c22);
        const tv3 = Fp22.mul(Fp22.sqr(y1), v);
        const isQR = Fp22.eql(tv3, u);
        let y = Fp22.cmov(y2, y1, isQR);
        return { isValid: isQR, value: y };
      };
    }
    return sqrtRatio;
  }
  function mapToCurveSimpleSWU(Fp22, opts) {
    (0, modular_ts_1.validateField)(Fp22);
    const { A, B, Z: Z2 } = opts;
    if (!Fp22.isValid(A) || !Fp22.isValid(B) || !Fp22.isValid(Z2))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp22, Z2);
    if (!Fp22.isOdd)
      throw new Error("Field does not have .isOdd()");
    return (u) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x2, y;
      tv1 = Fp22.sqr(u);
      tv1 = Fp22.mul(tv1, Z2);
      tv2 = Fp22.sqr(tv1);
      tv2 = Fp22.add(tv2, tv1);
      tv3 = Fp22.add(tv2, Fp22.ONE);
      tv3 = Fp22.mul(tv3, B);
      tv4 = Fp22.cmov(Z2, Fp22.neg(tv2), !Fp22.eql(tv2, Fp22.ZERO));
      tv4 = Fp22.mul(tv4, A);
      tv2 = Fp22.sqr(tv3);
      tv6 = Fp22.sqr(tv4);
      tv5 = Fp22.mul(tv6, A);
      tv2 = Fp22.add(tv2, tv5);
      tv2 = Fp22.mul(tv2, tv3);
      tv6 = Fp22.mul(tv6, tv4);
      tv5 = Fp22.mul(tv6, B);
      tv2 = Fp22.add(tv2, tv5);
      x2 = Fp22.mul(tv1, tv3);
      const { isValid, value } = sqrtRatio(tv2, tv6);
      y = Fp22.mul(tv1, u);
      y = Fp22.mul(y, value);
      x2 = Fp22.cmov(x2, tv3, isValid);
      y = Fp22.cmov(y, value, isValid);
      const e1 = Fp22.isOdd(u) === Fp22.isOdd(y);
      y = Fp22.cmov(Fp22.neg(y), y, e1);
      const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp22, [tv4], true)[0];
      x2 = Fp22.mul(x2, tv4_inv);
      return { x: x2, y };
    };
  }
});
var require__shortw_utils = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHash = getHash2;
  exports.createCurve = createCurve22;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var weierstrass_ts_1 = require_weierstrass();
  function getHash2(hash2) {
    return { hash: hash2 };
  }
  function createCurve22(curveDef, defHash) {
    const create22 = (hash2) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash2 });
    return { ...create22(defHash), create: create22 };
  }
});
var require_secp256k1 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = undefined;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  var sha2_js_1 = require_sha2();
  var utils_js_1 = require_utils();
  var _shortw_utils_ts_1 = require__shortw_utils();
  var hash_to_curve_ts_1 = require_hash_to_curve();
  var modular_ts_1 = require_modular();
  var weierstrass_ts_1 = require_weierstrass();
  var utils_ts_1 = require_utils2();
  var secp256k1_CURVE2 = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  var _0n92 = BigInt(0);
  var _1n92 = BigInt(1);
  var _2n72 = BigInt(2);
  var divNearest22 = (a, b22) => (a + b22 / _2n72) / b22;
  function sqrtMod22(y) {
    const P22 = secp256k1_CURVE2.p;
    const _3n42 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b22 = y * y * y % P22;
    const b3 = b22 * b22 * y % P22;
    const b6 = (0, modular_ts_1.pow2)(b3, _3n42, P22) * b3 % P22;
    const b9 = (0, modular_ts_1.pow2)(b6, _3n42, P22) * b3 % P22;
    const b11 = (0, modular_ts_1.pow2)(b9, _2n72, P22) * b22 % P22;
    const b222 = (0, modular_ts_1.pow2)(b11, _11n, P22) * b11 % P22;
    const b44 = (0, modular_ts_1.pow2)(b222, _22n, P22) * b222 % P22;
    const b88 = (0, modular_ts_1.pow2)(b44, _44n, P22) * b44 % P22;
    const b176 = (0, modular_ts_1.pow2)(b88, _88n, P22) * b88 % P22;
    const b220 = (0, modular_ts_1.pow2)(b176, _44n, P22) * b44 % P22;
    const b223 = (0, modular_ts_1.pow2)(b220, _3n42, P22) * b3 % P22;
    const t1 = (0, modular_ts_1.pow2)(b223, _23n, P22) * b222 % P22;
    const t2 = (0, modular_ts_1.pow2)(t1, _6n, P22) * b22 % P22;
    const root = (0, modular_ts_1.pow2)(t2, _2n72, P22);
    if (!Fpk12.eql(Fpk12.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fpk12 = (0, modular_ts_1.Field)(secp256k1_CURVE2.p, undefined, undefined, { sqrt: sqrtMod22 });
  exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({
    ...secp256k1_CURVE2,
    Fp: Fpk12,
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n2 = secp256k1_CURVE2.n;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n92 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b22 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest22(b22 * k, n2);
        const c2 = divNearest22(-b1 * k, n2);
        let k1 = (0, modular_ts_1.mod)(k - c1 * a1 - c2 * a2, n2);
        let k2 = (0, modular_ts_1.mod)(-c1 * b1 - c2 * b22, n2);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n2 - k1;
        if (k2neg)
          k2 = n2 - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha2_js_1.sha256);
  var TAGGED_HASH_PREFIXES = {};
  function taggedHash(tag2, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag2];
    if (tagP === undefined) {
      const tagH = (0, sha2_js_1.sha256)(Uint8Array.from(tag2, (c) => c.charCodeAt(0)));
      tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag2] = tagP;
    }
    return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
  }
  var pointToBytes = (point) => point.toBytes(true).slice(1);
  var numTo32b = (n2) => (0, utils_ts_1.numberToBytesBE)(n2, 32);
  var modP = (x2) => (0, modular_ts_1.mod)(x2, secp256k1_CURVE2.p);
  var modN = (x2) => (0, modular_ts_1.mod)(x2, secp256k1_CURVE2.n);
  var Point2 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
  var hasEven = (y) => y % _2n72 === _0n92;
  function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
    let p = Point2.fromPrivateKey(d_);
    const scalar = hasEven(p.y) ? d_ : modN(-d_);
    return { scalar, bytes: pointToBytes(p) };
  }
  function lift_x(x2) {
    (0, utils_ts_1.aInRange)("x", x2, _1n92, secp256k1_CURVE2.p);
    const xx = modP(x2 * x2);
    const c = modP(xx * x2 + BigInt(7));
    let y = sqrtMod22(c);
    if (!hasEven(y))
      y = modP(-y);
    const p = Point2.fromAffine({ x: x2, y });
    p.assertValidity();
    return p;
  }
  var num = utils_ts_1.bytesToNumberBE;
  function challenge(...args) {
    return modN(num(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message, privateKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
    const m = (0, utils_ts_1.ensureBytes)("message", message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
    const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
    const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
    const rand = taggedHash("BIP0340/nonce", t, px, m);
    const k_ = modN(num(rand));
    if (k_ === _0n92)
      throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    if (!schnorrVerify(sig, m, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature, message, publicKey2) {
    const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
    const m = (0, utils_ts_1.ensureBytes)("message", message);
    const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey2, 32);
    try {
      const P22 = lift_x(num(pub));
      const r = num(sig.subarray(0, 32));
      if (!(0, utils_ts_1.inRange)(r, _1n92, secp256k1_CURVE2.p))
        return false;
      const s = num(sig.subarray(32, 64));
      if (!(0, utils_ts_1.inRange)(s, _1n92, secp256k1_CURVE2.n))
        return false;
      const e = challenge(numTo32b(r), pointToBytes(P22), m);
      const R = Point2.BASE.multiplyUnsafe(s).add(P22.multiplyUnsafe(modN(-e)));
      const { x: x2, y } = R.toAffine();
      if (R.is0() || !hasEven(y) || x2 !== r)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE: utils_ts_1.numberToBytesBE,
      bytesToNumberBE: utils_ts_1.bytesToNumberBE,
      taggedHash,
      mod: modular_ts_1.mod
    }
  }))();
  var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk12, [
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ],
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
    ]
  ].map((i22) => i22.map((j) => BigInt(j)))))();
  var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk12, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Fpk12.create(BigInt("-11"))
  }))();
  exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
    const { x: x2, y } = mapSWU(Fpk12.create(scalars[0]));
    return isoMap(x2, y);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Fpk12.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha2_js_1.sha256
  }))();
  exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
  exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
});
var require_index_browser_cjs = __commonJS2((exports) => {
  var buffer = (init_buffer2(), __toCommonJS2(exports_buffer2));
  var ed255192 = require_ed25519();
  var BN2 = require_bn2();
  var bs582 = require_bs583();
  var sha25632 = require_sha256();
  var borsh = require_lib2();
  var BufferLayout2 = require_Layout2();
  var codecsNumbers = require_index_browser3();
  var superstruct = require_dist();
  var RpcClient2 = require_browser4();
  var rpcWebsockets = require_index_browser4();
  var sha3 = require_sha3();
  var secp256k122 = require_secp256k1();
  function _interopDefaultCompat(e) {
    return e && typeof e === "object" && "default" in e ? e : { default: e };
  }
  function _interopNamespaceCompat(e) {
    if (e && typeof e === "object" && "default" in e)
      return e;
    var n2 = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n2, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n2.default = e;
    return Object.freeze(n2);
  }
  var BN__default = /* @__PURE__ */ _interopDefaultCompat(BN2);
  var bs58__default = /* @__PURE__ */ _interopDefaultCompat(bs582);
  var BufferLayout__namespace = /* @__PURE__ */ _interopNamespaceCompat(BufferLayout2);
  var RpcClient__default = /* @__PURE__ */ _interopDefaultCompat(RpcClient2);
  var generatePrivateKey2 = ed255192.ed25519.utils.randomPrivateKey;
  var generateKeypair2 = () => {
    const privateScalar = ed255192.ed25519.utils.randomPrivateKey();
    const publicKey3 = getPublicKey2(privateScalar);
    const secretKey = new Uint8Array(64);
    secretKey.set(privateScalar);
    secretKey.set(publicKey3, 32);
    return {
      publicKey: publicKey3,
      secretKey
    };
  };
  var getPublicKey2 = ed255192.ed25519.getPublicKey;
  function isOnCurve2(publicKey3) {
    try {
      ed255192.ed25519.ExtendedPoint.fromHex(publicKey3);
      return true;
    } catch {
      return false;
    }
  }
  var sign22 = (message, secretKey) => ed255192.ed25519.sign(message, secretKey.slice(0, 32));
  var verify2 = ed255192.ed25519.verify;
  var toBuffer2 = (arr) => {
    if (buffer.Buffer.isBuffer(arr)) {
      return arr;
    } else if (arr instanceof Uint8Array) {
      return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
    } else {
      return buffer.Buffer.from(arr);
    }
  };

  class Struct3 {
    constructor(properties) {
      Object.assign(this, properties);
    }
    encode() {
      return buffer.Buffer.from(borsh.serialize(SOLANA_SCHEMA2, this));
    }
    static decode(data) {
      return borsh.deserialize(SOLANA_SCHEMA2, this, data);
    }
    static decodeUnchecked(data) {
      return borsh.deserializeUnchecked(SOLANA_SCHEMA2, this, data);
    }
  }

  class Enum extends Struct3 {
    constructor(properties) {
      super(properties);
      this.enum = "";
      if (Object.keys(properties).length !== 1) {
        throw new Error("Enum can only take single value");
      }
      Object.keys(properties).map((key) => {
        this.enum = key;
      });
    }
  }
  var SOLANA_SCHEMA2 = new Map;
  var _PublicKey2;
  var MAX_SEED_LENGTH2 = 32;
  var PUBLIC_KEY_LENGTH2 = 32;
  function isPublicKeyData2(value) {
    return value._bn !== undefined;
  }
  var uniquePublicKeyCounter2 = 1;

  class PublicKey2 extends Struct3 {
    constructor(value) {
      super({});
      this._bn = undefined;
      if (isPublicKeyData2(value)) {
        this._bn = value._bn;
      } else {
        if (typeof value === "string") {
          const decoded = bs58__default.default.decode(value);
          if (decoded.length != PUBLIC_KEY_LENGTH2) {
            throw new Error(`Invalid public key input`);
          }
          this._bn = new BN__default.default(decoded);
        } else {
          this._bn = new BN__default.default(value);
        }
        if (this._bn.byteLength() > PUBLIC_KEY_LENGTH2) {
          throw new Error(`Invalid public key input`);
        }
      }
    }
    static unique() {
      const key = new PublicKey2(uniquePublicKeyCounter2);
      uniquePublicKeyCounter2 += 1;
      return new PublicKey2(key.toBuffer());
    }
    equals(publicKey3) {
      return this._bn.eq(publicKey3._bn);
    }
    toBase58() {
      return bs58__default.default.encode(this.toBytes());
    }
    toJSON() {
      return this.toBase58();
    }
    toBytes() {
      const buf = this.toBuffer();
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    toBuffer() {
      const b22 = this._bn.toArrayLike(buffer.Buffer);
      if (b22.length === PUBLIC_KEY_LENGTH2) {
        return b22;
      }
      const zeroPad2 = buffer.Buffer.alloc(32);
      b22.copy(zeroPad2, 32 - b22.length);
      return zeroPad2;
    }
    get [Symbol.toStringTag]() {
      return `PublicKey(${this.toString()})`;
    }
    toString() {
      return this.toBase58();
    }
    static async createWithSeed(fromPublicKey, seed, programId) {
      const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);
      const publicKeyBytes = sha25632.sha256(buffer$1);
      return new PublicKey2(publicKeyBytes);
    }
    static createProgramAddressSync(seeds, programId) {
      let buffer$1 = buffer.Buffer.alloc(0);
      seeds.forEach(function(seed) {
        if (seed.length > MAX_SEED_LENGTH2) {
          throw new TypeError(`Max seed length exceeded`);
        }
        buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer2(seed)]);
      });
      buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
      const publicKeyBytes = sha25632.sha256(buffer$1);
      if (isOnCurve2(publicKeyBytes)) {
        throw new Error(`Invalid seeds, address must fall off the curve`);
      }
      return new PublicKey2(publicKeyBytes);
    }
    static async createProgramAddress(seeds, programId) {
      return this.createProgramAddressSync(seeds, programId);
    }
    static findProgramAddressSync(seeds, programId) {
      let nonce = 255;
      let address;
      while (nonce != 0) {
        try {
          const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
          address = this.createProgramAddressSync(seedsWithNonce, programId);
        } catch (err) {
          if (err instanceof TypeError) {
            throw err;
          }
          nonce--;
          continue;
        }
        return [address, nonce];
      }
      throw new Error(`Unable to find a viable program address nonce`);
    }
    static async findProgramAddress(seeds, programId) {
      return this.findProgramAddressSync(seeds, programId);
    }
    static isOnCurve(pubkeyData) {
      const pubkey = new PublicKey2(pubkeyData);
      return isOnCurve2(pubkey.toBytes());
    }
  }
  _PublicKey2 = PublicKey2;
  PublicKey2.default = new _PublicKey2("11111111111111111111111111111111");
  SOLANA_SCHEMA2.set(PublicKey2, {
    kind: "struct",
    fields: [["_bn", "u256"]]
  });

  class Account {
    constructor(secretKey) {
      this._publicKey = undefined;
      this._secretKey = undefined;
      if (secretKey) {
        const secretKeyBuffer = toBuffer2(secretKey);
        if (secretKey.length !== 64) {
          throw new Error("bad secret key size");
        }
        this._publicKey = secretKeyBuffer.slice(32, 64);
        this._secretKey = secretKeyBuffer.slice(0, 32);
      } else {
        this._secretKey = toBuffer2(generatePrivateKey2());
        this._publicKey = toBuffer2(getPublicKey2(this._secretKey));
      }
    }
    get publicKey() {
      return new PublicKey2(this._publicKey);
    }
    get secretKey() {
      return buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
    }
  }
  var BPF_LOADER_DEPRECATED_PROGRAM_ID2 = new PublicKey2("BPFLoader1111111111111111111111111111111111");
  var PACKET_DATA_SIZE2 = 1280 - 40 - 8;
  var VERSION_PREFIX_MASK2 = 127;
  var SIGNATURE_LENGTH_IN_BYTES2 = 64;

  class TransactionExpiredBlockheightExceededError2 extends Error {
    constructor(signature2) {
      super(`Signature ${signature2} has expired: block height exceeded.`);
      this.signature = undefined;
      this.signature = signature2;
    }
  }
  Object.defineProperty(TransactionExpiredBlockheightExceededError2.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
  });

  class TransactionExpiredTimeoutError2 extends Error {
    constructor(signature2, timeoutSeconds) {
      super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + "unknown if it succeeded or failed. Check signature " + `${signature2} using the Solana Explorer or CLI tools.`);
      this.signature = undefined;
      this.signature = signature2;
    }
  }
  Object.defineProperty(TransactionExpiredTimeoutError2.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
  });

  class TransactionExpiredNonceInvalidError2 extends Error {
    constructor(signature2) {
      super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
      this.signature = undefined;
      this.signature = signature2;
    }
  }
  Object.defineProperty(TransactionExpiredNonceInvalidError2.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
  });

  class MessageAccountKeys2 {
    constructor(staticAccountKeys, accountKeysFromLookups) {
      this.staticAccountKeys = undefined;
      this.accountKeysFromLookups = undefined;
      this.staticAccountKeys = staticAccountKeys;
      this.accountKeysFromLookups = accountKeysFromLookups;
    }
    keySegments() {
      const keySegments = [this.staticAccountKeys];
      if (this.accountKeysFromLookups) {
        keySegments.push(this.accountKeysFromLookups.writable);
        keySegments.push(this.accountKeysFromLookups.readonly);
      }
      return keySegments;
    }
    get(index) {
      for (const keySegment of this.keySegments()) {
        if (index < keySegment.length) {
          return keySegment[index];
        } else {
          index -= keySegment.length;
        }
      }
      return;
    }
    get length() {
      return this.keySegments().flat().length;
    }
    compileInstructions(instructions) {
      const U8_MAX = 255;
      if (this.length > U8_MAX + 1) {
        throw new Error("Account index overflow encountered during compilation");
      }
      const keyIndexMap = new Map;
      this.keySegments().flat().forEach((key, index) => {
        keyIndexMap.set(key.toBase58(), index);
      });
      const findKeyIndex = (key) => {
        const keyIndex = keyIndexMap.get(key.toBase58());
        if (keyIndex === undefined)
          throw new Error("Encountered an unknown instruction account key during compilation");
        return keyIndex;
      };
      return instructions.map((instruction) => {
        return {
          programIdIndex: findKeyIndex(instruction.programId),
          accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
          data: instruction.data
        };
      });
    }
  }
  var publicKey2 = (property = "publicKey") => {
    return BufferLayout__namespace.blob(32, property);
  };
  var signature = (property = "signature") => {
    return BufferLayout__namespace.blob(64, property);
  };
  var rustString2 = (property = "string") => {
    const rsl = BufferLayout__namespace.struct([BufferLayout__namespace.u32("length"), BufferLayout__namespace.u32("lengthPadding"), BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "chars")], property);
    const _decode2 = rsl.decode.bind(rsl);
    const _encode2 = rsl.encode.bind(rsl);
    const rslShim = rsl;
    rslShim.decode = (b22, offset2) => {
      const data = _decode2(b22, offset2);
      return data["chars"].toString();
    };
    rslShim.encode = (str, b22, offset2) => {
      const data = {
        chars: buffer.Buffer.from(str, "utf8")
      };
      return _encode2(data, b22, offset2);
    };
    rslShim.alloc = (str) => {
      return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str, "utf8").length;
    };
    return rslShim;
  };
  var authorized2 = (property = "authorized") => {
    return BufferLayout__namespace.struct([publicKey2("staker"), publicKey2("withdrawer")], property);
  };
  var lockup2 = (property = "lockup") => {
    return BufferLayout__namespace.struct([BufferLayout__namespace.ns64("unixTimestamp"), BufferLayout__namespace.ns64("epoch"), publicKey2("custodian")], property);
  };
  var voteInit2 = (property = "voteInit") => {
    return BufferLayout__namespace.struct([publicKey2("nodePubkey"), publicKey2("authorizedVoter"), publicKey2("authorizedWithdrawer"), BufferLayout__namespace.u8("commission")], property);
  };
  var voteAuthorizeWithSeedArgs2 = (property = "voteAuthorizeWithSeedArgs") => {
    return BufferLayout__namespace.struct([BufferLayout__namespace.u32("voteAuthorizationType"), publicKey2("currentAuthorityDerivedKeyOwnerPubkey"), rustString2("currentAuthorityDerivedKeySeed"), publicKey2("newAuthorized")], property);
  };
  function getAlloc2(type2, fields2) {
    const getItemAlloc = (item) => {
      if (item.span >= 0) {
        return item.span;
      } else if (typeof item.alloc === "function") {
        return item.alloc(fields2[item.property]);
      } else if ("count" in item && "elementLayout" in item) {
        const field = fields2[item.property];
        if (Array.isArray(field)) {
          return field.length * getItemAlloc(item.elementLayout);
        }
      } else if ("fields" in item) {
        return getAlloc2({
          layout: item
        }, fields2[item.property]);
      }
      return 0;
    };
    let alloc2 = 0;
    type2.layout.fields.forEach((item) => {
      alloc2 += getItemAlloc(item);
    });
    return alloc2;
  }
  function decodeLength2(bytes2) {
    let len2 = 0;
    let size = 0;
    for (;; ) {
      let elem = bytes2.shift();
      len2 |= (elem & 127) << size * 7;
      size += 1;
      if ((elem & 128) === 0) {
        break;
      }
    }
    return len2;
  }
  function encodeLength2(bytes2, len2) {
    let rem_len = len2;
    for (;; ) {
      let elem = rem_len & 127;
      rem_len >>= 7;
      if (rem_len == 0) {
        bytes2.push(elem);
        break;
      } else {
        elem |= 128;
        bytes2.push(elem);
      }
    }
  }
  function assert32(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  class CompiledKeys2 {
    constructor(payer, keyMetaMap) {
      this.payer = undefined;
      this.keyMetaMap = undefined;
      this.payer = payer;
      this.keyMetaMap = keyMetaMap;
    }
    static compile(instructions, payer) {
      const keyMetaMap = new Map;
      const getOrInsertDefault = (pubkey) => {
        const address = pubkey.toBase58();
        let keyMeta = keyMetaMap.get(address);
        if (keyMeta === undefined) {
          keyMeta = {
            isSigner: false,
            isWritable: false,
            isInvoked: false
          };
          keyMetaMap.set(address, keyMeta);
        }
        return keyMeta;
      };
      const payerKeyMeta = getOrInsertDefault(payer);
      payerKeyMeta.isSigner = true;
      payerKeyMeta.isWritable = true;
      for (const ix of instructions) {
        getOrInsertDefault(ix.programId).isInvoked = true;
        for (const accountMeta of ix.keys) {
          const keyMeta = getOrInsertDefault(accountMeta.pubkey);
          keyMeta.isSigner ||= accountMeta.isSigner;
          keyMeta.isWritable ||= accountMeta.isWritable;
        }
      }
      return new CompiledKeys2(payer, keyMetaMap);
    }
    getMessageComponents() {
      const mapEntries = [...this.keyMetaMap.entries()];
      assert32(mapEntries.length <= 256, "Max static account keys length exceeded");
      const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
      const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
      const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
      const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
      const header = {
        numRequiredSignatures: writableSigners.length + readonlySigners.length,
        numReadonlySignedAccounts: readonlySigners.length,
        numReadonlyUnsignedAccounts: readonlyNonSigners.length
      };
      {
        assert32(writableSigners.length > 0, "Expected at least one writable signer key");
        const [payerAddress] = writableSigners[0];
        assert32(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
      }
      const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey2(address)), ...readonlySigners.map(([address]) => new PublicKey2(address)), ...writableNonSigners.map(([address]) => new PublicKey2(address)), ...readonlyNonSigners.map(([address]) => new PublicKey2(address))];
      return [header, staticAccountKeys];
    }
    extractTableLookup(lookupTable) {
      const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
      const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
      if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
        return;
      }
      return [{
        accountKey: lookupTable.key,
        writableIndexes,
        readonlyIndexes
      }, {
        writable: drainedWritableKeys,
        readonly: drainedReadonlyKeys
      }];
    }
    drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
      const lookupTableIndexes = new Array;
      const drainedKeys = new Array;
      for (const [address, keyMeta] of this.keyMetaMap.entries()) {
        if (keyMetaFilter(keyMeta)) {
          const key = new PublicKey2(address);
          const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
          if (lookupTableIndex >= 0) {
            assert32(lookupTableIndex < 256, "Max lookup table index exceeded");
            lookupTableIndexes.push(lookupTableIndex);
            drainedKeys.push(key);
            this.keyMetaMap.delete(address);
          }
        }
      }
      return [lookupTableIndexes, drainedKeys];
    }
  }
  var END_OF_BUFFER_ERROR_MESSAGE2 = "Reached end of buffer unexpectedly";
  function guardedShift2(byteArray) {
    if (byteArray.length === 0) {
      throw new Error(END_OF_BUFFER_ERROR_MESSAGE2);
    }
    return byteArray.shift();
  }
  function guardedSplice2(byteArray, ...args) {
    const [start] = args;
    if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
      throw new Error(END_OF_BUFFER_ERROR_MESSAGE2);
    }
    return byteArray.splice(...args);
  }

  class Message2 {
    constructor(args) {
      this.header = undefined;
      this.accountKeys = undefined;
      this.recentBlockhash = undefined;
      this.instructions = undefined;
      this.indexToProgramIds = new Map;
      this.header = args.header;
      this.accountKeys = args.accountKeys.map((account) => new PublicKey2(account));
      this.recentBlockhash = args.recentBlockhash;
      this.instructions = args.instructions;
      this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
    }
    get version() {
      return "legacy";
    }
    get staticAccountKeys() {
      return this.accountKeys;
    }
    get compiledInstructions() {
      return this.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: bs58__default.default.decode(ix.data)
      }));
    }
    get addressTableLookups() {
      return [];
    }
    getAccountKeys() {
      return new MessageAccountKeys2(this.staticAccountKeys);
    }
    static compile(args) {
      const compiledKeys = CompiledKeys2.compile(args.instructions, args.payerKey);
      const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
      const accountKeys = new MessageAccountKeys2(staticAccountKeys);
      const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accounts: ix.accountKeyIndexes,
        data: bs58__default.default.encode(ix.data)
      }));
      return new Message2({
        header,
        accountKeys: staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        instructions
      });
    }
    isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
    isAccountWritable(index) {
      const numSignedAccounts = this.header.numRequiredSignatures;
      if (index >= this.header.numRequiredSignatures) {
        const unsignedAccountIndex = index - numSignedAccounts;
        const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
        const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
    isProgramId(index) {
      return this.indexToProgramIds.has(index);
    }
    programIds() {
      return [...this.indexToProgramIds.values()];
    }
    nonProgramIds() {
      return this.accountKeys.filter((_, index) => !this.isProgramId(index));
    }
    serialize() {
      const numKeys = this.accountKeys.length;
      let keyCount = [];
      encodeLength2(keyCount, numKeys);
      const instructions = this.instructions.map((instruction) => {
        const {
          accounts,
          programIdIndex
        } = instruction;
        const data = Array.from(bs58__default.default.decode(instruction.data));
        let keyIndicesCount = [];
        encodeLength2(keyIndicesCount, accounts.length);
        let dataCount = [];
        encodeLength2(dataCount, data.length);
        return {
          programIdIndex,
          keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
          keyIndices: accounts,
          dataLength: buffer.Buffer.from(dataCount),
          data
        };
      });
      let instructionCount = [];
      encodeLength2(instructionCount, instructions.length);
      let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE2);
      buffer.Buffer.from(instructionCount).copy(instructionBuffer);
      let instructionBufferLength = instructionCount.length;
      instructions.forEach((instruction) => {
        const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("programIdIndex"), BufferLayout__namespace.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout__namespace.blob(instruction.dataLength.length, "dataLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("userdatum"), instruction.data.length, "data")]);
        const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
        instructionBufferLength += length2;
      });
      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
      const signDataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(1, "numRequiredSignatures"), BufferLayout__namespace.blob(1, "numReadonlySignedAccounts"), BufferLayout__namespace.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout__namespace.blob(keyCount.length, "keyCount"), BufferLayout__namespace.seq(publicKey2("key"), numKeys, "keys"), publicKey2("recentBlockhash")]);
      const transaction = {
        numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
        numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
        numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
        keyCount: buffer.Buffer.from(keyCount),
        keys: this.accountKeys.map((key) => toBuffer2(key.toBytes())),
        recentBlockhash: bs58__default.default.decode(this.recentBlockhash)
      };
      let signData = buffer.Buffer.alloc(2048);
      const length = signDataLayout.encode(transaction, signData);
      instructionBuffer.copy(signData, length);
      return signData.slice(0, length + instructionBuffer.length);
    }
    static from(buffer$1) {
      let byteArray = [...buffer$1];
      const numRequiredSignatures = guardedShift2(byteArray);
      if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK2)) {
        throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
      }
      const numReadonlySignedAccounts = guardedShift2(byteArray);
      const numReadonlyUnsignedAccounts = guardedShift2(byteArray);
      const accountCount = decodeLength2(byteArray);
      let accountKeys = [];
      for (let i22 = 0;i22 < accountCount; i22++) {
        const account = guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2);
        accountKeys.push(new PublicKey2(buffer.Buffer.from(account)));
      }
      const recentBlockhash = guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2);
      const instructionCount = decodeLength2(byteArray);
      let instructions = [];
      for (let i22 = 0;i22 < instructionCount; i22++) {
        const programIdIndex = guardedShift2(byteArray);
        const accountCount2 = decodeLength2(byteArray);
        const accounts = guardedSplice2(byteArray, 0, accountCount2);
        const dataLength2 = decodeLength2(byteArray);
        const dataSlice2 = guardedSplice2(byteArray, 0, dataLength2);
        const data = bs58__default.default.encode(buffer.Buffer.from(dataSlice2));
        instructions.push({
          programIdIndex,
          accounts,
          data
        });
      }
      const messageArgs = {
        header: {
          numRequiredSignatures,
          numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts
        },
        recentBlockhash: bs58__default.default.encode(buffer.Buffer.from(recentBlockhash)),
        accountKeys,
        instructions
      };
      return new Message2(messageArgs);
    }
  }

  class MessageV0 {
    constructor(args) {
      this.header = undefined;
      this.staticAccountKeys = undefined;
      this.recentBlockhash = undefined;
      this.compiledInstructions = undefined;
      this.addressTableLookups = undefined;
      this.header = args.header;
      this.staticAccountKeys = args.staticAccountKeys;
      this.recentBlockhash = args.recentBlockhash;
      this.compiledInstructions = args.compiledInstructions;
      this.addressTableLookups = args.addressTableLookups;
    }
    get version() {
      return 0;
    }
    get numAccountKeysFromLookups() {
      let count = 0;
      for (const lookup2 of this.addressTableLookups) {
        count += lookup2.readonlyIndexes.length + lookup2.writableIndexes.length;
      }
      return count;
    }
    getAccountKeys(args) {
      let accountKeysFromLookups;
      if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
        if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
          throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
        }
        accountKeysFromLookups = args.accountKeysFromLookups;
      } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
        accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
      } else if (this.addressTableLookups.length > 0) {
        throw new Error("Failed to get account keys because address table lookups were not resolved");
      }
      return new MessageAccountKeys2(this.staticAccountKeys, accountKeysFromLookups);
    }
    isAccountSigner(index) {
      return index < this.header.numRequiredSignatures;
    }
    isAccountWritable(index) {
      const numSignedAccounts = this.header.numRequiredSignatures;
      const numStaticAccountKeys = this.staticAccountKeys.length;
      if (index >= numStaticAccountKeys) {
        const lookupAccountKeysIndex = index - numStaticAccountKeys;
        const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup2) => count + lookup2.writableIndexes.length, 0);
        return lookupAccountKeysIndex < numWritableLookupAccountKeys;
      } else if (index >= this.header.numRequiredSignatures) {
        const unsignedAccountIndex = index - numSignedAccounts;
        const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
        const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
        return unsignedAccountIndex < numWritableUnsignedAccounts;
      } else {
        const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
        return index < numWritableSignedAccounts;
      }
    }
    resolveAddressTableLookups(addressLookupTableAccounts) {
      const accountKeysFromLookups = {
        writable: [],
        readonly: []
      };
      for (const tableLookup of this.addressTableLookups) {
        const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
        if (!tableAccount) {
          throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
        }
        for (const index of tableLookup.writableIndexes) {
          if (index < tableAccount.state.addresses.length) {
            accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
          } else {
            throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
          }
        }
        for (const index of tableLookup.readonlyIndexes) {
          if (index < tableAccount.state.addresses.length) {
            accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
          } else {
            throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
          }
        }
      }
      return accountKeysFromLookups;
    }
    static compile(args) {
      const compiledKeys = CompiledKeys2.compile(args.instructions, args.payerKey);
      const addressTableLookups = new Array;
      const accountKeysFromLookups = {
        writable: new Array,
        readonly: new Array
      };
      const lookupTableAccounts = args.addressLookupTableAccounts || [];
      for (const lookupTable of lookupTableAccounts) {
        const extractResult = compiledKeys.extractTableLookup(lookupTable);
        if (extractResult !== undefined) {
          const [addressTableLookup, {
            writable,
            readonly
          }] = extractResult;
          addressTableLookups.push(addressTableLookup);
          accountKeysFromLookups.writable.push(...writable);
          accountKeysFromLookups.readonly.push(...readonly);
        }
      }
      const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
      const accountKeys = new MessageAccountKeys2(staticAccountKeys, accountKeysFromLookups);
      const compiledInstructions = accountKeys.compileInstructions(args.instructions);
      return new MessageV0({
        header,
        staticAccountKeys,
        recentBlockhash: args.recentBlockhash,
        compiledInstructions,
        addressTableLookups
      });
    }
    serialize() {
      const encodedStaticAccountKeysLength = Array();
      encodeLength2(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
      const serializedInstructions = this.serializeInstructions();
      const encodedInstructionsLength = Array();
      encodeLength2(encodedInstructionsLength, this.compiledInstructions.length);
      const serializedAddressTableLookups = this.serializeAddressTableLookups();
      const encodedAddressTableLookupsLength = Array();
      encodeLength2(encodedAddressTableLookupsLength, this.addressTableLookups.length);
      const messageLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("prefix"), BufferLayout__namespace.struct([BufferLayout__namespace.u8("numRequiredSignatures"), BufferLayout__namespace.u8("numReadonlySignedAccounts"), BufferLayout__namespace.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout__namespace.seq(publicKey2(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey2("recentBlockhash"), BufferLayout__namespace.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout__namespace.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout__namespace.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
      const serializedMessage = new Uint8Array(PACKET_DATA_SIZE2);
      const MESSAGE_VERSION_0_PREFIX = 1 << 7;
      const serializedMessageLength = messageLayout.encode({
        prefix: MESSAGE_VERSION_0_PREFIX,
        header: this.header,
        staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
        staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
        recentBlockhash: bs58__default.default.decode(this.recentBlockhash),
        instructionsLength: new Uint8Array(encodedInstructionsLength),
        serializedInstructions,
        addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
        serializedAddressTableLookups
      }, serializedMessage);
      return serializedMessage.slice(0, serializedMessageLength);
    }
    serializeInstructions() {
      let serializedLength = 0;
      const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE2);
      for (const instruction of this.compiledInstructions) {
        const encodedAccountKeyIndexesLength = Array();
        encodeLength2(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
        const encodedDataLength = Array();
        encodeLength2(encodedDataLength, instruction.data.length);
        const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("programIdIndex"), BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout__namespace.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout__namespace.blob(instruction.data.length, "data")]);
        serializedLength += instructionLayout.encode({
          programIdIndex: instruction.programIdIndex,
          encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
          accountKeyIndexes: instruction.accountKeyIndexes,
          encodedDataLength: new Uint8Array(encodedDataLength),
          data: instruction.data
        }, serializedInstructions, serializedLength);
      }
      return serializedInstructions.slice(0, serializedLength);
    }
    serializeAddressTableLookups() {
      let serializedLength = 0;
      const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE2);
      for (const lookup2 of this.addressTableLookups) {
        const encodedWritableIndexesLength = Array();
        encodeLength2(encodedWritableIndexesLength, lookup2.writableIndexes.length);
        const encodedReadonlyIndexesLength = Array();
        encodeLength2(encodedReadonlyIndexesLength, lookup2.readonlyIndexes.length);
        const addressTableLookupLayout = BufferLayout__namespace.struct([publicKey2("accountKey"), BufferLayout__namespace.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup2.writableIndexes.length, "writableIndexes"), BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup2.readonlyIndexes.length, "readonlyIndexes")]);
        serializedLength += addressTableLookupLayout.encode({
          accountKey: lookup2.accountKey.toBytes(),
          encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
          writableIndexes: lookup2.writableIndexes,
          encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
          readonlyIndexes: lookup2.readonlyIndexes
        }, serializedAddressTableLookups, serializedLength);
      }
      return serializedAddressTableLookups.slice(0, serializedLength);
    }
    static deserialize(serializedMessage) {
      let byteArray = [...serializedMessage];
      const prefix = guardedShift2(byteArray);
      const maskedPrefix = prefix & VERSION_PREFIX_MASK2;
      assert32(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
      const version22 = maskedPrefix;
      assert32(version22 === 0, `Expected versioned message with version 0 but found version ${version22}`);
      const header = {
        numRequiredSignatures: guardedShift2(byteArray),
        numReadonlySignedAccounts: guardedShift2(byteArray),
        numReadonlyUnsignedAccounts: guardedShift2(byteArray)
      };
      const staticAccountKeys = [];
      const staticAccountKeysLength = decodeLength2(byteArray);
      for (let i22 = 0;i22 < staticAccountKeysLength; i22++) {
        staticAccountKeys.push(new PublicKey2(guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2)));
      }
      const recentBlockhash = bs58__default.default.encode(guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2));
      const instructionCount = decodeLength2(byteArray);
      const compiledInstructions = [];
      for (let i22 = 0;i22 < instructionCount; i22++) {
        const programIdIndex = guardedShift2(byteArray);
        const accountKeyIndexesLength = decodeLength2(byteArray);
        const accountKeyIndexes = guardedSplice2(byteArray, 0, accountKeyIndexesLength);
        const dataLength2 = decodeLength2(byteArray);
        const data = new Uint8Array(guardedSplice2(byteArray, 0, dataLength2));
        compiledInstructions.push({
          programIdIndex,
          accountKeyIndexes,
          data
        });
      }
      const addressTableLookupsCount = decodeLength2(byteArray);
      const addressTableLookups = [];
      for (let i22 = 0;i22 < addressTableLookupsCount; i22++) {
        const accountKey = new PublicKey2(guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2));
        const writableIndexesLength = decodeLength2(byteArray);
        const writableIndexes = guardedSplice2(byteArray, 0, writableIndexesLength);
        const readonlyIndexesLength = decodeLength2(byteArray);
        const readonlyIndexes = guardedSplice2(byteArray, 0, readonlyIndexesLength);
        addressTableLookups.push({
          accountKey,
          writableIndexes,
          readonlyIndexes
        });
      }
      return new MessageV0({
        header,
        staticAccountKeys,
        recentBlockhash,
        compiledInstructions,
        addressTableLookups
      });
    }
  }
  var VersionedMessage = {
    deserializeMessageVersion(serializedMessage) {
      const prefix = serializedMessage[0];
      const maskedPrefix = prefix & VERSION_PREFIX_MASK2;
      if (maskedPrefix === prefix) {
        return "legacy";
      }
      return maskedPrefix;
    },
    deserialize: (serializedMessage) => {
      const version22 = VersionedMessage.deserializeMessageVersion(serializedMessage);
      if (version22 === "legacy") {
        return Message2.from(serializedMessage);
      }
      if (version22 === 0) {
        return MessageV0.deserialize(serializedMessage);
      } else {
        throw new Error(`Transaction message version ${version22} deserialization is not supported`);
      }
    }
  };
  var TransactionStatus = /* @__PURE__ */ function(TransactionStatus2) {
    TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
    TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
    TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
    TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
    return TransactionStatus2;
  }({});
  var DEFAULT_SIGNATURE2 = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES2).fill(0);

  class TransactionInstruction2 {
    constructor(opts) {
      this.keys = undefined;
      this.programId = undefined;
      this.data = buffer.Buffer.alloc(0);
      this.programId = opts.programId;
      this.keys = opts.keys;
      if (opts.data) {
        this.data = opts.data;
      }
    }
    toJSON() {
      return {
        keys: this.keys.map(({
          pubkey,
          isSigner,
          isWritable
        }) => ({
          pubkey: pubkey.toJSON(),
          isSigner,
          isWritable
        })),
        programId: this.programId.toJSON(),
        data: [...this.data]
      };
    }
  }

  class Transaction22 {
    get signature() {
      if (this.signatures.length > 0) {
        return this.signatures[0].signature;
      }
      return null;
    }
    constructor(opts) {
      this.signatures = [];
      this.feePayer = undefined;
      this.instructions = [];
      this.recentBlockhash = undefined;
      this.lastValidBlockHeight = undefined;
      this.nonceInfo = undefined;
      this.minNonceContextSlot = undefined;
      this._message = undefined;
      this._json = undefined;
      if (!opts) {
        return;
      }
      if (opts.feePayer) {
        this.feePayer = opts.feePayer;
      }
      if (opts.signatures) {
        this.signatures = opts.signatures;
      }
      if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
        const {
          minContextSlot,
          nonceInfo
        } = opts;
        this.minNonceContextSlot = minContextSlot;
        this.nonceInfo = nonceInfo;
      } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
        const {
          blockhash,
          lastValidBlockHeight
        } = opts;
        this.recentBlockhash = blockhash;
        this.lastValidBlockHeight = lastValidBlockHeight;
      } else {
        const {
          recentBlockhash,
          nonceInfo
        } = opts;
        if (nonceInfo) {
          this.nonceInfo = nonceInfo;
        }
        this.recentBlockhash = recentBlockhash;
      }
    }
    toJSON() {
      return {
        recentBlockhash: this.recentBlockhash || null,
        feePayer: this.feePayer ? this.feePayer.toJSON() : null,
        nonceInfo: this.nonceInfo ? {
          nonce: this.nonceInfo.nonce,
          nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
        } : null,
        instructions: this.instructions.map((instruction) => instruction.toJSON()),
        signers: this.signatures.map(({
          publicKey: publicKey3
        }) => {
          return publicKey3.toJSON();
        })
      };
    }
    add(...items) {
      if (items.length === 0) {
        throw new Error("No instructions");
      }
      items.forEach((item) => {
        if ("instructions" in item) {
          this.instructions = this.instructions.concat(item.instructions);
        } else if ("data" in item && "programId" in item && "keys" in item) {
          this.instructions.push(item);
        } else {
          this.instructions.push(new TransactionInstruction2(item));
        }
      });
      return this;
    }
    compileMessage() {
      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
        return this._message;
      }
      let recentBlockhash;
      let instructions;
      if (this.nonceInfo) {
        recentBlockhash = this.nonceInfo.nonce;
        if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
          instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
        } else {
          instructions = this.instructions;
        }
      } else {
        recentBlockhash = this.recentBlockhash;
        instructions = this.instructions;
      }
      if (!recentBlockhash) {
        throw new Error("Transaction recentBlockhash required");
      }
      if (instructions.length < 1) {
        console.warn("No instructions provided");
      }
      let feePayer;
      if (this.feePayer) {
        feePayer = this.feePayer;
      } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
        feePayer = this.signatures[0].publicKey;
      } else {
        throw new Error("Transaction fee payer required");
      }
      for (let i22 = 0;i22 < instructions.length; i22++) {
        if (instructions[i22].programId === undefined) {
          throw new Error(`Transaction instruction index ${i22} has undefined program id`);
        }
      }
      const programIds = [];
      const accountMetas = [];
      instructions.forEach((instruction) => {
        instruction.keys.forEach((accountMeta) => {
          accountMetas.push({
            ...accountMeta
          });
        });
        const programId = instruction.programId.toString();
        if (!programIds.includes(programId)) {
          programIds.push(programId);
        }
      });
      programIds.forEach((programId) => {
        accountMetas.push({
          pubkey: new PublicKey2(programId),
          isSigner: false,
          isWritable: false
        });
      });
      const uniqueMetas = [];
      accountMetas.forEach((accountMeta) => {
        const pubkeyString = accountMeta.pubkey.toString();
        const uniqueIndex = uniqueMetas.findIndex((x2) => {
          return x2.pubkey.toString() === pubkeyString;
        });
        if (uniqueIndex > -1) {
          uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
          uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
        } else {
          uniqueMetas.push(accountMeta);
        }
      });
      uniqueMetas.sort(function(x2, y) {
        if (x2.isSigner !== y.isSigner) {
          return x2.isSigner ? -1 : 1;
        }
        if (x2.isWritable !== y.isWritable) {
          return x2.isWritable ? -1 : 1;
        }
        const options = {
          localeMatcher: "best fit",
          usage: "sort",
          sensitivity: "variant",
          ignorePunctuation: false,
          numeric: false,
          caseFirst: "lower"
        };
        return x2.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
      });
      const feePayerIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.equals(feePayer);
      });
      if (feePayerIndex > -1) {
        const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
        payerMeta.isSigner = true;
        payerMeta.isWritable = true;
        uniqueMetas.unshift(payerMeta);
      } else {
        uniqueMetas.unshift({
          pubkey: feePayer,
          isSigner: true,
          isWritable: true
        });
      }
      for (const signature2 of this.signatures) {
        const uniqueIndex = uniqueMetas.findIndex((x2) => {
          return x2.pubkey.equals(signature2.publicKey);
        });
        if (uniqueIndex > -1) {
          if (!uniqueMetas[uniqueIndex].isSigner) {
            uniqueMetas[uniqueIndex].isSigner = true;
            console.warn("Transaction references a signature that is unnecessary, " + "only the fee payer and instruction signer accounts should sign a transaction. " + "This behavior is deprecated and will throw an error in the next major version release.");
          }
        } else {
          throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
        }
      }
      let numRequiredSignatures = 0;
      let numReadonlySignedAccounts = 0;
      let numReadonlyUnsignedAccounts = 0;
      const signedKeys = [];
      const unsignedKeys = [];
      uniqueMetas.forEach(({
        pubkey,
        isSigner,
        isWritable
      }) => {
        if (isSigner) {
          signedKeys.push(pubkey.toString());
          numRequiredSignatures += 1;
          if (!isWritable) {
            numReadonlySignedAccounts += 1;
          }
        } else {
          unsignedKeys.push(pubkey.toString());
          if (!isWritable) {
            numReadonlyUnsignedAccounts += 1;
          }
        }
      });
      const accountKeys = signedKeys.concat(unsignedKeys);
      const compiledInstructions = instructions.map((instruction) => {
        const {
          data,
          programId
        } = instruction;
        return {
          programIdIndex: accountKeys.indexOf(programId.toString()),
          accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
          data: bs58__default.default.encode(data)
        };
      });
      compiledInstructions.forEach((instruction) => {
        assert32(instruction.programIdIndex >= 0);
        instruction.accounts.forEach((keyIndex) => assert32(keyIndex >= 0));
      });
      return new Message2({
        header: {
          numRequiredSignatures,
          numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts
        },
        accountKeys,
        recentBlockhash,
        instructions: compiledInstructions
      });
    }
    _compile() {
      const message = this.compileMessage();
      const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
      if (this.signatures.length === signedKeys.length) {
        const valid = this.signatures.every((pair, index) => {
          return signedKeys[index].equals(pair.publicKey);
        });
        if (valid)
          return message;
      }
      this.signatures = signedKeys.map((publicKey3) => ({
        signature: null,
        publicKey: publicKey3
      }));
      return message;
    }
    serializeMessage() {
      return this._compile().serialize();
    }
    async getEstimatedFee(connection) {
      return (await connection.getFeeForMessage(this.compileMessage())).value;
    }
    setSigners(...signers) {
      if (signers.length === 0) {
        throw new Error("No signers");
      }
      const seen = new Set;
      this.signatures = signers.filter((publicKey3) => {
        const key = publicKey3.toString();
        if (seen.has(key)) {
          return false;
        } else {
          seen.add(key);
          return true;
        }
      }).map((publicKey3) => ({
        signature: null,
        publicKey: publicKey3
      }));
    }
    sign(...signers) {
      if (signers.length === 0) {
        throw new Error("No signers");
      }
      const seen = new Set;
      const uniqueSigners = [];
      for (const signer of signers) {
        const key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      this.signatures = uniqueSigners.map((signer) => ({
        signature: null,
        publicKey: signer.publicKey
      }));
      const message = this._compile();
      this._partialSign(message, ...uniqueSigners);
    }
    partialSign(...signers) {
      if (signers.length === 0) {
        throw new Error("No signers");
      }
      const seen = new Set;
      const uniqueSigners = [];
      for (const signer of signers) {
        const key = signer.publicKey.toString();
        if (seen.has(key)) {
          continue;
        } else {
          seen.add(key);
          uniqueSigners.push(signer);
        }
      }
      const message = this._compile();
      this._partialSign(message, ...uniqueSigners);
    }
    _partialSign(message, ...signers) {
      const signData = message.serialize();
      signers.forEach((signer) => {
        const signature2 = sign22(signData, signer.secretKey);
        this._addSignature(signer.publicKey, toBuffer2(signature2));
      });
    }
    addSignature(pubkey, signature2) {
      this._compile();
      this._addSignature(pubkey, signature2);
    }
    _addSignature(pubkey, signature2) {
      assert32(signature2.length === 64);
      const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
      if (index < 0) {
        throw new Error(`unknown signer: ${pubkey.toString()}`);
      }
      this.signatures[index].signature = buffer.Buffer.from(signature2);
    }
    verifySignatures(requireAllSignatures = true) {
      const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
      return !signatureErrors;
    }
    _getMessageSignednessErrors(message, requireAllSignatures) {
      const errors = {};
      for (const {
        signature: signature2,
        publicKey: publicKey3
      } of this.signatures) {
        if (signature2 === null) {
          if (requireAllSignatures) {
            (errors.missing ||= []).push(publicKey3);
          }
        } else {
          if (!verify2(signature2, message, publicKey3.toBytes())) {
            (errors.invalid ||= []).push(publicKey3);
          }
        }
      }
      return errors.invalid || errors.missing ? errors : undefined;
    }
    serialize(config2) {
      const {
        requireAllSignatures,
        verifySignatures
      } = Object.assign({
        requireAllSignatures: true,
        verifySignatures: true
      }, config2);
      const signData = this.serializeMessage();
      if (verifySignatures) {
        const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
        if (sigErrors) {
          let errorMessage = "Signature verification failed.";
          if (sigErrors.invalid) {
            errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
          }
          if (sigErrors.missing) {
            errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
          }
          throw new Error(errorMessage);
        }
      }
      return this._serialize(signData);
    }
    _serialize(signData) {
      const {
        signatures
      } = this;
      const signatureCount = [];
      encodeLength2(signatureCount, signatures.length);
      const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
      const wireTransaction = buffer.Buffer.alloc(transactionLength);
      assert32(signatures.length < 256);
      buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
      signatures.forEach(({
        signature: signature2
      }, index) => {
        if (signature2 !== null) {
          assert32(signature2.length === 64, `signature has invalid length`);
          buffer.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index * 64);
        }
      });
      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
      assert32(wireTransaction.length <= PACKET_DATA_SIZE2, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE2}`);
      return wireTransaction;
    }
    get keys() {
      assert32(this.instructions.length === 1);
      return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
    }
    get programId() {
      assert32(this.instructions.length === 1);
      return this.instructions[0].programId;
    }
    get data() {
      assert32(this.instructions.length === 1);
      return this.instructions[0].data;
    }
    static from(buffer$1) {
      let byteArray = [...buffer$1];
      const signatureCount = decodeLength2(byteArray);
      let signatures = [];
      for (let i22 = 0;i22 < signatureCount; i22++) {
        const signature2 = guardedSplice2(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES2);
        signatures.push(bs58__default.default.encode(buffer.Buffer.from(signature2)));
      }
      return Transaction22.populate(Message2.from(byteArray), signatures);
    }
    static populate(message, signatures = []) {
      const transaction = new Transaction22;
      transaction.recentBlockhash = message.recentBlockhash;
      if (message.header.numRequiredSignatures > 0) {
        transaction.feePayer = message.accountKeys[0];
      }
      signatures.forEach((signature2, index) => {
        const sigPubkeyPair = {
          signature: signature2 == bs58__default.default.encode(DEFAULT_SIGNATURE2) ? null : bs58__default.default.decode(signature2),
          publicKey: message.accountKeys[index]
        };
        transaction.signatures.push(sigPubkeyPair);
      });
      message.instructions.forEach((instruction) => {
        const keys = instruction.accounts.map((account) => {
          const pubkey = message.accountKeys[account];
          return {
            pubkey,
            isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
            isWritable: message.isAccountWritable(account)
          };
        });
        transaction.instructions.push(new TransactionInstruction2({
          keys,
          programId: message.accountKeys[instruction.programIdIndex],
          data: bs58__default.default.decode(instruction.data)
        }));
      });
      transaction._message = message;
      transaction._json = transaction.toJSON();
      return transaction;
    }
  }

  class TransactionMessage {
    constructor(args) {
      this.payerKey = undefined;
      this.instructions = undefined;
      this.recentBlockhash = undefined;
      this.payerKey = args.payerKey;
      this.instructions = args.instructions;
      this.recentBlockhash = args.recentBlockhash;
    }
    static decompile(message, args) {
      const {
        header,
        compiledInstructions,
        recentBlockhash
      } = message;
      const {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      } = header;
      const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
      assert32(numWritableSignedAccounts > 0, "Message header is invalid");
      const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
      assert32(numWritableUnsignedAccounts >= 0, "Message header is invalid");
      const accountKeys = message.getAccountKeys(args);
      const payerKey = accountKeys.get(0);
      if (payerKey === undefined) {
        throw new Error("Failed to decompile message because no account keys were found");
      }
      const instructions = [];
      for (const compiledIx of compiledInstructions) {
        const keys = [];
        for (const keyIndex of compiledIx.accountKeyIndexes) {
          const pubkey = accountKeys.get(keyIndex);
          if (pubkey === undefined) {
            throw new Error(`Failed to find key for account key index ${keyIndex}`);
          }
          const isSigner = keyIndex < numRequiredSignatures;
          let isWritable;
          if (isSigner) {
            isWritable = keyIndex < numWritableSignedAccounts;
          } else if (keyIndex < accountKeys.staticAccountKeys.length) {
            isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
          } else {
            isWritable = keyIndex - accountKeys.staticAccountKeys.length < accountKeys.accountKeysFromLookups.writable.length;
          }
          keys.push({
            pubkey,
            isSigner: keyIndex < header.numRequiredSignatures,
            isWritable
          });
        }
        const programId = accountKeys.get(compiledIx.programIdIndex);
        if (programId === undefined) {
          throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
        }
        instructions.push(new TransactionInstruction2({
          programId,
          data: toBuffer2(compiledIx.data),
          keys
        }));
      }
      return new TransactionMessage({
        payerKey,
        instructions,
        recentBlockhash
      });
    }
    compileToLegacyMessage() {
      return Message2.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions
      });
    }
    compileToV0Message(addressLookupTableAccounts) {
      return MessageV0.compile({
        payerKey: this.payerKey,
        recentBlockhash: this.recentBlockhash,
        instructions: this.instructions,
        addressLookupTableAccounts
      });
    }
  }

  class VersionedTransaction {
    get version() {
      return this.message.version;
    }
    constructor(message, signatures) {
      this.signatures = undefined;
      this.message = undefined;
      if (signatures !== undefined) {
        assert32(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
        this.signatures = signatures;
      } else {
        const defaultSignatures = [];
        for (let i22 = 0;i22 < message.header.numRequiredSignatures; i22++) {
          defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES2));
        }
        this.signatures = defaultSignatures;
      }
      this.message = message;
    }
    serialize() {
      const serializedMessage = this.message.serialize();
      const encodedSignaturesLength = Array();
      encodeLength2(encodedSignaturesLength, this.signatures.length);
      const transactionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout__namespace.seq(signature(), this.signatures.length, "signatures"), BufferLayout__namespace.blob(serializedMessage.length, "serializedMessage")]);
      const serializedTransaction = new Uint8Array(2048);
      const serializedTransactionLength = transactionLayout.encode({
        encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
        signatures: this.signatures,
        serializedMessage
      }, serializedTransaction);
      return serializedTransaction.slice(0, serializedTransactionLength);
    }
    static deserialize(serializedTransaction) {
      let byteArray = [...serializedTransaction];
      const signatures = [];
      const signaturesLength = decodeLength2(byteArray);
      for (let i22 = 0;i22 < signaturesLength; i22++) {
        signatures.push(new Uint8Array(guardedSplice2(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES2)));
      }
      const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
      return new VersionedTransaction(message, signatures);
    }
    sign(signers) {
      const messageData = this.message.serialize();
      const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      for (const signer of signers) {
        const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
        assert32(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
        this.signatures[signerIndex] = sign22(messageData, signer.secretKey);
      }
    }
    addSignature(publicKey3, signature2) {
      assert32(signature2.byteLength === 64, "Signature must be 64 bytes long");
      const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
      const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(publicKey3));
      assert32(signerIndex >= 0, `Can not add signature; \`${publicKey3.toBase58()}\` is not required to sign this transaction`);
      this.signatures[signerIndex] = signature2;
    }
  }
  var NUM_TICKS_PER_SECOND2 = 160;
  var DEFAULT_TICKS_PER_SLOT2 = 64;
  var NUM_SLOTS_PER_SECOND2 = NUM_TICKS_PER_SECOND2 / DEFAULT_TICKS_PER_SLOT2;
  var MS_PER_SLOT2 = 1000 / NUM_SLOTS_PER_SECOND2;
  var SYSVAR_CLOCK_PUBKEY2 = new PublicKey2("SysvarC1ock11111111111111111111111111111111");
  var SYSVAR_EPOCH_SCHEDULE_PUBKEY2 = new PublicKey2("SysvarEpochSchedu1e111111111111111111111111");
  var SYSVAR_INSTRUCTIONS_PUBKEY2 = new PublicKey2("Sysvar1nstructions1111111111111111111111111");
  var SYSVAR_RECENT_BLOCKHASHES_PUBKEY2 = new PublicKey2("SysvarRecentB1ockHashes11111111111111111111");
  var SYSVAR_RENT_PUBKEY2 = new PublicKey2("SysvarRent111111111111111111111111111111111");
  var SYSVAR_REWARDS_PUBKEY2 = new PublicKey2("SysvarRewards111111111111111111111111111111");
  var SYSVAR_SLOT_HASHES_PUBKEY2 = new PublicKey2("SysvarS1otHashes111111111111111111111111111");
  var SYSVAR_SLOT_HISTORY_PUBKEY2 = new PublicKey2("SysvarS1otHistory11111111111111111111111111");
  var SYSVAR_STAKE_HISTORY_PUBKEY2 = new PublicKey2("SysvarStakeHistory1111111111111111111111111");

  class SendTransactionError2 extends Error {
    constructor({
      action,
      signature: signature2,
      transactionMessage,
      logs
    }) {
      const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
      const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
      let message;
      switch (action) {
        case "send":
          message = `Transaction ${signature2} resulted in an error. 
` + `${transactionMessage}. ` + maybeLogsOutput + guideText;
          break;
        case "simulate":
          message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
          break;
        default: {
          message = `Unknown action '${((a) => a)(action)}'`;
        }
      }
      super(message);
      this.signature = undefined;
      this.transactionMessage = undefined;
      this.transactionLogs = undefined;
      this.signature = signature2;
      this.transactionMessage = transactionMessage;
      this.transactionLogs = logs ? logs : undefined;
    }
    get transactionError() {
      return {
        message: this.transactionMessage,
        logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined
      };
    }
    get logs() {
      const cachedLogs = this.transactionLogs;
      if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
        return;
      }
      return cachedLogs;
    }
    async getLogs(connection) {
      if (!Array.isArray(this.transactionLogs)) {
        this.transactionLogs = new Promise((resolve, reject) => {
          connection.getTransaction(this.signature).then((tx) => {
            if (tx && tx.meta && tx.meta.logMessages) {
              const logs = tx.meta.logMessages;
              this.transactionLogs = logs;
              resolve(logs);
            } else {
              reject(new Error("Log messages not found"));
            }
          }).catch(reject);
        });
      }
      return await this.transactionLogs;
    }
  }
  var SolanaJSONRPCErrorCode = {
    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
    JSON_RPC_SCAN_ERROR: -32012,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
  };

  class SolanaJSONRPCError extends Error {
    constructor({
      code: code2,
      message,
      data
    }, customMessage) {
      super(customMessage != null ? `${customMessage}: ${message}` : message);
      this.code = undefined;
      this.data = undefined;
      this.code = code2;
      this.data = data;
      this.name = "SolanaJSONRPCError";
    }
  }
  async function sendAndConfirmTransaction2(connection, transaction, signers, options) {
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment,
      maxRetries: options.maxRetries,
      minContextSlot: options.minContextSlot
    };
    const signature2 = await connection.sendTransaction(transaction, signers, sendOptions);
    let status;
    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
      status = (await connection.confirmTransaction({
        abortSignal: options?.abortSignal,
        signature: signature2,
        blockhash: transaction.recentBlockhash,
        lastValidBlockHeight: transaction.lastValidBlockHeight
      }, options && options.commitment)).value;
    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
      const {
        nonceInstruction
      } = transaction.nonceInfo;
      const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
      status = (await connection.confirmTransaction({
        abortSignal: options?.abortSignal,
        minContextSlot: transaction.minNonceContextSlot,
        nonceAccountPubkey,
        nonceValue: transaction.nonceInfo.nonce,
        signature: signature2
      }, options && options.commitment)).value;
    } else {
      if (options?.abortSignal != null) {
        console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was " + "supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` " + "or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
      }
      status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
    }
    if (status.err) {
      if (signature2 != null) {
        throw new SendTransactionError2({
          action: "send",
          signature: signature2,
          transactionMessage: `Status: (${JSON.stringify(status)})`
        });
      }
      throw new Error(`Transaction ${signature2} failed (${JSON.stringify(status)})`);
    }
    return signature2;
  }
  function sleep2(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function encodeData2(type2, fields2) {
    const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc2(type2, fields2);
    const data = buffer.Buffer.alloc(allocLength);
    const layoutFields = Object.assign({
      instruction: type2.index
    }, fields2);
    type2.layout.encode(layoutFields, data);
    return data;
  }
  function decodeData$1(type2, buffer2) {
    let data;
    try {
      data = type2.layout.decode(buffer2);
    } catch (err) {
      throw new Error("invalid instruction; " + err);
    }
    if (data.instruction !== type2.index) {
      throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type2.index}`);
    }
    return data;
  }
  var FeeCalculatorLayout2 = BufferLayout__namespace.nu64("lamportsPerSignature");
  var NonceAccountLayout2 = BufferLayout__namespace.struct([BufferLayout__namespace.u32("version"), BufferLayout__namespace.u32("state"), publicKey2("authorizedPubkey"), publicKey2("nonce"), BufferLayout__namespace.struct([FeeCalculatorLayout2], "feeCalculator")]);
  var NONCE_ACCOUNT_LENGTH2 = NonceAccountLayout2.span;

  class NonceAccount {
    constructor(args) {
      this.authorizedPubkey = undefined;
      this.nonce = undefined;
      this.feeCalculator = undefined;
      this.authorizedPubkey = args.authorizedPubkey;
      this.nonce = args.nonce;
      this.feeCalculator = args.feeCalculator;
    }
    static fromAccountData(buffer2) {
      const nonceAccount = NonceAccountLayout2.decode(toBuffer2(buffer2), 0);
      return new NonceAccount({
        authorizedPubkey: new PublicKey2(nonceAccount.authorizedPubkey),
        nonce: new PublicKey2(nonceAccount.nonce).toString(),
        feeCalculator: nonceAccount.feeCalculator
      });
    }
  }
  function u6422(property) {
    const layout = BufferLayout2.blob(8, property);
    const decode22 = layout.decode.bind(layout);
    const encode2 = layout.encode.bind(layout);
    const bigIntLayout = layout;
    const codec = codecsNumbers.getU64Codec();
    bigIntLayout.decode = (buffer2, offset2) => {
      const src = decode22(buffer2, offset2);
      return codec.decode(src);
    };
    bigIntLayout.encode = (bigInt, buffer2, offset2) => {
      const src = codec.encode(bigInt);
      return encode2(src, buffer2, offset2);
    };
    return bigIntLayout;
  }

  class SystemInstruction {
    constructor() {}
    static decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
      const typeIndex = instructionTypeLayout.decode(instruction.data);
      let type2;
      for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS2)) {
        if (layout.index == typeIndex) {
          type2 = ixType;
          break;
        }
      }
      if (!type2) {
        throw new Error("Instruction type incorrect; not a SystemInstruction");
      }
      return type2;
    }
    static decodeCreateAccount(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      const {
        lamports,
        space,
        programId
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.Create, instruction.data);
      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        lamports,
        space,
        programId: new PublicKey2(programId)
      };
    }
    static decodeTransfer(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      const {
        lamports
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.Transfer, instruction.data);
      return {
        fromPubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        lamports
      };
    }
    static decodeTransferWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      const {
        lamports,
        seed,
        programId
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.TransferWithSeed, instruction.data);
      return {
        fromPubkey: instruction.keys[0].pubkey,
        basePubkey: instruction.keys[1].pubkey,
        toPubkey: instruction.keys[2].pubkey,
        lamports,
        seed,
        programId: new PublicKey2(programId)
      };
    }
    static decodeAllocate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      const {
        space
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.Allocate, instruction.data);
      return {
        accountPubkey: instruction.keys[0].pubkey,
        space
      };
    }
    static decodeAllocateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      const {
        base: base2,
        seed,
        space,
        programId
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.AllocateWithSeed, instruction.data);
      return {
        accountPubkey: instruction.keys[0].pubkey,
        basePubkey: new PublicKey2(base2),
        seed,
        space,
        programId: new PublicKey2(programId)
      };
    }
    static decodeAssign(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      const {
        programId
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.Assign, instruction.data);
      return {
        accountPubkey: instruction.keys[0].pubkey,
        programId: new PublicKey2(programId)
      };
    }
    static decodeAssignWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 1);
      const {
        base: base2,
        seed,
        programId
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.AssignWithSeed, instruction.data);
      return {
        accountPubkey: instruction.keys[0].pubkey,
        basePubkey: new PublicKey2(base2),
        seed,
        programId: new PublicKey2(programId)
      };
    }
    static decodeCreateWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      const {
        base: base2,
        seed,
        lamports,
        space,
        programId
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.CreateWithSeed, instruction.data);
      return {
        fromPubkey: instruction.keys[0].pubkey,
        newAccountPubkey: instruction.keys[1].pubkey,
        basePubkey: new PublicKey2(base2),
        seed,
        lamports,
        space,
        programId: new PublicKey2(programId)
      };
    }
    static decodeNonceInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      const {
        authorized: authorized3
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.InitializeNonceAccount, instruction.data);
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: new PublicKey2(authorized3)
      };
    }
    static decodeNonceAdvance(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.AdvanceNonceAccount, instruction.data);
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }
    static decodeNonceWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);
      const {
        lamports
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.WithdrawNonceAccount, instruction.data);
      return {
        noncePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports
      };
    }
    static decodeNonceAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      const {
        authorized: authorized3
      } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS2.AuthorizeNonceAccount, instruction.data);
      return {
        noncePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[1].pubkey,
        newAuthorizedPubkey: new PublicKey2(authorized3)
      };
    }
    static checkProgramId(programId) {
      if (!programId.equals(SystemProgram2.programId)) {
        throw new Error("invalid instruction; programId is not SystemProgram");
      }
    }
    static checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
      }
    }
  }
  var SYSTEM_INSTRUCTION_LAYOUTS2 = Object.freeze({
    Create: {
      index: 0,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports"), BufferLayout__namespace.ns64("space"), publicKey2("programId")])
    },
    Assign: {
      index: 1,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("programId")])
    },
    Transfer: {
      index: 2,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u6422("lamports")])
    },
    CreateWithSeed: {
      index: 3,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("base"), rustString2("seed"), BufferLayout__namespace.ns64("lamports"), BufferLayout__namespace.ns64("space"), publicKey2("programId")])
    },
    AdvanceNonceAccount: {
      index: 4,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    },
    WithdrawNonceAccount: {
      index: 5,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
    },
    InitializeNonceAccount: {
      index: 6,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("authorized")])
    },
    AuthorizeNonceAccount: {
      index: 7,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("authorized")])
    },
    Allocate: {
      index: 8,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("space")])
    },
    AllocateWithSeed: {
      index: 9,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("base"), rustString2("seed"), BufferLayout__namespace.ns64("space"), publicKey2("programId")])
    },
    AssignWithSeed: {
      index: 10,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("base"), rustString2("seed"), publicKey2("programId")])
    },
    TransferWithSeed: {
      index: 11,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u6422("lamports"), rustString2("seed"), publicKey2("programId")])
    },
    UpgradeNonceAccount: {
      index: 12,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    }
  });

  class SystemProgram2 {
    constructor() {}
    static createAccount(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.Create;
      const data = encodeData2(type2, {
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer2(params.programId.toBuffer())
      });
      return new TransactionInstruction2({
        keys: [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: true,
          isWritable: true
        }],
        programId: this.programId,
        data
      });
    }
    static transfer(params) {
      let data;
      let keys;
      if ("basePubkey" in params) {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.TransferWithSeed;
        data = encodeData2(type2, {
          lamports: BigInt(params.lamports),
          seed: params.seed,
          programId: toBuffer2(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      } else {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.Transfer;
        data = encodeData2(type2, {
          lamports: BigInt(params.lamports)
        });
        keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }];
      }
      return new TransactionInstruction2({
        keys,
        programId: this.programId,
        data
      });
    }
    static assign(params) {
      let data;
      let keys;
      if ("basePubkey" in params) {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.AssignWithSeed;
        data = encodeData2(type2, {
          base: toBuffer2(params.basePubkey.toBuffer()),
          seed: params.seed,
          programId: toBuffer2(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.Assign;
        data = encodeData2(type2, {
          programId: toBuffer2(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction2({
        keys,
        programId: this.programId,
        data
      });
    }
    static createAccountWithSeed(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.CreateWithSeed;
      const data = encodeData2(type2, {
        base: toBuffer2(params.basePubkey.toBuffer()),
        seed: params.seed,
        lamports: params.lamports,
        space: params.space,
        programId: toBuffer2(params.programId.toBuffer())
      });
      let keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: false,
        isWritable: true
      }];
      if (!params.basePubkey.equals(params.fromPubkey)) {
        keys.push({
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new TransactionInstruction2({
        keys,
        programId: this.programId,
        data
      });
    }
    static createNonceAccount(params) {
      const transaction = new Transaction22;
      if ("basePubkey" in params && "seed" in params) {
        transaction.add(SystemProgram2.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH2,
          programId: this.programId
        }));
      } else {
        transaction.add(SystemProgram2.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.noncePubkey,
          lamports: params.lamports,
          space: NONCE_ACCOUNT_LENGTH2,
          programId: this.programId
        }));
      }
      const initParams = {
        noncePubkey: params.noncePubkey,
        authorizedPubkey: params.authorizedPubkey
      };
      transaction.add(this.nonceInitialize(initParams));
      return transaction;
    }
    static nonceInitialize(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.InitializeNonceAccount;
      const data = encodeData2(type2, {
        authorized: toBuffer2(params.authorizedPubkey.toBuffer())
      });
      const instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY2,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data
      };
      return new TransactionInstruction2(instructionData);
    }
    static nonceAdvance(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.AdvanceNonceAccount;
      const data = encodeData2(type2);
      const instructionData = {
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      };
      return new TransactionInstruction2(instructionData);
    }
    static nonceWithdraw(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.WithdrawNonceAccount;
      const data = encodeData2(type2, {
        lamports: params.lamports
      });
      return new TransactionInstruction2({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_RENT_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    static nonceAuthorize(params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.AuthorizeNonceAccount;
      const data = encodeData2(type2, {
        authorized: toBuffer2(params.newAuthorizedPubkey.toBuffer())
      });
      return new TransactionInstruction2({
        keys: [{
          pubkey: params.noncePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    static allocate(params) {
      let data;
      let keys;
      if ("basePubkey" in params) {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.AllocateWithSeed;
        data = encodeData2(type2, {
          base: toBuffer2(params.basePubkey.toBuffer()),
          seed: params.seed,
          space: params.space,
          programId: toBuffer2(params.programId.toBuffer())
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.basePubkey,
          isSigner: true,
          isWritable: false
        }];
      } else {
        const type2 = SYSTEM_INSTRUCTION_LAYOUTS2.Allocate;
        data = encodeData2(type2, {
          space: params.space
        });
        keys = [{
          pubkey: params.accountPubkey,
          isSigner: true,
          isWritable: true
        }];
      }
      return new TransactionInstruction2({
        keys,
        programId: this.programId,
        data
      });
    }
  }
  SystemProgram2.programId = new PublicKey2("11111111111111111111111111111111");
  var CHUNK_SIZE2 = PACKET_DATA_SIZE2 - 300;

  class Loader2 {
    constructor() {}
    static getMinNumSignatures(dataLength2) {
      return 2 * (Math.ceil(dataLength2 / Loader2.chunkSize) + 1 + 1);
    }
    static async load(connection, payer, program, programId, data) {
      {
        const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
        const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
        let transaction = null;
        if (programInfo !== null) {
          if (programInfo.executable) {
            console.error("Program load failed, account is already executable");
            return false;
          }
          if (programInfo.data.length !== data.length) {
            transaction = transaction || new Transaction22;
            transaction.add(SystemProgram2.allocate({
              accountPubkey: program.publicKey,
              space: data.length
            }));
          }
          if (!programInfo.owner.equals(programId)) {
            transaction = transaction || new Transaction22;
            transaction.add(SystemProgram2.assign({
              accountPubkey: program.publicKey,
              programId
            }));
          }
          if (programInfo.lamports < balanceNeeded) {
            transaction = transaction || new Transaction22;
            transaction.add(SystemProgram2.transfer({
              fromPubkey: payer.publicKey,
              toPubkey: program.publicKey,
              lamports: balanceNeeded - programInfo.lamports
            }));
          }
        } else {
          transaction = new Transaction22().add(SystemProgram2.createAccount({
            fromPubkey: payer.publicKey,
            newAccountPubkey: program.publicKey,
            lamports: balanceNeeded > 0 ? balanceNeeded : 1,
            space: data.length,
            programId
          }));
        }
        if (transaction !== null) {
          await sendAndConfirmTransaction2(connection, transaction, [payer, program], {
            commitment: "confirmed"
          });
        }
      }
      const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.u32("offset"), BufferLayout__namespace.u32("bytesLength"), BufferLayout__namespace.u32("bytesLengthPadding"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("byte"), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "bytes")]);
      const chunkSize = Loader2.chunkSize;
      let offset2 = 0;
      let array2 = data;
      let transactions = [];
      while (array2.length > 0) {
        const bytes2 = array2.slice(0, chunkSize);
        const data2 = buffer.Buffer.alloc(chunkSize + 16);
        dataLayout.encode({
          instruction: 0,
          offset: offset2,
          bytes: bytes2,
          bytesLength: 0,
          bytesLengthPadding: 0
        }, data2);
        const transaction = new Transaction22().add({
          keys: [{
            pubkey: program.publicKey,
            isSigner: true,
            isWritable: true
          }],
          programId,
          data: data2
        });
        transactions.push(sendAndConfirmTransaction2(connection, transaction, [payer, program], {
          commitment: "confirmed"
        }));
        if (connection._rpcEndpoint.includes("solana.com")) {
          const REQUESTS_PER_SECOND = 4;
          await sleep2(1000 / REQUESTS_PER_SECOND);
        }
        offset2 += chunkSize;
        array2 = array2.slice(chunkSize);
      }
      await Promise.all(transactions);
      {
        const dataLayout2 = BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")]);
        const data2 = buffer.Buffer.alloc(dataLayout2.span);
        dataLayout2.encode({
          instruction: 1
        }, data2);
        const transaction = new Transaction22().add({
          keys: [{
            pubkey: program.publicKey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY2,
            isSigner: false,
            isWritable: false
          }],
          programId,
          data: data2
        });
        const deployCommitment = "processed";
        const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
          preflightCommitment: deployCommitment
        });
        const {
          context,
          value
        } = await connection.confirmTransaction({
          signature: finalizeSignature,
          lastValidBlockHeight: transaction.lastValidBlockHeight,
          blockhash: transaction.recentBlockhash
        }, deployCommitment);
        if (value.err) {
          throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
        }
        while (true) {
          try {
            const currentSlot = await connection.getSlot({
              commitment: deployCommitment
            });
            if (currentSlot > context.slot) {
              break;
            }
          } catch {}
          await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT2 / 2)));
        }
      }
      return true;
    }
  }
  Loader2.chunkSize = CHUNK_SIZE2;
  var BPF_LOADER_PROGRAM_ID2 = new PublicKey2("BPFLoader2111111111111111111111111111111111");

  class BpfLoader {
    static getMinNumSignatures(dataLength2) {
      return Loader2.getMinNumSignatures(dataLength2);
    }
    static load(connection, payer, program, elf, loaderProgramId) {
      return Loader2.load(connection, payer, program, loaderProgramId, elf);
    }
  }
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var fastStableStringify$1;
  var hasRequiredFastStableStringify;
  function requireFastStableStringify() {
    if (hasRequiredFastStableStringify)
      return fastStableStringify$1;
    hasRequiredFastStableStringify = 1;
    var objToString = Object.prototype.toString;
    var objKeys = Object.keys || function(obj) {
      var keys = [];
      for (var name in obj) {
        keys.push(name);
      }
      return keys;
    };
    function stringify22(val, isArrayProp) {
      var i22, max2, str, keys, key, propVal, toStr2;
      if (val === true) {
        return "true";
      }
      if (val === false) {
        return "false";
      }
      switch (typeof val) {
        case "object":
          if (val === null) {
            return null;
          } else if (val.toJSON && typeof val.toJSON === "function") {
            return stringify22(val.toJSON(), isArrayProp);
          } else {
            toStr2 = objToString.call(val);
            if (toStr2 === "[object Array]") {
              str = "[";
              max2 = val.length - 1;
              for (i22 = 0;i22 < max2; i22++) {
                str += stringify22(val[i22], true) + ",";
              }
              if (max2 > -1) {
                str += stringify22(val[i22], true);
              }
              return str + "]";
            } else if (toStr2 === "[object Object]") {
              keys = objKeys(val).sort();
              max2 = keys.length;
              str = "";
              i22 = 0;
              while (i22 < max2) {
                key = keys[i22];
                propVal = stringify22(val[key], false);
                if (propVal !== undefined) {
                  if (str) {
                    str += ",";
                  }
                  str += JSON.stringify(key) + ":" + propVal;
                }
                i22++;
              }
              return "{" + str + "}";
            } else {
              return JSON.stringify(val);
            }
          }
        case "function":
        case "undefined":
          return isArrayProp ? null : undefined;
        case "string":
          return JSON.stringify(val);
        default:
          return isFinite(val) ? val : null;
      }
    }
    fastStableStringify$1 = function(val) {
      var returnVal = stringify22(val, false);
      if (returnVal !== undefined) {
        return "" + returnVal;
      }
    };
    return fastStableStringify$1;
  }
  var fastStableStringifyExports = /* @__PURE__ */ requireFastStableStringify();
  var fastStableStringify = /* @__PURE__ */ getDefaultExportFromCjs(fastStableStringifyExports);
  var MINIMUM_SLOT_PER_EPOCH = 32;
  function trailingZeros(n2) {
    let trailingZeros2 = 0;
    while (n2 > 1) {
      n2 /= 2;
      trailingZeros2++;
    }
    return trailingZeros2;
  }
  function nextPowerOfTwo(n2) {
    if (n2 === 0)
      return 1;
    n2--;
    n2 |= n2 >> 1;
    n2 |= n2 >> 2;
    n2 |= n2 >> 4;
    n2 |= n2 >> 8;
    n2 |= n2 >> 16;
    n2 |= n2 >> 32;
    return n2 + 1;
  }

  class EpochSchedule {
    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
      this.slotsPerEpoch = undefined;
      this.leaderScheduleSlotOffset = undefined;
      this.warmup = undefined;
      this.firstNormalEpoch = undefined;
      this.firstNormalSlot = undefined;
      this.slotsPerEpoch = slotsPerEpoch;
      this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
      this.warmup = warmup;
      this.firstNormalEpoch = firstNormalEpoch;
      this.firstNormalSlot = firstNormalSlot;
    }
    getEpoch(slot) {
      return this.getEpochAndSlotIndex(slot)[0];
    }
    getEpochAndSlotIndex(slot) {
      if (slot < this.firstNormalSlot) {
        const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
        const epochLen = this.getSlotsInEpoch(epoch);
        const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
        return [epoch, slotIndex];
      } else {
        const normalSlotIndex = slot - this.firstNormalSlot;
        const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
        const epoch = this.firstNormalEpoch + normalEpochIndex;
        const slotIndex = normalSlotIndex % this.slotsPerEpoch;
        return [epoch, slotIndex];
      }
    }
    getFirstSlotInEpoch(epoch) {
      if (epoch <= this.firstNormalEpoch) {
        return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
      } else {
        return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
      }
    }
    getLastSlotInEpoch(epoch) {
      return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
    }
    getSlotsInEpoch(epoch) {
      if (epoch < this.firstNormalEpoch) {
        return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
      } else {
        return this.slotsPerEpoch;
      }
    }
  }
  var fetchImpl2 = globalThis.fetch;

  class RpcWebSocketClient extends rpcWebsockets.CommonClient {
    constructor(address, options, generate_request_id) {
      const webSocketFactory = (url) => {
        const rpc = rpcWebsockets.WebSocket(url, {
          autoconnect: true,
          max_reconnects: 5,
          reconnect: true,
          reconnect_interval: 1000,
          ...options
        });
        if ("socket" in rpc) {
          this.underlyingSocket = rpc.socket;
        } else {
          this.underlyingSocket = rpc;
        }
        return rpc;
      };
      super(webSocketFactory, address, options, generate_request_id);
      this.underlyingSocket = undefined;
    }
    call(...args) {
      const readyState = this.underlyingSocket?.readyState;
      if (readyState === 1) {
        return super.call(...args);
      }
      return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
    }
    notify(...args) {
      const readyState = this.underlyingSocket?.readyState;
      if (readyState === 1) {
        return super.notify(...args);
      }
      return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
    }
  }
  function decodeData(type2, data) {
    let decoded;
    try {
      decoded = type2.layout.decode(data);
    } catch (err) {
      throw new Error("invalid instruction; " + err);
    }
    if (decoded.typeIndex !== type2.index) {
      throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type2.index}`);
    }
    return decoded;
  }
  var LOOKUP_TABLE_META_SIZE = 56;

  class AddressLookupTableAccount {
    constructor(args) {
      this.key = undefined;
      this.state = undefined;
      this.key = args.key;
      this.state = args.state;
    }
    isActive() {
      const U64_MAX = BigInt("0xffffffffffffffff");
      return this.state.deactivationSlot === U64_MAX;
    }
    static deserialize(accountData) {
      const meta = decodeData(LookupTableMetaLayout2, accountData);
      const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
      assert32(serializedAddressesLen >= 0, "lookup table is invalid");
      assert32(serializedAddressesLen % 32 === 0, "lookup table is invalid");
      const numSerializedAddresses = serializedAddressesLen / 32;
      const {
        addresses
      } = BufferLayout__namespace.struct([BufferLayout__namespace.seq(publicKey2(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
      return {
        deactivationSlot: meta.deactivationSlot,
        lastExtendedSlot: meta.lastExtendedSlot,
        lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
        authority: meta.authority.length !== 0 ? new PublicKey2(meta.authority[0]) : undefined,
        addresses: addresses.map((address) => new PublicKey2(address))
      };
    }
  }
  var LookupTableMetaLayout2 = {
    index: 1,
    layout: BufferLayout__namespace.struct([
      BufferLayout__namespace.u32("typeIndex"),
      u6422("deactivationSlot"),
      BufferLayout__namespace.nu64("lastExtendedSlot"),
      BufferLayout__namespace.u8("lastExtendedStartIndex"),
      BufferLayout__namespace.u8(),
      BufferLayout__namespace.seq(publicKey2(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), "authority")
    ])
  };
  var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
  function makeWebsocketUrl(endpoint2) {
    const matches = endpoint2.match(URL_RE);
    if (matches == null) {
      throw TypeError(`Failed to validate endpoint URL \`${endpoint2}\``);
    }
    const [
      _,
      hostish,
      portWithColon,
      rest
    ] = matches;
    const protocol = endpoint2.startsWith("https:") ? "wss:" : "ws:";
    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
    const websocketPort = startPort == null ? "" : `:${startPort + 1}`;
    return `${protocol}//${hostish}${websocketPort}${rest}`;
  }
  var PublicKeyFromString2 = superstruct.coerce(superstruct.instance(PublicKey2), superstruct.string(), (value) => new PublicKey2(value));
  var RawAccountDataResult2 = superstruct.tuple([superstruct.string(), superstruct.literal("base64")]);
  var BufferFromRawAccountData2 = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult2, (value) => buffer.Buffer.from(value[0], "base64"));
  var BLOCKHASH_CACHE_TIMEOUT_MS2 = 30 * 1000;
  function assertEndpointUrl(putativeUrl) {
    if (/^https?:/.test(putativeUrl) === false) {
      throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    }
    return putativeUrl;
  }
  function extractCommitmentFromConfig(commitmentOrConfig) {
    let commitment;
    let config2;
    if (typeof commitmentOrConfig === "string") {
      commitment = commitmentOrConfig;
    } else if (commitmentOrConfig) {
      const {
        commitment: specifiedCommitment,
        ...specifiedConfig
      } = commitmentOrConfig;
      commitment = specifiedCommitment;
      config2 = specifiedConfig;
    }
    return {
      commitment,
      config: config2
    };
  }
  function applyDefaultMemcmpEncodingToFilters(filters) {
    return filters.map((filter) => ("memcmp" in filter) ? {
      ...filter,
      memcmp: {
        ...filter.memcmp,
        encoding: filter.memcmp.encoding ?? "base58"
      }
    } : filter);
  }
  function createRpcResult2(result) {
    return superstruct.union([superstruct.type({
      jsonrpc: superstruct.literal("2.0"),
      id: superstruct.string(),
      result
    }), superstruct.type({
      jsonrpc: superstruct.literal("2.0"),
      id: superstruct.string(),
      error: superstruct.type({
        code: superstruct.unknown(),
        message: superstruct.string(),
        data: superstruct.optional(superstruct.any())
      })
    })]);
  }
  var UnknownRpcResult2 = createRpcResult2(superstruct.unknown());
  function jsonRpcResult2(schema) {
    return superstruct.coerce(createRpcResult2(schema), UnknownRpcResult2, (value) => {
      if ("error" in value) {
        return value;
      } else {
        return {
          ...value,
          result: superstruct.create(value.result, schema)
        };
      }
    });
  }
  function jsonRpcResultAndContext2(value) {
    return jsonRpcResult2(superstruct.type({
      context: superstruct.type({
        slot: superstruct.number()
      }),
      value
    }));
  }
  function notificationResultAndContext2(value) {
    return superstruct.type({
      context: superstruct.type({
        slot: superstruct.number()
      }),
      value
    });
  }
  function versionedMessageFromResponse(version22, response) {
    if (version22 === 0) {
      return new MessageV0({
        header: response.header,
        staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey2(accountKey)),
        recentBlockhash: response.recentBlockhash,
        compiledInstructions: response.instructions.map((ix) => ({
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: bs58__default.default.decode(ix.data)
        })),
        addressTableLookups: response.addressTableLookups
      });
    } else {
      return new Message2(response);
    }
  }
  var GetInflationGovernorResult2 = superstruct.type({
    foundation: superstruct.number(),
    foundationTerm: superstruct.number(),
    initial: superstruct.number(),
    taper: superstruct.number(),
    terminal: superstruct.number()
  });
  var GetInflationRewardResult2 = jsonRpcResult2(superstruct.array(superstruct.nullable(superstruct.type({
    epoch: superstruct.number(),
    effectiveSlot: superstruct.number(),
    amount: superstruct.number(),
    postBalance: superstruct.number(),
    commission: superstruct.optional(superstruct.nullable(superstruct.number()))
  }))));
  var GetRecentPrioritizationFeesResult2 = superstruct.array(superstruct.type({
    slot: superstruct.number(),
    prioritizationFee: superstruct.number()
  }));
  var GetInflationRateResult2 = superstruct.type({
    total: superstruct.number(),
    validator: superstruct.number(),
    foundation: superstruct.number(),
    epoch: superstruct.number()
  });
  var GetEpochInfoResult2 = superstruct.type({
    epoch: superstruct.number(),
    slotIndex: superstruct.number(),
    slotsInEpoch: superstruct.number(),
    absoluteSlot: superstruct.number(),
    blockHeight: superstruct.optional(superstruct.number()),
    transactionCount: superstruct.optional(superstruct.number())
  });
  var GetEpochScheduleResult2 = superstruct.type({
    slotsPerEpoch: superstruct.number(),
    leaderScheduleSlotOffset: superstruct.number(),
    warmup: superstruct.boolean(),
    firstNormalEpoch: superstruct.number(),
    firstNormalSlot: superstruct.number()
  });
  var GetLeaderScheduleResult2 = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));
  var TransactionErrorResult2 = superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()]));
  var SignatureStatusResult2 = superstruct.type({
    err: TransactionErrorResult2
  });
  var SignatureReceivedResult2 = superstruct.literal("receivedSignature");
  var VersionResult2 = superstruct.type({
    "solana-core": superstruct.string(),
    "feature-set": superstruct.optional(superstruct.number())
  });
  var ParsedInstructionStruct2 = superstruct.type({
    program: superstruct.string(),
    programId: PublicKeyFromString2,
    parsed: superstruct.unknown()
  });
  var PartiallyDecodedInstructionStruct2 = superstruct.type({
    programId: PublicKeyFromString2,
    accounts: superstruct.array(PublicKeyFromString2),
    data: superstruct.string()
  });
  var SimulatedTransactionResponseStruct2 = jsonRpcResultAndContext2(superstruct.type({
    err: superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()])),
    logs: superstruct.nullable(superstruct.array(superstruct.string())),
    accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({
      executable: superstruct.boolean(),
      owner: superstruct.string(),
      lamports: superstruct.number(),
      data: superstruct.array(superstruct.string()),
      rentEpoch: superstruct.optional(superstruct.number())
    }))))),
    unitsConsumed: superstruct.optional(superstruct.number()),
    returnData: superstruct.optional(superstruct.nullable(superstruct.type({
      programId: superstruct.string(),
      data: superstruct.tuple([superstruct.string(), superstruct.literal("base64")])
    }))),
    innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
      index: superstruct.number(),
      instructions: superstruct.array(superstruct.union([ParsedInstructionStruct2, PartiallyDecodedInstructionStruct2]))
    }))))
  }));
  var BlockProductionResponseStruct2 = jsonRpcResultAndContext2(superstruct.type({
    byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),
    range: superstruct.type({
      firstSlot: superstruct.number(),
      lastSlot: superstruct.number()
    })
  }));
  function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
    const fetch3 = customFetch ? customFetch : fetchImpl2;
    let agent;
    {
      if (httpAgent != null) {
        console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment." + "It has been ignored; `httpAgent` is only used in Node environments.");
      }
    }
    let fetchWithMiddleware;
    if (fetchMiddleware) {
      fetchWithMiddleware = async (info, init2) => {
        const modifiedFetchArgs = await new Promise((resolve, reject) => {
          try {
            fetchMiddleware(info, init2, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
          } catch (error) {
            reject(error);
          }
        });
        return await fetch3(...modifiedFetchArgs);
      };
    }
    const clientBrowser = new RpcClient__default.default(async (request, callback) => {
      const options = {
        method: "POST",
        body: request,
        agent,
        headers: Object.assign({
          "Content-Type": "application/json"
        }, httpHeaders || {}, COMMON_HTTP_HEADERS)
      };
      try {
        let too_many_requests_retries = 5;
        let res;
        let waitTime = 500;
        for (;; ) {
          if (fetchWithMiddleware) {
            res = await fetchWithMiddleware(url, options);
          } else {
            res = await fetch3(url, options);
          }
          if (res.status !== 429) {
            break;
          }
          if (disableRetryOnRateLimit === true) {
            break;
          }
          too_many_requests_retries -= 1;
          if (too_many_requests_retries === 0) {
            break;
          }
          console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
          await sleep2(waitTime);
          waitTime *= 2;
        }
        const text = await res.text();
        if (res.ok) {
          callback(null, text);
        } else {
          callback(new Error(`${res.status} ${res.statusText}: ${text}`));
        }
      } catch (err) {
        if (err instanceof Error)
          callback(err);
      }
    }, {});
    return clientBrowser;
  }
  function createRpcRequest(client) {
    return (method, args) => {
      return new Promise((resolve, reject) => {
        client.request(method, args, (err, response) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    };
  }
  function createRpcBatchRequest(client) {
    return (requests) => {
      return new Promise((resolve, reject) => {
        if (requests.length === 0)
          resolve([]);
        const batch = requests.map((params) => {
          return client.request(params.methodName, params.args);
        });
        client.request(batch, (err, response) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(response);
        });
      });
    };
  }
  var GetInflationGovernorRpcResult2 = jsonRpcResult2(GetInflationGovernorResult2);
  var GetInflationRateRpcResult2 = jsonRpcResult2(GetInflationRateResult2);
  var GetRecentPrioritizationFeesRpcResult2 = jsonRpcResult2(GetRecentPrioritizationFeesResult2);
  var GetEpochInfoRpcResult2 = jsonRpcResult2(GetEpochInfoResult2);
  var GetEpochScheduleRpcResult2 = jsonRpcResult2(GetEpochScheduleResult2);
  var GetLeaderScheduleRpcResult2 = jsonRpcResult2(GetLeaderScheduleResult2);
  var SlotRpcResult2 = jsonRpcResult2(superstruct.number());
  var GetSupplyRpcResult2 = jsonRpcResultAndContext2(superstruct.type({
    total: superstruct.number(),
    circulating: superstruct.number(),
    nonCirculating: superstruct.number(),
    nonCirculatingAccounts: superstruct.array(PublicKeyFromString2)
  }));
  var TokenAmountResult2 = superstruct.type({
    amount: superstruct.string(),
    uiAmount: superstruct.nullable(superstruct.number()),
    decimals: superstruct.number(),
    uiAmountString: superstruct.optional(superstruct.string())
  });
  var GetTokenLargestAccountsResult2 = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
    address: PublicKeyFromString2,
    amount: superstruct.string(),
    uiAmount: superstruct.nullable(superstruct.number()),
    decimals: superstruct.number(),
    uiAmountString: superstruct.optional(superstruct.string())
  })));
  var GetTokenAccountsByOwner2 = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
    pubkey: PublicKeyFromString2,
    account: superstruct.type({
      executable: superstruct.boolean(),
      owner: PublicKeyFromString2,
      lamports: superstruct.number(),
      data: BufferFromRawAccountData2,
      rentEpoch: superstruct.number()
    })
  })));
  var ParsedAccountDataResult2 = superstruct.type({
    program: superstruct.string(),
    parsed: superstruct.unknown(),
    space: superstruct.number()
  });
  var GetParsedTokenAccountsByOwner2 = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
    pubkey: PublicKeyFromString2,
    account: superstruct.type({
      executable: superstruct.boolean(),
      owner: PublicKeyFromString2,
      lamports: superstruct.number(),
      data: ParsedAccountDataResult2,
      rentEpoch: superstruct.number()
    })
  })));
  var GetLargestAccountsRpcResult2 = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
    lamports: superstruct.number(),
    address: PublicKeyFromString2
  })));
  var AccountInfoResult2 = superstruct.type({
    executable: superstruct.boolean(),
    owner: PublicKeyFromString2,
    lamports: superstruct.number(),
    data: BufferFromRawAccountData2,
    rentEpoch: superstruct.number()
  });
  var KeyedAccountInfoResult2 = superstruct.type({
    pubkey: PublicKeyFromString2,
    account: AccountInfoResult2
  });
  var ParsedOrRawAccountData2 = superstruct.coerce(superstruct.union([superstruct.instance(buffer.Buffer), ParsedAccountDataResult2]), superstruct.union([RawAccountDataResult2, ParsedAccountDataResult2]), (value) => {
    if (Array.isArray(value)) {
      return superstruct.create(value, BufferFromRawAccountData2);
    } else {
      return value;
    }
  });
  var ParsedAccountInfoResult2 = superstruct.type({
    executable: superstruct.boolean(),
    owner: PublicKeyFromString2,
    lamports: superstruct.number(),
    data: ParsedOrRawAccountData2,
    rentEpoch: superstruct.number()
  });
  var KeyedParsedAccountInfoResult2 = superstruct.type({
    pubkey: PublicKeyFromString2,
    account: ParsedAccountInfoResult2
  });
  var StakeActivationResult2 = superstruct.type({
    state: superstruct.union([superstruct.literal("active"), superstruct.literal("inactive"), superstruct.literal("activating"), superstruct.literal("deactivating")]),
    active: superstruct.number(),
    inactive: superstruct.number()
  });
  var GetConfirmedSignaturesForAddress2RpcResult2 = jsonRpcResult2(superstruct.array(superstruct.type({
    signature: superstruct.string(),
    slot: superstruct.number(),
    err: TransactionErrorResult2,
    memo: superstruct.nullable(superstruct.string()),
    blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
  })));
  var GetSignaturesForAddressRpcResult2 = jsonRpcResult2(superstruct.array(superstruct.type({
    signature: superstruct.string(),
    slot: superstruct.number(),
    err: TransactionErrorResult2,
    memo: superstruct.nullable(superstruct.string()),
    blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
  })));
  var AccountNotificationResult2 = superstruct.type({
    subscription: superstruct.number(),
    result: notificationResultAndContext2(AccountInfoResult2)
  });
  var ProgramAccountInfoResult2 = superstruct.type({
    pubkey: PublicKeyFromString2,
    account: AccountInfoResult2
  });
  var ProgramAccountNotificationResult2 = superstruct.type({
    subscription: superstruct.number(),
    result: notificationResultAndContext2(ProgramAccountInfoResult2)
  });
  var SlotInfoResult2 = superstruct.type({
    parent: superstruct.number(),
    slot: superstruct.number(),
    root: superstruct.number()
  });
  var SlotNotificationResult2 = superstruct.type({
    subscription: superstruct.number(),
    result: SlotInfoResult2
  });
  var SlotUpdateResult2 = superstruct.union([superstruct.type({
    type: superstruct.union([superstruct.literal("firstShredReceived"), superstruct.literal("completed"), superstruct.literal("optimisticConfirmation"), superstruct.literal("root")]),
    slot: superstruct.number(),
    timestamp: superstruct.number()
  }), superstruct.type({
    type: superstruct.literal("createdBank"),
    parent: superstruct.number(),
    slot: superstruct.number(),
    timestamp: superstruct.number()
  }), superstruct.type({
    type: superstruct.literal("frozen"),
    slot: superstruct.number(),
    timestamp: superstruct.number(),
    stats: superstruct.type({
      numTransactionEntries: superstruct.number(),
      numSuccessfulTransactions: superstruct.number(),
      numFailedTransactions: superstruct.number(),
      maxTransactionsPerEntry: superstruct.number()
    })
  }), superstruct.type({
    type: superstruct.literal("dead"),
    slot: superstruct.number(),
    timestamp: superstruct.number(),
    err: superstruct.string()
  })]);
  var SlotUpdateNotificationResult2 = superstruct.type({
    subscription: superstruct.number(),
    result: SlotUpdateResult2
  });
  var SignatureNotificationResult2 = superstruct.type({
    subscription: superstruct.number(),
    result: notificationResultAndContext2(superstruct.union([SignatureStatusResult2, SignatureReceivedResult2]))
  });
  var RootNotificationResult2 = superstruct.type({
    subscription: superstruct.number(),
    result: superstruct.number()
  });
  var ContactInfoResult2 = superstruct.type({
    pubkey: superstruct.string(),
    gossip: superstruct.nullable(superstruct.string()),
    tpu: superstruct.nullable(superstruct.string()),
    rpc: superstruct.nullable(superstruct.string()),
    version: superstruct.nullable(superstruct.string())
  });
  var VoteAccountInfoResult2 = superstruct.type({
    votePubkey: superstruct.string(),
    nodePubkey: superstruct.string(),
    activatedStake: superstruct.number(),
    epochVoteAccount: superstruct.boolean(),
    epochCredits: superstruct.array(superstruct.tuple([superstruct.number(), superstruct.number(), superstruct.number()])),
    commission: superstruct.number(),
    lastVote: superstruct.number(),
    rootSlot: superstruct.nullable(superstruct.number())
  });
  var GetVoteAccounts2 = jsonRpcResult2(superstruct.type({
    current: superstruct.array(VoteAccountInfoResult2),
    delinquent: superstruct.array(VoteAccountInfoResult2)
  }));
  var ConfirmationStatus2 = superstruct.union([superstruct.literal("processed"), superstruct.literal("confirmed"), superstruct.literal("finalized")]);
  var SignatureStatusResponse2 = superstruct.type({
    slot: superstruct.number(),
    confirmations: superstruct.nullable(superstruct.number()),
    err: TransactionErrorResult2,
    confirmationStatus: superstruct.optional(ConfirmationStatus2)
  });
  var GetSignatureStatusesRpcResult2 = jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(SignatureStatusResponse2)));
  var GetMinimumBalanceForRentExemptionRpcResult2 = jsonRpcResult2(superstruct.number());
  var AddressTableLookupStruct2 = superstruct.type({
    accountKey: PublicKeyFromString2,
    writableIndexes: superstruct.array(superstruct.number()),
    readonlyIndexes: superstruct.array(superstruct.number())
  });
  var ConfirmedTransactionResult2 = superstruct.type({
    signatures: superstruct.array(superstruct.string()),
    message: superstruct.type({
      accountKeys: superstruct.array(superstruct.string()),
      header: superstruct.type({
        numRequiredSignatures: superstruct.number(),
        numReadonlySignedAccounts: superstruct.number(),
        numReadonlyUnsignedAccounts: superstruct.number()
      }),
      instructions: superstruct.array(superstruct.type({
        accounts: superstruct.array(superstruct.number()),
        data: superstruct.string(),
        programIdIndex: superstruct.number()
      })),
      recentBlockhash: superstruct.string(),
      addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct2))
    })
  });
  var AnnotatedAccountKey2 = superstruct.type({
    pubkey: PublicKeyFromString2,
    signer: superstruct.boolean(),
    writable: superstruct.boolean(),
    source: superstruct.optional(superstruct.union([superstruct.literal("transaction"), superstruct.literal("lookupTable")]))
  });
  var ConfirmedTransactionAccountsModeResult2 = superstruct.type({
    accountKeys: superstruct.array(AnnotatedAccountKey2),
    signatures: superstruct.array(superstruct.string())
  });
  var ParsedInstructionResult2 = superstruct.type({
    parsed: superstruct.unknown(),
    program: superstruct.string(),
    programId: PublicKeyFromString2
  });
  var RawInstructionResult2 = superstruct.type({
    accounts: superstruct.array(PublicKeyFromString2),
    data: superstruct.string(),
    programId: PublicKeyFromString2
  });
  var InstructionResult2 = superstruct.union([RawInstructionResult2, ParsedInstructionResult2]);
  var UnknownInstructionResult2 = superstruct.union([superstruct.type({
    parsed: superstruct.unknown(),
    program: superstruct.string(),
    programId: superstruct.string()
  }), superstruct.type({
    accounts: superstruct.array(superstruct.string()),
    data: superstruct.string(),
    programId: superstruct.string()
  })]);
  var ParsedOrRawInstruction2 = superstruct.coerce(InstructionResult2, UnknownInstructionResult2, (value) => {
    if ("accounts" in value) {
      return superstruct.create(value, RawInstructionResult2);
    } else {
      return superstruct.create(value, ParsedInstructionResult2);
    }
  });
  var ParsedConfirmedTransactionResult2 = superstruct.type({
    signatures: superstruct.array(superstruct.string()),
    message: superstruct.type({
      accountKeys: superstruct.array(AnnotatedAccountKey2),
      instructions: superstruct.array(ParsedOrRawInstruction2),
      recentBlockhash: superstruct.string(),
      addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct2)))
    })
  });
  var TokenBalanceResult2 = superstruct.type({
    accountIndex: superstruct.number(),
    mint: superstruct.string(),
    owner: superstruct.optional(superstruct.string()),
    programId: superstruct.optional(superstruct.string()),
    uiTokenAmount: TokenAmountResult2
  });
  var LoadedAddressesResult2 = superstruct.type({
    writable: superstruct.array(PublicKeyFromString2),
    readonly: superstruct.array(PublicKeyFromString2)
  });
  var ConfirmedTransactionMetaResult2 = superstruct.type({
    err: TransactionErrorResult2,
    fee: superstruct.number(),
    innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
      index: superstruct.number(),
      instructions: superstruct.array(superstruct.type({
        accounts: superstruct.array(superstruct.number()),
        data: superstruct.string(),
        programIdIndex: superstruct.number()
      }))
    })))),
    preBalances: superstruct.array(superstruct.number()),
    postBalances: superstruct.array(superstruct.number()),
    logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
    preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult2))),
    postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult2))),
    loadedAddresses: superstruct.optional(LoadedAddressesResult2),
    computeUnitsConsumed: superstruct.optional(superstruct.number()),
    costUnits: superstruct.optional(superstruct.number())
  });
  var ParsedConfirmedTransactionMetaResult2 = superstruct.type({
    err: TransactionErrorResult2,
    fee: superstruct.number(),
    innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
      index: superstruct.number(),
      instructions: superstruct.array(ParsedOrRawInstruction2)
    })))),
    preBalances: superstruct.array(superstruct.number()),
    postBalances: superstruct.array(superstruct.number()),
    logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
    preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult2))),
    postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult2))),
    loadedAddresses: superstruct.optional(LoadedAddressesResult2),
    computeUnitsConsumed: superstruct.optional(superstruct.number()),
    costUnits: superstruct.optional(superstruct.number())
  });
  var TransactionVersionStruct2 = superstruct.union([superstruct.literal(0), superstruct.literal("legacy")]);
  var RewardsResult2 = superstruct.type({
    pubkey: superstruct.string(),
    lamports: superstruct.number(),
    postBalance: superstruct.nullable(superstruct.number()),
    rewardType: superstruct.nullable(superstruct.string()),
    commission: superstruct.optional(superstruct.nullable(superstruct.number()))
  });
  var GetBlockRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    blockhash: superstruct.string(),
    previousBlockhash: superstruct.string(),
    parentSlot: superstruct.number(),
    transactions: superstruct.array(superstruct.type({
      transaction: ConfirmedTransactionResult2,
      meta: superstruct.nullable(ConfirmedTransactionMetaResult2),
      version: superstruct.optional(TransactionVersionStruct2)
    })),
    rewards: superstruct.optional(superstruct.array(RewardsResult2)),
    blockTime: superstruct.nullable(superstruct.number()),
    blockHeight: superstruct.nullable(superstruct.number())
  })));
  var GetNoneModeBlockRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    blockhash: superstruct.string(),
    previousBlockhash: superstruct.string(),
    parentSlot: superstruct.number(),
    rewards: superstruct.optional(superstruct.array(RewardsResult2)),
    blockTime: superstruct.nullable(superstruct.number()),
    blockHeight: superstruct.nullable(superstruct.number())
  })));
  var GetAccountsModeBlockRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    blockhash: superstruct.string(),
    previousBlockhash: superstruct.string(),
    parentSlot: superstruct.number(),
    transactions: superstruct.array(superstruct.type({
      transaction: ConfirmedTransactionAccountsModeResult2,
      meta: superstruct.nullable(ConfirmedTransactionMetaResult2),
      version: superstruct.optional(TransactionVersionStruct2)
    })),
    rewards: superstruct.optional(superstruct.array(RewardsResult2)),
    blockTime: superstruct.nullable(superstruct.number()),
    blockHeight: superstruct.nullable(superstruct.number())
  })));
  var GetParsedBlockRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    blockhash: superstruct.string(),
    previousBlockhash: superstruct.string(),
    parentSlot: superstruct.number(),
    transactions: superstruct.array(superstruct.type({
      transaction: ParsedConfirmedTransactionResult2,
      meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult2),
      version: superstruct.optional(TransactionVersionStruct2)
    })),
    rewards: superstruct.optional(superstruct.array(RewardsResult2)),
    blockTime: superstruct.nullable(superstruct.number()),
    blockHeight: superstruct.nullable(superstruct.number())
  })));
  var GetParsedAccountsModeBlockRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    blockhash: superstruct.string(),
    previousBlockhash: superstruct.string(),
    parentSlot: superstruct.number(),
    transactions: superstruct.array(superstruct.type({
      transaction: ConfirmedTransactionAccountsModeResult2,
      meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult2),
      version: superstruct.optional(TransactionVersionStruct2)
    })),
    rewards: superstruct.optional(superstruct.array(RewardsResult2)),
    blockTime: superstruct.nullable(superstruct.number()),
    blockHeight: superstruct.nullable(superstruct.number())
  })));
  var GetParsedNoneModeBlockRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    blockhash: superstruct.string(),
    previousBlockhash: superstruct.string(),
    parentSlot: superstruct.number(),
    rewards: superstruct.optional(superstruct.array(RewardsResult2)),
    blockTime: superstruct.nullable(superstruct.number()),
    blockHeight: superstruct.nullable(superstruct.number())
  })));
  var GetConfirmedBlockRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    blockhash: superstruct.string(),
    previousBlockhash: superstruct.string(),
    parentSlot: superstruct.number(),
    transactions: superstruct.array(superstruct.type({
      transaction: ConfirmedTransactionResult2,
      meta: superstruct.nullable(ConfirmedTransactionMetaResult2)
    })),
    rewards: superstruct.optional(superstruct.array(RewardsResult2)),
    blockTime: superstruct.nullable(superstruct.number())
  })));
  var GetBlockSignaturesRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    blockhash: superstruct.string(),
    previousBlockhash: superstruct.string(),
    parentSlot: superstruct.number(),
    signatures: superstruct.array(superstruct.string()),
    blockTime: superstruct.nullable(superstruct.number())
  })));
  var GetTransactionRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    slot: superstruct.number(),
    meta: superstruct.nullable(ConfirmedTransactionMetaResult2),
    blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
    transaction: ConfirmedTransactionResult2,
    version: superstruct.optional(TransactionVersionStruct2)
  })));
  var GetParsedTransactionRpcResult2 = jsonRpcResult2(superstruct.nullable(superstruct.type({
    slot: superstruct.number(),
    transaction: ParsedConfirmedTransactionResult2,
    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult2),
    blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
    version: superstruct.optional(TransactionVersionStruct2)
  })));
  var GetLatestBlockhashRpcResult2 = jsonRpcResultAndContext2(superstruct.type({
    blockhash: superstruct.string(),
    lastValidBlockHeight: superstruct.number()
  }));
  var IsBlockhashValidRpcResult2 = jsonRpcResultAndContext2(superstruct.boolean());
  var PerfSampleResult2 = superstruct.type({
    slot: superstruct.number(),
    numTransactions: superstruct.number(),
    numSlots: superstruct.number(),
    samplePeriodSecs: superstruct.number()
  });
  var GetRecentPerformanceSamplesRpcResult2 = jsonRpcResult2(superstruct.array(PerfSampleResult2));
  var GetFeeCalculatorRpcResult2 = jsonRpcResultAndContext2(superstruct.nullable(superstruct.type({
    feeCalculator: superstruct.type({
      lamportsPerSignature: superstruct.number()
    })
  })));
  var RequestAirdropRpcResult2 = jsonRpcResult2(superstruct.string());
  var SendTransactionRpcResult2 = jsonRpcResult2(superstruct.string());
  var LogsResult2 = superstruct.type({
    err: TransactionErrorResult2,
    logs: superstruct.array(superstruct.string()),
    signature: superstruct.string()
  });
  var LogsNotificationResult2 = superstruct.type({
    result: notificationResultAndContext2(LogsResult2),
    subscription: superstruct.number()
  });
  var COMMON_HTTP_HEADERS = {
    "solana-client": `js/${"1.0.0-maintenance"}`
  };

  class Connection {
    constructor(endpoint2, _commitmentOrConfig) {
      this._commitment = undefined;
      this._confirmTransactionInitialTimeout = undefined;
      this._rpcEndpoint = undefined;
      this._rpcWsEndpoint = undefined;
      this._rpcClient = undefined;
      this._rpcRequest = undefined;
      this._rpcBatchRequest = undefined;
      this._rpcWebSocket = undefined;
      this._rpcWebSocketConnected = false;
      this._rpcWebSocketHeartbeat = null;
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketGeneration = 0;
      this._disableBlockhashCaching = false;
      this._pollingBlockhash = false;
      this._blockhashInfo = {
        latestBlockhash: null,
        lastFetch: 0,
        transactionSignatures: [],
        simulatedSignatures: []
      };
      this._nextClientSubscriptionId = 0;
      this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
      this._subscriptionHashByClientSubscriptionId = {};
      this._subscriptionStateChangeCallbacksByHash = {};
      this._subscriptionCallbacksByServerSubscriptionId = {};
      this._subscriptionsByHash = {};
      this._subscriptionsAutoDisposedByRpc = new Set;
      this.getBlockHeight = (() => {
        const requestPromises = {};
        return async (commitmentOrConfig) => {
          const {
            commitment,
            config: config2
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, undefined, config2);
          const requestHash = fastStableStringify(args);
          requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
            try {
              const unsafeRes = await this._rpcRequest("getBlockHeight", args);
              const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
              if ("error" in res) {
                throw new SolanaJSONRPCError(res.error, "failed to get block height information");
              }
              return res.result;
            } finally {
              delete requestPromises[requestHash];
            }
          })();
          return await requestPromises[requestHash];
        };
      })();
      let wsEndpoint;
      let httpHeaders;
      let fetch3;
      let fetchMiddleware;
      let disableRetryOnRateLimit;
      let httpAgent;
      if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
        this._commitment = _commitmentOrConfig;
      } else if (_commitmentOrConfig) {
        this._commitment = _commitmentOrConfig.commitment;
        this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
        wsEndpoint = _commitmentOrConfig.wsEndpoint;
        httpHeaders = _commitmentOrConfig.httpHeaders;
        fetch3 = _commitmentOrConfig.fetch;
        fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
        disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
        httpAgent = _commitmentOrConfig.httpAgent;
      }
      this._rpcEndpoint = assertEndpointUrl(endpoint2);
      this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
      this._rpcClient = createRpcClient(endpoint2, httpHeaders, fetch3, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
      this._rpcRequest = createRpcRequest(this._rpcClient);
      this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
      this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
        autoconnect: false,
        max_reconnects: Infinity
      });
      this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
      this._rpcWebSocket.on("error", this._wsOnError.bind(this));
      this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
      this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
      this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
      this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
      this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
      this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
      this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
      this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
    }
    get commitment() {
      return this._commitment;
    }
    get rpcEndpoint() {
      return this._rpcEndpoint;
    }
    async getBalanceAndContext(publicKey3, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("getBalance", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey3.toBase58()}`);
      }
      return res.result;
    }
    async getBalance(publicKey3, commitmentOrConfig) {
      return await this.getBalanceAndContext(publicKey3, commitmentOrConfig).then((x2) => x2.value).catch((e) => {
        throw new Error("failed to get balance of account " + publicKey3.toBase58() + ": " + e);
      });
    }
    async getBlockTime(slot) {
      const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.nullable(superstruct.number())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
      }
      return res.result;
    }
    async getMinimumLedgerSlot() {
      const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
      }
      return res.result;
    }
    async getFirstAvailableBlock() {
      const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
      const res = superstruct.create(unsafeRes, SlotRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get first available block");
      }
      return res.result;
    }
    async getSupply(config2) {
      let configArg = {};
      if (typeof config2 === "string") {
        configArg = {
          commitment: config2
        };
      } else if (config2) {
        configArg = {
          ...config2,
          commitment: config2 && config2.commitment || this.commitment
        };
      } else {
        configArg = {
          commitment: this.commitment
        };
      }
      const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
      const res = superstruct.create(unsafeRes, GetSupplyRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get supply");
      }
      return res.result;
    }
    async getTokenSupply(tokenMintAddress, commitment) {
      const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
      const unsafeRes = await this._rpcRequest("getTokenSupply", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(TokenAmountResult2));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token supply");
      }
      return res.result;
    }
    async getTokenAccountBalance(tokenAddress, commitment) {
      const args = this._buildArgs([tokenAddress.toBase58()], commitment);
      const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(TokenAmountResult2));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
      }
      return res.result;
    }
    async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      let _args = [ownerAddress.toBase58()];
      if ("mint" in filter) {
        _args.push({
          mint: filter.mint.toBase58()
        });
      } else {
        _args.push({
          programId: filter.programId.toBase58()
        });
      }
      const args = this._buildArgs(_args, commitment, "base64", config2);
      const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
      const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
      }
      return res.result;
    }
    async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
      let _args = [ownerAddress.toBase58()];
      if ("mint" in filter) {
        _args.push({
          mint: filter.mint.toBase58()
        });
      } else {
        _args.push({
          programId: filter.programId.toBase58()
        });
      }
      const args = this._buildArgs(_args, commitment, "jsonParsed");
      const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
      const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
      }
      return res.result;
    }
    async getLargestAccounts(config2) {
      const arg = {
        ...config2,
        commitment: config2 && config2.commitment || this.commitment
      };
      const args = arg.filter || arg.commitment ? [arg] : [];
      const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
      const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
      }
      return res.result;
    }
    async getTokenLargestAccounts(mintAddress, commitment) {
      const args = this._buildArgs([mintAddress.toBase58()], commitment);
      const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
      const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
      }
      return res.result;
    }
    async getAccountInfoAndContext(publicKey3, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment, "base64", config2);
      const unsafeRes = await this._rpcRequest("getAccountInfo", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(AccountInfoResult2)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey3.toBase58()}`);
      }
      return res.result;
    }
    async getParsedAccountInfo(publicKey3, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment, "jsonParsed", config2);
      const unsafeRes = await this._rpcRequest("getAccountInfo", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(ParsedAccountInfoResult2)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey3.toBase58()}`);
      }
      return res.result;
    }
    async getAccountInfo(publicKey3, commitmentOrConfig) {
      try {
        const res = await this.getAccountInfoAndContext(publicKey3, commitmentOrConfig);
        return res.value;
      } catch (e) {
        throw new Error("failed to get info about account " + publicKey3.toBase58() + ": " + e);
      }
    }
    async getMultipleParsedAccounts(publicKeys, rawConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(rawConfig);
      const keys = publicKeys.map((key) => key.toBase58());
      const args = this._buildArgs([keys], commitment, "jsonParsed", config2);
      const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(ParsedAccountInfoResult2))));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
      }
      return res.result;
    }
    async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const keys = publicKeys.map((key) => key.toBase58());
      const args = this._buildArgs([keys], commitment, "base64", config2);
      const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(AccountInfoResult2))));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
      }
      return res.result;
    }
    async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
      const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
      return res.value;
    }
    async getStakeActivation(publicKey3, commitmentOrConfig, epoch) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment, undefined, {
        ...config2,
        epoch: epoch != null ? epoch : config2?.epoch
      });
      const unsafeRes = await this._rpcRequest("getStakeActivation", args);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(StakeActivationResult2));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey3.toBase58()}`);
      }
      return res.result;
    }
    async getProgramAccounts(programId, configOrCommitment) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(configOrCommitment);
      const {
        encoding,
        ...configWithoutEncoding
      } = config2 || {};
      const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", {
        ...configWithoutEncoding,
        ...configWithoutEncoding.filters ? {
          filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
        } : null
      });
      const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
      const baseSchema = superstruct.array(KeyedAccountInfoResult2);
      const res = configWithoutEncoding.withContext === true ? superstruct.create(unsafeRes, jsonRpcResultAndContext2(baseSchema)) : superstruct.create(unsafeRes, jsonRpcResult2(baseSchema));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
      }
      return res.result;
    }
    async getParsedProgramAccounts(programId, configOrCommitment) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(configOrCommitment);
      const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config2);
      const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(KeyedParsedAccountInfoResult2)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
      }
      return res.result;
    }
    async confirmTransaction(strategy, commitment) {
      let rawSignature;
      if (typeof strategy == "string") {
        rawSignature = strategy;
      } else {
        const config2 = strategy;
        if (config2.abortSignal?.aborted) {
          return Promise.reject(config2.abortSignal.reason);
        }
        rawSignature = config2.signature;
      }
      let decodedSignature;
      try {
        decodedSignature = bs58__default.default.decode(rawSignature);
      } catch (err) {
        throw new Error("signature must be base58 encoded: " + rawSignature);
      }
      assert32(decodedSignature.length === 64, "signature has invalid length");
      if (typeof strategy === "string") {
        return await this.confirmTransactionUsingLegacyTimeoutStrategy({
          commitment: commitment || this.commitment,
          signature: rawSignature
        });
      } else if ("lastValidBlockHeight" in strategy) {
        return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
          commitment: commitment || this.commitment,
          strategy
        });
      } else {
        return await this.confirmTransactionUsingDurableNonceStrategy({
          commitment: commitment || this.commitment,
          strategy
        });
      }
    }
    getCancellationPromise(signal) {
      return new Promise((_, reject) => {
        if (signal == null) {
          return;
        }
        if (signal.aborted) {
          reject(signal.reason);
        } else {
          signal.addEventListener("abort", () => {
            reject(signal.reason);
          });
        }
      });
    }
    getTransactionConfirmationPromise({
      commitment,
      signature: signature2
    }) {
      let signatureSubscriptionId;
      let disposeSignatureSubscriptionStateChangeObserver;
      let done = false;
      const confirmationPromise = new Promise((resolve, reject) => {
        try {
          signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
            signatureSubscriptionId = undefined;
            const response = {
              context,
              value: result
            };
            resolve({
              __type: TransactionStatus.PROCESSED,
              response
            });
          }, commitment);
          const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
            if (signatureSubscriptionId == null) {
              resolveSubscriptionSetup();
            } else {
              disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
                if (nextState === "subscribed") {
                  resolveSubscriptionSetup();
                }
              });
            }
          });
          (async () => {
            await subscriptionSetupPromise;
            if (done)
              return;
            const response = await this.getSignatureStatus(signature2);
            if (done)
              return;
            if (response == null) {
              return;
            }
            const {
              context,
              value
            } = response;
            if (value == null) {
              return;
            }
            if (value?.err) {
              reject(value.err);
            } else {
              switch (commitment) {
                case "confirmed":
                case "single":
                case "singleGossip": {
                  if (value.confirmationStatus === "processed") {
                    return;
                  }
                  break;
                }
                case "finalized":
                case "max":
                case "root": {
                  if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                    return;
                  }
                  break;
                }
                case "processed":
                case "recent":
              }
              done = true;
              resolve({
                __type: TransactionStatus.PROCESSED,
                response: {
                  context,
                  value
                }
              });
            }
          })();
        } catch (err) {
          reject(err);
        }
      });
      const abortConfirmation = () => {
        if (disposeSignatureSubscriptionStateChangeObserver) {
          disposeSignatureSubscriptionStateChangeObserver();
          disposeSignatureSubscriptionStateChangeObserver = undefined;
        }
        if (signatureSubscriptionId != null) {
          this.removeSignatureListener(signatureSubscriptionId);
          signatureSubscriptionId = undefined;
        }
      };
      return {
        abortConfirmation,
        confirmationPromise
      };
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment,
      strategy: {
        abortSignal,
        lastValidBlockHeight,
        signature: signature2
      }
    }) {
      let done = false;
      const expiryPromise = new Promise((resolve) => {
        const checkBlockHeight = async () => {
          try {
            const blockHeight = await this.getBlockHeight(commitment);
            return blockHeight;
          } catch (_e) {
            return -1;
          }
        };
        (async () => {
          let currentBlockHeight = await checkBlockHeight();
          if (done)
            return;
          while (currentBlockHeight <= lastValidBlockHeight) {
            await sleep2(1000);
            if (done)
              return;
            currentBlockHeight = await checkBlockHeight();
            if (done)
              return;
          }
          resolve({
            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
          });
        })();
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature: signature2
      });
      const cancellationPromise = this.getCancellationPromise(abortSignal);
      let result;
      try {
        const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          throw new TransactionExpiredBlockheightExceededError2(signature2);
        }
      } finally {
        done = true;
        abortConfirmation();
      }
      return result;
    }
    async confirmTransactionUsingDurableNonceStrategy({
      commitment,
      strategy: {
        abortSignal,
        minContextSlot,
        nonceAccountPubkey,
        nonceValue,
        signature: signature2
      }
    }) {
      let done = false;
      const expiryPromise = new Promise((resolve) => {
        let currentNonceValue = nonceValue;
        let lastCheckedSlot = null;
        const getCurrentNonceValue = async () => {
          try {
            const {
              context,
              value: nonceAccount
            } = await this.getNonceAndContext(nonceAccountPubkey, {
              commitment,
              minContextSlot
            });
            lastCheckedSlot = context.slot;
            return nonceAccount?.nonce;
          } catch (e) {
            return currentNonceValue;
          }
        };
        (async () => {
          currentNonceValue = await getCurrentNonceValue();
          if (done)
            return;
          while (true) {
            if (nonceValue !== currentNonceValue) {
              resolve({
                __type: TransactionStatus.NONCE_INVALID,
                slotInWhichNonceDidAdvance: lastCheckedSlot
              });
              return;
            }
            await sleep2(2000);
            if (done)
              return;
            currentNonceValue = await getCurrentNonceValue();
            if (done)
              return;
          }
        })();
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature: signature2
      });
      const cancellationPromise = this.getCancellationPromise(abortSignal);
      let result;
      try {
        const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          let signatureStatus;
          while (true) {
            const status = await this.getSignatureStatus(signature2);
            if (status == null) {
              break;
            }
            if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
              await sleep2(400);
              continue;
            }
            signatureStatus = status;
            break;
          }
          if (signatureStatus?.value) {
            const commitmentForStatus = commitment || "finalized";
            const {
              confirmationStatus
            } = signatureStatus.value;
            switch (commitmentForStatus) {
              case "processed":
              case "recent":
                if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError2(signature2);
                }
                break;
              case "confirmed":
              case "single":
              case "singleGossip":
                if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError2(signature2);
                }
                break;
              case "finalized":
              case "max":
              case "root":
                if (confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError2(signature2);
                }
                break;
              default:
                ((_) => {})(commitmentForStatus);
            }
            result = {
              context: signatureStatus.context,
              value: {
                err: signatureStatus.value.err
              }
            };
          } else {
            throw new TransactionExpiredNonceInvalidError2(signature2);
          }
        }
      } finally {
        done = true;
        abortConfirmation();
      }
      return result;
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({
      commitment,
      signature: signature2
    }) {
      let timeoutId;
      const expiryPromise = new Promise((resolve) => {
        let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;
        switch (commitment) {
          case "processed":
          case "recent":
          case "single":
          case "confirmed":
          case "singleGossip": {
            timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;
            break;
          }
        }
        timeoutId = setTimeout(() => resolve({
          __type: TransactionStatus.TIMED_OUT,
          timeoutMs
        }), timeoutMs);
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature: signature2
      });
      let result;
      try {
        const outcome = await Promise.race([confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          throw new TransactionExpiredTimeoutError2(signature2, outcome.timeoutMs / 1000);
        }
      } finally {
        clearTimeout(timeoutId);
        abortConfirmation();
      }
      return result;
    }
    async getClusterNodes() {
      const unsafeRes = await this._rpcRequest("getClusterNodes", []);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(ContactInfoResult2)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
      }
      return res.result;
    }
    async getVoteAccounts(commitment) {
      const args = this._buildArgs([], commitment);
      const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
      const res = superstruct.create(unsafeRes, GetVoteAccounts2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
      }
      return res.result;
    }
    async getSlot(commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("getSlot", args);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot");
      }
      return res.result;
    }
    async getSlotLeader(commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("getSlotLeader", args);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.string()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
      }
      return res.result;
    }
    async getSlotLeaders(startSlot, limit) {
      const args = [startSlot, limit];
      const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(PublicKeyFromString2)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
      }
      return res.result;
    }
    async getSignatureStatus(signature2, config2) {
      const {
        context,
        value: values
      } = await this.getSignatureStatuses([signature2], config2);
      assert32(values.length === 1);
      const value = values[0];
      return {
        context,
        value
      };
    }
    async getSignatureStatuses(signatures, config2) {
      const params = [signatures];
      if (config2) {
        params.push(config2);
      }
      const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
      const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get signature status");
      }
      return res.result;
    }
    async getTransactionCount(commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("getTransactionCount", args);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
      }
      return res.result;
    }
    async getTotalSupply(commitment) {
      const result = await this.getSupply({
        commitment,
        excludeNonCirculatingAccountsList: true
      });
      return result.value.total;
    }
    async getInflationGovernor(commitment) {
      const args = this._buildArgs([], commitment);
      const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
      const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation");
      }
      return res.result;
    }
    async getInflationReward(addresses, epoch, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, undefined, {
        ...config2,
        epoch: epoch != null ? epoch : config2?.epoch
      });
      const unsafeRes = await this._rpcRequest("getInflationReward", args);
      const res = superstruct.create(unsafeRes, GetInflationRewardResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
      }
      return res.result;
    }
    async getInflationRate() {
      const unsafeRes = await this._rpcRequest("getInflationRate", []);
      const res = superstruct.create(unsafeRes, GetInflationRateRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
      }
      return res.result;
    }
    async getEpochInfo(commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("getEpochInfo", args);
      const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
      }
      return res.result;
    }
    async getEpochSchedule() {
      const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
      const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
      }
      const epochSchedule = res.result;
      return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
    }
    async getLeaderSchedule() {
      const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
      const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
      }
      return res.result;
    }
    async getMinimumBalanceForRentExemption(dataLength2, commitment) {
      const args = this._buildArgs([dataLength2], commitment);
      const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
      const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult2);
      if ("error" in res) {
        console.warn("Unable to fetch minimum balance for rent exemption");
        return 0;
      }
      return res.result;
    }
    async getRecentBlockhashAndContext(commitment) {
      const {
        context,
        value: {
          blockhash
        }
      } = await this.getLatestBlockhashAndContext(commitment);
      const feeCalculator = {
        get lamportsPerSignature() {
          throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is " + "no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee " + "for a given message.");
        },
        toJSON() {
          return {};
        }
      };
      return {
        context,
        value: {
          blockhash,
          feeCalculator
        }
      };
    }
    async getRecentPerformanceSamples(limit) {
      const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
      const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
      }
      return res.result;
    }
    async getFeeCalculatorForBlockhash(blockhash, commitment) {
      const args = this._buildArgs([blockhash], commitment);
      const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
      const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
      }
      const {
        context,
        value
      } = res.result;
      return {
        context,
        value: value !== null ? value.feeCalculator : null
      };
    }
    async getFeeForMessage(message, commitment) {
      const wireMessage = toBuffer2(message.serialize()).toString("base64");
      const args = this._buildArgs([wireMessage], commitment);
      const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(superstruct.number())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
      }
      if (res.result === null) {
        throw new Error("invalid blockhash");
      }
      return res.result;
    }
    async getRecentPrioritizationFees(config2) {
      const accounts = config2?.lockedWritableAccounts?.map((key) => key.toBase58());
      const args = accounts?.length ? [accounts] : [];
      const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
      const res = superstruct.create(unsafeRes, GetRecentPrioritizationFeesRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
      }
      return res.result;
    }
    async getRecentBlockhash(commitment) {
      try {
        const res = await this.getRecentBlockhashAndContext(commitment);
        return res.value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    async getLatestBlockhash(commitmentOrConfig) {
      try {
        const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
        return res.value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    }
    async getLatestBlockhashAndContext(commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
      const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
      }
      return res.result;
    }
    async isBlockhashValid(blockhash, rawConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(rawConfig);
      const args = this._buildArgs([blockhash], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
      const res = superstruct.create(unsafeRes, IsBlockhashValidRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
      }
      return res.result;
    }
    async getVersion() {
      const unsafeRes = await this._rpcRequest("getVersion", []);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(VersionResult2));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get version");
      }
      return res.result;
    }
    async getGenesisHash() {
      const unsafeRes = await this._rpcRequest("getGenesisHash", []);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.string()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
      }
      return res.result;
    }
    async getBlock(slot, rawConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(rawConfig);
      const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("getBlock", args);
      try {
        switch (config2?.transactionDetails) {
          case "accounts": {
            const res = superstruct.create(unsafeRes, GetAccountsModeBlockRpcResult2);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          case "none": {
            const res = superstruct.create(unsafeRes, GetNoneModeBlockRpcResult2);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          default: {
            const res = superstruct.create(unsafeRes, GetBlockRpcResult2);
            if ("error" in res) {
              throw res.error;
            }
            const {
              result
            } = res;
            return result ? {
              ...result,
              transactions: result.transactions.map(({
                transaction,
                meta,
                version: version22
              }) => ({
                meta,
                transaction: {
                  ...transaction,
                  message: versionedMessageFromResponse(version22, transaction.message)
                },
                version: version22
              }))
            } : null;
          }
        }
      } catch (e) {
        throw new SolanaJSONRPCError(e, "failed to get confirmed block");
      }
    }
    async getParsedBlock(slot, rawConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(rawConfig);
      const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config2);
      const unsafeRes = await this._rpcRequest("getBlock", args);
      try {
        switch (config2?.transactionDetails) {
          case "accounts": {
            const res = superstruct.create(unsafeRes, GetParsedAccountsModeBlockRpcResult2);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          case "none": {
            const res = superstruct.create(unsafeRes, GetParsedNoneModeBlockRpcResult2);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          default: {
            const res = superstruct.create(unsafeRes, GetParsedBlockRpcResult2);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
        }
      } catch (e) {
        throw new SolanaJSONRPCError(e, "failed to get block");
      }
    }
    async getBlockProduction(configOrCommitment) {
      let extra;
      let commitment;
      if (typeof configOrCommitment === "string") {
        commitment = configOrCommitment;
      } else if (configOrCommitment) {
        const {
          commitment: c,
          ...rest
        } = configOrCommitment;
        commitment = c;
        extra = rest;
      }
      const args = this._buildArgs([], commitment, "base64", extra);
      const unsafeRes = await this._rpcRequest("getBlockProduction", args);
      const res = superstruct.create(unsafeRes, BlockProductionResponseStruct2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get block production information");
      }
      return res.result;
    }
    async getTransaction(signature2, rawConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(rawConfig);
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, undefined, config2);
      const unsafeRes = await this._rpcRequest("getTransaction", args);
      const res = superstruct.create(unsafeRes, GetTransactionRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      const result = res.result;
      if (!result)
        return result;
      return {
        ...result,
        transaction: {
          ...result.transaction,
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        }
      };
    }
    async getParsedTransaction(signature2, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config2);
      const unsafeRes = await this._rpcRequest("getTransaction", args);
      const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      return res.result;
    }
    async getParsedTransactions(signatures, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const batch = signatures.map((signature2) => {
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config2);
        return {
          methodName: "getTransaction",
          args
        };
      });
      const unsafeRes = await this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = superstruct.create(unsafeRes2, GetParsedTransactionRpcResult2);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
        }
        return res2.result;
      });
      return res;
    }
    async getTransactions(signatures, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const batch = signatures.map((signature2) => {
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, undefined, config2);
        return {
          methodName: "getTransaction",
          args
        };
      });
      const unsafeRes = await this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = superstruct.create(unsafeRes2, GetTransactionRpcResult2);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
        }
        const result = res2.result;
        if (!result)
          return result;
        return {
          ...result,
          transaction: {
            ...result.transaction,
            message: versionedMessageFromResponse(result.version, result.transaction.message)
          }
        };
      });
      return res;
    }
    async getConfirmedBlock(slot, commitment) {
      const args = this._buildArgsAtLeastConfirmed([slot], commitment);
      const unsafeRes = await this._rpcRequest("getBlock", args);
      const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Confirmed block " + slot + " not found");
      }
      const block = {
        ...result,
        transactions: result.transactions.map(({
          transaction,
          meta
        }) => {
          const message = new Message2(transaction.message);
          return {
            meta,
            transaction: {
              ...transaction,
              message
            }
          };
        })
      };
      return {
        ...block,
        transactions: block.transactions.map(({
          transaction,
          meta
        }) => {
          return {
            meta,
            transaction: Transaction22.populate(transaction.message, transaction.signatures)
          };
        })
      };
    }
    async getBlocks(startSlot, endSlot, commitment) {
      const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);
      const unsafeRes = await this._rpcRequest("getBlocks", args);
      const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(superstruct.number())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get blocks");
      }
      return res.result;
    }
    async getBlockSignatures(slot, commitment) {
      const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
        transactionDetails: "signatures",
        rewards: false
      });
      const unsafeRes = await this._rpcRequest("getBlock", args);
      const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Block " + slot + " not found");
      }
      return result;
    }
    async getConfirmedBlockSignatures(slot, commitment) {
      const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
        transactionDetails: "signatures",
        rewards: false
      });
      const unsafeRes = await this._rpcRequest("getBlock", args);
      const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Confirmed block " + slot + " not found");
      }
      return result;
    }
    async getConfirmedTransaction(signature2, commitment) {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
      const unsafeRes = await this._rpcRequest("getTransaction", args);
      const res = superstruct.create(unsafeRes, GetTransactionRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      const result = res.result;
      if (!result)
        return result;
      const message = new Message2(result.transaction.message);
      const signatures = result.transaction.signatures;
      return {
        ...result,
        transaction: Transaction22.populate(message, signatures)
      };
    }
    async getParsedConfirmedTransaction(signature2, commitment) {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
      const unsafeRes = await this._rpcRequest("getTransaction", args);
      const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
      }
      return res.result;
    }
    async getParsedConfirmedTransactions(signatures, commitment) {
      const batch = signatures.map((signature2) => {
        const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
        return {
          methodName: "getTransaction",
          args
        };
      });
      const unsafeRes = await this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = superstruct.create(unsafeRes2, GetParsedTransactionRpcResult2);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
        }
        return res2.result;
      });
      return res;
    }
    async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
      let options = {};
      let firstAvailableBlock = await this.getFirstAvailableBlock();
      while (!("until" in options)) {
        startSlot--;
        if (startSlot <= 0 || startSlot < firstAvailableBlock) {
          break;
        }
        try {
          const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
          if (block.signatures.length > 0) {
            options.until = block.signatures[block.signatures.length - 1].toString();
          }
        } catch (err) {
          if (err instanceof Error && err.message.includes("skipped")) {
            continue;
          } else {
            throw err;
          }
        }
      }
      let highestConfirmedRoot = await this.getSlot("finalized");
      while (!("before" in options)) {
        endSlot++;
        if (endSlot > highestConfirmedRoot) {
          break;
        }
        try {
          const block = await this.getConfirmedBlockSignatures(endSlot);
          if (block.signatures.length > 0) {
            options.before = block.signatures[block.signatures.length - 1].toString();
          }
        } catch (err) {
          if (err instanceof Error && err.message.includes("skipped")) {
            continue;
          } else {
            throw err;
          }
        }
      }
      const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
      return confirmedSignatureInfo.map((info) => info.signature);
    }
    async getConfirmedSignaturesForAddress2(address, options, commitment) {
      const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
      const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
      const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
      }
      return res.result;
    }
    async getSignaturesForAddress(address, options, commitment) {
      const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
      const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
      const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
      }
      return res.result;
    }
    async getAddressLookupTable(accountKey, config2) {
      const {
        context,
        value: accountInfo
      } = await this.getAccountInfoAndContext(accountKey, config2);
      let value = null;
      if (accountInfo !== null) {
        value = new AddressLookupTableAccount({
          key: accountKey,
          state: AddressLookupTableAccount.deserialize(accountInfo.data)
        });
      }
      return {
        context,
        value
      };
    }
    async getNonceAndContext(nonceAccount, commitmentOrConfig) {
      const {
        context,
        value: accountInfo
      } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
      let value = null;
      if (accountInfo !== null) {
        value = NonceAccount.fromAccountData(accountInfo.data);
      }
      return {
        context,
        value
      };
    }
    async getNonce(nonceAccount, commitmentOrConfig) {
      return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x2) => x2.value).catch((e) => {
        throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
      });
    }
    async requestAirdrop(to, lamports) {
      const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
      const res = superstruct.create(unsafeRes, RequestAirdropRpcResult2);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
      }
      return res.result;
    }
    async _blockhashWithExpiryBlockHeight(disableCache) {
      if (!disableCache) {
        while (this._pollingBlockhash) {
          await sleep2(100);
        }
        const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
        const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS2;
        if (this._blockhashInfo.latestBlockhash !== null && !expired) {
          return this._blockhashInfo.latestBlockhash;
        }
      }
      return await this._pollNewBlockhash();
    }
    async _pollNewBlockhash() {
      this._pollingBlockhash = true;
      try {
        const startTime = Date.now();
        const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
        const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
        for (let i22 = 0;i22 < 50; i22++) {
          const latestBlockhash = await this.getLatestBlockhash("finalized");
          if (cachedBlockhash !== latestBlockhash.blockhash) {
            this._blockhashInfo = {
              latestBlockhash,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: []
            };
            return latestBlockhash;
          }
          await sleep2(MS_PER_SLOT2 / 2);
        }
        throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
      } finally {
        this._pollingBlockhash = false;
      }
    }
    async getStakeMinimumDelegation(config2) {
      const {
        commitment,
        config: configArg
      } = extractCommitmentFromConfig(config2);
      const args = this._buildArgs([], commitment, "base64", configArg);
      const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
      const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.number()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
      }
      return res.result;
    }
    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
      if ("message" in transactionOrMessage) {
        const versionedTx = transactionOrMessage;
        const wireTransaction2 = versionedTx.serialize();
        const encodedTransaction2 = buffer.Buffer.from(wireTransaction2).toString("base64");
        if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {
          throw new Error("Invalid arguments");
        }
        const config22 = configOrSigners || {};
        config22.encoding = "base64";
        if (!("commitment" in config22)) {
          config22.commitment = this.commitment;
        }
        if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
          config22.innerInstructions = configOrSigners.innerInstructions;
        }
        const args2 = [encodedTransaction2, config22];
        const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
        const res2 = superstruct.create(unsafeRes2, SimulatedTransactionResponseStruct2);
        if ("error" in res2) {
          throw new Error("failed to simulate transaction: " + res2.error.message);
        }
        return res2.result;
      }
      let transaction;
      if (transactionOrMessage instanceof Transaction22) {
        let originalTx = transactionOrMessage;
        transaction = new Transaction22;
        transaction.feePayer = originalTx.feePayer;
        transaction.instructions = transactionOrMessage.instructions;
        transaction.nonceInfo = originalTx.nonceInfo;
        transaction.signatures = originalTx.signatures;
      } else {
        transaction = Transaction22.populate(transactionOrMessage);
        transaction._message = transaction._json = undefined;
      }
      if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {
        throw new Error("Invalid arguments");
      }
      const signers = configOrSigners;
      if (transaction.nonceInfo && signers) {
        transaction.sign(...signers);
      } else {
        let disableCache = this._disableBlockhashCaching;
        for (;; ) {
          const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
          transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
          transaction.recentBlockhash = latestBlockhash.blockhash;
          if (!signers)
            break;
          transaction.sign(...signers);
          if (!transaction.signature) {
            throw new Error("!signature");
          }
          const signature2 = transaction.signature.toString("base64");
          if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
            this._blockhashInfo.simulatedSignatures.push(signature2);
            break;
          } else {
            disableCache = true;
          }
        }
      }
      const message = transaction._compile();
      const signData = message.serialize();
      const wireTransaction = transaction._serialize(signData);
      const encodedTransaction = wireTransaction.toString("base64");
      const config2 = {
        encoding: "base64",
        commitment: this.commitment
      };
      if (includeAccounts) {
        const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
        config2["accounts"] = {
          encoding: "base64",
          addresses
        };
      }
      if (signers) {
        config2.sigVerify = true;
      }
      if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
        config2.innerInstructions = configOrSigners.innerInstructions;
      }
      const args = [encodedTransaction, config2];
      const unsafeRes = await this._rpcRequest("simulateTransaction", args);
      const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct2);
      if ("error" in res) {
        let logs;
        if ("data" in res.error) {
          logs = res.error.data.logs;
          if (logs && Array.isArray(logs)) {
            const traceIndent = `
    `;
            const logTrace = traceIndent + logs.join(traceIndent);
            console.error(res.error.message, logTrace);
          }
        }
        throw new SendTransactionError2({
          action: "simulate",
          signature: "",
          transactionMessage: res.error.message,
          logs
        });
      }
      return res.result;
    }
    async sendTransaction(transaction, signersOrOptions, options) {
      if ("version" in transaction) {
        if (signersOrOptions && Array.isArray(signersOrOptions)) {
          throw new Error("Invalid arguments");
        }
        const wireTransaction2 = transaction.serialize();
        return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
      }
      if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {
        throw new Error("Invalid arguments");
      }
      const signers = signersOrOptions;
      if (transaction.nonceInfo) {
        transaction.sign(...signers);
      } else {
        let disableCache = this._disableBlockhashCaching;
        for (;; ) {
          const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
          transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
          transaction.recentBlockhash = latestBlockhash.blockhash;
          transaction.sign(...signers);
          if (!transaction.signature) {
            throw new Error("!signature");
          }
          const signature2 = transaction.signature.toString("base64");
          if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
            this._blockhashInfo.transactionSignatures.push(signature2);
            break;
          } else {
            disableCache = true;
          }
        }
      }
      const wireTransaction = transaction.serialize();
      return await this.sendRawTransaction(wireTransaction, options);
    }
    async sendRawTransaction(rawTransaction, options) {
      const encodedTransaction = toBuffer2(rawTransaction).toString("base64");
      const result = await this.sendEncodedTransaction(encodedTransaction, options);
      return result;
    }
    async sendEncodedTransaction(encodedTransaction, options) {
      const config2 = {
        encoding: "base64"
      };
      const skipPreflight = options && options.skipPreflight;
      const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
      if (options && options.maxRetries != null) {
        config2.maxRetries = options.maxRetries;
      }
      if (options && options.minContextSlot != null) {
        config2.minContextSlot = options.minContextSlot;
      }
      if (skipPreflight) {
        config2.skipPreflight = skipPreflight;
      }
      if (preflightCommitment) {
        config2.preflightCommitment = preflightCommitment;
      }
      const args = [encodedTransaction, config2];
      const unsafeRes = await this._rpcRequest("sendTransaction", args);
      const res = superstruct.create(unsafeRes, SendTransactionRpcResult2);
      if ("error" in res) {
        let logs = undefined;
        if ("data" in res.error) {
          logs = res.error.data.logs;
        }
        throw new SendTransactionError2({
          action: skipPreflight ? "send" : "simulate",
          signature: "",
          transactionMessage: res.error.message,
          logs
        });
      }
      return res.result;
    }
    _wsOnOpen() {
      this._rpcWebSocketConnected = true;
      this._rpcWebSocketHeartbeat = setInterval(() => {
        (async () => {
          try {
            await this._rpcWebSocket.notify("ping");
          } catch {}
        })();
      }, 5000);
      this._updateSubscriptions();
    }
    _wsOnError(err) {
      this._rpcWebSocketConnected = false;
      console.error("ws error:", err.message);
    }
    _wsOnClose(code2) {
      this._rpcWebSocketConnected = false;
      this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
      if (this._rpcWebSocketIdleTimeout) {
        clearTimeout(this._rpcWebSocketIdleTimeout);
        this._rpcWebSocketIdleTimeout = null;
      }
      if (this._rpcWebSocketHeartbeat) {
        clearInterval(this._rpcWebSocketHeartbeat);
        this._rpcWebSocketHeartbeat = null;
      }
      if (code2 === 1000) {
        this._updateSubscriptions();
        return;
      }
      this._subscriptionCallbacksByServerSubscriptionId = {};
      Object.entries(this._subscriptionsByHash).forEach(([hash2, subscription]) => {
        this._setSubscription(hash2, {
          ...subscription,
          state: "pending"
        });
      });
    }
    _setSubscription(hash2, nextSubscription) {
      const prevState = this._subscriptionsByHash[hash2]?.state;
      this._subscriptionsByHash[hash2] = nextSubscription;
      if (prevState !== nextSubscription.state) {
        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2];
        if (stateChangeCallbacks) {
          stateChangeCallbacks.forEach((cb) => {
            try {
              cb(nextSubscription.state);
            } catch {}
          });
        }
      }
    }
    _onSubscriptionStateChange(clientSubscriptionId, callback) {
      const hash2 = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      if (hash2 == null) {
        return () => {};
      }
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2] ||= new Set;
      stateChangeCallbacks.add(callback);
      return () => {
        stateChangeCallbacks.delete(callback);
        if (stateChangeCallbacks.size === 0) {
          delete this._subscriptionStateChangeCallbacksByHash[hash2];
        }
      };
    }
    async _updateSubscriptions() {
      if (Object.keys(this._subscriptionsByHash).length === 0) {
        if (this._rpcWebSocketConnected) {
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketIdleTimeout = setTimeout(() => {
            this._rpcWebSocketIdleTimeout = null;
            try {
              this._rpcWebSocket.close();
            } catch (err) {
              if (err instanceof Error) {
                console.log(`Error when closing socket connection: ${err.message}`);
              }
            }
          }, 500);
        }
        return;
      }
      if (this._rpcWebSocketIdleTimeout !== null) {
        clearTimeout(this._rpcWebSocketIdleTimeout);
        this._rpcWebSocketIdleTimeout = null;
        this._rpcWebSocketConnected = true;
      }
      if (!this._rpcWebSocketConnected) {
        this._rpcWebSocket.connect();
        return;
      }
      const activeWebSocketGeneration = this._rpcWebSocketGeneration;
      const isCurrentConnectionStillActive = () => {
        return activeWebSocketGeneration === this._rpcWebSocketGeneration;
      };
      await Promise.all(Object.keys(this._subscriptionsByHash).map(async (hash2) => {
        const subscription = this._subscriptionsByHash[hash2];
        if (subscription === undefined) {
          return;
        }
        switch (subscription.state) {
          case "pending":
          case "unsubscribed":
            if (subscription.callbacks.size === 0) {
              delete this._subscriptionsByHash[hash2];
              if (subscription.state === "unsubscribed") {
                delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
              }
              await this._updateSubscriptions();
              return;
            }
            await (async () => {
              const {
                args,
                method
              } = subscription;
              try {
                this._setSubscription(hash2, {
                  ...subscription,
                  state: "subscribing"
                });
                const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                this._setSubscription(hash2, {
                  ...subscription,
                  serverSubscriptionId,
                  state: "subscribed"
                });
                this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                await this._updateSubscriptions();
              } catch (e) {
                console.error(`Received ${e instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                  args,
                  error: e
                });
                if (!isCurrentConnectionStillActive()) {
                  return;
                }
                this._setSubscription(hash2, {
                  ...subscription,
                  state: "pending"
                });
                await this._updateSubscriptions();
              }
            })();
            break;
          case "subscribed":
            if (subscription.callbacks.size === 0) {
              await (async () => {
                const {
                  serverSubscriptionId,
                  unsubscribeMethod
                } = subscription;
                if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                  this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                } else {
                  this._setSubscription(hash2, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  this._setSubscription(hash2, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                  } catch (e) {
                    if (e instanceof Error) {
                      console.error(`${unsubscribeMethod} error:`, e.message);
                    }
                    if (!isCurrentConnectionStillActive()) {
                      return;
                    }
                    this._setSubscription(hash2, {
                      ...subscription,
                      state: "subscribed"
                    });
                    await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(hash2, {
                  ...subscription,
                  state: "unsubscribed"
                });
                await this._updateSubscriptions();
              })();
            }
            break;
        }
      }));
    }
    _handleServerNotification(serverSubscriptionId, callbackArgs) {
      const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
      if (callbacks === undefined) {
        return;
      }
      callbacks.forEach((cb) => {
        try {
          cb(...callbackArgs);
        } catch (e) {
          console.error(e);
        }
      });
    }
    _wsOnAccountNotification(notification) {
      const {
        result,
        subscription
      } = superstruct.create(notification, AccountNotificationResult2);
      this._handleServerNotification(subscription, [result.value, result.context]);
    }
    _makeSubscription(subscriptionConfig, args) {
      const clientSubscriptionId = this._nextClientSubscriptionId++;
      const hash2 = fastStableStringify([subscriptionConfig.method, args]);
      const existingSubscription = this._subscriptionsByHash[hash2];
      if (existingSubscription === undefined) {
        this._subscriptionsByHash[hash2] = {
          ...subscriptionConfig,
          args,
          callbacks: new Set([subscriptionConfig.callback]),
          state: "pending"
        };
      } else {
        existingSubscription.callbacks.add(subscriptionConfig.callback);
      }
      this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash2;
      this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
        delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
        delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
        const subscription = this._subscriptionsByHash[hash2];
        assert32(subscription !== undefined, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
        subscription.callbacks.delete(subscriptionConfig.callback);
        await this._updateSubscriptions();
      };
      this._updateSubscriptions();
      return clientSubscriptionId;
    }
    onAccountChange(publicKey3, callback, commitmentOrConfig) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([publicKey3.toBase58()], commitment || this._commitment || "finalized", "base64", config2);
      return this._makeSubscription({
        callback,
        method: "accountSubscribe",
        unsubscribeMethod: "accountUnsubscribe"
      }, args);
    }
    async removeAccountChangeListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
    }
    _wsOnProgramAccountNotification(notification) {
      const {
        result,
        subscription
      } = superstruct.create(notification, ProgramAccountNotificationResult2);
      this._handleServerNotification(subscription, [{
        accountId: result.value.pubkey,
        accountInfo: result.value.account
      }, result.context]);
    }
    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
      const {
        commitment,
        config: config2
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || "finalized", "base64", config2 ? config2 : maybeFilters ? {
        filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
      } : undefined);
      return this._makeSubscription({
        callback,
        method: "programSubscribe",
        unsubscribeMethod: "programUnsubscribe"
      }, args);
    }
    async removeProgramAccountChangeListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
    }
    onLogs(filter, callback, commitment) {
      const args = this._buildArgs([typeof filter === "object" ? {
        mentions: [filter.toString()]
      } : filter], commitment || this._commitment || "finalized");
      return this._makeSubscription({
        callback,
        method: "logsSubscribe",
        unsubscribeMethod: "logsUnsubscribe"
      }, args);
    }
    async removeOnLogsListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
    }
    _wsOnLogsNotification(notification) {
      const {
        result,
        subscription
      } = superstruct.create(notification, LogsNotificationResult2);
      this._handleServerNotification(subscription, [result.value, result.context]);
    }
    _wsOnSlotNotification(notification) {
      const {
        result,
        subscription
      } = superstruct.create(notification, SlotNotificationResult2);
      this._handleServerNotification(subscription, [result]);
    }
    onSlotChange(callback) {
      return this._makeSubscription({
        callback,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      }, []);
    }
    async removeSlotChangeListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
    }
    _wsOnSlotUpdatesNotification(notification) {
      const {
        result,
        subscription
      } = superstruct.create(notification, SlotUpdateNotificationResult2);
      this._handleServerNotification(subscription, [result]);
    }
    onSlotUpdate(callback) {
      return this._makeSubscription({
        callback,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      }, []);
    }
    async removeSlotUpdateListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
    }
    async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
      const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      if (dispose) {
        await dispose();
      } else {
        console.warn("Ignored unsubscribe request because an active subscription with id " + `\`${clientSubscriptionId}\` for '${subscriptionName}' events ` + "could not be found.");
      }
    }
    _buildArgs(args, override, encoding, extra) {
      const commitment = override || this._commitment;
      if (commitment || encoding || extra) {
        let options = {};
        if (encoding) {
          options.encoding = encoding;
        }
        if (commitment) {
          options.commitment = commitment;
        }
        if (extra) {
          options = Object.assign(options, extra);
        }
        args.push(options);
      }
      return args;
    }
    _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
      const commitment = override || this._commitment;
      if (commitment && !["confirmed", "finalized"].includes(commitment)) {
        throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
      }
      return this._buildArgs(args, override, encoding, extra);
    }
    _wsOnSignatureNotification(notification) {
      const {
        result,
        subscription
      } = superstruct.create(notification, SignatureNotificationResult2);
      if (result.value !== "receivedSignature") {
        this._subscriptionsAutoDisposedByRpc.add(subscription);
      }
      this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
        type: "received"
      }, result.context] : [{
        type: "status",
        result: result.value
      }, result.context]);
    }
    onSignature(signature2, callback, commitment) {
      const args = this._buildArgs([signature2], commitment || this._commitment || "finalized");
      const clientSubscriptionId = this._makeSubscription({
        callback: (notification, context) => {
          if (notification.type === "status") {
            callback(notification.result, context);
            try {
              this.removeSignatureListener(clientSubscriptionId);
            } catch (_err) {}
          }
        },
        method: "signatureSubscribe",
        unsubscribeMethod: "signatureUnsubscribe"
      }, args);
      return clientSubscriptionId;
    }
    onSignatureWithOptions(signature2, callback, options) {
      const {
        commitment,
        ...extra
      } = {
        ...options,
        commitment: options && options.commitment || this._commitment || "finalized"
      };
      const args = this._buildArgs([signature2], commitment, undefined, extra);
      const clientSubscriptionId = this._makeSubscription({
        callback: (notification, context) => {
          callback(notification, context);
          try {
            this.removeSignatureListener(clientSubscriptionId);
          } catch (_err) {}
        },
        method: "signatureSubscribe",
        unsubscribeMethod: "signatureUnsubscribe"
      }, args);
      return clientSubscriptionId;
    }
    async removeSignatureListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
    }
    _wsOnRootNotification(notification) {
      const {
        result,
        subscription
      } = superstruct.create(notification, RootNotificationResult2);
      this._handleServerNotification(subscription, [result]);
    }
    onRootChange(callback) {
      return this._makeSubscription({
        callback,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      }, []);
    }
    async removeRootChangeListener(clientSubscriptionId) {
      await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
    }
  }

  class Keypair2 {
    constructor(keypair) {
      this._keypair = undefined;
      this._keypair = keypair ?? generateKeypair2();
    }
    static generate() {
      return new Keypair2(generateKeypair2());
    }
    static fromSecretKey(secretKey, options) {
      if (secretKey.byteLength !== 64) {
        throw new Error("bad secret key size");
      }
      const publicKey3 = secretKey.slice(32, 64);
      if (!options || !options.skipValidation) {
        const privateScalar = secretKey.slice(0, 32);
        const computedPublicKey = getPublicKey2(privateScalar);
        for (let ii = 0;ii < 32; ii++) {
          if (publicKey3[ii] !== computedPublicKey[ii]) {
            throw new Error("provided secretKey is invalid");
          }
        }
      }
      return new Keypair2({
        publicKey: publicKey3,
        secretKey
      });
    }
    static fromSeed(seed) {
      const publicKey3 = getPublicKey2(seed);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey3, 32);
      return new Keypair2({
        publicKey: publicKey3,
        secretKey
      });
    }
    get publicKey() {
      return new PublicKey2(this._keypair.publicKey);
    }
    get secretKey() {
      return new Uint8Array(this._keypair.secretKey);
    }
  }
  var LOOKUP_TABLE_INSTRUCTION_LAYOUTS2 = Object.freeze({
    CreateLookupTable: {
      index: 0,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u6422("recentSlot"), BufferLayout__namespace.u8("bumpSeed")])
    },
    FreezeLookupTable: {
      index: 1,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    },
    ExtendLookupTable: {
      index: 2,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u6422(), BufferLayout__namespace.seq(publicKey2(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "addresses")])
    },
    DeactivateLookupTable: {
      index: 3,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    },
    CloseLookupTable: {
      index: 4,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    }
  });

  class AddressLookupTableInstruction {
    constructor() {}
    static decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
      const index = instructionTypeLayout.decode(instruction.data);
      let type2;
      for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS2)) {
        if (layout.index == index) {
          type2 = layoutType;
          break;
        }
      }
      if (!type2) {
        throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
      }
      return type2;
    }
    static decodeCreateLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 4);
      const {
        recentSlot
      } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.CreateLookupTable, instruction.data);
      return {
        authority: instruction.keys[1].pubkey,
        payer: instruction.keys[2].pubkey,
        recentSlot: Number(recentSlot)
      };
    }
    static decodeExtendLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      if (instruction.keys.length < 2) {
        throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
      }
      const {
        addresses
      } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.ExtendLookupTable, instruction.data);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey,
        payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
        addresses: addresses.map((buffer2) => new PublicKey2(buffer2))
      };
    }
    static decodeCloseLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 3);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey,
        recipient: instruction.keys[2].pubkey
      };
    }
    static decodeFreezeLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 2);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey
      };
    }
    static decodeDeactivateLookupTable(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeysLength(instruction.keys, 2);
      return {
        lookupTable: instruction.keys[0].pubkey,
        authority: instruction.keys[1].pubkey
      };
    }
    static checkProgramId(programId) {
      if (!programId.equals(AddressLookupTableProgram2.programId)) {
        throw new Error("invalid instruction; programId is not AddressLookupTable Program");
      }
    }
    static checkKeysLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
      }
    }
  }

  class AddressLookupTableProgram2 {
    constructor() {}
    static createLookupTable(params) {
      const [lookupTableAddress, bumpSeed] = PublicKey2.findProgramAddressSync([params.authority.toBuffer(), codecsNumbers.getU64Encoder().encode(params.recentSlot)], this.programId);
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.CreateLookupTable;
      const data = encodeData2(type2, {
        recentSlot: BigInt(params.recentSlot),
        bumpSeed
      });
      const keys = [{
        pubkey: lookupTableAddress,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram2.programId,
        isSigner: false,
        isWritable: false
      }];
      return [new TransactionInstruction2({
        programId: this.programId,
        keys,
        data
      }), lookupTableAddress];
    }
    static freezeLookupTable(params) {
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.FreezeLookupTable;
      const data = encodeData2(type2);
      const keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      return new TransactionInstruction2({
        programId: this.programId,
        keys,
        data
      });
    }
    static extendLookupTable(params) {
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.ExtendLookupTable;
      const data = encodeData2(type2, {
        addresses: params.addresses.map((addr) => addr.toBytes())
      });
      const keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      if (params.payer) {
        keys.push({
          pubkey: params.payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SystemProgram2.programId,
          isSigner: false,
          isWritable: false
        });
      }
      return new TransactionInstruction2({
        programId: this.programId,
        keys,
        data
      });
    }
    static deactivateLookupTable(params) {
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.DeactivateLookupTable;
      const data = encodeData2(type2);
      const keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }];
      return new TransactionInstruction2({
        programId: this.programId,
        keys,
        data
      });
    }
    static closeLookupTable(params) {
      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.CloseLookupTable;
      const data = encodeData2(type2);
      const keys = [{
        pubkey: params.lookupTable,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authority,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.recipient,
        isSigner: false,
        isWritable: true
      }];
      return new TransactionInstruction2({
        programId: this.programId,
        keys,
        data
      });
    }
  }
  AddressLookupTableProgram2.programId = new PublicKey2("AddressLookupTab1e1111111111111111111111111");

  class ComputeBudgetInstruction {
    constructor() {}
    static decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      const instructionTypeLayout = BufferLayout__namespace.u8("instruction");
      const typeIndex = instructionTypeLayout.decode(instruction.data);
      let type2;
      for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2)) {
        if (layout.index == typeIndex) {
          type2 = ixType;
          break;
        }
      }
      if (!type2) {
        throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
      }
      return type2;
    }
    static decodeRequestUnits(instruction) {
      this.checkProgramId(instruction.programId);
      const {
        units,
        additionalFee
      } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.RequestUnits, instruction.data);
      return {
        units,
        additionalFee
      };
    }
    static decodeRequestHeapFrame(instruction) {
      this.checkProgramId(instruction.programId);
      const {
        bytes: bytes2
      } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.RequestHeapFrame, instruction.data);
      return {
        bytes: bytes2
      };
    }
    static decodeSetComputeUnitLimit(instruction) {
      this.checkProgramId(instruction.programId);
      const {
        units
      } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.SetComputeUnitLimit, instruction.data);
      return {
        units
      };
    }
    static decodeSetComputeUnitPrice(instruction) {
      this.checkProgramId(instruction.programId);
      const {
        microLamports
      } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.SetComputeUnitPrice, instruction.data);
      return {
        microLamports
      };
    }
    static checkProgramId(programId) {
      if (!programId.equals(ComputeBudgetProgram2.programId)) {
        throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
      }
    }
  }
  var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2 = Object.freeze({
    RequestUnits: {
      index: 0,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("units"), BufferLayout__namespace.u32("additionalFee")])
    },
    RequestHeapFrame: {
      index: 1,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("bytes")])
    },
    SetComputeUnitLimit: {
      index: 2,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("units")])
    },
    SetComputeUnitPrice: {
      index: 3,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), u6422("microLamports")])
    }
  });

  class ComputeBudgetProgram2 {
    constructor() {}
    static requestUnits(params) {
      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.RequestUnits;
      const data = encodeData2(type2, params);
      return new TransactionInstruction2({
        keys: [],
        programId: this.programId,
        data
      });
    }
    static requestHeapFrame(params) {
      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.RequestHeapFrame;
      const data = encodeData2(type2, params);
      return new TransactionInstruction2({
        keys: [],
        programId: this.programId,
        data
      });
    }
    static setComputeUnitLimit(params) {
      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.SetComputeUnitLimit;
      const data = encodeData2(type2, params);
      return new TransactionInstruction2({
        keys: [],
        programId: this.programId,
        data
      });
    }
    static setComputeUnitPrice(params) {
      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.SetComputeUnitPrice;
      const data = encodeData2(type2, {
        microLamports: BigInt(params.microLamports)
      });
      return new TransactionInstruction2({
        keys: [],
        programId: this.programId,
        data
      });
    }
  }
  ComputeBudgetProgram2.programId = new PublicKey2("ComputeBudget111111111111111111111111111111");
  var PRIVATE_KEY_BYTES$12 = 64;
  var PUBLIC_KEY_BYTES$12 = 32;
  var SIGNATURE_BYTES2 = 64;
  var ED25519_INSTRUCTION_LAYOUT2 = BufferLayout__namespace.struct([BufferLayout__namespace.u8("numSignatures"), BufferLayout__namespace.u8("padding"), BufferLayout__namespace.u16("signatureOffset"), BufferLayout__namespace.u16("signatureInstructionIndex"), BufferLayout__namespace.u16("publicKeyOffset"), BufferLayout__namespace.u16("publicKeyInstructionIndex"), BufferLayout__namespace.u16("messageDataOffset"), BufferLayout__namespace.u16("messageDataSize"), BufferLayout__namespace.u16("messageInstructionIndex")]);

  class Ed25519Program2 {
    constructor() {}
    static createInstructionWithPublicKey(params) {
      const {
        publicKey: publicKey3,
        message,
        signature: signature2,
        instructionIndex
      } = params;
      assert32(publicKey3.length === PUBLIC_KEY_BYTES$12, `Public Key must be ${PUBLIC_KEY_BYTES$12} bytes but received ${publicKey3.length} bytes`);
      assert32(signature2.length === SIGNATURE_BYTES2, `Signature must be ${SIGNATURE_BYTES2} bytes but received ${signature2.length} bytes`);
      const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT2.span;
      const signatureOffset = publicKeyOffset + publicKey3.length;
      const messageDataOffset = signatureOffset + signature2.length;
      const numSignatures = 1;
      const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);
      const index = instructionIndex == null ? 65535 : instructionIndex;
      ED25519_INSTRUCTION_LAYOUT2.encode({
        numSignatures,
        padding: 0,
        signatureOffset,
        signatureInstructionIndex: index,
        publicKeyOffset,
        publicKeyInstructionIndex: index,
        messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: index
      }, instructionData);
      instructionData.fill(publicKey3, publicKeyOffset);
      instructionData.fill(signature2, signatureOffset);
      instructionData.fill(message, messageDataOffset);
      return new TransactionInstruction2({
        keys: [],
        programId: Ed25519Program2.programId,
        data: instructionData
      });
    }
    static createInstructionWithPrivateKey(params) {
      const {
        privateKey,
        message,
        instructionIndex
      } = params;
      assert32(privateKey.length === PRIVATE_KEY_BYTES$12, `Private key must be ${PRIVATE_KEY_BYTES$12} bytes but received ${privateKey.length} bytes`);
      try {
        const keypair = Keypair2.fromSecretKey(privateKey);
        const publicKey3 = keypair.publicKey.toBytes();
        const signature2 = sign22(message, keypair.secretKey);
        return this.createInstructionWithPublicKey({
          publicKey: publicKey3,
          message,
          signature: signature2,
          instructionIndex
        });
      } catch (error) {
        throw new Error(`Error creating instruction; ${error}`);
      }
    }
  }
  Ed25519Program2.programId = new PublicKey2("Ed25519SigVerify111111111111111111111111111");
  var ecdsaSign2 = (msgHash, privKey) => {
    const signature2 = secp256k122.secp256k1.sign(msgHash, privKey);
    return [signature2.toCompactRawBytes(), signature2.recovery];
  };
  secp256k122.secp256k1.utils.isValidPrivateKey;
  var publicKeyCreate2 = secp256k122.secp256k1.getPublicKey;
  var PRIVATE_KEY_BYTES2 = 32;
  var ETHEREUM_ADDRESS_BYTES2 = 20;
  var PUBLIC_KEY_BYTES2 = 64;
  var SIGNATURE_OFFSETS_SERIALIZED_SIZE2 = 11;
  var SECP256K1_INSTRUCTION_LAYOUT2 = BufferLayout__namespace.struct([BufferLayout__namespace.u8("numSignatures"), BufferLayout__namespace.u16("signatureOffset"), BufferLayout__namespace.u8("signatureInstructionIndex"), BufferLayout__namespace.u16("ethAddressOffset"), BufferLayout__namespace.u8("ethAddressInstructionIndex"), BufferLayout__namespace.u16("messageDataOffset"), BufferLayout__namespace.u16("messageDataSize"), BufferLayout__namespace.u8("messageInstructionIndex"), BufferLayout__namespace.blob(20, "ethAddress"), BufferLayout__namespace.blob(64, "signature"), BufferLayout__namespace.u8("recoveryId")]);

  class Secp256k1Program2 {
    constructor() {}
    static publicKeyToEthAddress(publicKey3) {
      assert32(publicKey3.length === PUBLIC_KEY_BYTES2, `Public key must be ${PUBLIC_KEY_BYTES2} bytes but received ${publicKey3.length} bytes`);
      try {
        return buffer.Buffer.from(sha3.keccak_256(toBuffer2(publicKey3))).slice(-ETHEREUM_ADDRESS_BYTES2);
      } catch (error) {
        throw new Error(`Error constructing Ethereum address: ${error}`);
      }
    }
    static createInstructionWithPublicKey(params) {
      const {
        publicKey: publicKey3,
        message,
        signature: signature2,
        recoveryId,
        instructionIndex
      } = params;
      return Secp256k1Program2.createInstructionWithEthAddress({
        ethAddress: Secp256k1Program2.publicKeyToEthAddress(publicKey3),
        message,
        signature: signature2,
        recoveryId,
        instructionIndex
      });
    }
    static createInstructionWithEthAddress(params) {
      const {
        ethAddress: rawAddress,
        message,
        signature: signature2,
        recoveryId,
        instructionIndex = 0
      } = params;
      let ethAddress;
      if (typeof rawAddress === "string") {
        if (rawAddress.startsWith("0x")) {
          ethAddress = buffer.Buffer.from(rawAddress.substr(2), "hex");
        } else {
          ethAddress = buffer.Buffer.from(rawAddress, "hex");
        }
      } else {
        ethAddress = rawAddress;
      }
      assert32(ethAddress.length === ETHEREUM_ADDRESS_BYTES2, `Address must be ${ETHEREUM_ADDRESS_BYTES2} bytes but received ${ethAddress.length} bytes`);
      const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE2;
      const ethAddressOffset = dataStart;
      const signatureOffset = dataStart + ethAddress.length;
      const messageDataOffset = signatureOffset + signature2.length + 1;
      const numSignatures = 1;
      const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT2.span + message.length);
      SECP256K1_INSTRUCTION_LAYOUT2.encode({
        numSignatures,
        signatureOffset,
        signatureInstructionIndex: instructionIndex,
        ethAddressOffset,
        ethAddressInstructionIndex: instructionIndex,
        messageDataOffset,
        messageDataSize: message.length,
        messageInstructionIndex: instructionIndex,
        signature: toBuffer2(signature2),
        ethAddress: toBuffer2(ethAddress),
        recoveryId
      }, instructionData);
      instructionData.fill(toBuffer2(message), SECP256K1_INSTRUCTION_LAYOUT2.span);
      return new TransactionInstruction2({
        keys: [],
        programId: Secp256k1Program2.programId,
        data: instructionData
      });
    }
    static createInstructionWithPrivateKey(params) {
      const {
        privateKey: pkey,
        message,
        instructionIndex
      } = params;
      assert32(pkey.length === PRIVATE_KEY_BYTES2, `Private key must be ${PRIVATE_KEY_BYTES2} bytes but received ${pkey.length} bytes`);
      try {
        const privateKey = toBuffer2(pkey);
        const publicKey3 = publicKeyCreate2(privateKey, false).slice(1);
        const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer2(message)));
        const [signature2, recoveryId] = ecdsaSign2(messageHash, privateKey);
        return this.createInstructionWithPublicKey({
          publicKey: publicKey3,
          message,
          signature: signature2,
          recoveryId,
          instructionIndex
        });
      } catch (error) {
        throw new Error(`Error creating instruction; ${error}`);
      }
    }
  }
  Secp256k1Program2.programId = new PublicKey2("KeccakSecp256k11111111111111111111111111111");
  var _Lockup2;
  var STAKE_CONFIG_ID2 = new PublicKey2("StakeConfig11111111111111111111111111111111");

  class Authorized {
    constructor(staker, withdrawer) {
      this.staker = undefined;
      this.withdrawer = undefined;
      this.staker = staker;
      this.withdrawer = withdrawer;
    }
  }

  class Lockup2 {
    constructor(unixTimestamp, epoch, custodian) {
      this.unixTimestamp = undefined;
      this.epoch = undefined;
      this.custodian = undefined;
      this.unixTimestamp = unixTimestamp;
      this.epoch = epoch;
      this.custodian = custodian;
    }
  }
  _Lockup2 = Lockup2;
  Lockup2.default = new _Lockup2(0, 0, PublicKey2.default);

  class StakeInstruction {
    constructor() {}
    static decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
      const typeIndex = instructionTypeLayout.decode(instruction.data);
      let type2;
      for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS2)) {
        if (layout.index == typeIndex) {
          type2 = ixType;
          break;
        }
      }
      if (!type2) {
        throw new Error("Instruction type incorrect; not a StakeInstruction");
      }
      return type2;
    }
    static decodeInitialize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      const {
        authorized: authorized3,
        lockup: lockup3
      } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS2.Initialize, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorized: new Authorized(new PublicKey2(authorized3.staker), new PublicKey2(authorized3.withdrawer)),
        lockup: new Lockup2(lockup3.unixTimestamp, lockup3.epoch, new PublicKey2(lockup3.custodian))
      };
    }
    static decodeDelegate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 6);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS2.Delegate, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        votePubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[5].pubkey
      };
    }
    static decodeAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      const {
        newAuthorized,
        stakeAuthorizationType
      } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS2.Authorize, instruction.data);
      const o = {
        stakePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        newAuthorizedPubkey: new PublicKey2(newAuthorized),
        stakeAuthorizationType: {
          index: stakeAuthorizationType
        }
      };
      if (instruction.keys.length > 3) {
        o.custodianPubkey = instruction.keys[3].pubkey;
      }
      return o;
    }
    static decodeAuthorizeWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 2);
      const {
        newAuthorized,
        stakeAuthorizationType,
        authoritySeed,
        authorityOwner
      } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS2.AuthorizeWithSeed, instruction.data);
      const o = {
        stakePubkey: instruction.keys[0].pubkey,
        authorityBase: instruction.keys[1].pubkey,
        authoritySeed,
        authorityOwner: new PublicKey2(authorityOwner),
        newAuthorizedPubkey: new PublicKey2(newAuthorized),
        stakeAuthorizationType: {
          index: stakeAuthorizationType
        }
      };
      if (instruction.keys.length > 3) {
        o.custodianPubkey = instruction.keys[3].pubkey;
      }
      return o;
    }
    static decodeSplit(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      const {
        lamports
      } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS2.Split, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        splitStakePubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        lamports
      };
    }
    static decodeMerge(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS2.Merge, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        sourceStakePubKey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey
      };
    }
    static decodeWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 5);
      const {
        lamports
      } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS2.Withdraw, instruction.data);
      const o = {
        stakePubkey: instruction.keys[0].pubkey,
        toPubkey: instruction.keys[1].pubkey,
        authorizedPubkey: instruction.keys[4].pubkey,
        lamports
      };
      if (instruction.keys.length > 5) {
        o.custodianPubkey = instruction.keys[5].pubkey;
      }
      return o;
    }
    static decodeDeactivate(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      decodeData$1(STAKE_INSTRUCTION_LAYOUTS2.Deactivate, instruction.data);
      return {
        stakePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey
      };
    }
    static checkProgramId(programId) {
      if (!programId.equals(StakeProgram2.programId)) {
        throw new Error("invalid instruction; programId is not StakeProgram");
      }
    }
    static checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
      }
    }
  }
  var STAKE_INSTRUCTION_LAYOUTS2 = Object.freeze({
    Initialize: {
      index: 0,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), authorized2(), lockup2()])
    },
    Authorize: {
      index: 1,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("newAuthorized"), BufferLayout__namespace.u32("stakeAuthorizationType")])
    },
    Delegate: {
      index: 2,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    },
    Split: {
      index: 3,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
    },
    Withdraw: {
      index: 4,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
    },
    Deactivate: {
      index: 5,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    },
    Merge: {
      index: 7,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    },
    AuthorizeWithSeed: {
      index: 8,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("newAuthorized"), BufferLayout__namespace.u32("stakeAuthorizationType"), rustString2("authoritySeed"), publicKey2("authorityOwner")])
    }
  });
  var StakeAuthorizationLayout2 = Object.freeze({
    Staker: {
      index: 0
    },
    Withdrawer: {
      index: 1
    }
  });

  class StakeProgram2 {
    constructor() {}
    static initialize(params) {
      const {
        stakePubkey,
        authorized: authorized3,
        lockup: maybeLockup
      } = params;
      const lockup3 = maybeLockup || Lockup2.default;
      const type2 = STAKE_INSTRUCTION_LAYOUTS2.Initialize;
      const data = encodeData2(type2, {
        authorized: {
          staker: toBuffer2(authorized3.staker.toBuffer()),
          withdrawer: toBuffer2(authorized3.withdrawer.toBuffer())
        },
        lockup: {
          unixTimestamp: lockup3.unixTimestamp,
          epoch: lockup3.epoch,
          custodian: toBuffer2(lockup3.custodian.toBuffer())
        }
      });
      const instructionData = {
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY2,
          isSigner: false,
          isWritable: false
        }],
        programId: this.programId,
        data
      };
      return new TransactionInstruction2(instructionData);
    }
    static createAccountWithSeed(params) {
      const transaction = new Transaction22;
      transaction.add(SystemProgram2.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      const {
        stakePubkey,
        authorized: authorized3,
        lockup: lockup3
      } = params;
      return transaction.add(this.initialize({
        stakePubkey,
        authorized: authorized3,
        lockup: lockup3
      }));
    }
    static createAccount(params) {
      const transaction = new Transaction22;
      transaction.add(SystemProgram2.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.stakePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      const {
        stakePubkey,
        authorized: authorized3,
        lockup: lockup3
      } = params;
      return transaction.add(this.initialize({
        stakePubkey,
        authorized: authorized3,
        lockup: lockup3
      }));
    }
    static delegate(params) {
      const {
        stakePubkey,
        authorizedPubkey,
        votePubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS2.Delegate;
      const data = encodeData2(type2);
      return new Transaction22().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: votePubkey,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: STAKE_CONFIG_ID2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    static authorize(params) {
      const {
        stakePubkey,
        authorizedPubkey,
        newAuthorizedPubkey,
        stakeAuthorizationType,
        custodianPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS2.Authorize;
      const data = encodeData2(type2, {
        newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
        stakeAuthorizationType: stakeAuthorizationType.index
      });
      const keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new Transaction22().add({
        keys,
        programId: this.programId,
        data
      });
    }
    static authorizeWithSeed(params) {
      const {
        stakePubkey,
        authorityBase,
        authoritySeed,
        authorityOwner,
        newAuthorizedPubkey,
        stakeAuthorizationType,
        custodianPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS2.AuthorizeWithSeed;
      const data = encodeData2(type2, {
        newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
        stakeAuthorizationType: stakeAuthorizationType.index,
        authoritySeed,
        authorityOwner: toBuffer2(authorityOwner.toBuffer())
      });
      const keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorityBase,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new Transaction22().add({
        keys,
        programId: this.programId,
        data
      });
    }
    static splitInstruction(params) {
      const {
        stakePubkey,
        authorizedPubkey,
        splitStakePubkey,
        lamports
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS2.Split;
      const data = encodeData2(type2, {
        lamports
      });
      return new TransactionInstruction2({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: splitStakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    static split(params, rentExemptReserve) {
      const transaction = new Transaction22;
      transaction.add(SystemProgram2.createAccount({
        fromPubkey: params.authorizedPubkey,
        newAccountPubkey: params.splitStakePubkey,
        lamports: rentExemptReserve,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.splitInstruction(params));
    }
    static splitWithSeed(params, rentExemptReserve) {
      const {
        stakePubkey,
        authorizedPubkey,
        splitStakePubkey,
        basePubkey,
        seed,
        lamports
      } = params;
      const transaction = new Transaction22;
      transaction.add(SystemProgram2.allocate({
        accountPubkey: splitStakePubkey,
        basePubkey,
        seed,
        space: this.space,
        programId: this.programId
      }));
      if (rentExemptReserve && rentExemptReserve > 0) {
        transaction.add(SystemProgram2.transfer({
          fromPubkey: params.authorizedPubkey,
          toPubkey: splitStakePubkey,
          lamports: rentExemptReserve
        }));
      }
      return transaction.add(this.splitInstruction({
        stakePubkey,
        authorizedPubkey,
        splitStakePubkey,
        lamports
      }));
    }
    static merge(params) {
      const {
        stakePubkey,
        sourceStakePubKey,
        authorizedPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS2.Merge;
      const data = encodeData2(type2);
      return new Transaction22().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: sourceStakePubKey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
    static withdraw(params) {
      const {
        stakePubkey,
        authorizedPubkey,
        toPubkey,
        lamports,
        custodianPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS2.Withdraw;
      const data = encodeData2(type2, {
        lamports
      });
      const keys = [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      if (custodianPubkey) {
        keys.push({
          pubkey: custodianPubkey,
          isSigner: true,
          isWritable: false
        });
      }
      return new Transaction22().add({
        keys,
        programId: this.programId,
        data
      });
    }
    static deactivate(params) {
      const {
        stakePubkey,
        authorizedPubkey
      } = params;
      const type2 = STAKE_INSTRUCTION_LAYOUTS2.Deactivate;
      const data = encodeData2(type2);
      return new Transaction22().add({
        keys: [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      });
    }
  }
  StakeProgram2.programId = new PublicKey2("Stake11111111111111111111111111111111111111");
  StakeProgram2.space = 200;

  class VoteInit {
    constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
      this.nodePubkey = undefined;
      this.authorizedVoter = undefined;
      this.authorizedWithdrawer = undefined;
      this.commission = undefined;
      this.nodePubkey = nodePubkey;
      this.authorizedVoter = authorizedVoter;
      this.authorizedWithdrawer = authorizedWithdrawer;
      this.commission = commission;
    }
  }

  class VoteInstruction {
    constructor() {}
    static decodeInstructionType(instruction) {
      this.checkProgramId(instruction.programId);
      const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
      const typeIndex = instructionTypeLayout.decode(instruction.data);
      let type2;
      for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS2)) {
        if (layout.index == typeIndex) {
          type2 = ixType;
          break;
        }
      }
      if (!type2) {
        throw new Error("Instruction type incorrect; not a VoteInstruction");
      }
      return type2;
    }
    static decodeInitializeAccount(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 4);
      const {
        voteInit: voteInit3
      } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS2.InitializeAccount, instruction.data);
      return {
        votePubkey: instruction.keys[0].pubkey,
        nodePubkey: instruction.keys[3].pubkey,
        voteInit: new VoteInit(new PublicKey2(voteInit3.nodePubkey), new PublicKey2(voteInit3.authorizedVoter), new PublicKey2(voteInit3.authorizedWithdrawer), voteInit3.commission)
      };
    }
    static decodeAuthorize(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      const {
        newAuthorized,
        voteAuthorizationType
      } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS2.Authorize, instruction.data);
      return {
        votePubkey: instruction.keys[0].pubkey,
        authorizedPubkey: instruction.keys[2].pubkey,
        newAuthorizedPubkey: new PublicKey2(newAuthorized),
        voteAuthorizationType: {
          index: voteAuthorizationType
        }
      };
    }
    static decodeAuthorizeWithSeed(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      const {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey,
          currentAuthorityDerivedKeySeed,
          newAuthorized,
          voteAuthorizationType
        }
      } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS2.AuthorizeWithSeed, instruction.data);
      return {
        currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
        currentAuthorityDerivedKeyOwnerPubkey: new PublicKey2(currentAuthorityDerivedKeyOwnerPubkey),
        currentAuthorityDerivedKeySeed,
        newAuthorizedPubkey: new PublicKey2(newAuthorized),
        voteAuthorizationType: {
          index: voteAuthorizationType
        },
        votePubkey: instruction.keys[0].pubkey
      };
    }
    static decodeWithdraw(instruction) {
      this.checkProgramId(instruction.programId);
      this.checkKeyLength(instruction.keys, 3);
      const {
        lamports
      } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS2.Withdraw, instruction.data);
      return {
        votePubkey: instruction.keys[0].pubkey,
        authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
        lamports,
        toPubkey: instruction.keys[1].pubkey
      };
    }
    static checkProgramId(programId) {
      if (!programId.equals(VoteProgram2.programId)) {
        throw new Error("invalid instruction; programId is not VoteProgram");
      }
    }
    static checkKeyLength(keys, expectedLength) {
      if (keys.length < expectedLength) {
        throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
      }
    }
  }
  var VOTE_INSTRUCTION_LAYOUTS2 = Object.freeze({
    InitializeAccount: {
      index: 0,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), voteInit2()])
    },
    Authorize: {
      index: 1,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey2("newAuthorized"), BufferLayout__namespace.u32("voteAuthorizationType")])
    },
    Withdraw: {
      index: 3,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
    },
    UpdateValidatorIdentity: {
      index: 4,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
    },
    AuthorizeWithSeed: {
      index: 10,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), voteAuthorizeWithSeedArgs2()])
    }
  });
  var VoteAuthorizationLayout2 = Object.freeze({
    Voter: {
      index: 0
    },
    Withdrawer: {
      index: 1
    }
  });

  class VoteProgram2 {
    constructor() {}
    static initializeAccount(params) {
      const {
        votePubkey,
        nodePubkey,
        voteInit: voteInit3
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS2.InitializeAccount;
      const data = encodeData2(type2, {
        voteInit: {
          nodePubkey: toBuffer2(voteInit3.nodePubkey.toBuffer()),
          authorizedVoter: toBuffer2(voteInit3.authorizedVoter.toBuffer()),
          authorizedWithdrawer: toBuffer2(voteInit3.authorizedWithdrawer.toBuffer()),
          commission: voteInit3.commission
        }
      });
      const instructionData = {
        keys: [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY2,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: nodePubkey,
          isSigner: true,
          isWritable: false
        }],
        programId: this.programId,
        data
      };
      return new TransactionInstruction2(instructionData);
    }
    static createAccount(params) {
      const transaction = new Transaction22;
      transaction.add(SystemProgram2.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.votePubkey,
        lamports: params.lamports,
        space: this.space,
        programId: this.programId
      }));
      return transaction.add(this.initializeAccount({
        votePubkey: params.votePubkey,
        nodePubkey: params.voteInit.nodePubkey,
        voteInit: params.voteInit
      }));
    }
    static authorize(params) {
      const {
        votePubkey,
        authorizedPubkey,
        newAuthorizedPubkey,
        voteAuthorizationType
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS2.Authorize;
      const data = encodeData2(type2, {
        newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      });
      const keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction22().add({
        keys,
        programId: this.programId,
        data
      });
    }
    static authorizeWithSeed(params) {
      const {
        currentAuthorityDerivedKeyBasePubkey,
        currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed,
        newAuthorizedPubkey,
        voteAuthorizationType,
        votePubkey
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS2.AuthorizeWithSeed;
      const data = encodeData2(type2, {
        voteAuthorizeWithSeedArgs: {
          currentAuthorityDerivedKeyOwnerPubkey: toBuffer2(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
          currentAuthorityDerivedKeySeed,
          newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
          voteAuthorizationType: voteAuthorizationType.index
        }
      });
      const keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: currentAuthorityDerivedKeyBasePubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction22().add({
        keys,
        programId: this.programId,
        data
      });
    }
    static withdraw(params) {
      const {
        votePubkey,
        authorizedWithdrawerPubkey,
        lamports,
        toPubkey
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS2.Withdraw;
      const data = encodeData2(type2, {
        lamports
      });
      const keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedWithdrawerPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction22().add({
        keys,
        programId: this.programId,
        data
      });
    }
    static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
      if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
        throw new Error("Withdraw will leave vote account with insufficient funds.");
      }
      return VoteProgram2.withdraw(params);
    }
    static updateValidatorIdentity(params) {
      const {
        votePubkey,
        authorizedWithdrawerPubkey,
        nodePubkey
      } = params;
      const type2 = VOTE_INSTRUCTION_LAYOUTS2.UpdateValidatorIdentity;
      const data = encodeData2(type2);
      const keys = [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: authorizedWithdrawerPubkey,
        isSigner: true,
        isWritable: false
      }];
      return new Transaction22().add({
        keys,
        programId: this.programId,
        data
      });
    }
  }
  VoteProgram2.programId = new PublicKey2("Vote111111111111111111111111111111111111111");
  VoteProgram2.space = 3762;
  var VALIDATOR_INFO_KEY2 = new PublicKey2("Va1idator1nfo111111111111111111111111111111");
  var InfoString2 = superstruct.type({
    name: superstruct.string(),
    website: superstruct.optional(superstruct.string()),
    details: superstruct.optional(superstruct.string()),
    iconUrl: superstruct.optional(superstruct.string()),
    keybaseUsername: superstruct.optional(superstruct.string())
  });

  class ValidatorInfo {
    constructor(key, info) {
      this.key = undefined;
      this.info = undefined;
      this.key = key;
      this.info = info;
    }
    static fromConfigData(buffer$1) {
      let byteArray = [...buffer$1];
      const configKeyCount = decodeLength2(byteArray);
      if (configKeyCount !== 2)
        return null;
      const configKeys = [];
      for (let i22 = 0;i22 < 2; i22++) {
        const publicKey3 = new PublicKey2(guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2));
        const isSigner = guardedShift2(byteArray) === 1;
        configKeys.push({
          publicKey: publicKey3,
          isSigner
        });
      }
      if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY2)) {
        if (configKeys[1].isSigner) {
          const rawInfo = rustString2().decode(buffer.Buffer.from(byteArray));
          const info = JSON.parse(rawInfo);
          superstruct.assert(info, InfoString2);
          return new ValidatorInfo(configKeys[1].publicKey, info);
        }
      }
      return null;
    }
  }
  var VOTE_PROGRAM_ID2 = new PublicKey2("Vote111111111111111111111111111111111111111");
  var VoteAccountLayout2 = BufferLayout__namespace.struct([
    publicKey2("nodePubkey"),
    publicKey2("authorizedWithdrawer"),
    BufferLayout__namespace.u8("commission"),
    BufferLayout__namespace.nu64(),
    BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("slot"), BufferLayout__namespace.u32("confirmationCount")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "votes"),
    BufferLayout__namespace.u8("rootSlotValid"),
    BufferLayout__namespace.nu64("rootSlot"),
    BufferLayout__namespace.nu64(),
    BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("epoch"), publicKey2("authorizedVoter")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "authorizedVoters"),
    BufferLayout__namespace.struct([BufferLayout__namespace.seq(BufferLayout__namespace.struct([publicKey2("authorizedPubkey"), BufferLayout__namespace.nu64("epochOfLastAuthorizedSwitch"), BufferLayout__namespace.nu64("targetEpoch")]), 32, "buf"), BufferLayout__namespace.nu64("idx"), BufferLayout__namespace.u8("isEmpty")], "priorVoters"),
    BufferLayout__namespace.nu64(),
    BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("epoch"), BufferLayout__namespace.nu64("credits"), BufferLayout__namespace.nu64("prevCredits")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "epochCredits"),
    BufferLayout__namespace.struct([BufferLayout__namespace.nu64("slot"), BufferLayout__namespace.nu64("timestamp")], "lastTimestamp")
  ]);

  class VoteAccount {
    constructor(args) {
      this.nodePubkey = undefined;
      this.authorizedWithdrawer = undefined;
      this.commission = undefined;
      this.rootSlot = undefined;
      this.votes = undefined;
      this.authorizedVoters = undefined;
      this.priorVoters = undefined;
      this.epochCredits = undefined;
      this.lastTimestamp = undefined;
      this.nodePubkey = args.nodePubkey;
      this.authorizedWithdrawer = args.authorizedWithdrawer;
      this.commission = args.commission;
      this.rootSlot = args.rootSlot;
      this.votes = args.votes;
      this.authorizedVoters = args.authorizedVoters;
      this.priorVoters = args.priorVoters;
      this.epochCredits = args.epochCredits;
      this.lastTimestamp = args.lastTimestamp;
    }
    static fromAccountData(buffer2) {
      const versionOffset = 4;
      const va = VoteAccountLayout2.decode(toBuffer2(buffer2), versionOffset);
      let rootSlot = va.rootSlot;
      if (!va.rootSlotValid) {
        rootSlot = null;
      }
      return new VoteAccount({
        nodePubkey: new PublicKey2(va.nodePubkey),
        authorizedWithdrawer: new PublicKey2(va.authorizedWithdrawer),
        commission: va.commission,
        votes: va.votes,
        rootSlot,
        authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
        priorVoters: getPriorVoters(va.priorVoters),
        epochCredits: va.epochCredits,
        lastTimestamp: va.lastTimestamp
      });
    }
  }
  function parseAuthorizedVoter({
    authorizedVoter,
    epoch
  }) {
    return {
      epoch,
      authorizedVoter: new PublicKey2(authorizedVoter)
    };
  }
  function parsePriorVoters({
    authorizedPubkey,
    epochOfLastAuthorizedSwitch,
    targetEpoch
  }) {
    return {
      authorizedPubkey: new PublicKey2(authorizedPubkey),
      epochOfLastAuthorizedSwitch,
      targetEpoch
    };
  }
  function getPriorVoters({
    buf,
    idx,
    isEmpty
  }) {
    if (isEmpty) {
      return [];
    }
    return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
  }
  var endpoint = {
    http: {
      devnet: "http://api.devnet.solana.com",
      testnet: "http://api.testnet.solana.com",
      "mainnet-beta": "http://api.mainnet-beta.solana.com/"
    },
    https: {
      devnet: "https://api.devnet.solana.com",
      testnet: "https://api.testnet.solana.com",
      "mainnet-beta": "https://api.mainnet-beta.solana.com/"
    }
  };
  function clusterApiUrl(cluster, tls) {
    const key = tls === false ? "http" : "https";
    if (!cluster) {
      return endpoint[key]["devnet"];
    }
    const url = endpoint[key][cluster];
    if (!url) {
      throw new Error(`Unknown ${key} cluster: ${cluster}`);
    }
    return url;
  }
  async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
    let confirmationStrategy;
    let options;
    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
      confirmationStrategy = confirmationStrategyOrConfirmOptions;
      options = maybeConfirmOptions;
    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
      confirmationStrategy = confirmationStrategyOrConfirmOptions;
      options = maybeConfirmOptions;
    } else {
      options = confirmationStrategyOrConfirmOptions;
    }
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment,
      minContextSlot: options.minContextSlot
    };
    const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
    const commitment = options && options.commitment;
    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature2, commitment);
    const status = (await confirmationPromise).value;
    if (status.err) {
      if (signature2 != null) {
        throw new SendTransactionError2({
          action: sendOptions?.skipPreflight ? "send" : "simulate",
          signature: signature2,
          transactionMessage: `Status: (${JSON.stringify(status)})`
        });
      }
      throw new Error(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
    }
    return signature2;
  }
  var LAMPORTS_PER_SOL = 1e9;
  exports.Account = Account;
  exports.AddressLookupTableAccount = AddressLookupTableAccount;
  exports.AddressLookupTableInstruction = AddressLookupTableInstruction;
  exports.AddressLookupTableProgram = AddressLookupTableProgram2;
  exports.Authorized = Authorized;
  exports.BLOCKHASH_CACHE_TIMEOUT_MS = BLOCKHASH_CACHE_TIMEOUT_MS2;
  exports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID2;
  exports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID2;
  exports.BpfLoader = BpfLoader;
  exports.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2;
  exports.ComputeBudgetInstruction = ComputeBudgetInstruction;
  exports.ComputeBudgetProgram = ComputeBudgetProgram2;
  exports.Connection = Connection;
  exports.Ed25519Program = Ed25519Program2;
  exports.Enum = Enum;
  exports.EpochSchedule = EpochSchedule;
  exports.FeeCalculatorLayout = FeeCalculatorLayout2;
  exports.Keypair = Keypair2;
  exports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;
  exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2;
  exports.Loader = Loader2;
  exports.Lockup = Lockup2;
  exports.MAX_SEED_LENGTH = MAX_SEED_LENGTH2;
  exports.Message = Message2;
  exports.MessageAccountKeys = MessageAccountKeys2;
  exports.MessageV0 = MessageV0;
  exports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH2;
  exports.NonceAccount = NonceAccount;
  exports.PACKET_DATA_SIZE = PACKET_DATA_SIZE2;
  exports.PUBLIC_KEY_LENGTH = PUBLIC_KEY_LENGTH2;
  exports.PublicKey = PublicKey2;
  exports.SIGNATURE_LENGTH_IN_BYTES = SIGNATURE_LENGTH_IN_BYTES2;
  exports.SOLANA_SCHEMA = SOLANA_SCHEMA2;
  exports.STAKE_CONFIG_ID = STAKE_CONFIG_ID2;
  exports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS2;
  exports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS2;
  exports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY2;
  exports.SYSVAR_EPOCH_SCHEDULE_PUBKEY = SYSVAR_EPOCH_SCHEDULE_PUBKEY2;
  exports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY2;
  exports.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = SYSVAR_RECENT_BLOCKHASHES_PUBKEY2;
  exports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY2;
  exports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY2;
  exports.SYSVAR_SLOT_HASHES_PUBKEY = SYSVAR_SLOT_HASHES_PUBKEY2;
  exports.SYSVAR_SLOT_HISTORY_PUBKEY = SYSVAR_SLOT_HISTORY_PUBKEY2;
  exports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY2;
  exports.Secp256k1Program = Secp256k1Program2;
  exports.SendTransactionError = SendTransactionError2;
  exports.SolanaJSONRPCError = SolanaJSONRPCError;
  exports.SolanaJSONRPCErrorCode = SolanaJSONRPCErrorCode;
  exports.StakeAuthorizationLayout = StakeAuthorizationLayout2;
  exports.StakeInstruction = StakeInstruction;
  exports.StakeProgram = StakeProgram2;
  exports.Struct = Struct3;
  exports.SystemInstruction = SystemInstruction;
  exports.SystemProgram = SystemProgram2;
  exports.Transaction = Transaction22;
  exports.TransactionExpiredBlockheightExceededError = TransactionExpiredBlockheightExceededError2;
  exports.TransactionExpiredNonceInvalidError = TransactionExpiredNonceInvalidError2;
  exports.TransactionExpiredTimeoutError = TransactionExpiredTimeoutError2;
  exports.TransactionInstruction = TransactionInstruction2;
  exports.TransactionMessage = TransactionMessage;
  exports.TransactionStatus = TransactionStatus;
  exports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY2;
  exports.VERSION_PREFIX_MASK = VERSION_PREFIX_MASK2;
  exports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID2;
  exports.ValidatorInfo = ValidatorInfo;
  exports.VersionedMessage = VersionedMessage;
  exports.VersionedTransaction = VersionedTransaction;
  exports.VoteAccount = VoteAccount;
  exports.VoteAuthorizationLayout = VoteAuthorizationLayout2;
  exports.VoteInit = VoteInit;
  exports.VoteInstruction = VoteInstruction;
  exports.VoteProgram = VoteProgram2;
  exports.clusterApiUrl = clusterApiUrl;
  exports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction;
  exports.sendAndConfirmTransaction = sendAndConfirmTransaction2;
});
var require_dist2 = __commonJS2((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod22) {
    return mod22 && mod22.__esModule ? mod22 : { default: mod22 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = undefined;
  exports.u64 = u6422;
  exports.i64 = i64;
  exports.u128 = u128;
  exports.i128 = i128;
  exports.u256 = u256;
  exports.i256 = i256;
  exports.publicKey = publicKey2;
  exports.option = option;
  exports.bool = bool;
  exports.vec = vec;
  exports.tagged = tagged;
  exports.vecU8 = vecU8;
  exports.str = str;
  exports.rustEnum = rustEnum;
  exports.array = array2;
  exports.map = map;
  var buffer_layout_1 = require_Layout22();
  var web3_js_1 = require_index_browser_cjs();
  var bn_js_1 = __importDefault(require_bn2());
  var buffer_layout_2 = require_Layout22();
  Object.defineProperty(exports, "u8", { enumerable: true, get: function() {
    return buffer_layout_2.u8;
  } });
  Object.defineProperty(exports, "i8", { enumerable: true, get: function() {
    return buffer_layout_2.s8;
  } });
  Object.defineProperty(exports, "u16", { enumerable: true, get: function() {
    return buffer_layout_2.u16;
  } });
  Object.defineProperty(exports, "i16", { enumerable: true, get: function() {
    return buffer_layout_2.s16;
  } });
  Object.defineProperty(exports, "u32", { enumerable: true, get: function() {
    return buffer_layout_2.u32;
  } });
  Object.defineProperty(exports, "i32", { enumerable: true, get: function() {
    return buffer_layout_2.s32;
  } });
  Object.defineProperty(exports, "f32", { enumerable: true, get: function() {
    return buffer_layout_2.f32;
  } });
  Object.defineProperty(exports, "f64", { enumerable: true, get: function() {
    return buffer_layout_2.f64;
  } });
  Object.defineProperty(exports, "struct", { enumerable: true, get: function() {
    return buffer_layout_2.struct;
  } });

  class BNLayout extends buffer_layout_1.Layout {
    constructor(span, signed2, property) {
      super(span, property);
      this.blob = (0, buffer_layout_1.blob)(span);
      this.signed = signed2;
    }
    decode(b22, offset2 = 0) {
      const num = new bn_js_1.default(this.blob.decode(b22, offset2), 10, "le");
      if (this.signed) {
        return num.fromTwos(this.span * 8).clone();
      }
      return num;
    }
    encode(src, b22, offset2 = 0) {
      if (this.signed) {
        src = src.toTwos(this.span * 8);
      }
      return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b22, offset2);
    }
  }
  function u6422(property) {
    return new BNLayout(8, false, property);
  }
  function i64(property) {
    return new BNLayout(8, true, property);
  }
  function u128(property) {
    return new BNLayout(16, false, property);
  }
  function i128(property) {
    return new BNLayout(16, true, property);
  }
  function u256(property) {
    return new BNLayout(32, false, property);
  }
  function i256(property) {
    return new BNLayout(32, true, property);
  }

  class WrappedLayout extends buffer_layout_1.Layout {
    constructor(layout, decoder, encoder, property) {
      super(layout.span, property);
      this.layout = layout;
      this.decoder = decoder;
      this.encoder = encoder;
    }
    decode(b22, offset2) {
      return this.decoder(this.layout.decode(b22, offset2));
    }
    encode(src, b22, offset2) {
      return this.layout.encode(this.encoder(src), b22, offset2);
    }
    getSpan(b22, offset2) {
      return this.layout.getSpan(b22, offset2);
    }
  }
  function publicKey2(property) {
    return new WrappedLayout((0, buffer_layout_1.blob)(32), (b22) => new web3_js_1.PublicKey(b22), (key) => key.toBuffer(), property);
  }

  class OptionLayout extends buffer_layout_1.Layout {
    constructor(layout, property) {
      super(-1, property);
      this.layout = layout;
      this.discriminator = (0, buffer_layout_1.u8)();
    }
    encode(src, b22, offset2 = 0) {
      if (src === null || src === undefined) {
        return this.discriminator.encode(0, b22, offset2);
      }
      this.discriminator.encode(1, b22, offset2);
      return this.layout.encode(src, b22, offset2 + 1) + 1;
    }
    decode(b22, offset2 = 0) {
      const discriminator = this.discriminator.decode(b22, offset2);
      if (discriminator === 0) {
        return null;
      } else if (discriminator === 1) {
        return this.layout.decode(b22, offset2 + 1);
      }
      throw new Error("Invalid option " + this.property);
    }
    getSpan(b22, offset2 = 0) {
      const discriminator = this.discriminator.decode(b22, offset2);
      if (discriminator === 0) {
        return 1;
      } else if (discriminator === 1) {
        return this.layout.getSpan(b22, offset2 + 1) + 1;
      }
      throw new Error("Invalid option " + this.property);
    }
  }
  function option(layout, property) {
    return new OptionLayout(layout, property);
  }
  function bool(property) {
    return new WrappedLayout((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);
  }
  function decodeBool(value) {
    if (value === 0) {
      return false;
    } else if (value === 1) {
      return true;
    }
    throw new Error("Invalid bool: " + value);
  }
  function encodeBool(value) {
    return value ? 1 : 0;
  }
  function vec(elementLayout, property) {
    const length = (0, buffer_layout_1.u32)("length");
    const layout = (0, buffer_layout_1.struct)([
      length,
      (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), "values")
    ]);
    return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);
  }
  function tagged(tag2, layout, property) {
    const wrappedLayout = (0, buffer_layout_1.struct)([
      u6422("tag"),
      layout.replicate("data")
    ]);
    function decodeTag({ tag: receivedTag, data }) {
      if (!receivedTag.eq(tag2)) {
        throw new Error("Invalid tag, expected: " + tag2.toString("hex") + ", got: " + receivedTag.toString("hex"));
      }
      return data;
    }
    return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag: tag2, data }), property);
  }
  function vecU8(property) {
    const length = (0, buffer_layout_1.u32)("length");
    const layout = (0, buffer_layout_1.struct)([
      length,
      (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), "data")
    ]);
    return new WrappedLayout(layout, ({ data }) => data, (data) => ({ data }), property);
  }
  function str(property) {
    return new WrappedLayout(vecU8(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
  }
  function rustEnum(variants, property, discriminant) {
    const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== undefined ? discriminant : (0, buffer_layout_1.u8)(), property);
    variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
    return unionLayout;
  }
  function array2(elementLayout, length, property) {
    const layout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.seq)(elementLayout, length, "values")
    ]);
    return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);
  }

  class MapEntryLayout extends buffer_layout_1.Layout {
    constructor(keyLayout, valueLayout, property) {
      super(keyLayout.span + valueLayout.span, property);
      this.keyLayout = keyLayout;
      this.valueLayout = valueLayout;
    }
    decode(b22, offset2) {
      offset2 = offset2 || 0;
      const key = this.keyLayout.decode(b22, offset2);
      const value = this.valueLayout.decode(b22, offset2 + this.keyLayout.getSpan(b22, offset2));
      return [key, value];
    }
    encode(src, b22, offset2) {
      offset2 = offset2 || 0;
      const keyBytes = this.keyLayout.encode(src[0], b22, offset2);
      const valueBytes = this.valueLayout.encode(src[1], b22, offset2 + keyBytes);
      return keyBytes + valueBytes;
    }
    getSpan(b22, offset2) {
      return this.keyLayout.getSpan(b22, offset2) + this.valueLayout.getSpan(b22, offset2);
    }
  }
  function map(keyLayout, valueLayout, property) {
    const length = (0, buffer_layout_1.u32)("length");
    const layout = (0, buffer_layout_1.struct)([
      length,
      (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), "values")
    ]);
    return new WrappedLayout(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
  }
});
var require_eventemitter322 = __commonJS2((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter22() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  EventEmitter22.prototype.eventNames = function eventNames() {
    var names2 = [], events, name;
    if (this._eventsCount === 0)
      return names2;
    for (name in events = this._events) {
      if (has.call(events, name))
        names2.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events));
    }
    return names2;
  };
  EventEmitter22.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i22 = 0, l = handlers.length, ee = new Array(l);i22 < l; i22++) {
      ee[i22] = handlers[i22].fn;
    }
    return ee;
  };
  EventEmitter22.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter22.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len2 = arguments.length, args, i22;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len2) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i22 = 1, args = new Array(len2 - 1);i22 < len2; i22++) {
        args[i22 - 1] = arguments[i22];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i22 = 0;i22 < length; i22++) {
        if (listeners[i22].once)
          this.removeListener(event, listeners[i22].fn, undefined, true);
        switch (len2) {
          case 1:
            listeners[i22].fn.call(listeners[i22].context);
            break;
          case 2:
            listeners[i22].fn.call(listeners[i22].context, a1);
            break;
          case 3:
            listeners[i22].fn.call(listeners[i22].context, a1, a2);
            break;
          case 4:
            listeners[i22].fn.call(listeners[i22].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len2 - 1);j < len2; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i22].fn.apply(listeners[i22].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter22.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter22.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter22.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i22 = 0, events = [], length = listeners.length;i22 < length; i22++) {
        if (listeners[i22].fn !== fn || once && !listeners[i22].once || context && listeners[i22].context !== context) {
          events.push(listeners[i22]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter22.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter22.prototype.off = EventEmitter22.prototype.removeListener;
  EventEmitter22.prototype.addListener = EventEmitter22.prototype.on;
  EventEmitter22.prefixed = prefix;
  EventEmitter22.EventEmitter = EventEmitter22;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter22;
  }
});
var require_browser22 = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var converter;
  function toBigIntLE(buf) {
    {
      const reversed = Buffer.from(buf);
      reversed.reverse();
      const hex = reversed.toString("hex");
      if (hex.length === 0) {
        return BigInt(0);
      }
      return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, false);
  }
  exports.toBigIntLE = toBigIntLE;
  function toBigIntBE(buf) {
    {
      const hex = buf.toString("hex");
      if (hex.length === 0) {
        return BigInt(0);
      }
      return BigInt(`0x${hex}`);
    }
    return converter.toBigInt(buf, true);
  }
  exports.toBigIntBE = toBigIntBE;
  function toBufferLE(num, width) {
    {
      const hex = num.toString(16);
      const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
      buffer.reverse();
      return buffer;
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
  }
  exports.toBufferLE = toBufferLE;
  function toBufferBE(num, width) {
    {
      const hex = num.toString(16);
      return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
    }
    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
  }
  exports.toBufferBE = toBufferBE;
});
init_buffer2();
var crypto22 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber2(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes2(b22, ...lengths) {
  if (!isBytes2(b22))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b22.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b22.length);
}
function ahash2(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber2(h.outputLen);
  anumber2(h.blockLen);
}
function aexists2(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance2) {
  abytes2(out);
  const min2 = instance2.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function u324(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean2(...arrays) {
  for (let i4 = 0;i4 < arrays.length; i4++) {
    arrays[i4].fill(0);
  }
}
function createView3(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr3(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE3 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap2(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap322(arr) {
  for (let i4 = 0;i4 < arr.length; i4++) {
    arr[i4] = byteSwap2(arr[i4]);
  }
  return arr;
}
var swap32IfBE2 = isLE3 ? (u) => u : byteSwap322;
var hasHexBuiltin2 = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i4) => i4.toString(16).padStart(2, "0"));
function bytesToHex3(bytes2) {
  abytes2(bytes2);
  if (hasHexBuiltin2)
    return bytes2.toHex();
  let hex = "";
  for (let i4 = 0;i4 < bytes2.length; i4++) {
    hex += hexes3[bytes2[i4]];
  }
  return hex;
}
var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase162(ch) {
  if (ch >= asciis2._0 && ch <= asciis2._9)
    return ch - asciis2._0;
  if (ch >= asciis2.A && ch <= asciis2.F)
    return ch - (asciis2.A - 10);
  if (ch >= asciis2.a && ch <= asciis2.f)
    return ch - (asciis2.a - 10);
  return;
}
function hexToBytes3(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin2)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array2 = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex.charCodeAt(hi));
    const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array2[ai] = n1 * 16 + n2;
  }
  return array2;
}
function utf8ToBytes5(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes5(data);
  abytes2(data);
  return data;
}
function concatBytes4(...arrays) {
  let sum2 = 0;
  for (let i4 = 0;i4 < arrays.length; i4++) {
    const a = arrays[i4];
    abytes2(a);
    sum2 += a.length;
  }
  const res = new Uint8Array(sum2);
  for (let i4 = 0, pad = 0;i4 < arrays.length; i4++) {
    const a = arrays[i4];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}

class Hash3 {
}
function createHasher2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes5(bytesLength = 32) {
  if (crypto22 && typeof crypto22.getRandomValues === "function") {
    return crypto22.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto22 && typeof crypto22.randomBytes === "function") {
    return Uint8Array.from(crypto22.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint643(view, byteOffset, value, isLE22) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE22);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE22 ? 4 : 0;
  const l = isLE22 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE22);
  view.setUint32(byteOffset + l, wl, isLE22);
}
function Chi3(a, b22, c) {
  return a & b22 ^ ~a & c;
}
function Maj3(a, b22, c) {
  return a & b22 ^ a & c ^ b22 & c;
}

class HashMD2 extends Hash3 {
  constructor(blockLen, outputLen, padOffset, isLE22) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE22;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView3(this.buffer);
  }
  update(data) {
    aexists2(this);
    data = toBytes3(data);
    abytes2(data);
    const { view, buffer, blockLen } = this;
    const len2 = data.length;
    for (let pos = 0;pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      if (take === blockLen) {
        const dataView = createView3(data);
        for (;blockLen <= len2 - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE22 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean2(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i4 = pos;i4 < blockLen; i4++)
      buffer[i4] = 0;
    setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE22);
    this.process(view, 0);
    const oview = createView3(out);
    const len2 = this.outputLen;
    if (len2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len2 / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i4 = 0;i4 < outLen; i4++)
      oview.setUint32(4 * i4, state[i4], isLE22);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished: finished3, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished3;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
var SHA256_IV2 = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA512_IV2 = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);
var U32_MASK643 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n3 = /* @__PURE__ */ BigInt(32);
function fromBig3(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK643), l: Number(n2 >> _32n3 & U32_MASK643) };
  return { h: Number(n2 >> _32n3 & U32_MASK643) | 0, l: Number(n2 & U32_MASK643) | 0 };
}
function split4(lst, le = false) {
  const len2 = lst.length;
  let Ah = new Uint32Array(len2);
  let Al = new Uint32Array(len2);
  for (let i4 = 0;i4 < len2; i4++) {
    const { h, l } = fromBig3(lst[i4], le);
    [Ah[i4], Al[i4]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH3 = (h, _l, s) => h >>> s;
var shrSL3 = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH3 = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL3 = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH3 = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL3 = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotlSH3 = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL3 = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH3 = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL3 = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add4(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L3 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H3 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L3 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H3 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L3 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H3 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var SHA256_K3 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W3 = /* @__PURE__ */ new Uint32Array(64);

class SHA2563 extends HashMD2 {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV2[0] | 0;
    this.B = SHA256_IV2[1] | 0;
    this.C = SHA256_IV2[2] | 0;
    this.D = SHA256_IV2[3] | 0;
    this.E = SHA256_IV2[4] | 0;
    this.F = SHA256_IV2[5] | 0;
    this.G = SHA256_IV2[6] | 0;
    this.H = SHA256_IV2[7] | 0;
  }
  get() {
    const { A, B, C, D: D2, E: E2, F, G, H } = this;
    return [A, B, C, D2, E2, F, G, H];
  }
  set(A, B, C, D2, E2, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset2) {
    for (let i4 = 0;i4 < 16; i4++, offset2 += 4)
      SHA256_W3[i4] = view.getUint32(offset2, false);
    for (let i4 = 16;i4 < 64; i4++) {
      const W15 = SHA256_W3[i4 - 15];
      const W2 = SHA256_W3[i4 - 2];
      const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
      const s1 = rotr3(W2, 17) ^ rotr3(W2, 19) ^ W2 >>> 10;
      SHA256_W3[i4] = s1 + SHA256_W3[i4 - 7] + s0 + SHA256_W3[i4 - 16] | 0;
    }
    let { A, B, C, D: D2, E: E2, F, G, H } = this;
    for (let i4 = 0;i4 < 64; i4++) {
      const sigma1 = rotr3(E2, 6) ^ rotr3(E2, 11) ^ rotr3(E2, 25);
      const T13 = H + sigma1 + Chi3(E2, F, G) + SHA256_K3[i4] + SHA256_W3[i4] | 0;
      const sigma0 = rotr3(A, 2) ^ rotr3(A, 13) ^ rotr3(A, 22);
      const T22 = sigma0 + Maj3(A, B, C) | 0;
      H = G;
      G = F;
      F = E2;
      E2 = D2 + T13 | 0;
      D2 = C;
      C = B;
      B = A;
      A = T13 + T22 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D2, E2, F, G, H);
  }
  roundClean() {
    clean2(SHA256_W3);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean2(this.buffer);
  }
}
var K5122 = /* @__PURE__ */ (() => split4([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh3 = /* @__PURE__ */ (() => K5122[0])();
var SHA512_Kl3 = /* @__PURE__ */ (() => K5122[1])();
var SHA512_W_H3 = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L3 = /* @__PURE__ */ new Uint32Array(80);

class SHA5123 extends HashMD2 {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV2[0] | 0;
    this.Al = SHA512_IV2[1] | 0;
    this.Bh = SHA512_IV2[2] | 0;
    this.Bl = SHA512_IV2[3] | 0;
    this.Ch = SHA512_IV2[4] | 0;
    this.Cl = SHA512_IV2[5] | 0;
    this.Dh = SHA512_IV2[6] | 0;
    this.Dl = SHA512_IV2[7] | 0;
    this.Eh = SHA512_IV2[8] | 0;
    this.El = SHA512_IV2[9] | 0;
    this.Fh = SHA512_IV2[10] | 0;
    this.Fl = SHA512_IV2[11] | 0;
    this.Gh = SHA512_IV2[12] | 0;
    this.Gl = SHA512_IV2[13] | 0;
    this.Hh = SHA512_IV2[14] | 0;
    this.Hl = SHA512_IV2[15] | 0;
  }
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset2) {
    for (let i4 = 0;i4 < 16; i4++, offset2 += 4) {
      SHA512_W_H3[i4] = view.getUint32(offset2);
      SHA512_W_L3[i4] = view.getUint32(offset2 += 4);
    }
    for (let i4 = 16;i4 < 80; i4++) {
      const W15h = SHA512_W_H3[i4 - 15] | 0;
      const W15l = SHA512_W_L3[i4 - 15] | 0;
      const s0h = rotrSH3(W15h, W15l, 1) ^ rotrSH3(W15h, W15l, 8) ^ shrSH3(W15h, W15l, 7);
      const s0l = rotrSL3(W15h, W15l, 1) ^ rotrSL3(W15h, W15l, 8) ^ shrSL3(W15h, W15l, 7);
      const W2h = SHA512_W_H3[i4 - 2] | 0;
      const W2l = SHA512_W_L3[i4 - 2] | 0;
      const s1h = rotrSH3(W2h, W2l, 19) ^ rotrBH3(W2h, W2l, 61) ^ shrSH3(W2h, W2l, 6);
      const s1l = rotrSL3(W2h, W2l, 19) ^ rotrBL3(W2h, W2l, 61) ^ shrSL3(W2h, W2l, 6);
      const SUMl = add4L3(s0l, s1l, SHA512_W_L3[i4 - 7], SHA512_W_L3[i4 - 16]);
      const SUMh = add4H3(SUMl, s0h, s1h, SHA512_W_H3[i4 - 7], SHA512_W_H3[i4 - 16]);
      SHA512_W_H3[i4] = SUMh | 0;
      SHA512_W_L3[i4] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i4 = 0;i4 < 80; i4++) {
      const sigma1h = rotrSH3(Eh, El, 14) ^ rotrSH3(Eh, El, 18) ^ rotrBH3(Eh, El, 41);
      const sigma1l = rotrSL3(Eh, El, 14) ^ rotrSL3(Eh, El, 18) ^ rotrBL3(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L3(Hl, sigma1l, CHIl, SHA512_Kl3[i4], SHA512_W_L3[i4]);
      const T1h = add5H3(T1ll, Hh, sigma1h, CHIh, SHA512_Kh3[i4], SHA512_W_H3[i4]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH3(Ah, Al, 28) ^ rotrBH3(Ah, Al, 34) ^ rotrBH3(Ah, Al, 39);
      const sigma0l = rotrSL3(Ah, Al, 28) ^ rotrBL3(Ah, Al, 34) ^ rotrBL3(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add4(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L3(T1l, sigma0l, MAJl);
      Ah = add3H3(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add4(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add4(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add4(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add4(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add4(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add4(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add4(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add4(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean2(SHA512_W_H3, SHA512_W_L3);
  }
  destroy() {
    clean2(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
var sha2565 = /* @__PURE__ */ createHasher2(() => new SHA2563);
var sha5124 = /* @__PURE__ */ createHasher2(() => new SHA5123);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n15 = /* @__PURE__ */ BigInt(0);
var _1n15 = /* @__PURE__ */ BigInt(1);
function abool2(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded3(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber3(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n15 : BigInt("0x" + hex);
}
function bytesToNumberBE3(bytes2) {
  return hexToNumber3(bytesToHex3(bytes2));
}
function bytesToNumberLE3(bytes2) {
  abytes2(bytes2);
  return hexToNumber3(bytesToHex3(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE3(n2, len2) {
  return hexToBytes3(n2.toString(16).padStart(len2 * 2, "0"));
}
function numberToBytesLE3(n2, len2) {
  return numberToBytesBE3(n2, len2).reverse();
}
function ensureBytes3(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes3(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len2 = res.length;
  if (typeof expectedLength === "number" && len2 !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len2);
  return res;
}
var isPosBig2 = (n2) => typeof n2 === "bigint" && _0n15 <= n2;
function inRange3(n2, min2, max2) {
  return isPosBig2(n2) && isPosBig2(min2) && isPosBig2(max2) && min2 <= n2 && n2 < max2;
}
function aInRange2(title, n2, min2, max2) {
  if (!inRange3(n2, min2, max2))
    throw new Error("expected valid " + title + ": " + min2 + " <= n < " + max2 + ", got " + n2);
}
function bitLen3(n2) {
  let len2;
  for (len2 = 0;n2 > _0n15; n2 >>= _1n15, len2 += 1)
    ;
  return len2;
}
var bitMask3 = (n2) => (_1n15 << BigInt(n2)) - _1n15;
function createHmacDrbg3(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n2 = (len2) => new Uint8Array(len2);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i4 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i4 = 0;
  };
  const h = (...b22) => hmacFn(k, v, ...b22);
  const reseed = (seed = u8n2(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen3 = () => {
    if (i4++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len2 = 0;
    const out = [];
    while (len2 < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len2 += v.length;
    }
    return concatBytes4(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen3())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function _validateObject2(object2, fields2, optFields = {}) {
  if (!object2 || typeof object2 !== "object")
    throw new Error("expected valid options object");
  function checkField2(fieldName, expectedType, isOpt) {
    const val = object2[fieldName];
    if (isOpt && val === undefined)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields2).forEach(([k, v]) => checkField2(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField2(k, v, true));
}
function memoized2(fn) {
  const map = new WeakMap;
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== undefined)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n22 = BigInt(0);
var _1n22 = BigInt(1);
var _2n12 = /* @__PURE__ */ BigInt(2);
var _3n6 = /* @__PURE__ */ BigInt(3);
var _4n5 = /* @__PURE__ */ BigInt(4);
var _5n4 = /* @__PURE__ */ BigInt(5);
var _8n5 = /* @__PURE__ */ BigInt(8);
function mod4(a, b22) {
  const result = a % b22;
  return result >= _0n22 ? result : b22 + result;
}
function pow24(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n22) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert3(number3, modulo) {
  if (number3 === _0n22)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n22)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod4(number3, modulo);
  let b22 = modulo;
  let x2 = _0n22, y = _1n22, u = _1n22, v = _0n22;
  while (a !== _0n22) {
    const q = b22 / a;
    const r = b22 % a;
    const m = x2 - u * q;
    const n2 = y - v * q;
    b22 = a, a = r, x2 = u, y = v, u = m, v = n2;
  }
  const gcd = b22;
  if (gcd !== _1n22)
    throw new Error("invert: does not exist");
  return mod4(x2, modulo);
}
function sqrt3mod42(Fp3, n2) {
  const p1div4 = (Fp3.ORDER + _1n22) / _4n5;
  const root = Fp3.pow(n2, p1div4);
  if (!Fp3.eql(Fp3.sqr(root), n2))
    throw new Error("Cannot find square root");
  return root;
}
function sqrt5mod82(Fp3, n2) {
  const p5div8 = (Fp3.ORDER - _5n4) / _8n5;
  const n22 = Fp3.mul(n2, _2n12);
  const v = Fp3.pow(n22, p5div8);
  const nv = Fp3.mul(n2, v);
  const i4 = Fp3.mul(Fp3.mul(nv, _2n12), v);
  const root = Fp3.mul(nv, Fp3.sub(i4, Fp3.ONE));
  if (!Fp3.eql(Fp3.sqr(root), n2))
    throw new Error("Cannot find square root");
  return root;
}
function tonelliShanks3(P22) {
  if (P22 < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let Q = P22 - _1n22;
  let S2 = 0;
  while (Q % _2n12 === _0n22) {
    Q /= _2n12;
    S2++;
  }
  let Z2 = _2n12;
  const _Fp = Field3(P22);
  while (FpLegendre2(_Fp, Z2) === 1) {
    if (Z2++ > 1000)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S2 === 1)
    return sqrt3mod42;
  let cc = _Fp.pow(Z2, Q);
  const Q1div2 = (Q + _1n22) / _2n12;
  return function tonelliSlow(Fp3, n2) {
    if (Fp3.is0(n2))
      return n2;
    if (FpLegendre2(Fp3, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S2;
    let c = Fp3.mul(Fp3.ONE, cc);
    let t = Fp3.pow(n2, Q);
    let R = Fp3.pow(n2, Q1div2);
    while (!Fp3.eql(t, Fp3.ONE)) {
      if (Fp3.is0(t))
        return Fp3.ZERO;
      let i4 = 1;
      let t_tmp = Fp3.sqr(t);
      while (!Fp3.eql(t_tmp, Fp3.ONE)) {
        i4++;
        t_tmp = Fp3.sqr(t_tmp);
        if (i4 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n22 << BigInt(M - i4 - 1);
      const b22 = Fp3.pow(c, exponent);
      M = i4;
      c = Fp3.sqr(b22);
      t = Fp3.mul(t, c);
      R = Fp3.mul(R, b22);
    }
    return R;
  };
}
function FpSqrt3(P22) {
  if (P22 % _4n5 === _3n6)
    return sqrt3mod42;
  if (P22 % _8n5 === _5n4)
    return sqrt5mod82;
  return tonelliShanks3(P22);
}
var isNegativeLE2 = (num, modulo) => (mod4(num, modulo) & _1n22) === _1n22;
var FIELD_FIELDS3 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField3(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS3.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject2(field, opts);
  return field;
}
function FpPow3(Fp3, num, power) {
  if (power < _0n22)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n22)
    return Fp3.ONE;
  if (power === _1n22)
    return num;
  let p = Fp3.ONE;
  let d = num;
  while (power > _0n22) {
    if (power & _1n22)
      p = Fp3.mul(p, d);
    d = Fp3.sqr(d);
    power >>= _1n22;
  }
  return p;
}
function FpInvertBatch3(Fp3, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp3.ZERO : undefined);
  const multipliedAcc = nums.reduce((acc, num, i4) => {
    if (Fp3.is0(num))
      return acc;
    inverted[i4] = acc;
    return Fp3.mul(acc, num);
  }, Fp3.ONE);
  const invertedAcc = Fp3.inv(multipliedAcc);
  nums.reduceRight((acc, num, i4) => {
    if (Fp3.is0(num))
      return acc;
    inverted[i4] = Fp3.mul(acc, inverted[i4]);
    return Fp3.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre2(Fp3, n2) {
  const p1mod2 = (Fp3.ORDER - _1n22) / _2n12;
  const powered = Fp3.pow(n2, p1mod2);
  const yes = Fp3.eql(powered, Fp3.ONE);
  const zero = Fp3.eql(powered, Fp3.ZERO);
  const no = Fp3.eql(powered, Fp3.neg(Fp3.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength3(n2, nBitLength) {
  if (nBitLength !== undefined)
    anumber2(nBitLength);
  const _nBitLength = nBitLength !== undefined ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field3(ORDER, bitLenOrOpts, isLE22 = false, opts = {}) {
  if (ORDER <= _0n22)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = undefined;
  let _sqrt = undefined;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE22)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE22 = _opts.isLE;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength3(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f4 = Object.freeze({
    ORDER,
    isLE: isLE22,
    BITS,
    BYTES,
    MASK: bitMask3(BITS),
    ZERO: _0n22,
    ONE: _1n22,
    create: (num) => mod4(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n22 <= num && num < ORDER;
    },
    is0: (num) => num === _0n22,
    isValidNot0: (num) => !f4.is0(num) && f4.isValid(num),
    isOdd: (num) => (num & _1n22) === _1n22,
    neg: (num) => mod4(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod4(num * num, ORDER),
    add: (lhs, rhs) => mod4(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod4(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod4(lhs * rhs, ORDER),
    pow: (num, power) => FpPow3(f4, num, power),
    div: (lhs, rhs) => mod4(lhs * invert3(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert3(num, ORDER),
    sqrt: _sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt3(ORDER);
      return sqrtP(f4, n2);
    }),
    toBytes: (num) => isLE22 ? numberToBytesLE3(num, BYTES) : numberToBytesBE3(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE22 ? bytesToNumberLE3(bytes2) : bytesToNumberBE3(bytes2);
    },
    invertBatch: (lst) => FpInvertBatch3(f4, lst),
    cmov: (a, b22, c) => c ? b22 : a
  });
  return Object.freeze(f4);
}
function getFieldBytesLength3(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength3(fieldOrder) {
  const length = getFieldBytesLength3(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField3(key, fieldOrder, isLE22 = false) {
  const len2 = key.length;
  const fieldLen = getFieldBytesLength3(fieldOrder);
  const minLen = getMinHashLength3(fieldOrder);
  if (len2 < 16 || len2 < minLen || len2 > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len2);
  const num = isLE22 ? bytesToNumberLE3(key) : bytesToNumberBE3(key);
  const reduced = mod4(num, fieldOrder - _1n22) + _1n22;
  return isLE22 ? numberToBytesLE3(reduced, fieldLen) : numberToBytesBE3(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n32 = BigInt(0);
var _1n32 = BigInt(1);
function negateCt2(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ2(c, property, points) {
  const getz = property === "pz" ? (p) => p.pz : (p) => p.ez;
  const toInv = FpInvertBatch3(c.Fp, points.map(getz));
  const affined = points.map((p, i4) => p.toAffine(toInv[i4]));
  return affined.map(c.fromAffine);
}
function validateW2(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts2(W, scalarBits) {
  validateW2(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask3 = bitMask3(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask: mask3, maxNumber, shiftBy };
}
function calcOffsets2(n2, window2, wOpts) {
  const { windowSize, mask: mask3, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask3);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n32;
  }
  const offsetStart = window2 * windowSize;
  const offset2 = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints2(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i4) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i4);
  });
}
function validateMSMScalars2(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i4) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i4);
  });
}
var pointPrecomputes2 = new WeakMap;
var pointWindowSizes2 = new WeakMap;
function getW2(P22) {
  return pointWindowSizes2.get(P22) || 1;
}
function assert02(n2) {
  if (n2 !== _0n32)
    throw new Error("invalid wNAF");
}
function wNAF3(c, bits) {
  return {
    constTimeNegate: negateCt2,
    hasPrecomputes(elm) {
      return getW2(elm) !== 1;
    },
    unsafeLadder(elm, n2, p = c.ZERO) {
      let d = elm;
      while (n2 > _0n32) {
        if (n2 & _1n32)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n32;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts2(W, bits);
      const points = [];
      let p = elm;
      let base2 = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base2 = p;
        points.push(base2);
        for (let i4 = 1;i4 < windowSize; i4++) {
          base2 = base2.add(p);
          points.push(base2);
        }
        p = base2.double();
      }
      return points;
    },
    wNAF(W, precomputes, n2) {
      let p = c.ZERO;
      let f4 = c.BASE;
      const wo = calcWOpts2(W, bits);
      for (let window2 = 0;window2 < wo.windows; window2++) {
        const { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF } = calcOffsets2(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          f4 = f4.add(negateCt2(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt2(isNeg, precomputes[offset2]));
        }
      }
      assert02(n2);
      return { p, f: f4 };
    },
    wNAFUnsafe(W, precomputes, n2, acc = c.ZERO) {
      const wo = calcWOpts2(W, bits);
      for (let window2 = 0;window2 < wo.windows; window2++) {
        if (n2 === _0n32)
          break;
        const { nextN, offset: offset2, isZero, isNeg } = calcOffsets2(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset2];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert02(n2);
      return acc;
    },
    getPrecomputes(W, P22, transform) {
      let comp = pointPrecomputes2.get(P22);
      if (!comp) {
        comp = this.precomputeWindow(P22, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes2.set(P22, comp);
        }
      }
      return comp;
    },
    wNAFCached(P22, n2, transform) {
      const W = getW2(P22);
      return this.wNAF(W, this.getPrecomputes(W, P22, transform), n2);
    },
    wNAFCachedUnsafe(P22, n2, transform, prev) {
      const W = getW2(P22);
      if (W === 1)
        return this.unsafeLadder(P22, n2, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P22, transform), n2, prev);
    },
    setWindowSize(P22, W) {
      validateW2(W, bits);
      pointWindowSizes2.set(P22, W);
      pointPrecomputes2.delete(P22);
    }
  };
}
function mulEndoUnsafe2(c, point, k1, k2) {
  let acc = point;
  let p1 = c.ZERO;
  let p2 = c.ZERO;
  while (k1 > _0n32 || k2 > _0n32) {
    if (k1 & _1n32)
      p1 = p1.add(acc);
    if (k2 & _1n32)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n32;
    k2 >>= _1n32;
  }
  return { p1, p2 };
}
function pippenger2(c, fieldN, points, scalars) {
  validateMSMPoints2(points, c);
  validateMSMScalars2(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen3(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask3(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum2 = zero;
  for (let i4 = lastBits;i4 >= 0; i4 -= windowSize) {
    buckets.fill(zero);
    for (let j = 0;j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i4) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero;j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum2 = sum2.add(resI);
    if (i4 !== 0)
      for (let j = 0;j < windowSize; j++)
        sum2 = sum2.double();
  }
  return sum2;
}
function createField2(order, field) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField3(field);
    return field;
  } else {
    return Field3(order);
  }
}
function _createCurveFields2(type2, CURVE, curveOpts = {}) {
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type2} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n32))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp3 = createField2(CURVE.p, curveOpts.Fp);
  const Fn = createField2(CURVE.n, curveOpts.Fn);
  const _b = type2 === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp3.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  return { Fp: Fp3, Fn };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n42 = BigInt(0);
var _1n42 = BigInt(1);
var _2n22 = BigInt(2);
var _8n22 = BigInt(8);
var VERIFY_DEFAULT2 = { zip215: true };
function isEdValidXY2(Fp3, CURVE, x2, y) {
  const x22 = Fp3.sqr(x2);
  const y2 = Fp3.sqr(y);
  const left = Fp3.add(Fp3.mul(CURVE.a, x22), y2);
  const right = Fp3.add(Fp3.ONE, Fp3.mul(CURVE.d, Fp3.mul(x22, y2)));
  return Fp3.eql(left, right);
}
function edwards2(CURVE, curveOpts = {}) {
  const { Fp: Fp3, Fn } = _createCurveFields2("edwards", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject2(curveOpts, {}, { uvRatio: "function" });
  const MASK = _2n22 << BigInt(Fn.BYTES * 8) - _1n42;
  const modP = (n2) => Fp3.create(n2);
  const uvRatio2 = curveOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp3.sqrt(Fp3.div(u, v)) };
    } catch (e) {
      return { isValid: false, value: _0n42 };
    }
  });
  if (!isEdValidXY2(Fp3, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min2 = banZero ? _1n42 : _0n42;
    aInRange2("coordinate " + title, n2, min2, MASK);
    return n2;
  }
  function aextpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized2((p, iz) => {
    const { ex: x2, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n22 : Fp3.inv(z);
    const ax = modP(x2 * iz);
    const ay = modP(y * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n42, y: _1n42 };
    if (zz !== _1n42)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized2((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z2, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z22 = modP(Z2 * Z2);
    const Z4 = modP(Z22 * Z22);
    const aX2 = modP(X2 * a);
    const left = modP(Z22 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z2 * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });

  class Point2 {
    constructor(ex, ey, ez, et2) {
      this.ex = acoord("x", ex);
      this.ey = acoord("y", ey);
      this.ez = acoord("z", ez, true);
      this.et = acoord("t", et2);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x: x2, y } = p || {};
      acoord("x", x2);
      acoord("y", y);
      return new Point2(x2, y, _1n42, modP(x2 * y));
    }
    static normalizeZ(points) {
      return normalizeZ2(Point2, "ez", points);
    }
    static msm(points, scalars) {
      return pippenger2(Point2, Fn, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_2n22);
      return this;
    }
    assertValidity() {
      assertValidMemo(this);
    }
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n22 * modP(Z1 * Z1));
      const D2 = modP(a * A);
      const x1y1 = X1 + Y1;
      const E2 = modP(modP(x1y1 * x1y1) - A - B);
      const G = D2 + B;
      const F = G - C;
      const H = D2 - B;
      const X3 = modP(E2 * F);
      const Y3 = modP(G * H);
      const T32 = modP(E2 * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T32);
    }
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T13 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T22 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T13 * d * T22);
      const D2 = modP(Z1 * Z2);
      const E2 = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D2 - C;
      const G = D2 + C;
      const H = modP(B - a * A);
      const X3 = modP(E2 * F);
      const Y3 = modP(G * H);
      const T32 = modP(E2 * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      const n2 = scalar;
      aInRange2("scalar", n2, _1n42, CURVE_ORDER);
      const { p, f: f4 } = wnaf.wNAFCached(this, n2, Point2.normalizeZ);
      return Point2.normalizeZ([p, f4])[0];
    }
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      const n2 = scalar;
      aInRange2("scalar", n2, _0n42, CURVE_ORDER);
      if (n2 === _0n42)
        return Point2.ZERO;
      if (this.is0() || n2 === _1n42)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n2, Point2.normalizeZ, acc);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    isTorsionFree() {
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n42)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    static fromBytes(bytes2, zip215 = false) {
      abytes2(bytes2);
      return this.fromHex(bytes2, zip215);
    }
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len2 = Fp3.BYTES;
      hex = ensureBytes3("pointHex", hex, len2);
      abool2("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len2 - 1];
      normed[len2 - 1] = lastByte & ~128;
      const y = bytesToNumberLE3(normed);
      const max2 = zip215 ? MASK : Fp3.ORDER;
      aInRange2("pointHex.y", y, _0n42, max2);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n42);
      const v = modP(d * y2 - a);
      let { isValid, value: x2 } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x2 & _1n42) === _1n42;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x2 === _0n42 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x2 = modP(-x2);
      return Point2.fromAffine({ x: x2, y });
    }
    static fromPrivateScalar(scalar) {
      return Point2.BASE.multiply(scalar);
    }
    toBytes() {
      const { x: x2, y } = this.toAffine();
      const bytes2 = numberToBytesLE3(y, Fp3.BYTES);
      bytes2[bytes2.length - 1] |= x2 & _1n42 ? 128 : 0;
      return bytes2;
    }
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex3(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n42, modP(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n42, _1n42, _1n42, _0n42);
  Point2.Fp = Fp3;
  Point2.Fn = Fn;
  const wnaf = wNAF3(Point2, Fn.BYTES * 8);
  return Point2;
}
function eddsa2(Point2, eddsaOpts) {
  _validateObject2(eddsaOpts, {
    hash: "function"
  }, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash, hash: cHash } = eddsaOpts;
  const { BASE: G, Fp: Fp3, Fn } = Point2;
  const CURVE_ORDER = Fn.ORDER;
  const randomBytes_ = eddsaOpts.randomBytes || randomBytes5;
  const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool2("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN(a) {
    return Fn.create(a);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE3(hash2));
  }
  function getPrivateScalar(key) {
    const len2 = Fp3.BYTES;
    key = ensureBytes3("private key", key, len2);
    const hashed = ensureBytes3("hashed private key", cHash(key), 2 * len2);
    const head = adjustScalarBytes2(hashed.slice(0, len2));
    const prefix = hashed.slice(len2, 2 * len2);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head, prefix, scalar } = getPrivateScalar(key);
    const point = G.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey2(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes4(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes3("context", context), !!prehash)));
  }
  function sign3(msg, privKey, options = {}) {
    msg = ensureBytes3("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    aInRange2("signature.s", s, _0n42, CURVE_ORDER);
    const L = Fp3.BYTES;
    const res = concatBytes4(R, numberToBytesLE3(s, L));
    return ensureBytes3("result", res, L * 2);
  }
  const verifyOpts = VERIFY_DEFAULT2;
  function verify2(sig, msg, publicKey2, options = verifyOpts) {
    const { context, zip215 } = options;
    const len2 = Fp3.BYTES;
    sig = ensureBytes3("signature", sig, 2 * len2);
    msg = ensureBytes3("message", msg);
    publicKey2 = ensureBytes3("publicKey", publicKey2, len2);
    if (zip215 !== undefined)
      abool2("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE3(sig.slice(len2, 2 * len2));
    let A, R, SB;
    try {
      A = Point2.fromHex(publicKey2, zip215);
      R = Point2.fromHex(sig.slice(0, len2), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  G.precompute(8);
  const utils = {
    getExtendedPublicKey,
    randomPrivateKey: () => randomBytes_(Fp3.BYTES),
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return { getPublicKey: getPublicKey2, sign: sign3, verify: verify2, utils, Point: Point2 };
}
function _eddsa_legacy_opts_to_new2(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp3 = c.Fp;
  const Fn = Field3(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp3, Fn, uvRatio: c.uvRatio };
  const eddsaOpts = {
    hash: c.hash,
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, eddsaOpts };
}
function _eddsa_new_output_to_legacy2(c, eddsa22) {
  const legacy = Object.assign({}, eddsa22, { ExtendedPoint: eddsa22.Point, CURVE: c });
  return legacy;
}
function twistedEdwards2(c) {
  const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new2(c);
  const Point2 = edwards2(CURVE, curveOpts);
  const EDDSA = eddsa2(Point2, eddsaOpts);
  return _eddsa_new_output_to_legacy2(c, EDDSA);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n52 = BigInt(0);
var _1n52 = BigInt(1);
var _2n32 = BigInt(2);
var _3n22 = BigInt(3);
var _5n22 = BigInt(5);
var _8n32 = BigInt(8);
var ed25519_CURVE2 = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n32,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_32(x2) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P22 = ed25519_CURVE2.p;
  const x22 = x2 * x2 % P22;
  const b22 = x22 * x2 % P22;
  const b4 = pow24(b22, _2n32, P22) * b22 % P22;
  const b5 = pow24(b4, _1n52, P22) * x2 % P22;
  const b10 = pow24(b5, _5n22, P22) * b5 % P22;
  const b20 = pow24(b10, _10n, P22) * b10 % P22;
  const b40 = pow24(b20, _20n, P22) * b20 % P22;
  const b80 = pow24(b40, _40n, P22) * b40 % P22;
  const b160 = pow24(b80, _80n, P22) * b80 % P22;
  const b240 = pow24(b160, _80n, P22) * b80 % P22;
  const b250 = pow24(b240, _10n, P22) * b10 % P22;
  const pow_p_5_8 = pow24(b250, _2n32, P22) * x2 % P22;
  return { pow_p_5_8, b2: b22 };
}
function adjustScalarBytes2(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
var ED25519_SQRT_M12 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio2(u, v) {
  const P22 = ed25519_CURVE2.p;
  const v33 = mod4(v * v * v, P22);
  const v7 = mod4(v33 * v33 * v, P22);
  const pow3 = ed25519_pow_2_252_32(u * v7).pow_p_5_8;
  let x2 = mod4(u * v33 * pow3, P22);
  const vx2 = mod4(v * x2 * x2, P22);
  const root1 = x2;
  const root2 = mod4(x2 * ED25519_SQRT_M12, P22);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod4(-u, P22);
  const noRoot = vx2 === mod4(-u * ED25519_SQRT_M12, P22);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (isNegativeLE2(x2, P22))
    x2 = mod4(-x2, P22);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
var Fp3 = /* @__PURE__ */ (() => Field3(ed25519_CURVE2.p, undefined, true))();
var ed25519Defaults2 = /* @__PURE__ */ (() => ({
  ...ed25519_CURVE2,
  Fp: Fp3,
  hash: sha5124,
  adjustScalarBytes: adjustScalarBytes2,
  uvRatio: uvRatio2
}))();
var ed255192 = /* @__PURE__ */ (() => twistedEdwards2(ed25519Defaults2))();
var import_bn2 = __toESM2(require_bn2(), 1);
var import_bs583 = __toESM2(require_bs583(), 1);
var sha25622 = sha2565;
var import_borsh2 = __toESM2(require_lib2(), 1);
var BufferLayout2 = __toESM2(require_Layout2(), 1);
var import_buffer_layout2 = __toESM2(require_Layout2(), 1);
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2 = 1;
var SOLANA_ERROR__INVALID_NONCE2 = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2 = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2 = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2 = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2 = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING2 = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING2 = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2 = 9;
var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2 = 10;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR2 = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2 = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2 = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2 = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2 = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2 = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2 = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2 = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2 = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR2 = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2 = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2 = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2 = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2 = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2 = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2 = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2 = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2 = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2 = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2 = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2 = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2 = 2800000;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2 = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2 = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2 = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2 = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2 = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2 = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2 = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2 = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2 = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2 = 2800010;
var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2 = 2800011;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2 = 3230000;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2 = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2 = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2 = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2 = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2 = 3610000;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2 = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2 = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2 = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2 = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2 = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2 = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2 = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2 = 3611000;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2 = 3704000;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2 = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2 = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2 = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2 = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2 = 4128000;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2 = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2 = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2 = 4615000;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2 = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2 = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2 = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2 = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2 = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2 = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2 = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2 = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2 = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2 = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2 = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2 = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2 = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2 = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2 = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2 = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2 = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2 = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2 = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2 = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2 = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2 = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2 = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2 = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2 = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2 = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2 = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2 = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2 = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2 = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2 = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2 = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2 = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2 = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2 = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2 = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2 = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2 = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2 = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2 = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2 = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2 = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2 = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2 = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2 = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2 = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2 = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2 = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2 = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2 = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2 = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2 = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2 = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2 = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2 = 5508000;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2 = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2 = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2 = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2 = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2 = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2 = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2 = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2 = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2 = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2 = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2 = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2 = 5663000;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2 = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2 = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2 = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2 = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2 = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2 = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2 = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2 = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2 = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2 = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2 = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2 = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2 = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2 = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2 = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2 = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2 = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2 = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2 = 5663019;
var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2 = 5663020;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2 = 7050000;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2 = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2 = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2 = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2 = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2 = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2 = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2 = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2 = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2 = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2 = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2 = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2 = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2 = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2 = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2 = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2 = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2 = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2 = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2 = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2 = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2 = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2 = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2 = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2 = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2 = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2 = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2 = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2 = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2 = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2 = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2 = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2 = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2 = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2 = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2 = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2 = 7050036;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2 = 8078000;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2 = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2 = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2 = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2 = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2 = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2 = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2 = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2 = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2 = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2 = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2 = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2 = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2 = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2 = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2 = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2 = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2 = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT2 = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2 = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2 = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2 = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2 = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW2 = 8100000;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2 = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2 = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2 = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2 = 8190000;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2 = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2 = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2 = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2 = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2 = 9900000;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2 = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2 = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2 = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2 = 9900004;
var SolanaErrorMessages2 = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT2]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE2]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR2]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING2]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2]: "$message",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING2]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW2]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2]: `This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX2 = "i";
var TYPE2 = "t";
function getHumanReadableErrorMessage2(code2, context = {}) {
  const messageFormatString = SolanaErrorMessages2[code2];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE2] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX2] + 1, endIndex);
      fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);
    } else if (state[TYPE2] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX2], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii) => {
    if (ii === 0) {
      state = {
        [START_INDEX2]: 0,
        [TYPE2]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
      };
      return;
    }
    let nextState;
    switch (state[TYPE2]) {
      case 0:
        nextState = { [START_INDEX2]: ii, [TYPE2]: 1 };
        break;
      case 1:
        if (char === "\\") {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 2 };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 2 };
        } else if (!char.match(/\w/)) {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 1 };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage2(code2, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage2(code2, context);
  } else {}
}
var SolanaError2 = class extends Error {
  cause = this.cause;
  context;
  constructor(...[code2, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage2(code2, context);
    super(message, errorOptions);
    this.context = {
      __code: code2,
      ...context
    };
    this.name = "SolanaError";
  }
};
function getEncodedSize2(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder2(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes2 = new Uint8Array(getEncodedSize2(value, encoder));
      encoder.write(value, bytes2, 0);
      return bytes2;
    }
  });
}
function createDecoder2(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes2, offset2 = 0) => decoder.read(bytes2, offset2)[0]
  });
}
function isFixedSize2(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec2(encoder, decoder) {
  if (isFixedSize2(encoder) !== isFixedSize2(decoder)) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2);
  }
  if (isFixedSize2(encoder) && isFixedSize2(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize2(encoder) && !isFixedSize2(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec2(codecDescription, bytes2, offset2 = 0) {
  if (bytes2.length - offset2 <= 0) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec2(codecDescription, expected, bytes2, offset2 = 0) {
  const bytesLength = bytes2.length - offset2;
  if (bytesLength < expected) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}
function assertNumberIsBetweenForCodec2(codecDescription, min2, max2, value) {
  if (value < min2 || value > max2) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2, {
      codecDescription,
      max: max2,
      min: min2,
      value
    });
  }
}
function isLittleEndian2(config2) {
  return config2?.endian === 1 ? false : true;
}
function numberEncoderFactory2(input) {
  return createEncoder2({
    fixedSize: input.size,
    write(value, bytes2, offset2) {
      if (input.range) {
        assertNumberIsBetweenForCodec2(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian2(input.config));
      bytes2.set(new Uint8Array(arrayBuffer), offset2);
      return offset2 + input.size;
    }
  });
}
function numberDecoderFactory2(input) {
  return createDecoder2({
    fixedSize: input.size,
    read(bytes2, offset2 = 0) {
      assertByteArrayIsNotEmptyForCodec2(input.name, bytes2, offset2);
      assertByteArrayHasEnoughBytesForCodec2(input.name, input.size, bytes2, offset2);
      const view = new DataView(toArrayBuffer2(bytes2, offset2, input.size));
      return [input.get(view, isLittleEndian2(input.config)), offset2 + input.size];
    }
  });
}
function toArrayBuffer2(bytes2, offset2, length) {
  const bytesOffset = bytes2.byteOffset + (offset2 ?? 0);
  const bytesLength = length ?? bytes2.byteLength;
  return bytes2.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder2 = (config2 = {}) => numberEncoderFactory2({
  config: config2,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
  size: 8
});
var getU64Decoder2 = (config2 = {}) => numberDecoderFactory2({
  config: config2,
  get: (view, le) => view.getBigUint64(0, le),
  name: "u64",
  size: 8
});
var getU64Codec2 = (config2 = {}) => combineCodec2(getU64Encoder2(config2), getU64Decoder2(config2));

class StructError2 extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
}
function isIterable2(x2) {
  return isObject3(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject3(x2) {
  return typeof x2 === "object" && x2 != null;
}
function isNonArrayObject2(x2) {
  return isObject3(x2) && !Array.isArray(x2);
}
function print2(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator2(input) {
  const { done, value } = input.next();
  return done ? undefined : value;
}
function toFailure2(result, context, struct2, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type2 } = struct2;
  const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print2(value)}\`` } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures2(result, context, struct2, value) {
  if (!isIterable2(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure2(r, context, struct2, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run2(value, struct2, options = {}) {
  const { path = [], branch = [value], coerce: coerce2 = false, mask: mask3 = false } = options;
  const ctx = { path, branch, mask: mask3 };
  if (coerce2) {
    value = struct2.coercer(value, ctx);
  }
  let status = "valid";
  for (const failure of struct2.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, undefined];
  }
  for (let [k, v, s] of struct2.entries(value, ctx)) {
    const ts = run2(v, s, {
      path: k === undefined ? path : [...path, k],
      branch: k === undefined ? branch : [...branch, v],
      coerce: coerce2,
      mask: mask3,
      message: options.message
    });
    for (const t of ts) {
      if (t[0]) {
        status = t[0].refinement != null ? "not_refined" : "not_valid";
        yield [t[0], undefined];
      } else if (coerce2) {
        v = t[1];
        if (k === undefined) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject3(value)) {
          if (v !== undefined || k in value)
            value[k] = v;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct2.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, undefined];
    }
  }
  if (status === "valid") {
    yield [undefined, value];
  }
}

class Struct3 {
  constructor(props) {
    const { type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {} } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures2(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures2(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  assert(value, message) {
    return assert6(value, this, message);
  }
  create(value, message) {
    return create4(value, this, message);
  }
  is(value) {
    return is2(value, this);
  }
  mask(value, message) {
    return mask3(value, this, message);
  }
  validate(value, options = {}) {
    return validate3(value, this, options);
  }
}
function assert6(value, struct2, message) {
  const result = validate3(value, struct2, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create4(value, struct2, message) {
  const result = validate3(value, struct2, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask3(value, struct2, message) {
  const result = validate3(value, struct2, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is2(value, struct2) {
  const result = validate3(value, struct2);
  return !result[0];
}
function validate3(value, struct2, options = {}) {
  const tuples = run2(value, struct2, options);
  const tuple2 = shiftIterator2(tuples);
  if (tuple2[0]) {
    const error = new StructError2(tuple2[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, undefined];
  } else {
    const v = tuple2[1];
    return [undefined, v];
  }
}
function define22(name, validator) {
  return new Struct3({ type: name, schema: null, validator });
}
function any2() {
  return define22("any", () => true);
}
function array2(Element) {
  return new Struct3({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i4, v] of value.entries()) {
          yield [i4, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print2(value)}`;
    }
  });
}
function boolean2() {
  return define22("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance2(Class) {
  return define22("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print2(value)}`;
  });
}
function literal2(constant) {
  const description = print2(constant);
  const t = typeof constant;
  return new Struct3({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print2(value)}`;
    }
  });
}
function never2() {
  return define22("never", () => false);
}
function nullable2(struct2) {
  return new Struct3({
    ...struct2,
    validator: (value, ctx) => value === null || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
  });
}
function number3() {
  return define22("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print2(value)}`;
  });
}
function optional2(struct2) {
  return new Struct3({
    ...struct2,
    validator: (value, ctx) => value === undefined || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === undefined || struct2.refiner(value, ctx)
  });
}
function record2(Key, Value) {
  return new Struct3({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject3(value)) {
        for (const k in value) {
          const v = value[k];
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },
    validator(value) {
      return isNonArrayObject2(value) || `Expected an object, but received: ${print2(value)}`;
    },
    coercer(value) {
      return isNonArrayObject2(value) ? { ...value } : value;
    }
  });
}
function string2() {
  return define22("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print2(value)}`;
  });
}
function tuple2(Structs) {
  const Never = never2();
  return new Struct3({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Structs.length, value.length);
        for (let i4 = 0;i4 < length; i4++) {
          yield [i4, value[i4], Structs[i4] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print2(value)}`;
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    }
  });
}
function type2(schema) {
  const keys = Object.keys(schema);
  return new Struct3({
    type: "type",
    schema,
    *entries(value) {
      if (isObject3(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isNonArrayObject2(value) || `Expected an object, but received: ${print2(value)}`;
    },
    coercer(value) {
      return isNonArrayObject2(value) ? { ...value } : value;
    }
  });
}
function union2(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct3({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      for (const S2 of Structs) {
        const [error, coerced] = S2.validate(value, {
          coerce: true,
          mask: ctx.mask
        });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run2(value, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print2(value)}`,
        ...failures
      ];
    }
  });
}
function unknown2() {
  return define22("unknown", () => true);
}
function coerce2(struct2, condition, coercer) {
  return new Struct3({
    ...struct2,
    coercer: (value, ctx) => {
      return is2(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
    }
  });
}
var import_browser2 = __toESM2(require_browser4(), 1);
init_buffer2();
var import__2 = __toESM2(require_eventemitter32(), 1);
var _0n62 = BigInt(0);
var _1n62 = BigInt(1);
var _2n42 = BigInt(2);
var _7n3 = BigInt(7);
var _256n3 = BigInt(256);
var _0x71n3 = BigInt(113);
var SHA3_PI3 = [];
var SHA3_ROTL3 = [];
var _SHA3_IOTA3 = [];
for (let round2 = 0, R = _1n62, x2 = 1, y = 0;round2 < 24; round2++) {
  [x2, y] = [y, (2 * x2 + 3 * y) % 5];
  SHA3_PI3.push(2 * (5 * y + x2));
  SHA3_ROTL3.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t = _0n62;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n62 ^ (R >> _7n3) * _0x71n3) % _256n3;
    if (R & _2n42)
      t ^= _1n62 << (_1n62 << /* @__PURE__ */ BigInt(j)) - _1n62;
  }
  _SHA3_IOTA3.push(t);
}
var IOTAS2 = split4(_SHA3_IOTA3, true);
var SHA3_IOTA_H3 = IOTAS2[0];
var SHA3_IOTA_L3 = IOTAS2[1];
var rotlH3 = (h, l, s) => s > 32 ? rotlBH3(h, l, s) : rotlSH3(h, l, s);
var rotlL3 = (h, l, s) => s > 32 ? rotlBL3(h, l, s) : rotlSL3(h, l, s);
function keccakP3(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds;round2 < 24; round2++) {
    for (let x2 = 0;x2 < 10; x2++)
      B[x2] = s[x2] ^ s[x2 + 10] ^ s[x2 + 20] ^ s[x2 + 30] ^ s[x2 + 40];
    for (let x2 = 0;x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH3(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL3(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x2 + y] ^= Th;
        s[x2 + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL3[t];
      const Th = rotlH3(curH, curL, shift);
      const Tl = rotlL3(curH, curL, shift);
      const PI2 = SHA3_PI3[t];
      curH = s[PI2];
      curL = s[PI2 + 1];
      s[PI2] = Th;
      s[PI2 + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x2 = 0;x2 < 10; x2++)
        B[x2] = s[y + x2];
      for (let x2 = 0;x2 < 10; x2++)
        s[y + x2] ^= ~B[(x2 + 2) % 10] & B[(x2 + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H3[round2];
    s[1] ^= SHA3_IOTA_L3[round2];
  }
  clean2(B);
}

class Keccak3 extends Hash3 {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber2(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u324(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE2(this.state32);
    keccakP3(this.state32, this.rounds);
    swap32IfBE2(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists2(this);
    data = toBytes3(data);
    abytes2(data);
    const { blockLen, state } = this;
    const len2 = data.length;
    for (let pos = 0;pos < len2; ) {
      const take = Math.min(blockLen - this.pos, len2 - pos);
      for (let i22 = 0;i22 < take; i22++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists2(this, false);
    abytes2(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len2 = out.length;pos < len2; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len2 - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber2(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput2(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean2(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak3(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen3 = (suffix, blockLen, outputLen) => createHasher2(() => new Keccak3(blockLen, suffix, outputLen));
var keccak_2563 = /* @__PURE__ */ (() => gen3(1, 136, 256 / 8))();

class HMAC3 extends Hash3 {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash2(hash2);
    const key = toBytes3(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i22 = 0;i22 < pad.length; i22++)
      pad[i22] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i22 = 0;i22 < pad.length; i22++)
      pad[i22] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean2(pad);
  }
  update(buf) {
    aexists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists2(this);
    abytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished22, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished22;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac3 = (hash2, key, message) => new HMAC3(hash2, key).update(message).digest();
hmac3.create = (hash2, key) => new HMAC3(hash2, key);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts2(opts) {
  if (opts.lowS !== undefined)
    abool2("lowS", opts.lowS);
  if (opts.prehash !== undefined)
    abool2("prehash", opts.prehash);
}

class DERErr3 extends Error {
  constructor(m = "") {
    super(m);
  }
}
var DER3 = {
  Err: DERErr3,
  _tlv: {
    encode: (tag2, data) => {
      const { Err: E2 } = DER3;
      if (tag2 < 0 || tag2 > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E2("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len2 = numberToHexUnpadded3(dataLen);
      if (len2.length / 2 & 128)
        throw new E2("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded3(len2.length / 2 | 128) : "";
      const t = numberToHexUnpadded3(tag2);
      return t + lenLen + len2 + data;
    },
    decode(tag2, data) {
      const { Err: E2 } = DER3;
      let pos = 0;
      if (tag2 < 0 || tag2 > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag2)
        throw new E2("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E2("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E2("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E2("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E2("tlv.decode(long): zero leftmost byte");
        for (const b22 of lengthBytes)
          length = length << 8 | b22;
        pos += lenLen;
        if (length < 128)
          throw new E2("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E2("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  _int: {
    encode(num) {
      const { Err: E2 } = DER3;
      if (num < _0n72)
        throw new E2("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded3(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E2("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E2 } = DER3;
      if (data[0] & 128)
        throw new E2("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E2("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE3(data);
    }
  },
  toSig(hex) {
    const { Err: E2, _int: int, _tlv: tlv } = DER3;
    const data = ensureBytes3("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER3;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq2 = rs + ss;
    return tlv.encode(48, seq2);
  }
};
var _0n72 = BigInt(0);
var _1n72 = BigInt(1);
var _2n52 = BigInt(2);
var _3n32 = BigInt(3);
var _4n22 = BigInt(4);
function _legacyHelperEquat2(Fp22, a, b22) {
  function weierstrassEquation(x2) {
    const x22 = Fp22.sqr(x2);
    const x3 = Fp22.mul(x22, x2);
    return Fp22.add(Fp22.add(x3, Fp22.mul(x2, a)), b22);
  }
  return weierstrassEquation;
}
function _legacyHelperNormPriv2(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
  const { BYTES: expected } = Fn;
  function normPrivateKeyToScalar(key) {
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else {
      let bytes2 = ensureBytes3("private key", key);
      if (allowedPrivateKeyLengths) {
        if (!allowedPrivateKeyLengths.includes(bytes2.length * 2))
          throw new Error("invalid private key");
        const padded = new Uint8Array(expected);
        padded.set(bytes2, padded.length - bytes2.length);
        bytes2 = padded;
      }
      try {
        num = Fn.fromBytes(bytes2);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (wrapPrivateKey)
      num = Fn.create(num);
    if (!Fn.isValidNot0(num))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num;
  }
  return normPrivateKeyToScalar;
}
function weierstrassN2(CURVE, curveOpts = {}) {
  const { Fp: Fp22, Fn } = _createCurveFields2("weierstrass", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject2(curveOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = curveOpts;
  if (endo) {
    if (!Fp22.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
  }
  function assertCompressionIsSupported() {
    if (!Fp22.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes(_c, point, isCompressed) {
    const { x: x2, y } = point.toAffine();
    const bx = Fp22.toBytes(x2);
    abool2("isCompressed", isCompressed);
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp22.isOdd(y);
      return concatBytes4(pprefix2(hasEvenY), bx);
    } else {
      return concatBytes4(Uint8Array.of(4), bx, Fp22.toBytes(y));
    }
  }
  function pointFromBytes(bytes2) {
    abytes2(bytes2);
    const L = Fp22.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    const length = bytes2.length;
    const head = bytes2[0];
    const tail = bytes2.subarray(1);
    if (length === LC && (head === 2 || head === 3)) {
      const x2 = Fp22.fromBytes(tail);
      if (!Fp22.isValid(x2))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x2);
      let y;
      try {
        y = Fp22.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp22.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp22.neg(y);
      return { x: x2, y };
    } else if (length === LU && head === 4) {
      const x2 = Fp22.fromBytes(tail.subarray(L * 0, L * 1));
      const y = Fp22.fromBytes(tail.subarray(L * 1, L * 2));
      if (!isValidXY(x2, y))
        throw new Error("bad point: is not on curve");
      return { x: x2, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
    }
  }
  const toBytes22 = curveOpts.toBytes || pointToBytes;
  const fromBytes = curveOpts.fromBytes || pointFromBytes;
  const weierstrassEquation = _legacyHelperEquat2(Fp22, CURVE.a, CURVE.b);
  function isValidXY(x2, y) {
    const left = Fp22.sqr(y);
    const right = weierstrassEquation(x2);
    return Fp22.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp22.mul(Fp22.pow(CURVE.a, _3n32), _4n22);
  const _27b2 = Fp22.mul(Fp22.sqr(CURVE.b), BigInt(27));
  if (Fp22.is0(Fp22.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp22.isValid(n2) || banZero && Fp22.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized2((p, iz) => {
    const { px: x2, py: y, pz: z } = p;
    if (Fp22.eql(z, Fp22.ONE))
      return { x: x2, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp22.ONE : Fp22.inv(z);
    const ax = Fp22.mul(x2, iz);
    const ay = Fp22.mul(y, iz);
    const zz = Fp22.mul(z, iz);
    if (is0)
      return { x: Fp22.ZERO, y: Fp22.ZERO };
    if (!Fp22.eql(zz, Fp22.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized2((p) => {
    if (p.is0()) {
      if (curveOpts.allowInfinityPoint && !Fp22.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y } = p.toAffine();
    if (!Fp22.isValid(x2) || !Fp22.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x2, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp22.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
    k1p = negateCt2(k1neg, k1p);
    k2p = negateCt2(k2neg, k2p);
    return k1p.add(k2p);
  }

  class Point2 {
    constructor(px, py, pz) {
      this.px = acoord("x", px);
      this.py = acoord("y", py, true);
      this.pz = acoord("z", pz);
      Object.freeze(this);
    }
    static fromAffine(p) {
      const { x: x2, y } = p || {};
      if (!p || !Fp22.isValid(x2) || !Fp22.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp22.is0(x2) && Fp22.is0(y))
        return Point2.ZERO;
      return new Point2(x2, y, Fp22.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      return normalizeZ2(Point2, "pz", points);
    }
    static fromBytes(bytes2) {
      abytes2(bytes2);
      return Point2.fromHex(bytes2);
    }
    static fromHex(hex) {
      const P22 = Point2.fromAffine(fromBytes(ensureBytes3("pointHex", hex)));
      P22.assertValidity();
      return P22;
    }
    static fromPrivateKey(privateKey) {
      const normPrivateKeyToScalar = _legacyHelperNormPriv2(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    static msm(points, scalars) {
      return pippenger2(Point2, Fn, points, scalars);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_3n32);
      return this;
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp22.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp22.isOdd(y);
    }
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp22.eql(Fp22.mul(X1, Z2), Fp22.mul(X2, Z1));
      const U22 = Fp22.eql(Fp22.mul(Y1, Z2), Fp22.mul(Y2, Z1));
      return U12 && U22;
    }
    negate() {
      return new Point2(this.px, Fp22.neg(this.py), this.pz);
    }
    double() {
      const { a, b: b22 } = CURVE;
      const b3 = Fp22.mul(b22, _3n32);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp22;
      let t0 = Fp22.mul(X1, X1);
      let t1 = Fp22.mul(Y1, Y1);
      let t2 = Fp22.mul(Z1, Z1);
      let t3 = Fp22.mul(X1, Y1);
      t3 = Fp22.add(t3, t3);
      Z3 = Fp22.mul(X1, Z1);
      Z3 = Fp22.add(Z3, Z3);
      X3 = Fp22.mul(a, Z3);
      Y3 = Fp22.mul(b3, t2);
      Y3 = Fp22.add(X3, Y3);
      X3 = Fp22.sub(t1, Y3);
      Y3 = Fp22.add(t1, Y3);
      Y3 = Fp22.mul(X3, Y3);
      X3 = Fp22.mul(t3, X3);
      Z3 = Fp22.mul(b3, Z3);
      t2 = Fp22.mul(a, t2);
      t3 = Fp22.sub(t0, t2);
      t3 = Fp22.mul(a, t3);
      t3 = Fp22.add(t3, Z3);
      Z3 = Fp22.add(t0, t0);
      t0 = Fp22.add(Z3, t0);
      t0 = Fp22.add(t0, t2);
      t0 = Fp22.mul(t0, t3);
      Y3 = Fp22.add(Y3, t0);
      t2 = Fp22.mul(Y1, Z1);
      t2 = Fp22.add(t2, t2);
      t0 = Fp22.mul(t2, t3);
      X3 = Fp22.sub(X3, t0);
      Z3 = Fp22.mul(t2, t1);
      Z3 = Fp22.add(Z3, Z3);
      Z3 = Fp22.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp22;
      const a = CURVE.a;
      const b3 = Fp22.mul(CURVE.b, _3n32);
      let t0 = Fp22.mul(X1, X2);
      let t1 = Fp22.mul(Y1, Y2);
      let t2 = Fp22.mul(Z1, Z2);
      let t3 = Fp22.add(X1, Y1);
      let t4 = Fp22.add(X2, Y2);
      t3 = Fp22.mul(t3, t4);
      t4 = Fp22.add(t0, t1);
      t3 = Fp22.sub(t3, t4);
      t4 = Fp22.add(X1, Z1);
      let t5 = Fp22.add(X2, Z2);
      t4 = Fp22.mul(t4, t5);
      t5 = Fp22.add(t0, t2);
      t4 = Fp22.sub(t4, t5);
      t5 = Fp22.add(Y1, Z1);
      X3 = Fp22.add(Y2, Z2);
      t5 = Fp22.mul(t5, X3);
      X3 = Fp22.add(t1, t2);
      t5 = Fp22.sub(t5, X3);
      Z3 = Fp22.mul(a, t4);
      X3 = Fp22.mul(b3, t2);
      Z3 = Fp22.add(X3, Z3);
      X3 = Fp22.sub(t1, Z3);
      Z3 = Fp22.add(t1, Z3);
      Y3 = Fp22.mul(X3, Z3);
      t1 = Fp22.add(t0, t0);
      t1 = Fp22.add(t1, t0);
      t2 = Fp22.mul(a, t2);
      t4 = Fp22.mul(b3, t4);
      t1 = Fp22.add(t1, t2);
      t2 = Fp22.sub(t0, t2);
      t2 = Fp22.mul(a, t2);
      t4 = Fp22.add(t4, t2);
      t0 = Fp22.mul(t1, t4);
      Y3 = Fp22.add(Y3, t0);
      t0 = Fp22.mul(t5, t4);
      X3 = Fp22.mul(t3, X3);
      X3 = Fp22.sub(X3, t0);
      t0 = Fp22.mul(t3, t1);
      Z3 = Fp22.mul(t5, Z3);
      Z3 = Fp22.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    multiply(scalar) {
      const { endo: endo2 } = curveOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul2 = (n2) => wnaf.wNAFCached(this, n2, Point2.normalizeZ);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
        const { p: k1p, f: k1f } = mul2(k1);
        const { p: k2p, f: k2f } = mul2(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f: f22 } = mul2(scalar);
        point = p;
        fake = f22;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    multiplyUnsafe(sc) {
      const { endo: endo2 } = curveOpts;
      const p = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n72 || p.is0())
        return Point2.ZERO;
      if (sc === _1n72)
        return p;
      if (wnaf.hasPrecomputes(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
        const { p1, p2 } = mulEndoUnsafe2(Point2, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.wNAFCachedUnsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b22) {
      const sum2 = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b22));
      return sum2.is0() ? undefined : sum2;
    }
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    isTorsionFree() {
      const { isTorsionFree } = curveOpts;
      if (cofactor === _1n72)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = curveOpts;
      if (cofactor === _1n72)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    toBytes(isCompressed = true) {
      abool2("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes22(Point2, this, isCompressed);
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex3(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp22.ONE);
  Point2.ZERO = new Point2(Fp22.ZERO, Fp22.ONE, Fp22.ZERO);
  Point2.Fp = Fp22;
  Point2.Fn = Fn;
  const bits = Fn.BITS;
  const wnaf = wNAF3(Point2, curveOpts.endo ? Math.ceil(bits / 2) : bits);
  return Point2;
}
function pprefix2(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function ecdsa2(Point2, ecdsaOpts, curveOpts = {}) {
  _validateObject2(ecdsaOpts, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes5;
  const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac3(ecdsaOpts.hash, key, concatBytes4(...msgs)));
  const { Fp: Fp22, Fn } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  function isBiggerThanHalfOrder(number22) {
    const HALF = CURVE_ORDER >> _1n72;
    return number22 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
  }
  function aValidRS(title, num) {
    if (!Fn.isValidNot0(num))
      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
  }

  class Signature2 {
    constructor(r, s, recovery) {
      aValidRS("r", r);
      aValidRS("s", s);
      this.r = r;
      this.s = s;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromCompact(hex) {
      const L = Fn.BYTES;
      const b22 = ensureBytes3("compactSignature", hex, L * 2);
      return new Signature2(Fn.fromBytes(b22.subarray(0, L)), Fn.fromBytes(b22.subarray(L, L * 2)));
    }
    static fromDER(hex) {
      const { r, s } = DER3.toSig(ensureBytes3("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {}
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const FIELD_ORDER = Fp22.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n52 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp22.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x2 = Fp22.toBytes(radj);
      const R = Point2.fromHex(concatBytes4(pprefix2((rec & 1) === 0), x2));
      const ir = Fn.inv(radj);
      const h = bits2int_modN(ensureBytes3("msgHash", msgHash));
      const u1 = Fn.create(-h * ir);
      const u2 = Fn.create(s * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, Fn.neg(this.s), this.recovery) : this;
    }
    toBytes(format) {
      if (format === "compact")
        return concatBytes4(Fn.toBytes(this.r), Fn.toBytes(this.s));
      if (format === "der")
        return hexToBytes3(DER3.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex3(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex3(this.toBytes("compact"));
    }
  }
  const normPrivateKeyToScalar = _legacyHelperNormPriv2(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const n2 = CURVE_ORDER;
      return mapHashToField3(randomBytes_(getMinHashLength3(n2)), n2);
    },
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function getPublicKey2(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point2)
      return true;
    const arr = ensureBytes3("key", item);
    const length = arr.length;
    const L = Fp22.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
      return;
    } else {
      return length === LC || length === LU;
    }
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicB) === false)
      throw new Error("second arg must be public key");
    const b22 = Point2.fromHex(publicB);
    return b22.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
  }
  const bits2int = ecdsaOpts.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE3(bytes2);
    const delta = bytes2.length * 8 - fnBits;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes2) {
    return Fn.create(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask3(fnBits);
  function int2octets(num) {
    aInRange2("num < 2^" + fnBits, num, _0n72, ORDER_MASK);
    return Fn.toBytes(num);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2 } = ecdsaOpts;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes3("msgHash", msgHash);
    validateSigVerOpts2(opts);
    if (prehash)
      msgHash = ensureBytes3("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes_(Fp22.BYTES) : ent;
      seedArgs.push(ensureBytes3("extraEntropy", e));
    }
    const seed = concatBytes4(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = Fn.create(q.x);
      if (r === _0n72)
        return;
      const s = Fn.create(ik * Fn.create(m + r * d));
      if (s === _0n72)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n72);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  function sign3(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const drbg = createHmacDrbg3(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
    return drbg(seed, k2sig);
  }
  Point2.BASE.precompute(8);
  function verify2(signature, msgHash, publicKey2, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes3("msgHash", msgHash);
    publicKey2 = ensureBytes3("publicKey", publicKey2);
    validateSigVerOpts2(opts);
    const { lowS, prehash, format } = opts;
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== undefined && !["compact", "der", "js"].includes(format))
      throw new Error('format must be "compact", "der" or "js"');
    const isHex2 = typeof sg === "string" || isBytes2(sg);
    const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = undefined;
    let P22;
    try {
      if (isObj) {
        if (format === undefined || format === "js") {
          _sig = new Signature2(sg.r, sg.s);
        } else {
          throw new Error("invalid format");
        }
      }
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER3.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature2.fromCompact(sg);
      }
      P22 = Point2.fromHex(publicKey2);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = ecdsaOpts.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is22 = Fn.inv(s);
    const u1 = Fn.create(h * is22);
    const u2 = Fn.create(r * is22);
    const R = Point2.BASE.multiplyUnsafe(u1).add(P22.multiplyUnsafe(u2));
    if (R.is0())
      return false;
    const v = Fn.create(R.x);
    return v === r;
  }
  return Object.freeze({
    getPublicKey: getPublicKey2,
    getSharedSecret,
    sign: sign3,
    verify: verify2,
    utils,
    Point: Point2,
    Signature: Signature2
  });
}
function _weierstrass_legacy_opts_to_new2(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp22 = c.Fp;
  const Fn = Field3(CURVE.n, c.nBitLength);
  const curveOpts = {
    Fp: Fp22,
    Fn,
    allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    wrapPrivateKey: c.wrapPrivateKey,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new2(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new2(c);
  const ecdsaOpts = {
    hash: c.hash,
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy2(c, ecdsa22) {
  return Object.assign({}, ecdsa22, {
    ProjectivePoint: ecdsa22.Point,
    CURVE: c
  });
}
function weierstrass3(c) {
  const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new2(c);
  const Point2 = weierstrassN2(CURVE, curveOpts);
  const signs = ecdsa2(Point2, ecdsaOpts, curveOpts);
  return _ecdsa_new_output_to_legacy2(c, signs);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function createCurve3(curveDef, defHash) {
  const create22 = (hash2) => weierstrass3({ ...curveDef, hash: hash2 });
  return { ...create22(defHash), create: create22 };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var secp256k1_CURVE2 = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var _0n82 = BigInt(0);
var _1n82 = BigInt(1);
var _2n62 = BigInt(2);
var divNearest3 = (a, b22) => (a + b22 / _2n62) / b22;
function sqrtMod3(y) {
  const P22 = secp256k1_CURVE2.p;
  const _3n42 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y * y * y % P22;
  const b3 = b22 * b22 * y % P22;
  const b6 = pow24(b3, _3n42, P22) * b3 % P22;
  const b9 = pow24(b6, _3n42, P22) * b3 % P22;
  const b11 = pow24(b9, _2n62, P22) * b22 % P22;
  const b222 = pow24(b11, _11n, P22) * b11 % P22;
  const b44 = pow24(b222, _22n, P22) * b222 % P22;
  const b88 = pow24(b44, _44n, P22) * b44 % P22;
  const b176 = pow24(b88, _88n, P22) * b88 % P22;
  const b220 = pow24(b176, _44n, P22) * b44 % P22;
  const b223 = pow24(b220, _3n42, P22) * b3 % P22;
  const t1 = pow24(b223, _23n, P22) * b222 % P22;
  const t2 = pow24(t1, _6n, P22) * b22 % P22;
  const root = pow24(t2, _2n62, P22);
  if (!Fpk12.eql(Fpk12.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk12 = Field3(secp256k1_CURVE2.p, undefined, undefined, { sqrt: sqrtMod3 });
var secp256k13 = createCurve3({
  ...secp256k1_CURVE2,
  Fp: Fpk12,
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1_CURVE2.n;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n82 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest3(b22 * k, n2);
      const c2 = divNearest3(-b1 * k, n2);
      let k1 = mod4(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod4(-c1 * b1 - c2 * b22, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2565);
var generatePrivateKey2 = ed255192.utils.randomPrivateKey;
var generateKeypair2 = () => {
  const privateScalar = ed255192.utils.randomPrivateKey();
  const publicKey2 = getPublicKey2(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey2, 32);
  return {
    publicKey: publicKey2,
    secretKey
  };
};
var getPublicKey2 = ed255192.getPublicKey;
function isOnCurve2(publicKey2) {
  try {
    ed255192.ExtendedPoint.fromHex(publicKey2);
    return true;
  } catch {
    return false;
  }
}
var sign3 = (message, secretKey) => ed255192.sign(message, secretKey.slice(0, 32));
var verify2 = ed255192.verify;
var toBuffer2 = (arr) => {
  if (export_Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return export_Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return export_Buffer.from(arr);
  }
};

class Struct22 {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return export_Buffer.from(import_borsh2.serialize(SOLANA_SCHEMA2, this));
  }
  static decode(data) {
    return import_borsh2.deserialize(SOLANA_SCHEMA2, this, data);
  }
  static decodeUnchecked(data) {
    return import_borsh2.deserializeUnchecked(SOLANA_SCHEMA2, this, data);
  }
}
var SOLANA_SCHEMA2 = new Map;
var _PublicKey2;
var MAX_SEED_LENGTH2 = 32;
var PUBLIC_KEY_LENGTH2 = 32;
function isPublicKeyData2(value) {
  return value._bn !== undefined;
}
var uniquePublicKeyCounter2 = 1;

class PublicKey2 extends Struct22 {
  constructor(value) {
    super({});
    this._bn = undefined;
    if (isPublicKeyData2(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs583.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH2) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn2.default(decoded);
      } else {
        this._bn = new import_bn2.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH2) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  static unique() {
    const key = new PublicKey2(uniquePublicKeyCounter2);
    uniquePublicKeyCounter2 += 1;
    return new PublicKey2(key.toBuffer());
  }
  equals(publicKey2) {
    return this._bn.eq(publicKey2._bn);
  }
  toBase58() {
    return import_bs583.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  toBuffer() {
    const b22 = this._bn.toArrayLike(export_Buffer);
    if (b22.length === PUBLIC_KEY_LENGTH2) {
      return b22;
    }
    const zeroPad2 = export_Buffer.alloc(32);
    b22.copy(zeroPad2, 32 - b22.length);
    return zeroPad2;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer = export_Buffer.concat([fromPublicKey.toBuffer(), export_Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha25622(buffer);
    return new PublicKey2(publicKeyBytes);
  }
  static createProgramAddressSync(seeds, programId) {
    let buffer = export_Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH2) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = export_Buffer.concat([buffer, toBuffer2(seed)]);
    });
    buffer = export_Buffer.concat([buffer, programId.toBuffer(), export_Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha25622(buffer);
    if (isOnCurve2(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey2(publicKeyBytes);
  }
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(export_Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey2(pubkeyData);
    return isOnCurve2(pubkey.toBytes());
  }
}
_PublicKey2 = PublicKey2;
PublicKey2.default = new _PublicKey2("11111111111111111111111111111111");
SOLANA_SCHEMA2.set(PublicKey2, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID2 = new PublicKey2("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE2 = 1280 - 40 - 8;
var VERSION_PREFIX_MASK2 = 127;
var SIGNATURE_LENGTH_IN_BYTES2 = 64;

class TransactionExpiredBlockheightExceededError2 extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError2.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});

class TransactionExpiredTimeoutError2 extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + "unknown if it succeeded or failed. Check signature " + `${signature} using the Solana Explorer or CLI tools.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError2.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});

class TransactionExpiredNonceInvalidError2 extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError2.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});

class MessageAccountKeys2 {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = undefined;
    this.accountKeysFromLookups = undefined;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = new Map;
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === undefined)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}
var publicKey2 = (property = "publicKey") => {
  return BufferLayout2.blob(32, property);
};
var rustString2 = (property = "string") => {
  const rsl = BufferLayout2.struct([BufferLayout2.u32("length"), BufferLayout2.u32("lengthPadding"), BufferLayout2.blob(BufferLayout2.offset(BufferLayout2.u32(), -8), "chars")], property);
  const _decode2 = rsl.decode.bind(rsl);
  const _encode2 = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b22, offset2) => {
    const data = _decode2(b22, offset2);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b22, offset2) => {
    const data = {
      chars: export_Buffer.from(str, "utf8")
    };
    return _encode2(data, b22, offset2);
  };
  rslShim.alloc = (str) => {
    return BufferLayout2.u32().span + BufferLayout2.u32().span + export_Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized2 = (property = "authorized") => {
  return BufferLayout2.struct([publicKey2("staker"), publicKey2("withdrawer")], property);
};
var lockup2 = (property = "lockup") => {
  return BufferLayout2.struct([BufferLayout2.ns64("unixTimestamp"), BufferLayout2.ns64("epoch"), publicKey2("custodian")], property);
};
var voteInit2 = (property = "voteInit") => {
  return BufferLayout2.struct([publicKey2("nodePubkey"), publicKey2("authorizedVoter"), publicKey2("authorizedWithdrawer"), BufferLayout2.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs2 = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout2.struct([BufferLayout2.u32("voteAuthorizationType"), publicKey2("currentAuthorityDerivedKeyOwnerPubkey"), rustString2("currentAuthorityDerivedKeySeed"), publicKey2("newAuthorized")], property);
};
function getAlloc2(type22, fields2) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields2[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields2[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc2({
        layout: item
      }, fields2[item.property]);
    }
    return 0;
  };
  let alloc2 = 0;
  type22.layout.fields.forEach((item) => {
    alloc2 += getItemAlloc(item);
  });
  return alloc2;
}
function decodeLength2(bytes2) {
  let len2 = 0;
  let size = 0;
  for (;; ) {
    let elem = bytes2.shift();
    len2 |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len2;
}
function encodeLength2(bytes2, len2) {
  let rem_len = len2;
  for (;; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem);
      break;
    } else {
      elem |= 128;
      bytes2.push(elem);
    }
  }
}
function assert22(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

class CompiledKeys2 {
  constructor(payer, keyMetaMap) {
    this.payer = undefined;
    this.keyMetaMap = undefined;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = new Map;
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === undefined) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner ||= accountMeta.isSigner;
        keyMeta.isWritable ||= accountMeta.isWritable;
      }
    }
    return new CompiledKeys2(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert22(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert22(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert22(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey2(address)), ...readonlySigners.map(([address]) => new PublicKey2(address)), ...writableNonSigners.map(([address]) => new PublicKey2(address)), ...readonlyNonSigners.map(([address]) => new PublicKey2(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array;
    const drainedKeys = new Array;
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey2(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert22(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}
var END_OF_BUFFER_ERROR_MESSAGE2 = "Reached end of buffer unexpectedly";
function guardedShift2(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE2);
  }
  return byteArray.shift();
}
function guardedSplice2(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE2);
  }
  return byteArray.splice(...args);
}

class Message2 {
  constructor(args) {
    this.header = undefined;
    this.accountKeys = undefined;
    this.recentBlockhash = undefined;
    this.instructions = undefined;
    this.indexToProgramIds = new Map;
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey2(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs583.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys2(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys2.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys2(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs583.default.encode(ix.data)
    }));
    return new Message2({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength2(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs583.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength2(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength2(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: export_Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: export_Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength2(instructionCount, instructions.length);
    let instructionBuffer = export_Buffer.alloc(PACKET_DATA_SIZE2);
    export_Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout2.struct([BufferLayout2.u8("programIdIndex"), BufferLayout2.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout2.seq(BufferLayout2.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout2.blob(instruction.dataLength.length, "dataLength"), BufferLayout2.seq(BufferLayout2.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout2.struct([BufferLayout2.blob(1, "numRequiredSignatures"), BufferLayout2.blob(1, "numReadonlySignedAccounts"), BufferLayout2.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout2.blob(keyCount.length, "keyCount"), BufferLayout2.seq(publicKey2("key"), numKeys, "keys"), publicKey2("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: export_Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: export_Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: export_Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: export_Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer2(key.toBytes())),
      recentBlockhash: import_bs583.default.decode(this.recentBlockhash)
    };
    let signData = export_Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift2(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK2)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift2(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift2(byteArray);
    const accountCount = decodeLength2(byteArray);
    let accountKeys = [];
    for (let i22 = 0;i22 < accountCount; i22++) {
      const account = guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2);
      accountKeys.push(new PublicKey2(export_Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice2(byteArray, 0, PUBLIC_KEY_LENGTH2);
    const instructionCount = decodeLength2(byteArray);
    let instructions = [];
    for (let i22 = 0;i22 < instructionCount; i22++) {
      const programIdIndex = guardedShift2(byteArray);
      const accountCount2 = decodeLength2(byteArray);
      const accounts = guardedSplice2(byteArray, 0, accountCount2);
      const dataLength2 = decodeLength2(byteArray);
      const dataSlice2 = guardedSplice2(byteArray, 0, dataLength2);
      const data = import_bs583.default.encode(export_Buffer.from(dataSlice2));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs583.default.encode(export_Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message2(messageArgs);
  }
}
var DEFAULT_SIGNATURE2 = export_Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES2).fill(0);

class TransactionInstruction2 {
  constructor(opts) {
    this.keys = undefined;
    this.programId = undefined;
    this.data = export_Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}

class Transaction3 {
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  constructor(opts) {
    this.signatures = [];
    this.feePayer = undefined;
    this.instructions = [];
    this.recentBlockhash = undefined;
    this.lastValidBlockHeight = undefined;
    this.nonceInfo = undefined;
    this.minNonceContextSlot = undefined;
    this._message = undefined;
    this._json = undefined;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey22
      }) => {
        return publicKey22.toJSON();
      })
    };
  }
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction2(item));
      }
    });
    return this;
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i22 = 0;i22 < instructions.length; i22++) {
      if (instructions[i22].programId === undefined) {
        throw new Error(`Transaction instruction index ${i22} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey2(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x2, y) {
      if (x2.isSigner !== y.isSigner) {
        return x2.isSigner ? -1 : 1;
      }
      if (x2.isWritable !== y.isWritable) {
        return x2.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x2.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x2) => {
      return x2.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.equals(signature.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, " + "only the fee payer and instruction signer accounts should sign a transaction. " + "This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs583.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert22(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert22(keyIndex >= 0));
    });
    return new Message2({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid)
        return message;
    }
    this.signatures = signedKeys.map((publicKey22) => ({
      signature: null,
      publicKey: publicKey22
    }));
    return message;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    this.signatures = signers.filter((publicKey22) => {
      const key = publicKey22.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey22) => ({
      signature: null,
      publicKey: publicKey22
    }));
  }
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature = sign3(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer2(signature));
    });
  }
  addSignature(pubkey, signature) {
    this._compile();
    this._addSignature(pubkey, signature);
  }
  _addSignature(pubkey, signature) {
    assert22(signature.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = export_Buffer.from(signature);
  }
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature,
      publicKey: publicKey22
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          (errors.missing ||= []).push(publicKey22);
        }
      } else {
        if (!verify2(signature, message, publicKey22.toBytes())) {
          (errors.invalid ||= []).push(publicKey22);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : undefined;
  }
  serialize(config2) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config2);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength2(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = export_Buffer.alloc(transactionLength);
    assert22(signatures.length < 256);
    export_Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert22(signature.length === 64, `signature has invalid length`);
        export_Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert22(wireTransaction.length <= PACKET_DATA_SIZE2, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE2}`);
    return wireTransaction;
  }
  get keys() {
    assert22(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  get programId() {
    assert22(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  get data() {
    assert22(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength2(byteArray);
    let signatures = [];
    for (let i22 = 0;i22 < signatureCount; i22++) {
      const signature = guardedSplice2(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES2);
      signatures.push(import_bs583.default.encode(export_Buffer.from(signature)));
    }
    return Transaction3.populate(Message2.from(byteArray), signatures);
  }
  static populate(message, signatures = []) {
    const transaction = new Transaction3;
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == import_bs583.default.encode(DEFAULT_SIGNATURE2) ? null : import_bs583.default.decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction2({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs583.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
}
var NUM_TICKS_PER_SECOND2 = 160;
var DEFAULT_TICKS_PER_SLOT2 = 64;
var NUM_SLOTS_PER_SECOND2 = NUM_TICKS_PER_SECOND2 / DEFAULT_TICKS_PER_SLOT2;
var MS_PER_SLOT2 = 1000 / NUM_SLOTS_PER_SECOND2;
var SYSVAR_CLOCK_PUBKEY2 = new PublicKey2("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY2 = new PublicKey2("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY2 = new PublicKey2("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY2 = new PublicKey2("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY2 = new PublicKey2("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY2 = new PublicKey2("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY2 = new PublicKey2("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY2 = new PublicKey2("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY2 = new PublicKey2("SysvarStakeHistory1111111111111111111111111");

class SendTransactionError2 extends Error {
  constructor({
    action,
    signature,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature} resulted in an error. 
` + `${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${((a) => a)(action)}'`;
      }
    }
    super(message);
    this.signature = undefined;
    this.transactionMessage = undefined;
    this.transactionLogs = undefined;
    this.signature = signature;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : undefined;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined
    };
  }
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
}
async function sendAndConfirmTransaction2(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was " + "supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` " + "or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature != null) {
      throw new SendTransactionError2({
        action: "send",
        signature,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
function sleep2(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function encodeData2(type22, fields2) {
  const allocLength = type22.layout.span >= 0 ? type22.layout.span : getAlloc2(type22, fields2);
  const data = export_Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type22.index
  }, fields2);
  type22.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout2 = BufferLayout2.nu64("lamportsPerSignature");
var NonceAccountLayout2 = BufferLayout2.struct([BufferLayout2.u32("version"), BufferLayout2.u32("state"), publicKey2("authorizedPubkey"), publicKey2("nonce"), BufferLayout2.struct([FeeCalculatorLayout2], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH2 = NonceAccountLayout2.span;
function u643(property) {
  const layout = import_buffer_layout2.blob(8, property);
  const decode22 = layout.decode.bind(layout);
  const encode2 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec2();
  bigIntLayout.decode = (buffer, offset2) => {
    const src = decode22(buffer, offset2);
    return codec.decode(src);
  };
  bigIntLayout.encode = (bigInt, buffer, offset2) => {
    const src = codec.encode(bigInt);
    return encode2(src, buffer, offset2);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS2 = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports"), BufferLayout2.ns64("space"), publicKey2("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), u643("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("base"), rustString2("seed"), BufferLayout2.ns64("lamports"), BufferLayout2.ns64("space"), publicKey2("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("base"), rustString2("seed"), BufferLayout2.ns64("space"), publicKey2("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("base"), rustString2("seed"), publicKey2("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), u643("lamports"), rustString2("seed"), publicKey2("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  }
});

class SystemProgram2 {
  constructor() {}
  static createAccount(params) {
    const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.Create;
    const data = encodeData2(type22, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer2(params.programId.toBuffer())
    });
    return new TransactionInstruction2({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.TransferWithSeed;
      data = encodeData2(type22, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer2(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.Transfer;
      data = encodeData2(type22, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction2({
      keys,
      programId: this.programId,
      data
    });
  }
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.AssignWithSeed;
      data = encodeData2(type22, {
        base: toBuffer2(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer2(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.Assign;
      data = encodeData2(type22, {
        programId: toBuffer2(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction2({
      keys,
      programId: this.programId,
      data
    });
  }
  static createAccountWithSeed(params) {
    const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.CreateWithSeed;
    const data = encodeData2(type22, {
      base: toBuffer2(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer2(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction2({
      keys,
      programId: this.programId,
      data
    });
  }
  static createNonceAccount(params) {
    const transaction = new Transaction3;
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(SystemProgram2.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH2,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram2.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH2,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  static nonceInitialize(params) {
    const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.InitializeNonceAccount;
    const data = encodeData2(type22, {
      authorized: toBuffer2(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY2,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction2(instructionData);
  }
  static nonceAdvance(params) {
    const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.AdvanceNonceAccount;
    const data = encodeData2(type22);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction2(instructionData);
  }
  static nonceWithdraw(params) {
    const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.WithdrawNonceAccount;
    const data = encodeData2(type22, {
      lamports: params.lamports
    });
    return new TransactionInstruction2({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static nonceAuthorize(params) {
    const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.AuthorizeNonceAccount;
    const data = encodeData2(type22, {
      authorized: toBuffer2(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction2({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.AllocateWithSeed;
      data = encodeData2(type22, {
        base: toBuffer2(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer2(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type22 = SYSTEM_INSTRUCTION_LAYOUTS2.Allocate;
      data = encodeData2(type22, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction2({
      keys,
      programId: this.programId,
      data
    });
  }
}
SystemProgram2.programId = new PublicKey2("11111111111111111111111111111111");
var CHUNK_SIZE2 = PACKET_DATA_SIZE2 - 300;

class Loader2 {
  constructor() {}
  static getMinNumSignatures(dataLength2) {
    return 2 * (Math.ceil(dataLength2 / Loader2.chunkSize) + 1 + 1);
  }
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction3;
          transaction.add(SystemProgram2.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction3;
          transaction.add(SystemProgram2.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction3;
          transaction.add(SystemProgram2.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction3().add(SystemProgram2.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction2(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.u32("offset"), BufferLayout2.u32("bytesLength"), BufferLayout2.u32("bytesLengthPadding"), BufferLayout2.seq(BufferLayout2.u8("byte"), BufferLayout2.offset(BufferLayout2.u32(), -8), "bytes")]);
    const chunkSize = Loader2.chunkSize;
    let offset2 = 0;
    let array22 = data;
    let transactions = [];
    while (array22.length > 0) {
      const bytes2 = array22.slice(0, chunkSize);
      const data2 = export_Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        offset: offset2,
        bytes: bytes2,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction3().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction2(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep2(1000 / REQUESTS_PER_SECOND);
      }
      offset2 += chunkSize;
      array22 = array22.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout2.struct([BufferLayout2.u32("instruction")]);
      const data2 = export_Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
      }, data2);
      const transaction = new Transaction3().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY2,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {}
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT2 / 2)));
      }
    }
    return true;
  }
}
Loader2.chunkSize = CHUNK_SIZE2;
var BPF_LOADER_PROGRAM_ID2 = new PublicKey2("BPFLoader2111111111111111111111111111111111");
var fetchImpl2 = globalThis.fetch;
var LookupTableMetaLayout2 = {
  index: 1,
  layout: BufferLayout2.struct([
    BufferLayout2.u32("typeIndex"),
    u643("deactivationSlot"),
    BufferLayout2.nu64("lastExtendedSlot"),
    BufferLayout2.u8("lastExtendedStartIndex"),
    BufferLayout2.u8(),
    BufferLayout2.seq(publicKey2(), BufferLayout2.offset(BufferLayout2.u8(), -1), "authority")
  ])
};
var PublicKeyFromString2 = coerce2(instance2(PublicKey2), string2(), (value) => new PublicKey2(value));
var RawAccountDataResult2 = tuple2([string2(), literal2("base64")]);
var BufferFromRawAccountData2 = coerce2(instance2(export_Buffer), RawAccountDataResult2, (value) => export_Buffer.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS2 = 30 * 1000;
function createRpcResult2(result) {
  return union2([type2({
    jsonrpc: literal2("2.0"),
    id: string2(),
    result
  }), type2({
    jsonrpc: literal2("2.0"),
    id: string2(),
    error: type2({
      code: unknown2(),
      message: string2(),
      data: optional2(any2())
    })
  })]);
}
var UnknownRpcResult2 = createRpcResult2(unknown2());
function jsonRpcResult2(schema) {
  return coerce2(createRpcResult2(schema), UnknownRpcResult2, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create4(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext2(value) {
  return jsonRpcResult2(type2({
    context: type2({
      slot: number3()
    }),
    value
  }));
}
function notificationResultAndContext2(value) {
  return type2({
    context: type2({
      slot: number3()
    }),
    value
  });
}
var GetInflationGovernorResult2 = type2({
  foundation: number3(),
  foundationTerm: number3(),
  initial: number3(),
  taper: number3(),
  terminal: number3()
});
var GetInflationRewardResult2 = jsonRpcResult2(array2(nullable2(type2({
  epoch: number3(),
  effectiveSlot: number3(),
  amount: number3(),
  postBalance: number3(),
  commission: optional2(nullable2(number3()))
}))));
var GetRecentPrioritizationFeesResult2 = array2(type2({
  slot: number3(),
  prioritizationFee: number3()
}));
var GetInflationRateResult2 = type2({
  total: number3(),
  validator: number3(),
  foundation: number3(),
  epoch: number3()
});
var GetEpochInfoResult2 = type2({
  epoch: number3(),
  slotIndex: number3(),
  slotsInEpoch: number3(),
  absoluteSlot: number3(),
  blockHeight: optional2(number3()),
  transactionCount: optional2(number3())
});
var GetEpochScheduleResult2 = type2({
  slotsPerEpoch: number3(),
  leaderScheduleSlotOffset: number3(),
  warmup: boolean2(),
  firstNormalEpoch: number3(),
  firstNormalSlot: number3()
});
var GetLeaderScheduleResult2 = record2(string2(), array2(number3()));
var TransactionErrorResult2 = nullable2(union2([type2({}), string2()]));
var SignatureStatusResult2 = type2({
  err: TransactionErrorResult2
});
var SignatureReceivedResult2 = literal2("receivedSignature");
var VersionResult2 = type2({
  "solana-core": string2(),
  "feature-set": optional2(number3())
});
var ParsedInstructionStruct2 = type2({
  program: string2(),
  programId: PublicKeyFromString2,
  parsed: unknown2()
});
var PartiallyDecodedInstructionStruct2 = type2({
  programId: PublicKeyFromString2,
  accounts: array2(PublicKeyFromString2),
  data: string2()
});
var SimulatedTransactionResponseStruct2 = jsonRpcResultAndContext2(type2({
  err: nullable2(union2([type2({}), string2()])),
  logs: nullable2(array2(string2())),
  accounts: optional2(nullable2(array2(nullable2(type2({
    executable: boolean2(),
    owner: string2(),
    lamports: number3(),
    data: array2(string2()),
    rentEpoch: optional2(number3())
  }))))),
  unitsConsumed: optional2(number3()),
  returnData: optional2(nullable2(type2({
    programId: string2(),
    data: tuple2([string2(), literal2("base64")])
  }))),
  innerInstructions: optional2(nullable2(array2(type2({
    index: number3(),
    instructions: array2(union2([ParsedInstructionStruct2, PartiallyDecodedInstructionStruct2]))
  }))))
}));
var BlockProductionResponseStruct2 = jsonRpcResultAndContext2(type2({
  byIdentity: record2(string2(), array2(number3())),
  range: type2({
    firstSlot: number3(),
    lastSlot: number3()
  })
}));
var GetInflationGovernorRpcResult2 = jsonRpcResult2(GetInflationGovernorResult2);
var GetInflationRateRpcResult2 = jsonRpcResult2(GetInflationRateResult2);
var GetRecentPrioritizationFeesRpcResult2 = jsonRpcResult2(GetRecentPrioritizationFeesResult2);
var GetEpochInfoRpcResult2 = jsonRpcResult2(GetEpochInfoResult2);
var GetEpochScheduleRpcResult2 = jsonRpcResult2(GetEpochScheduleResult2);
var GetLeaderScheduleRpcResult2 = jsonRpcResult2(GetLeaderScheduleResult2);
var SlotRpcResult2 = jsonRpcResult2(number3());
var GetSupplyRpcResult2 = jsonRpcResultAndContext2(type2({
  total: number3(),
  circulating: number3(),
  nonCirculating: number3(),
  nonCirculatingAccounts: array2(PublicKeyFromString2)
}));
var TokenAmountResult2 = type2({
  amount: string2(),
  uiAmount: nullable2(number3()),
  decimals: number3(),
  uiAmountString: optional2(string2())
});
var GetTokenLargestAccountsResult2 = jsonRpcResultAndContext2(array2(type2({
  address: PublicKeyFromString2,
  amount: string2(),
  uiAmount: nullable2(number3()),
  decimals: number3(),
  uiAmountString: optional2(string2())
})));
var GetTokenAccountsByOwner2 = jsonRpcResultAndContext2(array2(type2({
  pubkey: PublicKeyFromString2,
  account: type2({
    executable: boolean2(),
    owner: PublicKeyFromString2,
    lamports: number3(),
    data: BufferFromRawAccountData2,
    rentEpoch: number3()
  })
})));
var ParsedAccountDataResult2 = type2({
  program: string2(),
  parsed: unknown2(),
  space: number3()
});
var GetParsedTokenAccountsByOwner2 = jsonRpcResultAndContext2(array2(type2({
  pubkey: PublicKeyFromString2,
  account: type2({
    executable: boolean2(),
    owner: PublicKeyFromString2,
    lamports: number3(),
    data: ParsedAccountDataResult2,
    rentEpoch: number3()
  })
})));
var GetLargestAccountsRpcResult2 = jsonRpcResultAndContext2(array2(type2({
  lamports: number3(),
  address: PublicKeyFromString2
})));
var AccountInfoResult2 = type2({
  executable: boolean2(),
  owner: PublicKeyFromString2,
  lamports: number3(),
  data: BufferFromRawAccountData2,
  rentEpoch: number3()
});
var KeyedAccountInfoResult2 = type2({
  pubkey: PublicKeyFromString2,
  account: AccountInfoResult2
});
var ParsedOrRawAccountData2 = coerce2(union2([instance2(export_Buffer), ParsedAccountDataResult2]), union2([RawAccountDataResult2, ParsedAccountDataResult2]), (value) => {
  if (Array.isArray(value)) {
    return create4(value, BufferFromRawAccountData2);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult2 = type2({
  executable: boolean2(),
  owner: PublicKeyFromString2,
  lamports: number3(),
  data: ParsedOrRawAccountData2,
  rentEpoch: number3()
});
var KeyedParsedAccountInfoResult2 = type2({
  pubkey: PublicKeyFromString2,
  account: ParsedAccountInfoResult2
});
var StakeActivationResult2 = type2({
  state: union2([literal2("active"), literal2("inactive"), literal2("activating"), literal2("deactivating")]),
  active: number3(),
  inactive: number3()
});
var GetConfirmedSignaturesForAddress2RpcResult2 = jsonRpcResult2(array2(type2({
  signature: string2(),
  slot: number3(),
  err: TransactionErrorResult2,
  memo: nullable2(string2()),
  blockTime: optional2(nullable2(number3()))
})));
var GetSignaturesForAddressRpcResult2 = jsonRpcResult2(array2(type2({
  signature: string2(),
  slot: number3(),
  err: TransactionErrorResult2,
  memo: nullable2(string2()),
  blockTime: optional2(nullable2(number3()))
})));
var AccountNotificationResult2 = type2({
  subscription: number3(),
  result: notificationResultAndContext2(AccountInfoResult2)
});
var ProgramAccountInfoResult2 = type2({
  pubkey: PublicKeyFromString2,
  account: AccountInfoResult2
});
var ProgramAccountNotificationResult2 = type2({
  subscription: number3(),
  result: notificationResultAndContext2(ProgramAccountInfoResult2)
});
var SlotInfoResult2 = type2({
  parent: number3(),
  slot: number3(),
  root: number3()
});
var SlotNotificationResult2 = type2({
  subscription: number3(),
  result: SlotInfoResult2
});
var SlotUpdateResult2 = union2([type2({
  type: union2([literal2("firstShredReceived"), literal2("completed"), literal2("optimisticConfirmation"), literal2("root")]),
  slot: number3(),
  timestamp: number3()
}), type2({
  type: literal2("createdBank"),
  parent: number3(),
  slot: number3(),
  timestamp: number3()
}), type2({
  type: literal2("frozen"),
  slot: number3(),
  timestamp: number3(),
  stats: type2({
    numTransactionEntries: number3(),
    numSuccessfulTransactions: number3(),
    numFailedTransactions: number3(),
    maxTransactionsPerEntry: number3()
  })
}), type2({
  type: literal2("dead"),
  slot: number3(),
  timestamp: number3(),
  err: string2()
})]);
var SlotUpdateNotificationResult2 = type2({
  subscription: number3(),
  result: SlotUpdateResult2
});
var SignatureNotificationResult2 = type2({
  subscription: number3(),
  result: notificationResultAndContext2(union2([SignatureStatusResult2, SignatureReceivedResult2]))
});
var RootNotificationResult2 = type2({
  subscription: number3(),
  result: number3()
});
var ContactInfoResult2 = type2({
  pubkey: string2(),
  gossip: nullable2(string2()),
  tpu: nullable2(string2()),
  rpc: nullable2(string2()),
  version: nullable2(string2())
});
var VoteAccountInfoResult2 = type2({
  votePubkey: string2(),
  nodePubkey: string2(),
  activatedStake: number3(),
  epochVoteAccount: boolean2(),
  epochCredits: array2(tuple2([number3(), number3(), number3()])),
  commission: number3(),
  lastVote: number3(),
  rootSlot: nullable2(number3())
});
var GetVoteAccounts2 = jsonRpcResult2(type2({
  current: array2(VoteAccountInfoResult2),
  delinquent: array2(VoteAccountInfoResult2)
}));
var ConfirmationStatus2 = union2([literal2("processed"), literal2("confirmed"), literal2("finalized")]);
var SignatureStatusResponse2 = type2({
  slot: number3(),
  confirmations: nullable2(number3()),
  err: TransactionErrorResult2,
  confirmationStatus: optional2(ConfirmationStatus2)
});
var GetSignatureStatusesRpcResult2 = jsonRpcResultAndContext2(array2(nullable2(SignatureStatusResponse2)));
var GetMinimumBalanceForRentExemptionRpcResult2 = jsonRpcResult2(number3());
var AddressTableLookupStruct2 = type2({
  accountKey: PublicKeyFromString2,
  writableIndexes: array2(number3()),
  readonlyIndexes: array2(number3())
});
var ConfirmedTransactionResult2 = type2({
  signatures: array2(string2()),
  message: type2({
    accountKeys: array2(string2()),
    header: type2({
      numRequiredSignatures: number3(),
      numReadonlySignedAccounts: number3(),
      numReadonlyUnsignedAccounts: number3()
    }),
    instructions: array2(type2({
      accounts: array2(number3()),
      data: string2(),
      programIdIndex: number3()
    })),
    recentBlockhash: string2(),
    addressTableLookups: optional2(array2(AddressTableLookupStruct2))
  })
});
var AnnotatedAccountKey2 = type2({
  pubkey: PublicKeyFromString2,
  signer: boolean2(),
  writable: boolean2(),
  source: optional2(union2([literal2("transaction"), literal2("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult2 = type2({
  accountKeys: array2(AnnotatedAccountKey2),
  signatures: array2(string2())
});
var ParsedInstructionResult2 = type2({
  parsed: unknown2(),
  program: string2(),
  programId: PublicKeyFromString2
});
var RawInstructionResult2 = type2({
  accounts: array2(PublicKeyFromString2),
  data: string2(),
  programId: PublicKeyFromString2
});
var InstructionResult2 = union2([RawInstructionResult2, ParsedInstructionResult2]);
var UnknownInstructionResult2 = union2([type2({
  parsed: unknown2(),
  program: string2(),
  programId: string2()
}), type2({
  accounts: array2(string2()),
  data: string2(),
  programId: string2()
})]);
var ParsedOrRawInstruction2 = coerce2(InstructionResult2, UnknownInstructionResult2, (value) => {
  if ("accounts" in value) {
    return create4(value, RawInstructionResult2);
  } else {
    return create4(value, ParsedInstructionResult2);
  }
});
var ParsedConfirmedTransactionResult2 = type2({
  signatures: array2(string2()),
  message: type2({
    accountKeys: array2(AnnotatedAccountKey2),
    instructions: array2(ParsedOrRawInstruction2),
    recentBlockhash: string2(),
    addressTableLookups: optional2(nullable2(array2(AddressTableLookupStruct2)))
  })
});
var TokenBalanceResult2 = type2({
  accountIndex: number3(),
  mint: string2(),
  owner: optional2(string2()),
  programId: optional2(string2()),
  uiTokenAmount: TokenAmountResult2
});
var LoadedAddressesResult2 = type2({
  writable: array2(PublicKeyFromString2),
  readonly: array2(PublicKeyFromString2)
});
var ConfirmedTransactionMetaResult2 = type2({
  err: TransactionErrorResult2,
  fee: number3(),
  innerInstructions: optional2(nullable2(array2(type2({
    index: number3(),
    instructions: array2(type2({
      accounts: array2(number3()),
      data: string2(),
      programIdIndex: number3()
    }))
  })))),
  preBalances: array2(number3()),
  postBalances: array2(number3()),
  logMessages: optional2(nullable2(array2(string2()))),
  preTokenBalances: optional2(nullable2(array2(TokenBalanceResult2))),
  postTokenBalances: optional2(nullable2(array2(TokenBalanceResult2))),
  loadedAddresses: optional2(LoadedAddressesResult2),
  computeUnitsConsumed: optional2(number3()),
  costUnits: optional2(number3())
});
var ParsedConfirmedTransactionMetaResult2 = type2({
  err: TransactionErrorResult2,
  fee: number3(),
  innerInstructions: optional2(nullable2(array2(type2({
    index: number3(),
    instructions: array2(ParsedOrRawInstruction2)
  })))),
  preBalances: array2(number3()),
  postBalances: array2(number3()),
  logMessages: optional2(nullable2(array2(string2()))),
  preTokenBalances: optional2(nullable2(array2(TokenBalanceResult2))),
  postTokenBalances: optional2(nullable2(array2(TokenBalanceResult2))),
  loadedAddresses: optional2(LoadedAddressesResult2),
  computeUnitsConsumed: optional2(number3()),
  costUnits: optional2(number3())
});
var TransactionVersionStruct2 = union2([literal2(0), literal2("legacy")]);
var RewardsResult2 = type2({
  pubkey: string2(),
  lamports: number3(),
  postBalance: nullable2(number3()),
  rewardType: nullable2(string2()),
  commission: optional2(nullable2(number3()))
});
var GetBlockRpcResult2 = jsonRpcResult2(nullable2(type2({
  blockhash: string2(),
  previousBlockhash: string2(),
  parentSlot: number3(),
  transactions: array2(type2({
    transaction: ConfirmedTransactionResult2,
    meta: nullable2(ConfirmedTransactionMetaResult2),
    version: optional2(TransactionVersionStruct2)
  })),
  rewards: optional2(array2(RewardsResult2)),
  blockTime: nullable2(number3()),
  blockHeight: nullable2(number3())
})));
var GetNoneModeBlockRpcResult2 = jsonRpcResult2(nullable2(type2({
  blockhash: string2(),
  previousBlockhash: string2(),
  parentSlot: number3(),
  rewards: optional2(array2(RewardsResult2)),
  blockTime: nullable2(number3()),
  blockHeight: nullable2(number3())
})));
var GetAccountsModeBlockRpcResult2 = jsonRpcResult2(nullable2(type2({
  blockhash: string2(),
  previousBlockhash: string2(),
  parentSlot: number3(),
  transactions: array2(type2({
    transaction: ConfirmedTransactionAccountsModeResult2,
    meta: nullable2(ConfirmedTransactionMetaResult2),
    version: optional2(TransactionVersionStruct2)
  })),
  rewards: optional2(array2(RewardsResult2)),
  blockTime: nullable2(number3()),
  blockHeight: nullable2(number3())
})));
var GetParsedBlockRpcResult2 = jsonRpcResult2(nullable2(type2({
  blockhash: string2(),
  previousBlockhash: string2(),
  parentSlot: number3(),
  transactions: array2(type2({
    transaction: ParsedConfirmedTransactionResult2,
    meta: nullable2(ParsedConfirmedTransactionMetaResult2),
    version: optional2(TransactionVersionStruct2)
  })),
  rewards: optional2(array2(RewardsResult2)),
  blockTime: nullable2(number3()),
  blockHeight: nullable2(number3())
})));
var GetParsedAccountsModeBlockRpcResult2 = jsonRpcResult2(nullable2(type2({
  blockhash: string2(),
  previousBlockhash: string2(),
  parentSlot: number3(),
  transactions: array2(type2({
    transaction: ConfirmedTransactionAccountsModeResult2,
    meta: nullable2(ParsedConfirmedTransactionMetaResult2),
    version: optional2(TransactionVersionStruct2)
  })),
  rewards: optional2(array2(RewardsResult2)),
  blockTime: nullable2(number3()),
  blockHeight: nullable2(number3())
})));
var GetParsedNoneModeBlockRpcResult2 = jsonRpcResult2(nullable2(type2({
  blockhash: string2(),
  previousBlockhash: string2(),
  parentSlot: number3(),
  rewards: optional2(array2(RewardsResult2)),
  blockTime: nullable2(number3()),
  blockHeight: nullable2(number3())
})));
var GetConfirmedBlockRpcResult2 = jsonRpcResult2(nullable2(type2({
  blockhash: string2(),
  previousBlockhash: string2(),
  parentSlot: number3(),
  transactions: array2(type2({
    transaction: ConfirmedTransactionResult2,
    meta: nullable2(ConfirmedTransactionMetaResult2)
  })),
  rewards: optional2(array2(RewardsResult2)),
  blockTime: nullable2(number3())
})));
var GetBlockSignaturesRpcResult2 = jsonRpcResult2(nullable2(type2({
  blockhash: string2(),
  previousBlockhash: string2(),
  parentSlot: number3(),
  signatures: array2(string2()),
  blockTime: nullable2(number3())
})));
var GetTransactionRpcResult2 = jsonRpcResult2(nullable2(type2({
  slot: number3(),
  meta: nullable2(ConfirmedTransactionMetaResult2),
  blockTime: optional2(nullable2(number3())),
  transaction: ConfirmedTransactionResult2,
  version: optional2(TransactionVersionStruct2)
})));
var GetParsedTransactionRpcResult2 = jsonRpcResult2(nullable2(type2({
  slot: number3(),
  transaction: ParsedConfirmedTransactionResult2,
  meta: nullable2(ParsedConfirmedTransactionMetaResult2),
  blockTime: optional2(nullable2(number3())),
  version: optional2(TransactionVersionStruct2)
})));
var GetLatestBlockhashRpcResult2 = jsonRpcResultAndContext2(type2({
  blockhash: string2(),
  lastValidBlockHeight: number3()
}));
var IsBlockhashValidRpcResult2 = jsonRpcResultAndContext2(boolean2());
var PerfSampleResult2 = type2({
  slot: number3(),
  numTransactions: number3(),
  numSlots: number3(),
  samplePeriodSecs: number3()
});
var GetRecentPerformanceSamplesRpcResult2 = jsonRpcResult2(array2(PerfSampleResult2));
var GetFeeCalculatorRpcResult2 = jsonRpcResultAndContext2(nullable2(type2({
  feeCalculator: type2({
    lamportsPerSignature: number3()
  })
})));
var RequestAirdropRpcResult2 = jsonRpcResult2(string2());
var SendTransactionRpcResult2 = jsonRpcResult2(string2());
var LogsResult2 = type2({
  err: TransactionErrorResult2,
  logs: array2(string2()),
  signature: string2()
});
var LogsNotificationResult2 = type2({
  result: notificationResultAndContext2(LogsResult2),
  subscription: number3()
});

class Keypair2 {
  constructor(keypair) {
    this._keypair = undefined;
    this._keypair = keypair ?? generateKeypair2();
  }
  static generate() {
    return new Keypair2(generateKeypair2());
  }
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey22 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey2(privateScalar);
      for (let ii = 0;ii < 32; ii++) {
        if (publicKey22[ii] !== computedPublicKey[ii]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new Keypair2({
      publicKey: publicKey22,
      secretKey
    });
  }
  static fromSeed(seed) {
    const publicKey22 = getPublicKey2(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey22, 32);
    return new Keypair2({
      publicKey: publicKey22,
      secretKey
    });
  }
  get publicKey() {
    return new PublicKey2(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS2 = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), u643("recentSlot"), BufferLayout2.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), u643(), BufferLayout2.seq(publicKey2(), BufferLayout2.offset(BufferLayout2.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  }
});

class AddressLookupTableProgram2 {
  constructor() {}
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey2.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder2().encode(params.recentSlot)], this.programId);
    const type22 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.CreateLookupTable;
    const data = encodeData2(type22, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram2.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction2({
      programId: this.programId,
      keys,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type22 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.FreezeLookupTable;
    const data = encodeData2(type22);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction2({
      programId: this.programId,
      keys,
      data
    });
  }
  static extendLookupTable(params) {
    const type22 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.ExtendLookupTable;
    const data = encodeData2(type22, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram2.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction2({
      programId: this.programId,
      keys,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type22 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.DeactivateLookupTable;
    const data = encodeData2(type22);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction2({
      programId: this.programId,
      keys,
      data
    });
  }
  static closeLookupTable(params) {
    const type22 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS2.CloseLookupTable;
    const data = encodeData2(type22);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction2({
      programId: this.programId,
      keys,
      data
    });
  }
}
AddressLookupTableProgram2.programId = new PublicKey2("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2 = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u8("instruction"), BufferLayout2.u32("units"), BufferLayout2.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u8("instruction"), BufferLayout2.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout2.struct([BufferLayout2.u8("instruction"), BufferLayout2.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u8("instruction"), u643("microLamports")])
  }
});

class ComputeBudgetProgram2 {
  constructor() {}
  static requestUnits(params) {
    const type22 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.RequestUnits;
    const data = encodeData2(type22, params);
    return new TransactionInstruction2({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type22 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.RequestHeapFrame;
    const data = encodeData2(type22, params);
    return new TransactionInstruction2({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type22 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.SetComputeUnitLimit;
    const data = encodeData2(type22, params);
    return new TransactionInstruction2({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type22 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS2.SetComputeUnitPrice;
    const data = encodeData2(type22, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction2({
      keys: [],
      programId: this.programId,
      data
    });
  }
}
ComputeBudgetProgram2.programId = new PublicKey2("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$12 = 64;
var PUBLIC_KEY_BYTES$12 = 32;
var SIGNATURE_BYTES2 = 64;
var ED25519_INSTRUCTION_LAYOUT2 = BufferLayout2.struct([BufferLayout2.u8("numSignatures"), BufferLayout2.u8("padding"), BufferLayout2.u16("signatureOffset"), BufferLayout2.u16("signatureInstructionIndex"), BufferLayout2.u16("publicKeyOffset"), BufferLayout2.u16("publicKeyInstructionIndex"), BufferLayout2.u16("messageDataOffset"), BufferLayout2.u16("messageDataSize"), BufferLayout2.u16("messageInstructionIndex")]);

class Ed25519Program2 {
  constructor() {}
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey22,
      message,
      signature,
      instructionIndex
    } = params;
    assert22(publicKey22.length === PUBLIC_KEY_BYTES$12, `Public Key must be ${PUBLIC_KEY_BYTES$12} bytes but received ${publicKey22.length} bytes`);
    assert22(signature.length === SIGNATURE_BYTES2, `Signature must be ${SIGNATURE_BYTES2} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT2.span;
    const signatureOffset = publicKeyOffset + publicKey22.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = export_Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT2.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey22, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction2({
      keys: [],
      programId: Ed25519Program2.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert22(privateKey.length === PRIVATE_KEY_BYTES$12, `Private key must be ${PRIVATE_KEY_BYTES$12} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair2.fromSecretKey(privateKey);
      const publicKey22 = keypair.publicKey.toBytes();
      const signature = sign3(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey22,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Ed25519Program2.programId = new PublicKey2("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign2 = (msgHash, privKey) => {
  const signature = secp256k13.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
secp256k13.utils.isValidPrivateKey;
var publicKeyCreate2 = secp256k13.getPublicKey;
var PRIVATE_KEY_BYTES2 = 32;
var ETHEREUM_ADDRESS_BYTES2 = 20;
var PUBLIC_KEY_BYTES2 = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE2 = 11;
var SECP256K1_INSTRUCTION_LAYOUT2 = BufferLayout2.struct([BufferLayout2.u8("numSignatures"), BufferLayout2.u16("signatureOffset"), BufferLayout2.u8("signatureInstructionIndex"), BufferLayout2.u16("ethAddressOffset"), BufferLayout2.u8("ethAddressInstructionIndex"), BufferLayout2.u16("messageDataOffset"), BufferLayout2.u16("messageDataSize"), BufferLayout2.u8("messageInstructionIndex"), BufferLayout2.blob(20, "ethAddress"), BufferLayout2.blob(64, "signature"), BufferLayout2.u8("recoveryId")]);

class Secp256k1Program2 {
  constructor() {}
  static publicKeyToEthAddress(publicKey22) {
    assert22(publicKey22.length === PUBLIC_KEY_BYTES2, `Public key must be ${PUBLIC_KEY_BYTES2} bytes but received ${publicKey22.length} bytes`);
    try {
      return export_Buffer.from(keccak_2563(toBuffer2(publicKey22))).slice(-ETHEREUM_ADDRESS_BYTES2);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey22,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program2.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program2.publicKeyToEthAddress(publicKey22),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = export_Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = export_Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert22(ethAddress.length === ETHEREUM_ADDRESS_BYTES2, `Address must be ${ETHEREUM_ADDRESS_BYTES2} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE2;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = export_Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT2.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT2.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer2(signature),
      ethAddress: toBuffer2(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer2(message), SECP256K1_INSTRUCTION_LAYOUT2.span);
    return new TransactionInstruction2({
      keys: [],
      programId: Secp256k1Program2.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert22(pkey.length === PRIVATE_KEY_BYTES2, `Private key must be ${PRIVATE_KEY_BYTES2} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer2(pkey);
      const publicKey22 = publicKeyCreate2(privateKey, false).slice(1);
      const messageHash = export_Buffer.from(keccak_2563(toBuffer2(message)));
      const [signature, recoveryId] = ecdsaSign2(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey22,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Secp256k1Program2.programId = new PublicKey2("KeccakSecp256k11111111111111111111111111111");
var _Lockup2;
var STAKE_CONFIG_ID2 = new PublicKey2("StakeConfig11111111111111111111111111111111");

class Lockup2 {
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = undefined;
    this.epoch = undefined;
    this.custodian = undefined;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
}
_Lockup2 = Lockup2;
Lockup2.default = new _Lockup2(0, 0, PublicKey2.default);
var STAKE_INSTRUCTION_LAYOUTS2 = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), authorized2(), lockup2()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("newAuthorized"), BufferLayout2.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("newAuthorized"), BufferLayout2.u32("stakeAuthorizationType"), rustString2("authoritySeed"), publicKey2("authorityOwner")])
  }
});
var StakeAuthorizationLayout2 = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class StakeProgram2 {
  constructor() {}
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized22,
      lockup: maybeLockup
    } = params;
    const lockup22 = maybeLockup || Lockup2.default;
    const type22 = STAKE_INSTRUCTION_LAYOUTS2.Initialize;
    const data = encodeData2(type22, {
      authorized: {
        staker: toBuffer2(authorized22.staker.toBuffer()),
        withdrawer: toBuffer2(authorized22.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup22.unixTimestamp,
        epoch: lockup22.epoch,
        custodian: toBuffer2(lockup22.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY2,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction2(instructionData);
  }
  static createAccountWithSeed(params) {
    const transaction = new Transaction3;
    transaction.add(SystemProgram2.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized22,
      lockup: lockup22
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized22,
      lockup: lockup22
    }));
  }
  static createAccount(params) {
    const transaction = new Transaction3;
    transaction.add(SystemProgram2.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized22,
      lockup: lockup22
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized22,
      lockup: lockup22
    }));
  }
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type22 = STAKE_INSTRUCTION_LAYOUTS2.Delegate;
    const data = encodeData2(type22);
    return new Transaction3().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type22 = STAKE_INSTRUCTION_LAYOUTS2.Authorize;
    const data = encodeData2(type22, {
      newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction3().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type22 = STAKE_INSTRUCTION_LAYOUTS2.AuthorizeWithSeed;
    const data = encodeData2(type22, {
      newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer2(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction3().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type22 = STAKE_INSTRUCTION_LAYOUTS2.Split;
    const data = encodeData2(type22, {
      lamports
    });
    return new TransactionInstruction2({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static split(params, rentExemptReserve) {
    const transaction = new Transaction3;
    transaction.add(SystemProgram2.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction3;
    transaction.add(SystemProgram2.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram2.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type22 = STAKE_INSTRUCTION_LAYOUTS2.Merge;
    const data = encodeData2(type22);
    return new Transaction3().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type22 = STAKE_INSTRUCTION_LAYOUTS2.Withdraw;
    const data = encodeData2(type22, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY2,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction3().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type22 = STAKE_INSTRUCTION_LAYOUTS2.Deactivate;
    const data = encodeData2(type22);
    return new Transaction3().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
}
StakeProgram2.programId = new PublicKey2("Stake11111111111111111111111111111111111111");
StakeProgram2.space = 200;
var VOTE_INSTRUCTION_LAYOUTS2 = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), voteInit2()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), publicKey2("newAuthorized"), BufferLayout2.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), BufferLayout2.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout2.struct([BufferLayout2.u32("instruction"), voteAuthorizeWithSeedArgs2()])
  }
});
var VoteAuthorizationLayout2 = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class VoteProgram2 {
  constructor() {}
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit22
    } = params;
    const type22 = VOTE_INSTRUCTION_LAYOUTS2.InitializeAccount;
    const data = encodeData2(type22, {
      voteInit: {
        nodePubkey: toBuffer2(voteInit22.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer2(voteInit22.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer2(voteInit22.authorizedWithdrawer.toBuffer()),
        commission: voteInit22.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY2,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction2(instructionData);
  }
  static createAccount(params) {
    const transaction = new Transaction3;
    transaction.add(SystemProgram2.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type22 = VOTE_INSTRUCTION_LAYOUTS2.Authorize;
    const data = encodeData2(type22, {
      newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction3().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type22 = VOTE_INSTRUCTION_LAYOUTS2.AuthorizeWithSeed;
    const data = encodeData2(type22, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer2(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer2(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY2,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction3().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type22 = VOTE_INSTRUCTION_LAYOUTS2.Withdraw;
    const data = encodeData2(type22, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction3().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return VoteProgram2.withdraw(params);
  }
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type22 = VOTE_INSTRUCTION_LAYOUTS2.UpdateValidatorIdentity;
    const data = encodeData2(type22);
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction3().add({
      keys,
      programId: this.programId,
      data
    });
  }
}
VoteProgram2.programId = new PublicKey2("Vote111111111111111111111111111111111111111");
VoteProgram2.space = 3762;
var VALIDATOR_INFO_KEY2 = new PublicKey2("Va1idator1nfo111111111111111111111111111111");
var InfoString2 = type2({
  name: string2(),
  website: optional2(string2()),
  details: optional2(string2()),
  iconUrl: optional2(string2()),
  keybaseUsername: optional2(string2())
});
var VOTE_PROGRAM_ID2 = new PublicKey2("Vote111111111111111111111111111111111111111");
var VoteAccountLayout2 = BufferLayout2.struct([
  publicKey2("nodePubkey"),
  publicKey2("authorizedWithdrawer"),
  BufferLayout2.u8("commission"),
  BufferLayout2.nu64(),
  BufferLayout2.seq(BufferLayout2.struct([BufferLayout2.nu64("slot"), BufferLayout2.u32("confirmationCount")]), BufferLayout2.offset(BufferLayout2.u32(), -8), "votes"),
  BufferLayout2.u8("rootSlotValid"),
  BufferLayout2.nu64("rootSlot"),
  BufferLayout2.nu64(),
  BufferLayout2.seq(BufferLayout2.struct([BufferLayout2.nu64("epoch"), publicKey2("authorizedVoter")]), BufferLayout2.offset(BufferLayout2.u32(), -8), "authorizedVoters"),
  BufferLayout2.struct([BufferLayout2.seq(BufferLayout2.struct([publicKey2("authorizedPubkey"), BufferLayout2.nu64("epochOfLastAuthorizedSwitch"), BufferLayout2.nu64("targetEpoch")]), 32, "buf"), BufferLayout2.nu64("idx"), BufferLayout2.u8("isEmpty")], "priorVoters"),
  BufferLayout2.nu64(),
  BufferLayout2.seq(BufferLayout2.struct([BufferLayout2.nu64("epoch"), BufferLayout2.nu64("credits"), BufferLayout2.nu64("prevCredits")]), BufferLayout2.offset(BufferLayout2.u32(), -8), "epochCredits"),
  BufferLayout2.struct([BufferLayout2.nu64("slot"), BufferLayout2.nu64("timestamp")], "lastTimestamp")
]);
var PATH_PARAM_RE = /\{[^{}]+\}/g;
var supportsRequestInitExt = () => {
  return typeof process === "object" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;
};
function randomID() {
  return Math.random().toString(36).slice(2, 11);
}
function createClient(clientOptions) {
  let {
    baseUrl = "",
    Request: CustomRequest = globalThis.Request,
    fetch: baseFetch = globalThis.fetch,
    querySerializer: globalQuerySerializer,
    bodySerializer: globalBodySerializer,
    headers: baseHeaders,
    requestInitExt = undefined,
    ...baseOptions
  } = { ...clientOptions };
  requestInitExt = supportsRequestInitExt() ? requestInitExt : undefined;
  baseUrl = removeTrailingSlash(baseUrl);
  const middlewares = [];
  async function coreFetch(schemaPath, fetchOptions) {
    const {
      baseUrl: localBaseUrl,
      fetch: fetch3 = baseFetch,
      Request = CustomRequest,
      headers,
      params = {},
      parseAs = "json",
      querySerializer: requestQuerySerializer,
      bodySerializer = globalBodySerializer ?? defaultBodySerializer,
      body,
      ...init2
    } = fetchOptions || {};
    let finalBaseUrl = baseUrl;
    if (localBaseUrl) {
      finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;
    }
    let querySerializer = typeof globalQuerySerializer === "function" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);
    if (requestQuerySerializer) {
      querySerializer = typeof requestQuerySerializer === "function" ? requestQuerySerializer : createQuerySerializer({
        ...typeof globalQuerySerializer === "object" ? globalQuerySerializer : {},
        ...requestQuerySerializer
      });
    }
    const serializedBody = body === undefined ? undefined : bodySerializer(body, mergeHeaders(baseHeaders, headers, params.header));
    const finalHeaders = mergeHeaders(serializedBody === undefined || serializedBody instanceof FormData ? {} : {
      "Content-Type": "application/json"
    }, baseHeaders, headers, params.header);
    const requestInit = {
      redirect: "follow",
      ...baseOptions,
      ...init2,
      body: serializedBody,
      headers: finalHeaders
    };
    let id2;
    let options;
    let request = new CustomRequest(createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }), requestInit);
    let response;
    for (const key in init2) {
      if (!(key in request)) {
        request[key] = init2[key];
      }
    }
    if (middlewares.length) {
      id2 = randomID();
      options = Object.freeze({
        baseUrl: finalBaseUrl,
        fetch: fetch3,
        parseAs,
        querySerializer,
        bodySerializer
      });
      for (const m of middlewares) {
        if (m && typeof m === "object" && typeof m.onRequest === "function") {
          const result = await m.onRequest({
            request,
            schemaPath,
            params,
            options,
            id: id2
          });
          if (result) {
            if (result instanceof CustomRequest) {
              request = result;
            } else if (result instanceof Response) {
              response = result;
              break;
            } else {
              throw new Error("onRequest: must return new Request() or Response() when modifying the request");
            }
          }
        }
      }
    }
    if (!response) {
      try {
        response = await fetch3(request, requestInitExt);
      } catch (error2) {
        let errorAfterMiddleware = error2;
        if (middlewares.length) {
          for (let i22 = middlewares.length - 1;i22 >= 0; i22--) {
            const m = middlewares[i22];
            if (m && typeof m === "object" && typeof m.onError === "function") {
              const result = await m.onError({
                request,
                error: errorAfterMiddleware,
                schemaPath,
                params,
                options,
                id: id2
              });
              if (result) {
                if (result instanceof Response) {
                  errorAfterMiddleware = undefined;
                  response = result;
                  break;
                }
                if (result instanceof Error) {
                  errorAfterMiddleware = result;
                  continue;
                }
                throw new Error("onError: must return new Response() or instance of Error");
              }
            }
          }
        }
        if (errorAfterMiddleware) {
          throw errorAfterMiddleware;
        }
      }
      if (middlewares.length) {
        for (let i22 = middlewares.length - 1;i22 >= 0; i22--) {
          const m = middlewares[i22];
          if (m && typeof m === "object" && typeof m.onResponse === "function") {
            const result = await m.onResponse({
              request,
              response,
              schemaPath,
              params,
              options,
              id: id2
            });
            if (result) {
              if (!(result instanceof Response)) {
                throw new Error("onResponse: must return new Response() when modifying the response");
              }
              response = result;
            }
          }
        }
      }
    }
    if (response.status === 204 || request.method === "HEAD" || response.headers.get("Content-Length") === "0") {
      return response.ok ? { data: undefined, response } : { error: undefined, response };
    }
    if (response.ok) {
      if (parseAs === "stream") {
        return { data: response.body, response };
      }
      return { data: await response[parseAs](), response };
    }
    let error = await response.text();
    try {
      error = JSON.parse(error);
    } catch {}
    return { error, response };
  }
  return {
    request(method, url, init2) {
      return coreFetch(url, { ...init2, method: method.toUpperCase() });
    },
    GET(url, init2) {
      return coreFetch(url, { ...init2, method: "GET" });
    },
    PUT(url, init2) {
      return coreFetch(url, { ...init2, method: "PUT" });
    },
    POST(url, init2) {
      return coreFetch(url, { ...init2, method: "POST" });
    },
    DELETE(url, init2) {
      return coreFetch(url, { ...init2, method: "DELETE" });
    },
    OPTIONS(url, init2) {
      return coreFetch(url, { ...init2, method: "OPTIONS" });
    },
    HEAD(url, init2) {
      return coreFetch(url, { ...init2, method: "HEAD" });
    },
    PATCH(url, init2) {
      return coreFetch(url, { ...init2, method: "PATCH" });
    },
    TRACE(url, init2) {
      return coreFetch(url, { ...init2, method: "TRACE" });
    },
    use(...middleware) {
      for (const m of middleware) {
        if (!m) {
          continue;
        }
        if (typeof m !== "object" || !(("onRequest" in m) || ("onResponse" in m) || ("onError" in m))) {
          throw new Error("Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`");
        }
        middlewares.push(m);
      }
    },
    eject(...middleware) {
      for (const m of middleware) {
        const i22 = middlewares.indexOf(m);
        if (i22 !== -1) {
          middlewares.splice(i22, 1);
        }
      }
    }
  };
}
function serializePrimitiveParam(name, value, options) {
  if (value === undefined || value === null) {
    return "";
  }
  if (typeof value === "object") {
    throw new Error("Deeply-nested arrays/objects arent supported. Provide your own `querySerializer()` to handle these.");
  }
  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;
}
function serializeObjectParam(name, value, options) {
  if (!value || typeof value !== "object") {
    return "";
  }
  const values = [];
  const joiner = {
    simple: ",",
    label: ".",
    matrix: ";"
  }[options.style] || "&";
  if (options.style !== "deepObject" && options.explode === false) {
    for (const k in value) {
      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));
    }
    const final2 = values.join(",");
    switch (options.style) {
      case "form": {
        return `${name}=${final2}`;
      }
      case "label": {
        return `.${final2}`;
      }
      case "matrix": {
        return `;${name}=${final2}`;
      }
      default: {
        return final2;
      }
    }
  }
  for (const k in value) {
    const finalName = options.style === "deepObject" ? `${name}[${k}]` : k;
    values.push(serializePrimitiveParam(finalName, value[k], options));
  }
  const final = values.join(joiner);
  return options.style === "label" || options.style === "matrix" ? `${joiner}${final}` : final;
}
function serializeArrayParam(name, value, options) {
  if (!Array.isArray(value)) {
    return "";
  }
  if (options.explode === false) {
    const joiner2 = { form: ",", spaceDelimited: "%20", pipeDelimited: "|" }[options.style] || ",";
    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner2);
    switch (options.style) {
      case "simple": {
        return final;
      }
      case "label": {
        return `.${final}`;
      }
      case "matrix": {
        return `;${name}=${final}`;
      }
      default: {
        return `${name}=${final}`;
      }
    }
  }
  const joiner = { simple: ",", label: ".", matrix: ";" }[options.style] || "&";
  const values = [];
  for (const v of value) {
    if (options.style === "simple" || options.style === "label") {
      values.push(options.allowReserved === true ? v : encodeURIComponent(v));
    } else {
      values.push(serializePrimitiveParam(name, v, options));
    }
  }
  return options.style === "label" || options.style === "matrix" ? `${joiner}${values.join(joiner)}` : values.join(joiner);
}
function createQuerySerializer(options) {
  return function querySerializer(queryParams) {
    const search = [];
    if (queryParams && typeof queryParams === "object") {
      for (const name in queryParams) {
        const value = queryParams[name];
        if (value === undefined || value === null) {
          continue;
        }
        if (Array.isArray(value)) {
          if (value.length === 0) {
            continue;
          }
          search.push(serializeArrayParam(name, value, {
            style: "form",
            explode: true,
            ...options?.array,
            allowReserved: options?.allowReserved || false
          }));
          continue;
        }
        if (typeof value === "object") {
          search.push(serializeObjectParam(name, value, {
            style: "deepObject",
            explode: true,
            ...options?.object,
            allowReserved: options?.allowReserved || false
          }));
          continue;
        }
        search.push(serializePrimitiveParam(name, value, options));
      }
    }
    return search.join("&");
  };
}
function defaultPathSerializer(pathname, pathParams) {
  let nextURL = pathname;
  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {
    let name = match.substring(1, match.length - 1);
    let explode = false;
    let style = "simple";
    if (name.endsWith("*")) {
      explode = true;
      name = name.substring(0, name.length - 1);
    }
    if (name.startsWith(".")) {
      style = "label";
      name = name.substring(1);
    } else if (name.startsWith(";")) {
      style = "matrix";
      name = name.substring(1);
    }
    if (!pathParams || pathParams[name] === undefined || pathParams[name] === null) {
      continue;
    }
    const value = pathParams[name];
    if (Array.isArray(value)) {
      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));
      continue;
    }
    if (typeof value === "object") {
      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));
      continue;
    }
    if (style === "matrix") {
      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);
      continue;
    }
    nextURL = nextURL.replace(match, style === "label" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));
  }
  return nextURL;
}
function defaultBodySerializer(body, headers) {
  if (body instanceof FormData) {
    return body;
  }
  if (headers) {
    const contentType = headers.get instanceof Function ? headers.get("Content-Type") ?? headers.get("content-type") : headers["Content-Type"] ?? headers["content-type"];
    if (contentType === "application/x-www-form-urlencoded") {
      return new URLSearchParams(body).toString();
    }
  }
  return JSON.stringify(body);
}
function createFinalURL(pathname, options) {
  let finalURL = `${options.baseUrl}${pathname}`;
  if (options.params?.path) {
    finalURL = defaultPathSerializer(finalURL, options.params.path);
  }
  let search = options.querySerializer(options.params.query ?? {});
  if (search.startsWith("?")) {
    search = search.substring(1);
  }
  if (search) {
    finalURL += `?${search}`;
  }
  return finalURL;
}
function mergeHeaders(...allHeaders) {
  const finalHeaders = new Headers;
  for (const h of allHeaders) {
    if (!h || typeof h !== "object") {
      continue;
    }
    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);
    for (const [k, v] of iterator) {
      if (v === null) {
        finalHeaders.delete(k);
      } else if (Array.isArray(v)) {
        for (const v2 of v) {
          finalHeaders.append(k, v2);
        }
      } else if (v !== undefined) {
        finalHeaders.set(k, v);
      }
    }
  }
  return finalHeaders;
}
function removeTrailingSlash(url) {
  if (url.endsWith("/")) {
    return url.substring(0, url.length - 1);
  }
  return url;
}
var exports_bridge = {};
__export2(exports_bridge, {
  discriminator: () => discriminator,
  depositIx: () => depositIx,
  decode: () => decode3,
  createAnchorProgram: () => createAnchorProgram,
  WITHDRAWAL_LIMITER_SEED: () => WITHDRAWAL_LIMITER_SEED,
  TOKEN_AUTHORITY_SEED: () => TOKEN_AUTHORITY_SEED,
  GLOBAL_SEED: () => GLOBAL_SEED,
  EVENT_SEED: () => EVENT_SEED,
  EFFECT_NULLIFIER_SEED: () => EFFECT_NULLIFIER_SEED,
  CRUMB_AUTHORITY_SEED: () => CRUMB_AUTHORITY_SEED,
  CHILD_BLOCKS_STORAGE_SEED: () => CHILD_BLOCKS_STORAGE_SEED,
  CHALLENGE_NULLIFIER_SEED: () => CHALLENGE_NULLIFIER_SEED,
  ASSET_CONFIG_SEED: () => ASSET_CONFIG_SEED,
  ACL_SEED: () => ACL_SEED
});
var import_bn22 = __toESM2(require_bn2(), 1);
var import_bn3 = __toESM2(require_bn2(), 1);
init_buffer2();
var import_bs5822 = __toESM2(require_bs5822(), 1);
var import_camelcase = __toESM2(require_camelcase(), 1);
var borsh = __toESM2(require_dist2(), 1);
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w2) => {
  s.pending_buf[s.pending++] = w2 & 255;
  s.pending_buf[s.pending++] = w2 >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(s, tree[c * 2], tree[c * 2 + 1]);
};
var bi_reverse = (code2, len2) => {
  let res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len2 > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base2 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n2, m;
  let bits;
  let xbits;
  let f22;
  let overflow = 0;
  for (bits = 0;bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1;h < HEAP_SIZE$1; h++) {
    n2 = s.heap[h];
    bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits;
    if (n2 > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n2 >= base2) {
      xbits = extra[n2 - base2];
    }
    f22 = tree[n2 * 2];
    s.opt_len += f22 * (bits + xbits);
    if (has_stree) {
      s.static_len += f22 * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length;bits !== 0; bits--) {
    n2 = s.bl_count[bits];
    while (n2 !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n2--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code2 = 0;
  let bits;
  let n2;
  for (bits = 1;bits <= MAX_BITS$1; bits++) {
    code2 = code2 + bl_count[bits - 1] << 1;
    next_code[bits] = code2;
  }
  for (n2 = 0;n2 <= max_code; n2++) {
    let len2 = tree[n2 * 2 + 1];
    if (len2 === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse(next_code[len2]++, len2);
  }
};
var tr_static_init = () => {
  let n2;
  let bits;
  let length;
  let code2;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code2 = 0;code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length;
    for (n2 = 0;n2 < 1 << extra_lbits[code2]; n2++) {
      _length_code[length++] = code2;
    }
  }
  _length_code[length - 1] = code2;
  dist = 0;
  for (code2 = 0;code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n2 = 0;n2 < 1 << extra_dbits[code2]; n2++) {
      _dist_code[dist++] = code2;
    }
  }
  dist >>= 7;
  for (;code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist << 7;
    for (n2 = 0;n2 < 1 << extra_dbits[code2] - 7; n2++) {
      _dist_code[256 + dist++] = code2;
    }
  }
  for (bits = 0;bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n2 = 0;n2 < D_CODES$1; n2++) {
    static_dtree[n2 * 2 + 1] = 5;
    static_dtree[n2 * 2] = bi_reverse(n2, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n2;
  for (n2 = 0;n2 < L_CODES$1; n2++) {
    s.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0;n2 < D_CODES$1; n2++) {
    s.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0;n2 < BL_CODES$1; n2++) {
    s.bl_tree[n2 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n2, m, depth) => {
  const _n2 = n2 * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code2;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s, lc, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n2, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n2 = 0;n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n2;
      s.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s.heap_len >> 1;n2 >= 1; n2--) {
    pqdownheap(s, tree, n2);
  }
  node = elems;
  do {
    n2 = s.heap[1];
    s.heap[1] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1);
    m = s.heap[1];
    s.heap[--s.heap_max] = n2;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n2 * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[1] = node++;
    pqdownheap(s, tree, 1);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0;n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0;n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1;max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank = 0;rank < blcodes; rank++) {
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n2;
  for (n2 = 0;n2 <= 31; n2++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n2 = 32;n2 < LITERALS$1; n2++) {
    if (s.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len2, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len2 !== 0) {
    n2 = len2 > 2000 ? 2000 : len2;
    len2 -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n2 = 0;n2 < 256; n2++) {
    c = n2;
    for (var k = 0;k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n2] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len2, pos) => {
  const t = crcTable;
  const end = pos + len2;
  crc ^= -1;
  for (let i22 = pos;i22 < end; i22++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i22]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f22) => {
  return f22 * 2 - (f22 > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
};
var slide_hash = (s) => {
  let n2, m;
  let p;
  let wsize = s.w_size;
  n2 = s.hash_size;
  p = n2;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n2);
  n2 = wsize;
  p = n2;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n2);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len2 = s.pending;
  if (len2 > strm.avail_out) {
    len2 = strm.avail_out;
  }
  if (len2 === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len2), strm.next_out);
  strm.next_out += len2;
  s.pending_out += len2;
  strm.total_out += len2;
  strm.avail_out -= len2;
  s.pending -= len2;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b22) => {
  s.pending_buf[s.pending++] = b22;
};
var putShortMSB = (s, b22) => {
  s.pending_buf[s.pending++] = b22 >>> 8 & 255;
  s.pending_buf[s.pending++] = b22 & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len2 = strm.avail_in;
  if (len2 > size) {
    len2 = size;
  }
  if (len2 === 0) {
    return 0;
  }
  strm.avail_in -= len2;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len2), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len2, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len2, start);
  }
  strm.next_in += len2;
  strm.total_in += len2;
  return len2;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len2;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len2 = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len2 > best_len) {
      s.match_start = cur_match;
      best_len = len2;
      if (len2 >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n2, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n2;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len2, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len2 = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len2 > left + s.strm.avail_in) {
      len2 = left + s.strm.avail_in;
    }
    if (len2 > have) {
      len2 = have;
    }
    if (len2 < min_block && (len2 === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len2 !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len2 === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len2;
    s.pending_buf[s.pending - 3] = len2 >> 8;
    s.pending_buf[s.pending - 2] = ~len2;
    s.pending_buf[s.pending - 1] = ~len2 >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len2) {
        left = len2;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len2 -= left;
    }
    if (len2) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len2);
      s.strm.next_out += len2;
      s.strm.avail_out -= len2;
      s.strm.total_out += len2;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len2 = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len2 === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len2, last);
    s.block_start += len2;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (;; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (;; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (;; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (;; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState;
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy4 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy4), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy4;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy4;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n2 = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n2);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len2 = 0;
  for (let i22 = 0, l = chunks.length;i22 < l; i22++) {
    len2 += chunks[i22].length;
  }
  const result = new Uint8Array(len2);
  for (let i22 = 0, pos = 0, l = chunks.length;i22 < l; i22++) {
    let chunk = chunks[i22];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0;q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i22, str_len = str.length, buf_len = 0;
  for (m_pos = 0;m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i22 = 0, m_pos = 0;i22 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i22++] = c;
    } else if (c < 2048) {
      buf[i22++] = 192 | c >>> 6;
      buf[i22++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i22++] = 224 | c >>> 12;
      buf[i22++] = 128 | c >>> 6 & 63;
      buf[i22++] = 128 | c & 63;
    } else {
      buf[i22++] = 240 | c >>> 18;
      buf[i22++] = 128 | c >>> 12 & 63;
      buf[i22++] = 128 | c >>> 6 & 63;
      buf[i22++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len2) => {
  if (len2 < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len2 ? buf : buf.subarray(0, len2));
    }
  }
  let result = "";
  for (let i22 = 0;i22 < len2; i22++) {
    result += String.fromCharCode(buf[i22]);
  }
  return result;
};
var buf2string = (buf, max2) => {
  const len2 = max2 || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max2));
  }
  let i22, out;
  const utf16buf = new Array(len2 * 2);
  for (out = 0, i22 = 0;i22 < len2; ) {
    let c = buf[i22++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i22 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i22 < len2) {
      c = c << 6 | buf[i22++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max2) => {
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  let pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream;
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (;; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len2;
  let dist;
  let from2;
  let from_source;
  let input, output2;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (;; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (;; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from2 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from2 += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from2 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output2[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from2 += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output2[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len2 > 2) {
                      output2[_out++] = from_source[from2++];
                      output2[_out++] = from_source[from2++];
                      output2[_out++] = from_source[from2++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output2[_out++] = from_source[from2++];
                      if (len2 > 1) {
                        output2[_out++] = from_source[from2++];
                      }
                    }
                  } else {
                    from2 = _out - dist;
                    do {
                      output2[_out++] = output2[from2++];
                      output2[_out++] = output2[from2++];
                      output2[_out++] = output2[from2++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output2[_out++] = output2[from2++];
                      if (len2 > 1) {
                        output2[_out++] = output2[from2++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len2 = bits >> 3;
  _in -= len2;
  bits -= len2 << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type22, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len2 = 0;
  let sym = 0;
  let min2 = 0, max2 = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask22;
  let next;
  let base2 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len2 = 0;len2 <= MAXBITS; len2++) {
    count[len2] = 0;
  }
  for (sym = 0;sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS;max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min2 = 1;min2 < max2; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len2 = 1;len2 <= MAXBITS; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type22 === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len2 = 1;len2 < MAXBITS; len2++) {
    offs[len2 + 1] = offs[len2] + count[len2];
  }
  for (sym = 0;sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type22 === CODES$1) {
    base2 = extra = work;
    match = 20;
  } else if (type22 === LENS$1) {
    base2 = lbase;
    extra = lext;
    match = 257;
  } else {
    base2 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len2 = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask22 = used - 1;
  if (type22 === LENS$1 && used > ENOUGH_LENS$1 || type22 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (;; ) {
    here_bits = len2 - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base2[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill = 1 << curr;
    min2 = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max2) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask22) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type22 === LENS$1 && used > ENOUGH_LENS$1 || type22 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask22;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE22 = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState;
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy4) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy4 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy4) {
      dist = copy4;
    }
    state.window.set(src.subarray(end - copy4, end - copy4 + dist), state.wnext);
    copy4 -= dist;
    if (copy4) {
      state.window.set(src.subarray(end - copy4, end), 0);
      state.wnext = copy4;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output2;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy4;
  let from2;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len2;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE22) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (;; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          }
          if (len2 > 15 || len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE22;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy4 = state.length;
            if (copy4 > have) {
              copy4 = have;
            }
            if (copy4) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(input.subarray(next, next + copy4), len2);
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy4, next);
              }
              have -= copy4;
              next += copy4;
              state.length -= copy4;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy4 = 0;
            do {
              len2 = input[next + copy4++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy4 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy4, next);
            }
            have -= copy4;
            next += copy4;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy4 = 0;
            do {
              len2 = input[next + copy4++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy4 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy4, next);
            }
            have -= copy4;
            next += copy4;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE22;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE22;
        case TYPE22:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy4 = state.length;
          if (copy4) {
            if (copy4 > have) {
              copy4 = have;
            }
            if (copy4 > left) {
              copy4 = left;
            }
            if (copy4 === 0) {
              break inf_leave;
            }
            output2.set(input.subarray(next, next + copy4), put);
            have -= copy4;
            next += copy4;
            left -= copy4;
            put += copy4;
            state.length -= copy4;
            break;
          }
          state.mode = TYPE22;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy4 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len2 = 0;
                copy4 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len2 = 0;
                copy4 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy4 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy4--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE22) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (;; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE22;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (;; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy4 = _out - left;
          if (state.offset > copy4) {
            copy4 = state.offset - copy4;
            if (copy4 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy4 > state.wnext) {
              copy4 -= state.wnext;
              from2 = state.wsize - copy4;
            } else {
              from2 = state.wnext - copy4;
            }
            if (copy4 > state.length) {
              copy4 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from2 = put - state.offset;
            copy4 = state.length;
          }
          if (copy4 > left) {
            copy4 = left;
          }
          left -= copy4;
          state.length -= copy4;
          do {
            output2[put++] = from_source[from2++];
          } while (--copy4);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output2, _out, put - _out) : adler32_1(state.check, output2, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output2, _out, strm.next_out - _out) : adler32_1(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE22 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString2 = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream;
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader;
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString2.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (;; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants2 = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants: constants2
};
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;
var import_eventemitter32 = __toESM2(require_eventemitter322(), 1);
function chunks(array3, size) {
  return Array.apply(0, new Array(Math.ceil(array3.length / size))).map((_, index) => array3.slice(index * size, (index + 1) * size));
}
var isVersionedTransaction = (tx) => {
  return "version" in tx;
};
function decode$2(array3) {
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(array3);
}
function encode$1(data) {
  return import_bs5822.default.encode(data);
}
function decode22(data) {
  return export_Buffer.from(data, "base64");
}
function isCompositeAccounts(accountItem) {
  return "accounts" in accountItem;
}
async function idlAddress(programId) {
  const base2 = (await PublicKey2.findProgramAddress([], programId))[0];
  return await PublicKey2.createWithSeed(base2, seed(), programId);
}
function seed() {
  return "anchor:idl";
}
var IDL_ACCOUNT_LAYOUT = borsh.struct([
  borsh.publicKey("authority"),
  borsh.vecU8("data")
]);
function decodeIdlAccount(data) {
  return IDL_ACCOUNT_LAYOUT.decode(data);
}
function convertIdlToCamelCase(idl) {
  const KEYS_TO_CONVERT = ["name", "path", "account", "relations", "generic"];
  const toCamelCase = (s) => s.split(".").map(import_camelcase.default).join(".");
  const recursivelyConvertNamesToCamelCase = (obj) => {
    for (const key in obj) {
      const val = obj[key];
      if (KEYS_TO_CONVERT.includes(key)) {
        obj[key] = Array.isArray(val) ? val.map(toCamelCase) : toCamelCase(val);
      } else if (typeof val === "object") {
        recursivelyConvertNamesToCamelCase(val);
      }
    }
  };
  const camelCasedIdl = structuredClone(idl);
  recursivelyConvertNamesToCamelCase(camelCasedIdl);
  return camelCasedIdl;
}
function handleDefinedFields(fields2, unitCb, namedCb, tupleCb) {
  if (!(fields2 === null || fields2 === undefined ? undefined : fields2.length))
    return unitCb();
  if (fields2[0].name) {
    return namedCb(fields2);
  }
  return tupleCb(fields2);
}
function parseIdlErrors(idl) {
  const errors = new Map;
  if (idl.errors) {
    idl.errors.forEach((e) => {
      var _a;
      let msg = (_a = e.msg) !== null && _a !== undefined ? _a : e.name;
      errors.set(e.code, msg);
    });
  }
  return errors;
}
function toInstruction(idlIx, ...args) {
  if (idlIx.args.length != args.length) {
    throw new Error("Invalid argument length");
  }
  const ix = {};
  let idx = 0;
  idlIx.args.forEach((ixArg) => {
    ix[ixArg.name] = args[idx];
    idx += 1;
  });
  return ix;
}
function validateAccounts(ixAccounts, accounts = {}) {
  ixAccounts.forEach((acc) => {
    if (isCompositeAccounts(acc)) {
      validateAccounts(acc.accounts, accounts[acc.name]);
    } else {
      if (!accounts[acc.name]) {
        throw new Error(`Account \`${acc.name}\` not provided.`);
      }
    }
  });
}
function translateAddress(address) {
  return address instanceof PublicKey2 ? address : new PublicKey2(address);
}

class StructError22 extends TypeError {
  constructor(failure, failures) {
    let cached;
    const {
      message,
      ...rest
    } = failure;
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
    super(msg);
    this.value = undefined;
    this.key = undefined;
    this.type = undefined;
    this.refinement = undefined;
    this.path = undefined;
    this.branch = undefined;
    this.failures = undefined;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      var _cached;
      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }
}
function isIterable22(x2) {
  return isObject22(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject22(x2) {
  return typeof x2 === "object" && x2 != null;
}
function print22(value) {
  return typeof value === "string" ? JSON.stringify(value) : "" + value;
}
function shiftIterator22(input) {
  const {
    done,
    value
  } = input.next();
  return done ? undefined : value;
}
function toFailure22(result, context, struct3, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type: type22
  } = struct3;
  const {
    refinement,
    message = "Expected a value of type `" + type22 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print22(value) + "`"
  } = result;
  return {
    value,
    type: type22,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures22(result, context, struct3, value) {
  if (!isIterable22(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure22(r, context, struct3, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run22(value, struct3, options) {
  if (options === undefined) {
    options = {};
  }
  const {
    path = [],
    branch = [value],
    coerce: coerce22 = false,
    mask: mask22 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce22) {
    value = struct3.coercer(value, ctx);
    if (mask22 && struct3.type !== "type" && isObject22(struct3.schema) && isObject22(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct3.schema[key] === undefined) {
          delete value[key];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct3.validator(value, ctx)) {
    valid = false;
    yield [failure, undefined];
  }
  for (let [k, v, s] of struct3.entries(value, ctx)) {
    const ts = run22(v, s, {
      path: k === undefined ? path : [...path, k],
      branch: k === undefined ? branch : [...branch, v],
      coerce: coerce22,
      mask: mask22
    });
    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], undefined];
      } else if (coerce22) {
        v = t[1];
        if (k === undefined) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject22(value)) {
          value[k] = v;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct3.refiner(value, ctx)) {
      valid = false;
      yield [failure, undefined];
    }
  }
  if (valid) {
    yield [undefined, value];
  }
}

class Struct32 {
  constructor(props) {
    this.TYPE = undefined;
    this.type = undefined;
    this.schema = undefined;
    this.coercer = undefined;
    this.validator = undefined;
    this.refiner = undefined;
    this.entries = undefined;
    const {
      type: type22,
      schema,
      validator,
      refiner,
      coercer = (value) => value,
      entries = function* () {}
    } = props;
    this.type = type22;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures22(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures22(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  assert(value) {
    return assert32(value, this);
  }
  create(value) {
    return create22(value, this);
  }
  is(value) {
    return is22(value, this);
  }
  mask(value) {
    return mask22(value, this);
  }
  validate(value, options) {
    if (options === undefined) {
      options = {};
    }
    return validate32(value, this, options);
  }
}
function assert32(value, struct3) {
  const result = validate32(value, struct3);
  if (result[0]) {
    throw result[0];
  }
}
function create22(value, struct3) {
  const result = validate32(value, struct3, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask22(value, struct3) {
  const result = validate32(value, struct3, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is22(value, struct3) {
  const result = validate32(value, struct3);
  return !result[0];
}
function validate32(value, struct3, options) {
  if (options === undefined) {
    options = {};
  }
  const tuples = run22(value, struct3, options);
  const tuple22 = shiftIterator22(tuples);
  if (tuple22[0]) {
    const error = new StructError22(tuple22[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, undefined];
  } else {
    const v = tuple22[1];
    return [undefined, v];
  }
}
function define3(name, validator) {
  return new Struct32({
    type: name,
    schema: null,
    validator
  });
}
function any22() {
  return define3("any", () => true);
}
function array3(Element) {
  return new Struct32({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i22, v] of value.entries()) {
          yield [i22, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print22(value);
    }
  });
}
function boolean22() {
  return define3("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function literal22(constant) {
  const description = print22(constant);
  const t = typeof constant;
  return new Struct32({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print22(value);
    }
  });
}
function nullable22(struct3) {
  return new Struct32({
    ...struct3,
    validator: (value, ctx) => value === null || struct3.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct3.refiner(value, ctx)
  });
}
function number22() {
  return define3("number", (value) => {
    return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print22(value);
  });
}
function optional22(struct3) {
  return new Struct32({
    ...struct3,
    validator: (value, ctx) => value === undefined || struct3.validator(value, ctx),
    refiner: (value, ctx) => value === undefined || struct3.refiner(value, ctx)
  });
}
function string22() {
  return define3("string", (value) => {
    return typeof value === "string" || "Expected a string, but received: " + print22(value);
  });
}
function type22(schema) {
  const keys = Object.keys(schema);
  return new Struct32({
    type: "type",
    schema,
    *entries(value) {
      if (isObject22(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isObject22(value) || "Expected an object, but received: " + print22(value);
    }
  });
}
function union$1(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct32({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      const firstMatch = Structs.find((s) => {
        const [e] = s.validate(value, {
          coerce: true
        });
        return !e;
      }) || unknown22();
      return firstMatch.coercer(value, ctx);
    },
    validator(value, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run22(value, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print22(value), ...failures];
    }
  });
}
function unknown22() {
  return define3("unknown", () => true);
}
function coerce22(struct3, condition, coercer) {
  return new Struct32({
    ...struct3,
    coercer: (value, ctx) => {
      return is22(value, condition) ? struct3.coercer(coercer(value, ctx), ctx) : struct3.coercer(value, ctx);
    }
  });
}
var GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
async function getMultipleAccountsAndContext(connection, publicKeys, commitment) {
  if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {
    return await getMultipleAccountsAndContextCore(connection, publicKeys, commitment);
  } else {
    const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);
    const results = await Promise.all(batches.map((batch) => getMultipleAccountsAndContextCore(connection, batch, commitment)));
    return results.flat();
  }
}
async function getMultipleAccountsAndContextCore(connection, publicKeys, commitmentOverride) {
  const commitment = commitmentOverride !== null && commitmentOverride !== undefined ? commitmentOverride : connection.commitment;
  const { value: accountInfos, context } = await connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);
  const accounts = accountInfos.map((account, idx) => {
    if (account === null) {
      return null;
    }
    return {
      publicKey: publicKeys[idx],
      account,
      context
    };
  });
  return accounts;
}
async function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {
  var _a;
  if (signers && signers.length > 0) {
    transaction.sign(...signers);
  }
  const message = transaction._compile();
  const signData = message.serialize();
  const wireTransaction = transaction._serialize(signData);
  const encodedTransaction = wireTransaction.toString("base64");
  const config2 = {
    encoding: "base64",
    commitment: commitment !== null && commitment !== undefined ? commitment : connection.commitment
  };
  if (includeAccounts) {
    const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
    config2["accounts"] = {
      encoding: "base64",
      addresses
    };
  }
  if (signers && signers.length > 0) {
    config2.sigVerify = true;
  }
  const args = [encodedTransaction, config2];
  const unsafeRes = await connection._rpcRequest("simulateTransaction", args);
  const res = create22(unsafeRes, SimulatedTransactionResponseStruct22);
  if ("error" in res) {
    let logs;
    if ("data" in res.error) {
      logs = (_a = res.error.data) === null || _a === undefined ? undefined : _a.logs;
      if (logs && Array.isArray(logs)) {
        const traceIndent = `
    `;
        const logTrace = traceIndent + logs.join(traceIndent);
        console.error(res.error.message, logTrace);
      }
    }
    throw new SendTransactionError2("failed to simulate transaction: " + res.error.message, logs);
  }
  return res.result;
}
function jsonRpcResult22(schema) {
  return coerce22(createRpcResult22(schema), UnknownRpcResult22, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create22(value.result, schema)
      };
    }
  });
}
var UnknownRpcResult22 = createRpcResult22(unknown22());
function createRpcResult22(result) {
  return union$1([
    type22({
      jsonrpc: literal22("2.0"),
      id: string22(),
      result
    }),
    type22({
      jsonrpc: literal22("2.0"),
      id: string22(),
      error: type22({
        code: unknown22(),
        message: string22(),
        data: optional22(any22())
      })
    })
  ]);
}
function jsonRpcResultAndContext22(value) {
  return jsonRpcResult22(type22({
    context: type22({
      slot: number22()
    }),
    value
  }));
}
var SimulatedTransactionResponseStruct22 = jsonRpcResultAndContext22(type22({
  err: nullable22(union$1([type22({}), string22()])),
  logs: nullable22(array3(string22())),
  accounts: optional22(nullable22(array3(nullable22(type22({
    executable: boolean22(),
    owner: string22(),
    lamports: number22(),
    data: array3(string22()),
    rentEpoch: optional22(number22())
  }))))),
  unitsConsumed: optional22(number22())
}));

class AnchorProvider {
  constructor(connection, wallet, opts = AnchorProvider.defaultOptions()) {
    this.connection = connection;
    this.wallet = wallet;
    this.opts = opts;
    this.publicKey = wallet === null || wallet === undefined ? undefined : wallet.publicKey;
  }
  static defaultOptions() {
    return {
      preflightCommitment: "processed",
      commitment: "processed"
    };
  }
  static local(url, opts = AnchorProvider.defaultOptions()) {
    {
      throw new Error(`Provider local is not available on browser.`);
    }
  }
  static env() {
    {
      throw new Error(`Provider env is not available on browser.`);
    }
  }
  async sendAndConfirm(tx, signers, opts) {
    var _a, _b, _c, _d;
    if (opts === undefined) {
      opts = this.opts;
    }
    if (isVersionedTransaction(tx)) {
      if (signers) {
        tx.sign(signers);
      }
    } else {
      tx.feePayer = (_a = tx.feePayer) !== null && _a !== undefined ? _a : this.wallet.publicKey;
      tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
      if (signers) {
        for (const signer of signers) {
          tx.partialSign(signer);
        }
      }
    }
    tx = await this.wallet.signTransaction(tx);
    const rawTx = tx.serialize();
    try {
      return await sendAndConfirmRawTransaction(this.connection, rawTx, opts);
    } catch (err2) {
      if (err2 instanceof ConfirmError) {
        const txSig = encode$1(isVersionedTransaction(tx) ? ((_b = tx.signatures) === null || _b === undefined ? undefined : _b[0]) || new Uint8Array : (_c = tx.signature) !== null && _c !== undefined ? _c : new Uint8Array);
        const maxVer = isVersionedTransaction(tx) ? 0 : undefined;
        const failedTx = await this.connection.getTransaction(txSig, {
          commitment: "confirmed",
          maxSupportedTransactionVersion: maxVer
        });
        if (!failedTx) {
          throw err2;
        } else {
          const logs = (_d = failedTx.meta) === null || _d === undefined ? undefined : _d.logMessages;
          throw !logs ? err2 : new SendTransactionError2(err2.message, logs);
        }
      } else {
        throw err2;
      }
    }
  }
  async sendAll(txWithSigners, opts) {
    var _a, _b, _c;
    if (opts === undefined) {
      opts = this.opts;
    }
    const recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
    let txs = txWithSigners.map((r) => {
      var _a2, _b2;
      if (isVersionedTransaction(r.tx)) {
        let tx = r.tx;
        if (r.signers) {
          tx.sign(r.signers);
        }
        return tx;
      } else {
        let tx = r.tx;
        let signers = (_a2 = r.signers) !== null && _a2 !== undefined ? _a2 : [];
        tx.feePayer = (_b2 = tx.feePayer) !== null && _b2 !== undefined ? _b2 : this.wallet.publicKey;
        tx.recentBlockhash = recentBlockhash;
        signers.forEach((kp) => {
          tx.partialSign(kp);
        });
        return tx;
      }
    });
    const signedTxs = await this.wallet.signAllTransactions(txs);
    const sigs = [];
    for (let k = 0;k < txs.length; k += 1) {
      const tx = signedTxs[k];
      const rawTx = tx.serialize();
      try {
        sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));
      } catch (err2) {
        if (err2 instanceof ConfirmError) {
          const txSig = encode$1(isVersionedTransaction(tx) ? ((_a = tx.signatures) === null || _a === undefined ? undefined : _a[0]) || new Uint8Array : (_b = tx.signature) !== null && _b !== undefined ? _b : new Uint8Array);
          const maxVer = isVersionedTransaction(tx) ? 0 : undefined;
          const failedTx = await this.connection.getTransaction(txSig, {
            commitment: "confirmed",
            maxSupportedTransactionVersion: maxVer
          });
          if (!failedTx) {
            throw err2;
          } else {
            const logs = (_c = failedTx.meta) === null || _c === undefined ? undefined : _c.logMessages;
            throw !logs ? err2 : new SendTransactionError2(err2.message, logs);
          }
        } else {
          throw err2;
        }
      }
    }
    return sigs;
  }
  async simulate(tx, signers, commitment, includeAccounts) {
    let recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== undefined ? commitment : this.connection.commitment)).blockhash;
    let result;
    if (isVersionedTransaction(tx)) {
      if (signers && signers.length > 0) {
        tx.sign(signers);
        tx = await this.wallet.signTransaction(tx);
      }
      result = await this.connection.simulateTransaction(tx, { commitment });
    } else {
      tx.feePayer = tx.feePayer || this.wallet.publicKey;
      tx.recentBlockhash = recentBlockhash;
      if (signers && signers.length > 0) {
        tx = await this.wallet.signTransaction(tx);
      }
      result = await simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);
    }
    if (result.value.err) {
      throw new SimulateError(result.value);
    }
    return result.value;
  }
}

class SimulateError extends Error {
  constructor(simulationResponse, message) {
    super(message);
    this.simulationResponse = simulationResponse;
  }
}
async function sendAndConfirmRawTransaction(connection, rawTransaction, options) {
  const sendOptions = options ? {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  } : {};
  let status;
  const startTime = Date.now();
  while (Date.now() - startTime < 60000) {
    try {
      const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
      if (options === null || options === undefined ? undefined : options.blockhash) {
        if (sendOptions.maxRetries === 0) {
          const abortSignal = AbortSignal.timeout(15000);
          status = (await connection.confirmTransaction({ abortSignal, signature, ...options.blockhash }, options && options.commitment)).value;
        } else {
          status = (await connection.confirmTransaction({ signature, ...options.blockhash }, options && options.commitment)).value;
        }
      } else {
        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
      }
      if (status.err) {
        throw new ConfirmError(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
      }
      return signature;
    } catch (err2) {
      if (err2.name === "TimeoutError") {
        continue;
      }
      throw err2;
    }
  }
  throw Error("Transaction failed to confirm in 60s");
}

class ConfirmError extends Error {
  constructor(message) {
    super(message);
  }
}
function getProvider2() {
  if (_provider === null) {
    return AnchorProvider.local();
  }
  return _provider;
}
var _provider = null;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
var ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = ANCHOR_ERROR__REQUIRE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_VIOLATED = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = dist.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = ANCHOR_ERROR__CONSTRAINT_SPACE = dist.ANCHOR_ERROR__CONSTRAINT_SPACE = ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = ANCHOR_ERROR__CONSTRAINT_ZERO = dist.ANCHOR_ERROR__CONSTRAINT_ZERO = ANCHOR_ERROR__CONSTRAINT_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_ADDRESS = ANCHOR_ERROR__CONSTRAINT_CLOSE = dist.ANCHOR_ERROR__CONSTRAINT_CLOSE = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = ANCHOR_ERROR__CONSTRAINT_STATE = dist.ANCHOR_ERROR__CONSTRAINT_STATE = ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = dist.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = ANCHOR_ERROR__CONSTRAINT_SEEDS = dist.ANCHOR_ERROR__CONSTRAINT_SEEDS = ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = dist.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = ANCHOR_ERROR__CONSTRAINT_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_OWNER = ANCHOR_ERROR__CONSTRAINT_RAW = dist.ANCHOR_ERROR__CONSTRAINT_RAW = ANCHOR_ERROR__CONSTRAINT_SIGNER = dist.ANCHOR_ERROR__CONSTRAINT_SIGNER = ANCHOR_ERROR__CONSTRAINT_HAS_ONE = dist.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = ANCHOR_ERROR__CONSTRAINT_MUT = dist.ANCHOR_ERROR__CONSTRAINT_MUT = ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = dist.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = dist.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = dist.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = ANCHOR_ERROR__IDL_INSTRUCTION_STUB = dist.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = dist.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = ANCHOR_ERROR__INSTRUCTION_MISSING = dist.ANCHOR_ERROR__INSTRUCTION_MISSING = undefined;
var ANCHOR_ERROR__DEPRECATED = dist.ANCHOR_ERROR__DEPRECATED = ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = dist.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = dist.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = dist.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = dist.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = dist.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = dist.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = dist.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = dist.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = dist.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = dist.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = dist.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = ANCHOR_ERROR__INVALID_PROGRAM_ID = dist.ANCHOR_ERROR__INVALID_PROGRAM_ID = ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = dist.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = dist.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = dist.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = ANCHOR_ERROR__REQUIRE_GT_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = undefined;
var ANCHOR_ERROR__INSTRUCTION_MISSING = dist.ANCHOR_ERROR__INSTRUCTION_MISSING = 100;
var ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = dist.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = 101;
var ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = 102;
var ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = 103;
var ANCHOR_ERROR__IDL_INSTRUCTION_STUB = dist.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = 1000;
var ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = dist.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = 1001;
var ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = dist.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = 1002;
var ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = dist.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = 1500;
var ANCHOR_ERROR__CONSTRAINT_MUT = dist.ANCHOR_ERROR__CONSTRAINT_MUT = 2000;
var ANCHOR_ERROR__CONSTRAINT_HAS_ONE = dist.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = 2001;
var ANCHOR_ERROR__CONSTRAINT_SIGNER = dist.ANCHOR_ERROR__CONSTRAINT_SIGNER = 2002;
var ANCHOR_ERROR__CONSTRAINT_RAW = dist.ANCHOR_ERROR__CONSTRAINT_RAW = 2003;
var ANCHOR_ERROR__CONSTRAINT_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_OWNER = 2004;
var ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = dist.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = 2005;
var ANCHOR_ERROR__CONSTRAINT_SEEDS = dist.ANCHOR_ERROR__CONSTRAINT_SEEDS = 2006;
var ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = dist.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = 2007;
var ANCHOR_ERROR__CONSTRAINT_STATE = dist.ANCHOR_ERROR__CONSTRAINT_STATE = 2008;
var ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = 2009;
var ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = 2010;
var ANCHOR_ERROR__CONSTRAINT_CLOSE = dist.ANCHOR_ERROR__CONSTRAINT_CLOSE = 2011;
var ANCHOR_ERROR__CONSTRAINT_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_ADDRESS = 2012;
var ANCHOR_ERROR__CONSTRAINT_ZERO = dist.ANCHOR_ERROR__CONSTRAINT_ZERO = 2013;
var ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = 2014;
var ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = 2015;
var ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = 2016;
var ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = 2017;
var ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = 2018;
var ANCHOR_ERROR__CONSTRAINT_SPACE = dist.ANCHOR_ERROR__CONSTRAINT_SPACE = 2019;
var ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = dist.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = 2020;
var ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = 2021;
var ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = 2022;
var ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = 2023;
var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = 2024;
var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = 2025;
var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = 2026;
var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = 2027;
var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = 2028;
var ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = 2029;
var ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = 2030;
var ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = 2031;
var ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = 2032;
var ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = 2033;
var ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = 2034;
var ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = 2035;
var ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = 2036;
var ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = 2037;
var ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = 2038;
var ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = 2039;
var ANCHOR_ERROR__REQUIRE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_VIOLATED = 2500;
ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = 2501;
var ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = 2502;
var ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = 2503;
var ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = 2504;
var ANCHOR_ERROR__REQUIRE_GT_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = 2505;
var ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = 2506;
var ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = 3000;
var ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = 3001;
var ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = 3002;
var ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = 3003;
var ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = 3004;
var ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = dist.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = 3005;
var ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = dist.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = 3006;
var ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = dist.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = 3007;
var ANCHOR_ERROR__INVALID_PROGRAM_ID = dist.ANCHOR_ERROR__INVALID_PROGRAM_ID = 3008;
var ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = dist.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = 3009;
var ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = dist.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = 3010;
var ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = dist.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = 3011;
var ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = dist.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = 3012;
var ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = dist.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = 3013;
var ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = dist.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = 3014;
var ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = 3015;
var ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = dist.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = 3016;
var ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = dist.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = 3017;
var ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = dist.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = 4100;
var ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = dist.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = 4101;
var ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = dist.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = 4102;
ANCHOR_ERROR__DEPRECATED = dist.ANCHOR_ERROR__DEPRECATED = 5000;
var _AVAILABLE_FEATURES = new Set(["debug-logs"]);
var _FEATURES = new Map;
function isSet(key) {
  return _FEATURES.get(key) !== undefined;
}

class IdlError extends Error {
  constructor(message) {
    super(message);
    this.name = "IdlError";
  }
}

class ProgramErrorStack {
  constructor(stack) {
    this.stack = stack;
  }
  static parse(logs) {
    var _a;
    const programKeyRegex = /^Program (\w*) invoke/;
    const successRegex = /^Program \w* success/;
    const programStack = [];
    for (let i22 = 0;i22 < logs.length; i22++) {
      if (successRegex.exec(logs[i22])) {
        programStack.pop();
        continue;
      }
      const programKey = (_a = programKeyRegex.exec(logs[i22])) === null || _a === undefined ? undefined : _a[1];
      if (!programKey) {
        continue;
      }
      programStack.push(new PublicKey2(programKey));
    }
    return new ProgramErrorStack(programStack);
  }
}

class AnchorError extends Error {
  constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {
    super(errorLogs.join(`
`).replace("Program log: ", ""));
    this.errorLogs = errorLogs;
    this.logs = logs;
    this.error = { errorCode, errorMessage, comparedValues, origin };
    this._programErrorStack = ProgramErrorStack.parse(logs);
  }
  static parse(logs) {
    if (!logs) {
      return null;
    }
    const anchorErrorLogIndex = logs.findIndex((log3) => log3.startsWith("Program log: AnchorError"));
    if (anchorErrorLogIndex === -1) {
      return null;
    }
    const anchorErrorLog = logs[anchorErrorLogIndex];
    const errorLogs = [anchorErrorLog];
    let comparedValues;
    if (anchorErrorLogIndex + 1 < logs.length) {
      if (logs[anchorErrorLogIndex + 1] === "Program log: Left:") {
        const pubkeyRegex = /^Program log: (.*)$/;
        const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];
        const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];
        comparedValues = [
          new PublicKey2(leftPubkey),
          new PublicKey2(rightPubkey)
        ];
        errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));
      } else if (logs[anchorErrorLogIndex + 1].startsWith("Program log: Left:")) {
        const valueRegex = /^Program log: (Left|Right): (.*)$/;
        const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];
        const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];
        errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));
        comparedValues = [leftValue, rightValue];
      }
    }
    const regexNoInfo = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);
    const regexFileLine = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);
    const regexAccountName = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
    const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);
    if (noInfoAnchorErrorLog) {
      const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      return new AnchorError(errorCode, errorMessage, errorLogs, logs, undefined, comparedValues);
    } else if (fileLineAnchorErrorLog) {
      const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      const fileLine = { file, line: parseInt(line) };
      return new AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);
    } else if (accountNameAnchorErrorLog) {
      const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);
      const origin = accountName;
      const errorCode = {
        code: errorCodeString,
        number: parseInt(errorNumber)
      };
      return new AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);
    } else {
      return null;
    }
  }
  get program() {
    return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
  }
  get programErrorStack() {
    return this._programErrorStack.stack;
  }
  toString() {
    return this.message;
  }
}

class ProgramError extends Error {
  constructor(code2, msg, logs) {
    super();
    this.code = code2;
    this.msg = msg;
    this.logs = logs;
    if (logs) {
      this._programErrorStack = ProgramErrorStack.parse(logs);
    }
  }
  static parse(err2, idlErrors) {
    const errString = err2.toString();
    let unparsedErrorCode;
    if (errString.includes("custom program error:")) {
      let components = errString.split("custom program error: ");
      if (components.length !== 2) {
        return null;
      } else {
        unparsedErrorCode = components[1];
      }
    } else {
      const matches = errString.match(/"Custom":([0-9]+)}/g);
      if (!matches || matches.length > 1) {
        return null;
      }
      unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];
    }
    let errorCode;
    try {
      errorCode = parseInt(unparsedErrorCode);
    } catch (parseErr) {
      return null;
    }
    let errorMsg = idlErrors.get(errorCode);
    if (errorMsg !== undefined) {
      return new ProgramError(errorCode, errorMsg, err2.logs);
    }
    errorMsg = LangErrorMessage.get(errorCode);
    if (errorMsg !== undefined) {
      return new ProgramError(errorCode, errorMsg, err2.logs);
    }
    return null;
  }
  get program() {
    var _a;
    return (_a = this._programErrorStack) === null || _a === undefined ? undefined : _a.stack[this._programErrorStack.stack.length - 1];
  }
  get programErrorStack() {
    var _a;
    return (_a = this._programErrorStack) === null || _a === undefined ? undefined : _a.stack;
  }
  toString() {
    return this.msg;
  }
}
function translateError(err2, idlErrors) {
  if (isSet("debug-logs")) {
    console.log("Translating error:", err2);
  }
  const anchorError = AnchorError.parse(err2.logs);
  if (anchorError) {
    return anchorError;
  }
  const programError = ProgramError.parse(err2, idlErrors);
  if (programError) {
    return programError;
  }
  if (err2.logs) {
    const handler = {
      get: function(target, prop) {
        if (prop === "programErrorStack") {
          return target.programErrorStack.stack;
        } else if (prop === "program") {
          return target.programErrorStack.stack[err2.programErrorStack.stack.length - 1];
        } else {
          return Reflect.get(...arguments);
        }
      }
    };
    err2.programErrorStack = ProgramErrorStack.parse(err2.logs);
    return new Proxy(err2, handler);
  }
  return err2;
}
var LangErrorCode = {
  InstructionMissing: ANCHOR_ERROR__INSTRUCTION_MISSING,
  InstructionFallbackNotFound: ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND,
  InstructionDidNotDeserialize: ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE,
  InstructionDidNotSerialize: ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE,
  IdlInstructionStub: ANCHOR_ERROR__IDL_INSTRUCTION_STUB,
  IdlInstructionInvalidProgram: ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM,
  IdlAccountNotEmpty: ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY,
  EventInstructionStub: ANCHOR_ERROR__EVENT_INSTRUCTION_STUB,
  ConstraintMut: ANCHOR_ERROR__CONSTRAINT_MUT,
  ConstraintHasOne: ANCHOR_ERROR__CONSTRAINT_HAS_ONE,
  ConstraintSigner: ANCHOR_ERROR__CONSTRAINT_SIGNER,
  ConstraintRaw: ANCHOR_ERROR__CONSTRAINT_RAW,
  ConstraintOwner: ANCHOR_ERROR__CONSTRAINT_OWNER,
  ConstraintRentExempt: ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT,
  ConstraintSeeds: ANCHOR_ERROR__CONSTRAINT_SEEDS,
  ConstraintExecutable: ANCHOR_ERROR__CONSTRAINT_EXECUTABLE,
  ConstraintState: ANCHOR_ERROR__CONSTRAINT_STATE,
  ConstraintAssociated: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED,
  ConstraintAssociatedInit: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT,
  ConstraintClose: ANCHOR_ERROR__CONSTRAINT_CLOSE,
  ConstraintAddress: ANCHOR_ERROR__CONSTRAINT_ADDRESS,
  ConstraintZero: ANCHOR_ERROR__CONSTRAINT_ZERO,
  ConstraintTokenMint: ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT,
  ConstraintTokenOwner: ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER,
  ConstraintMintMintAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY,
  ConstraintMintFreezeAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY,
  ConstraintMintDecimals: ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS,
  ConstraintSpace: ANCHOR_ERROR__CONSTRAINT_SPACE,
  ConstraintAccountIsNone: ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE,
  ConstraintTokenTokenProgram: ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM,
  ConstraintMintTokenProgram: ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM,
  ConstraintAssociatedTokenTokenProgram: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM,
  ConstraintMintGroupPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION,
  ConstraintMintGroupPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY,
  ConstraintMintGroupPointerExtensionGroupAddress: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS,
  ConstraintMintGroupMemberPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION,
  ConstraintMintGroupMemberPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY,
  ConstraintMintGroupMemberPointerExtensionMemberAddress: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS,
  ConstraintMintMetadataPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION,
  ConstraintMintMetadataPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY,
  ConstraintMintMetadataPointerExtensionMetadataAddress: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS,
  ConstraintMintCloseAuthorityExtension: ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION,
  ConstraintMintCloseAuthorityExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY,
  ConstraintMintPermanentDelegateExtension: ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION,
  ConstraintMintPermanentDelegateExtensionDelegate: ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE,
  ConstraintMintTransferHookExtension: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION,
  ConstraintMintTransferHookExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY,
  ConstraintMintTransferHookExtensionProgramId: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID,
  RequireViolated: ANCHOR_ERROR__REQUIRE_VIOLATED,
  RequireEqViolated: ANCHOR_ERROR__REQUIRE_EQ_VIOLATED,
  RequireKeysEqViolated: ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED,
  RequireNeqViolated: ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED,
  RequireKeysNeqViolated: ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED,
  RequireGtViolated: ANCHOR_ERROR__REQUIRE_GT_VIOLATED,
  RequireGteViolated: ANCHOR_ERROR__REQUIRE_GTE_VIOLATED,
  AccountDiscriminatorAlreadySet: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET,
  AccountDiscriminatorNotFound: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND,
  AccountDiscriminatorMismatch: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH,
  AccountDidNotDeserialize: ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE,
  AccountDidNotSerialize: ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE,
  AccountNotEnoughKeys: ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS,
  AccountNotMutable: ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE,
  AccountOwnedByWrongProgram: ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM,
  InvalidProgramId: ANCHOR_ERROR__INVALID_PROGRAM_ID,
  InvalidProgramExecutable: ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE,
  AccountNotSigner: ANCHOR_ERROR__ACCOUNT_NOT_SIGNER,
  AccountNotSystemOwned: ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED,
  AccountNotInitialized: ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED,
  AccountNotProgramData: ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA,
  AccountNotAssociatedTokenAccount: ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT,
  AccountSysvarMismatch: ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH,
  AccountReallocExceedsLimit: ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT,
  AccountDuplicateReallocs: ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS,
  DeclaredProgramIdMismatch: ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH,
  TryingToInitPayerAsProgramAccount: ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT,
  InvalidNumericConversion: ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION,
  Deprecated: ANCHOR_ERROR__DEPRECATED
};
var LangErrorMessage = new Map([
  [LangErrorCode.InstructionMissing, "Instruction discriminator not provided"],
  [
    LangErrorCode.InstructionFallbackNotFound,
    "Fallback functions are not supported"
  ],
  [
    LangErrorCode.InstructionDidNotDeserialize,
    "The program could not deserialize the given instruction"
  ],
  [
    LangErrorCode.InstructionDidNotSerialize,
    "The program could not serialize the given instruction"
  ],
  [
    LangErrorCode.IdlInstructionStub,
    "The program was compiled without idl instructions"
  ],
  [
    LangErrorCode.IdlInstructionInvalidProgram,
    "The transaction was given an invalid program for the IDL instruction"
  ],
  [
    LangErrorCode.IdlAccountNotEmpty,
    "IDL account must be empty in order to resize, try closing first"
  ],
  [
    LangErrorCode.EventInstructionStub,
    "The program was compiled without `event-cpi` feature"
  ],
  [LangErrorCode.ConstraintMut, "A mut constraint was violated"],
  [LangErrorCode.ConstraintHasOne, "A has one constraint was violated"],
  [LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
  [LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
  [LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
  [
    LangErrorCode.ConstraintRentExempt,
    "A rent exemption constraint was violated"
  ],
  [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
  [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
  [
    LangErrorCode.ConstraintState,
    "Deprecated Error, feel free to replace with something else"
  ],
  [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
  [
    LangErrorCode.ConstraintAssociatedInit,
    "An associated init constraint was violated"
  ],
  [LangErrorCode.ConstraintClose, "A close constraint was violated"],
  [LangErrorCode.ConstraintAddress, "An address constraint was violated"],
  [LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
  [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
  [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
  [
    LangErrorCode.ConstraintMintMintAuthority,
    "A mint mint authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintFreezeAuthority,
    "A mint freeze authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintDecimals,
    "A mint decimals constraint was violated"
  ],
  [LangErrorCode.ConstraintSpace, "A space constraint was violated"],
  [
    LangErrorCode.ConstraintAccountIsNone,
    "A required account for the constraint is None"
  ],
  [
    LangErrorCode.ConstraintTokenTokenProgram,
    "A token account token program constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintTokenProgram,
    "A mint token program constraint was violated"
  ],
  [
    LangErrorCode.ConstraintAssociatedTokenTokenProgram,
    "An associated token account token program constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintGroupPointerExtension,
    "A group pointer extension constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintGroupPointerExtensionAuthority,
    "A group pointer extension authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintGroupPointerExtensionGroupAddress,
    "A group pointer extension group address constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintGroupMemberPointerExtension,
    "A group member pointer extension constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintGroupMemberPointerExtensionAuthority,
    "A group member pointer extension authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintGroupMemberPointerExtensionMemberAddress,
    "A group member pointer extension group address constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintMetadataPointerExtension,
    "A metadata pointer extension constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintMetadataPointerExtensionAuthority,
    "A metadata pointer extension authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintMetadataPointerExtensionMetadataAddress,
    "A metadata pointer extension metadata address constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintCloseAuthorityExtension,
    "A close authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintCloseAuthorityExtensionAuthority,
    "A close authority extension authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintPermanentDelegateExtension,
    "A permanent delegate extension constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintPermanentDelegateExtensionDelegate,
    "A permanent delegate extension delegate constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintTransferHookExtension,
    "A transfer hook extension constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintTransferHookExtensionAuthority,
    "A transfer hook extension authority constraint was violated"
  ],
  [
    LangErrorCode.ConstraintMintTransferHookExtensionProgramId,
    "A transfer hook extension transfer hook program id constraint was violated"
  ],
  [LangErrorCode.RequireViolated, "A require expression was violated"],
  [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"],
  [
    LangErrorCode.RequireKeysEqViolated,
    "A require_keys_eq expression was violated"
  ],
  [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"],
  [
    LangErrorCode.RequireKeysNeqViolated,
    "A require_keys_neq expression was violated"
  ],
  [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"],
  [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"],
  [
    LangErrorCode.AccountDiscriminatorAlreadySet,
    "The account discriminator was already set on this account"
  ],
  [
    LangErrorCode.AccountDiscriminatorNotFound,
    "No discriminator was found on the account"
  ],
  [
    LangErrorCode.AccountDiscriminatorMismatch,
    "Account discriminator did not match what was expected"
  ],
  [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
  [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
  [
    LangErrorCode.AccountNotEnoughKeys,
    "Not enough account keys given to the instruction"
  ],
  [LangErrorCode.AccountNotMutable, "The given account is not mutable"],
  [
    LangErrorCode.AccountOwnedByWrongProgram,
    "The given account is owned by a different program than expected"
  ],
  [LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
  [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
  [LangErrorCode.AccountNotSigner, "The given account did not sign"],
  [
    LangErrorCode.AccountNotSystemOwned,
    "The given account is not owned by the system program"
  ],
  [
    LangErrorCode.AccountNotInitialized,
    "The program expected this account to be already initialized"
  ],
  [
    LangErrorCode.AccountNotProgramData,
    "The given account is not a program data account"
  ],
  [
    LangErrorCode.AccountNotAssociatedTokenAccount,
    "The given account is not the associated token account"
  ],
  [
    LangErrorCode.AccountSysvarMismatch,
    "The given public key does not match the required sysvar"
  ],
  [
    LangErrorCode.AccountReallocExceedsLimit,
    "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"
  ],
  [
    LangErrorCode.AccountDuplicateReallocs,
    "The account was duplicated for more than one reallocation"
  ],
  [
    LangErrorCode.DeclaredProgramIdMismatch,
    "The declared program id does not match the actual program id"
  ],
  [
    LangErrorCode.TryingToInitPayerAsProgramAccount,
    "You cannot/should not initialize the payer account as a program account"
  ],
  [
    LangErrorCode.InvalidNumericConversion,
    "The program could not perform the numeric conversion, out of range integral type conversion attempted"
  ],
  [
    LangErrorCode.Deprecated,
    "The API being used is deprecated and should no longer be used"
  ]
]);

class IdlCoder {
  static fieldLayout(field, types2 = [], genericArgs) {
    const fieldName = field.name;
    switch (field.type) {
      case "bool": {
        return borsh.bool(fieldName);
      }
      case "u8": {
        return borsh.u8(fieldName);
      }
      case "i8": {
        return borsh.i8(fieldName);
      }
      case "u16": {
        return borsh.u16(fieldName);
      }
      case "i16": {
        return borsh.i16(fieldName);
      }
      case "u32": {
        return borsh.u32(fieldName);
      }
      case "i32": {
        return borsh.i32(fieldName);
      }
      case "f32": {
        return borsh.f32(fieldName);
      }
      case "u64": {
        return borsh.u64(fieldName);
      }
      case "i64": {
        return borsh.i64(fieldName);
      }
      case "f64": {
        return borsh.f64(fieldName);
      }
      case "u128": {
        return borsh.u128(fieldName);
      }
      case "i128": {
        return borsh.i128(fieldName);
      }
      case "u256": {
        return borsh.u256(fieldName);
      }
      case "i256": {
        return borsh.i256(fieldName);
      }
      case "bytes": {
        return borsh.vecU8(fieldName);
      }
      case "string": {
        return borsh.str(fieldName);
      }
      case "pubkey": {
        return borsh.publicKey(fieldName);
      }
      default: {
        if ("option" in field.type) {
          return borsh.option(IdlCoder.fieldLayout({ type: field.type.option }, types2, genericArgs), fieldName);
        }
        if ("vec" in field.type) {
          return borsh.vec(IdlCoder.fieldLayout({ type: field.type.vec }, types2, genericArgs), fieldName);
        }
        if ("array" in field.type) {
          let [type3, len2] = field.type.array;
          len2 = IdlCoder.resolveArrayLen(len2, genericArgs);
          return borsh.array(IdlCoder.fieldLayout({ type: type3 }, types2, genericArgs), len2, fieldName);
        }
        if ("defined" in field.type) {
          if (!types2) {
            throw new IdlError("User defined types not provided");
          }
          const definedName = field.type.defined.name;
          const typeDef = types2.find((t) => t.name === definedName);
          if (!typeDef) {
            throw new IdlError(`Type not found: ${field.name}`);
          }
          return IdlCoder.typeDefLayout({
            typeDef,
            types: types2,
            genericArgs: genericArgs !== null && genericArgs !== undefined ? genericArgs : field.type.defined.generics,
            name: fieldName
          });
        }
        if ("generic" in field.type) {
          const genericArg = genericArgs === null || genericArgs === undefined ? undefined : genericArgs.at(0);
          if ((genericArg === null || genericArg === undefined ? undefined : genericArg.kind) !== "type") {
            throw new IdlError(`Invalid generic field: ${field.name}`);
          }
          return IdlCoder.fieldLayout({ ...field, type: genericArg.type }, types2);
        }
        throw new IdlError(`Not yet implemented: ${JSON.stringify(field.type)}`);
      }
    }
  }
  static typeDefLayout({ typeDef, types: types2, name, genericArgs }) {
    switch (typeDef.type.kind) {
      case "struct": {
        const fieldLayouts = handleDefinedFields(typeDef.type.fields, () => [], (fields2) => fields2.map((f22) => {
          const genArgs = genericArgs ? IdlCoder.resolveGenericArgs({
            type: f22.type,
            typeDef,
            genericArgs
          }) : genericArgs;
          return IdlCoder.fieldLayout(f22, types2, genArgs);
        }), (fields2) => fields2.map((f22, i22) => {
          const genArgs = genericArgs ? IdlCoder.resolveGenericArgs({
            type: f22,
            typeDef,
            genericArgs
          }) : genericArgs;
          return IdlCoder.fieldLayout({ name: i22.toString(), type: f22 }, types2, genArgs);
        }));
        return borsh.struct(fieldLayouts, name);
      }
      case "enum": {
        const variants = typeDef.type.variants.map((variant) => {
          const fieldLayouts = handleDefinedFields(variant.fields, () => [], (fields2) => fields2.map((f22) => {
            const genArgs = genericArgs ? IdlCoder.resolveGenericArgs({
              type: f22.type,
              typeDef,
              genericArgs
            }) : genericArgs;
            return IdlCoder.fieldLayout(f22, types2, genArgs);
          }), (fields2) => fields2.map((f22, i22) => {
            const genArgs = genericArgs ? IdlCoder.resolveGenericArgs({
              type: f22,
              typeDef,
              genericArgs
            }) : genericArgs;
            return IdlCoder.fieldLayout({ name: i22.toString(), type: f22 }, types2, genArgs);
          }));
          return borsh.struct(fieldLayouts, variant.name);
        });
        if (name !== undefined) {
          return borsh.rustEnum(variants).replicate(name);
        }
        return borsh.rustEnum(variants, name);
      }
      case "type": {
        return IdlCoder.fieldLayout({ type: typeDef.type.alias, name }, types2);
      }
    }
  }
  static typeSize(ty, idl, genericArgs) {
    var _a;
    switch (ty) {
      case "bool":
        return 1;
      case "u8":
        return 1;
      case "i8":
        return 1;
      case "i16":
        return 2;
      case "u16":
        return 2;
      case "u32":
        return 4;
      case "i32":
        return 4;
      case "f32":
        return 4;
      case "u64":
        return 8;
      case "i64":
        return 8;
      case "f64":
        return 8;
      case "u128":
        return 16;
      case "i128":
        return 16;
      case "u256":
        return 32;
      case "i256":
        return 32;
      case "bytes":
        return 1;
      case "string":
        return 1;
      case "pubkey":
        return 32;
      default:
        if ("option" in ty) {
          return 1 + IdlCoder.typeSize(ty.option, idl, genericArgs);
        }
        if ("coption" in ty) {
          return 4 + IdlCoder.typeSize(ty.coption, idl, genericArgs);
        }
        if ("vec" in ty) {
          return 1;
        }
        if ("array" in ty) {
          let [type3, len2] = ty.array;
          len2 = IdlCoder.resolveArrayLen(len2, genericArgs);
          return IdlCoder.typeSize(type3, idl, genericArgs) * len2;
        }
        if ("defined" in ty) {
          const typeDef = (_a = idl.types) === null || _a === undefined ? undefined : _a.find((t) => t.name === ty.defined.name);
          if (!typeDef) {
            throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);
          }
          const typeSize = (type3) => {
            const genArgs = genericArgs !== null && genericArgs !== undefined ? genericArgs : ty.defined.generics;
            const args = genArgs ? IdlCoder.resolveGenericArgs({
              type: type3,
              typeDef,
              genericArgs: genArgs
            }) : genArgs;
            return IdlCoder.typeSize(type3, idl, args);
          };
          switch (typeDef.type.kind) {
            case "struct": {
              return handleDefinedFields(typeDef.type.fields, () => [0], (fields2) => fields2.map((f22) => typeSize(f22.type)), (fields2) => fields2.map((f22) => typeSize(f22))).reduce((acc, size) => acc + size, 0);
            }
            case "enum": {
              const variantSizes = typeDef.type.variants.map((variant) => {
                return handleDefinedFields(variant.fields, () => [0], (fields2) => fields2.map((f22) => typeSize(f22.type)), (fields2) => fields2.map((f22) => typeSize(f22))).reduce((acc, size) => acc + size, 0);
              });
              return Math.max(...variantSizes) + 1;
            }
            case "type": {
              return IdlCoder.typeSize(typeDef.type.alias, idl, genericArgs);
            }
          }
        }
        if ("generic" in ty) {
          const genericArg = genericArgs === null || genericArgs === undefined ? undefined : genericArgs.at(0);
          if ((genericArg === null || genericArg === undefined ? undefined : genericArg.kind) !== "type") {
            throw new IdlError(`Invalid generic: ${ty.generic}`);
          }
          return IdlCoder.typeSize(genericArg.type, idl, genericArgs);
        }
        throw new Error(`Invalid type ${JSON.stringify(ty)}`);
    }
  }
  static resolveArrayLen(len2, genericArgs) {
    if (typeof len2 === "number")
      return len2;
    if (genericArgs) {
      const genericLen = genericArgs.find((g) => g.kind === "const");
      if ((genericLen === null || genericLen === undefined ? undefined : genericLen.kind) === "const") {
        len2 = +genericLen.value;
      }
    }
    if (typeof len2 !== "number") {
      throw new IdlError("Generic array length did not resolve");
    }
    return len2;
  }
  static resolveGenericArgs({ type: type3, typeDef, genericArgs, isDefined }) {
    if (typeof type3 !== "object")
      return null;
    for (const index in typeDef.generics) {
      const defGeneric = typeDef.generics[index];
      if ("generic" in type3 && defGeneric.name === type3.generic) {
        return [genericArgs[index]];
      }
      if ("option" in type3) {
        const args = IdlCoder.resolveGenericArgs({
          type: type3.option,
          typeDef,
          genericArgs,
          isDefined
        });
        if (!args || !isDefined)
          return args;
        if (args[0].kind === "type") {
          return [
            {
              kind: "type",
              type: { option: args[0].type }
            }
          ];
        }
      }
      if ("vec" in type3) {
        const args = IdlCoder.resolveGenericArgs({
          type: type3.vec,
          typeDef,
          genericArgs,
          isDefined
        });
        if (!args || !isDefined)
          return args;
        if (args[0].kind === "type") {
          return [
            {
              kind: "type",
              type: { vec: args[0].type }
            }
          ];
        }
      }
      if ("array" in type3) {
        const [elTy, len2] = type3.array;
        const isGenericLen = typeof len2 === "object";
        const args = IdlCoder.resolveGenericArgs({
          type: elTy,
          typeDef,
          genericArgs,
          isDefined
        }) || [];
        if (isGenericLen) {
          const matchingGeneric = typeDef.generics.findIndex((g) => g.name === len2.generic);
          if (matchingGeneric !== -1) {
            args.push(genericArgs[matchingGeneric]);
          }
        }
        if (args.length > 0) {
          if (!isDefined)
            return args;
          if (args[0].kind === "type" && args[1].kind === "const") {
            return [
              {
                kind: "type",
                type: { array: [args[0].type, +args[1].value] }
              }
            ];
          }
        }
        if (isGenericLen && defGeneric.name === len2.generic) {
          const arg = genericArgs[index];
          if (!isDefined)
            return [arg];
          return [
            {
              kind: "type",
              type: { array: [elTy, +arg.value] }
            }
          ];
        }
        return null;
      }
      if ("defined" in type3) {
        if (!type3.defined.generics)
          return null;
        return type3.defined.generics.flatMap((g) => {
          switch (g.kind) {
            case "type":
              return IdlCoder.resolveGenericArgs({
                type: g.type,
                typeDef,
                genericArgs,
                isDefined: true
              });
            case "const":
              return [g];
          }
        }).filter((g) => g !== null);
      }
    }
    return null;
  }
}

class BorshInstructionCoder {
  constructor(idl) {
    this.idl = idl;
    const ixLayouts = idl.instructions.map((ix) => {
      const name = ix.name;
      const fieldLayouts = ix.args.map((arg) => IdlCoder.fieldLayout(arg, idl.types));
      const layout = borsh.struct(fieldLayouts, name);
      return [name, { discriminator: ix.discriminator, layout }];
    });
    this.ixLayouts = new Map(ixLayouts);
  }
  encode(ixName, ix) {
    const buffer = export_Buffer.alloc(1000);
    const encoder = this.ixLayouts.get(ixName);
    if (!encoder) {
      throw new Error(`Unknown method: ${ixName}`);
    }
    const len2 = encoder.layout.encode(ix, buffer);
    const data = buffer.slice(0, len2);
    return export_Buffer.concat([export_Buffer.from(encoder.discriminator), data]);
  }
  decode(ix, encoding = "hex") {
    if (typeof ix === "string") {
      ix = encoding === "hex" ? export_Buffer.from(ix, "hex") : import_bs5822.default.decode(ix);
    }
    for (const [name, layout] of this.ixLayouts) {
      const givenDisc = ix.subarray(0, layout.discriminator.length);
      const matches = givenDisc.equals(export_Buffer.from(layout.discriminator));
      if (matches) {
        return {
          name,
          data: layout.layout.decode(ix.subarray(givenDisc.length))
        };
      }
    }
    return null;
  }
  format(ix, accountMetas) {
    return InstructionFormatter.format(ix, accountMetas, this.idl);
  }
}

class InstructionFormatter {
  static format(ix, accountMetas, idl) {
    const idlIx = idl.instructions.find((i22) => ix.name === i22.name);
    if (!idlIx) {
      console.error("Invalid instruction given");
      return null;
    }
    const args = idlIx.args.map((idlField) => {
      return {
        name: idlField.name,
        type: InstructionFormatter.formatIdlType(idlField.type),
        data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)
      };
    });
    const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);
    const accounts = accountMetas.map((meta, idx) => {
      if (idx < flatIdlAccounts.length) {
        return {
          name: flatIdlAccounts[idx].name,
          ...meta
        };
      } else {
        return {
          name: undefined,
          ...meta
        };
      }
    });
    return {
      args,
      accounts
    };
  }
  static formatIdlType(idlType) {
    if (typeof idlType === "string") {
      return idlType;
    }
    if ("option" in idlType) {
      return `Option<${this.formatIdlType(idlType.option)}>`;
    }
    if ("coption" in idlType) {
      return `COption<${this.formatIdlType(idlType.coption)}>`;
    }
    if ("vec" in idlType) {
      return `Vec<${this.formatIdlType(idlType.vec)}>`;
    }
    if ("array" in idlType) {
      return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;
    }
    if ("defined" in idlType) {
      const name = idlType.defined.name;
      if (idlType.defined.generics) {
        const generics = idlType.defined.generics.map((g) => {
          switch (g.kind) {
            case "type":
              return InstructionFormatter.formatIdlType(g.type);
            case "const":
              return g.value;
          }
        }).join(", ");
        return `${name}<${generics}>`;
      }
      return name;
    }
    throw new Error(`Unknown IDL type: ${idlType}`);
  }
  static formatIdlData(idlField, data, types2) {
    if (typeof idlField.type === "string") {
      return data.toString();
    }
    if ("vec" in idlField.type) {
      return "[" + data.map((d) => this.formatIdlData({ name: "", type: idlField.type.vec }, d, types2)).join(", ") + "]";
    }
    if ("option" in idlField.type) {
      return data === null ? "null" : this.formatIdlData({ name: "", type: idlField.type.option }, data, types2);
    }
    if ("defined" in idlField.type) {
      if (!types2) {
        throw new Error("User defined types not provided");
      }
      const definedName = idlField.type.defined.name;
      const typeDef = types2.find((t) => t.name === definedName);
      if (!typeDef) {
        throw new Error(`Type not found: ${definedName}`);
      }
      return InstructionFormatter.formatIdlDataDefined(typeDef, data, types2);
    }
    return "unknown";
  }
  static formatIdlDataDefined(typeDef, data, types2) {
    switch (typeDef.type.kind) {
      case "struct": {
        return "{ " + handleDefinedFields(typeDef.type.fields, () => "", (fields2) => {
          return Object.entries(data).map(([key, val]) => {
            const field = fields2.find((f22) => f22.name === key);
            if (!field) {
              throw new Error(`Field not found: ${key}`);
            }
            return key + ": " + InstructionFormatter.formatIdlData(field, val, types2);
          }).join(", ");
        }, (fields2) => {
          return Object.entries(data).map(([key, val]) => {
            return key + ": " + InstructionFormatter.formatIdlData({ name: "", type: fields2[key] }, val, types2);
          }).join(", ");
        }) + " }";
      }
      case "enum": {
        const variantName = Object.keys(data)[0];
        const variant = typeDef.type.variants.find((v) => v.name === variantName);
        if (!variant) {
          throw new Error(`Unable to find variant: ${variantName}`);
        }
        const enumValue = data[variantName];
        return handleDefinedFields(variant.fields, () => variantName, (fields2) => {
          const namedFields = Object.keys(enumValue).map((f22) => {
            const fieldData = enumValue[f22];
            const idlField = fields2.find((v) => v.name === f22);
            if (!idlField) {
              throw new Error(`Field not found: ${f22}`);
            }
            return f22 + ": " + InstructionFormatter.formatIdlData(idlField, fieldData, types2);
          }).join(", ");
          return `${variantName} { ${namedFields} }`;
        }, (fields2) => {
          const tupleFields = Object.entries(enumValue).map(([key, val]) => {
            return key + ": " + InstructionFormatter.formatIdlData({ name: "", type: fields2[key] }, val, types2);
          }).join(", ");
          return `${variantName} { ${tupleFields} }`;
        });
      }
      case "type": {
        return InstructionFormatter.formatIdlType(typeDef.type.alias);
      }
    }
  }
  static flattenIdlAccounts(accounts, prefix) {
    return accounts.map((account) => {
      const accName = sentenceCase(account.name);
      if (account.hasOwnProperty("accounts")) {
        const newPrefix = prefix ? `${prefix} > ${accName}` : accName;
        return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);
      } else {
        return {
          ...account,
          name: prefix ? `${prefix} > ${accName}` : accName
        };
      }
    }).flat();
  }
}
function sentenceCase(field) {
  const result = field.replace(/([A-Z])/g, " $1");
  return result.charAt(0).toUpperCase() + result.slice(1);
}

class BorshAccountsCoder {
  constructor(idl) {
    this.idl = idl;
    if (!idl.accounts) {
      this.accountLayouts = new Map;
      return;
    }
    const types2 = idl.types;
    if (!types2) {
      throw new Error("Accounts require `idl.types`");
    }
    const layouts = idl.accounts.map((acc) => {
      const typeDef = types2.find((ty) => ty.name === acc.name);
      if (!typeDef) {
        throw new Error(`Account not found: ${acc.name}`);
      }
      return [
        acc.name,
        {
          discriminator: acc.discriminator,
          layout: IdlCoder.typeDefLayout({ typeDef, types: types2 })
        }
      ];
    });
    this.accountLayouts = new Map(layouts);
  }
  async encode(accountName, account) {
    const buffer = export_Buffer.alloc(1000);
    const layout = this.accountLayouts.get(accountName);
    if (!layout) {
      throw new Error(`Unknown account: ${accountName}`);
    }
    const len2 = layout.layout.encode(account, buffer);
    const accountData = buffer.slice(0, len2);
    const discriminator = this.accountDiscriminator(accountName);
    return export_Buffer.concat([discriminator, accountData]);
  }
  decode(accountName, data) {
    const discriminator = this.accountDiscriminator(accountName);
    if (discriminator.compare(data.slice(0, discriminator.length))) {
      throw new Error("Invalid account discriminator");
    }
    return this.decodeUnchecked(accountName, data);
  }
  decodeAny(data) {
    for (const [name, layout] of this.accountLayouts) {
      const givenDisc = data.subarray(0, layout.discriminator.length);
      const matches = givenDisc.equals(export_Buffer.from(layout.discriminator));
      if (matches)
        return this.decodeUnchecked(name, data);
    }
    throw new Error("Account not found");
  }
  decodeUnchecked(accountName, acc) {
    const discriminator = this.accountDiscriminator(accountName);
    const data = acc.subarray(discriminator.length);
    const layout = this.accountLayouts.get(accountName);
    if (!layout) {
      throw new Error(`Unknown account: ${accountName}`);
    }
    return layout.layout.decode(data);
  }
  memcmp(accountName, appendData) {
    const discriminator = this.accountDiscriminator(accountName);
    return {
      offset: 0,
      bytes: import_bs5822.default.encode(appendData ? export_Buffer.concat([discriminator, appendData]) : discriminator)
    };
  }
  size(accountName) {
    return this.accountDiscriminator(accountName).length + IdlCoder.typeSize({ defined: { name: accountName } }, this.idl);
  }
  accountDiscriminator(name) {
    var _a;
    const account = (_a = this.idl.accounts) === null || _a === undefined ? undefined : _a.find((acc) => acc.name === name);
    if (!account) {
      throw new Error(`Account not found: ${name}`);
    }
    return export_Buffer.from(account.discriminator);
  }
}

class BorshEventCoder {
  constructor(idl) {
    if (!idl.events) {
      this.layouts = new Map;
      return;
    }
    const types2 = idl.types;
    if (!types2) {
      throw new Error("Events require `idl.types`");
    }
    const layouts = idl.events.map((ev) => {
      const typeDef = types2.find((ty) => ty.name === ev.name);
      if (!typeDef) {
        throw new Error(`Event not found: ${ev.name}`);
      }
      return [
        ev.name,
        {
          discriminator: ev.discriminator,
          layout: IdlCoder.typeDefLayout({ typeDef, types: types2 })
        }
      ];
    });
    this.layouts = new Map(layouts);
  }
  decode(log3) {
    let logArr;
    try {
      logArr = decode22(log3);
    } catch (e) {
      return null;
    }
    for (const [name, layout] of this.layouts) {
      const givenDisc = logArr.subarray(0, layout.discriminator.length);
      const matches = givenDisc.equals(export_Buffer.from(layout.discriminator));
      if (matches) {
        return {
          name,
          data: layout.layout.decode(logArr.subarray(givenDisc.length))
        };
      }
    }
    return null;
  }
}

class BorshTypesCoder {
  constructor(idl) {
    const types2 = idl.types;
    if (!types2) {
      this.typeLayouts = new Map;
      return;
    }
    const layouts = types2.filter((ty) => !ty.generics).map((ty) => [
      ty.name,
      IdlCoder.typeDefLayout({ typeDef: ty, types: types2 })
    ]);
    this.typeLayouts = new Map(layouts);
  }
  encode(name, type3) {
    const buffer = export_Buffer.alloc(1000);
    const layout = this.typeLayouts.get(name);
    if (!layout) {
      throw new Error(`Unknown type: ${name}`);
    }
    const len2 = layout.encode(type3, buffer);
    return buffer.slice(0, len2);
  }
  decode(name, data) {
    const layout = this.typeLayouts.get(name);
    if (!layout) {
      throw new Error(`Unknown type: ${name}`);
    }
    return layout.decode(data);
  }
}

class BorshCoder {
  constructor(idl) {
    this.instruction = new BorshInstructionCoder(idl);
    this.accounts = new BorshAccountsCoder(idl);
    this.events = new BorshEventCoder(idl);
    this.types = new BorshTypesCoder(idl);
  }
}

class Layout {
  constructor(span, property) {
    if (!Number.isInteger(span)) {
      throw new TypeError("span must be an integer");
    }
    this.span = span;
    this.property = property;
  }
  makeDestinationObject() {
    return {};
  }
  decode(b22, offset2) {
    throw new Error("Layout is abstract");
  }
  encode(src, b22, offset2) {
    throw new Error("Layout is abstract");
  }
  getSpan(b22, offset2) {
    if (0 > this.span) {
      throw new RangeError("indeterminate span");
    }
    return this.span;
  }
  replicate(property) {
    const rv = Object.create(this.constructor.prototype);
    Object.assign(rv, this);
    rv.property = property;
    return rv;
  }
  fromArray(values) {
    return;
  }
}
var Layout_2 = Layout;
function nameWithProperty(name, lo) {
  if (lo.property) {
    return name + "[" + lo.property + "]";
  }
  return name;
}

class ExternalLayout extends Layout {
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}

class OffsetLayout extends ExternalLayout {
  constructor(layout, offset2, property) {
    if (!(layout instanceof Layout)) {
      throw new TypeError("layout must be a Layout");
    }
    if (offset2 === undefined) {
      offset2 = 0;
    } else if (!Number.isInteger(offset2)) {
      throw new TypeError("offset must be integer or undefined");
    }
    super(layout.span, property || layout.property);
    this.layout = layout;
    this.offset = offset2;
  }
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  decode(b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    return this.layout.decode(b22, offset2 + this.offset);
  }
  encode(src, b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    return this.layout.encode(src, b22, offset2 + this.offset);
  }
}

class UInt extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  decode(b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    return b22.readUIntLE(offset2, this.span);
  }
  encode(src, b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    b22.writeUIntLE(src, offset2, this.span);
    return this.span;
  }
}

class UIntBE extends Layout {
  constructor(span, property) {
    super(span, property);
    if (6 < this.span) {
      throw new RangeError("span must not exceed 6 bytes");
    }
  }
  decode(b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    return b22.readUIntBE(offset2, this.span);
  }
  encode(src, b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    b22.writeUIntBE(src, offset2, this.span);
    return this.span;
  }
}
var V2E32 = Math.pow(2, 32);
function divmodInt64(src) {
  const hi32 = Math.floor(src / V2E32);
  const lo32 = src - hi32 * V2E32;
  return { hi32, lo32 };
}
function roundedInt64(hi32, lo32) {
  return hi32 * V2E32 + lo32;
}

class NearUInt64 extends Layout {
  constructor(property) {
    super(8, property);
  }
  decode(b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    const lo32 = b22.readUInt32LE(offset2);
    const hi32 = b22.readUInt32LE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  encode(src, b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    const split22 = divmodInt64(src);
    b22.writeUInt32LE(split22.lo32, offset2);
    b22.writeUInt32LE(split22.hi32, offset2 + 4);
    return 8;
  }
}

class NearInt64 extends Layout {
  constructor(property) {
    super(8, property);
  }
  decode(b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    const lo32 = b22.readUInt32LE(offset2);
    const hi32 = b22.readInt32LE(offset2 + 4);
    return roundedInt64(hi32, lo32);
  }
  encode(src, b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    const split22 = divmodInt64(src);
    b22.writeUInt32LE(split22.lo32, offset2);
    b22.writeInt32LE(split22.hi32, offset2 + 4);
    return 8;
  }
}

class Structure extends Layout {
  constructor(fields2, property, decodePrefixes) {
    if (!(Array.isArray(fields2) && fields2.reduce((acc, v) => acc && v instanceof Layout, true))) {
      throw new TypeError("fields must be array of Layout instances");
    }
    if (typeof property === "boolean" && decodePrefixes === undefined) {
      decodePrefixes = property;
      property = undefined;
    }
    for (const fd of fields2) {
      if (0 > fd.span && fd.property === undefined) {
        throw new Error("fields cannot contain unnamed variable-length layout");
      }
    }
    let span = -1;
    try {
      span = fields2.reduce((span2, fd) => span2 + fd.getSpan(), 0);
    } catch (e) {}
    super(span, property);
    this.fields = fields2;
    this.decodePrefixes = !!decodePrefixes;
  }
  getSpan(b22, offset2) {
    if (0 <= this.span) {
      return this.span;
    }
    if (offset2 === undefined) {
      offset2 = 0;
    }
    let span = 0;
    try {
      span = this.fields.reduce((span2, fd) => {
        const fsp = fd.getSpan(b22, offset2);
        offset2 += fsp;
        return span2 + fsp;
      }, 0);
    } catch (e) {
      throw new RangeError("indeterminate span");
    }
    return span;
  }
  decode(b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    const dest = this.makeDestinationObject();
    for (const fd of this.fields) {
      if (fd.property !== undefined) {
        dest[fd.property] = fd.decode(b22, offset2);
      }
      offset2 += fd.getSpan(b22, offset2);
      if (this.decodePrefixes && b22.length === offset2) {
        break;
      }
    }
    return dest;
  }
  encode(src, b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    const firstOffset = offset2;
    let lastOffset = 0;
    let lastWrote = 0;
    for (const fd of this.fields) {
      let span = fd.span;
      lastWrote = 0 < span ? span : 0;
      if (fd.property !== undefined) {
        const fv = src[fd.property];
        if (fv !== undefined) {
          lastWrote = fd.encode(fv, b22, offset2);
          if (0 > span) {
            span = fd.getSpan(b22, offset2);
          }
        }
      }
      lastOffset = offset2;
      offset2 += span;
    }
    return lastOffset + lastWrote - firstOffset;
  }
  fromArray(values) {
    const dest = this.makeDestinationObject();
    for (const fd of this.fields) {
      if (fd.property !== undefined && 0 < values.length) {
        dest[fd.property] = values.shift();
      }
    }
    return dest;
  }
  layoutFor(property) {
    if (typeof property !== "string") {
      throw new TypeError("property must be string");
    }
    for (const fd of this.fields) {
      if (fd.property === property) {
        return fd;
      }
    }
  }
  offsetOf(property) {
    if (typeof property !== "string") {
      throw new TypeError("property must be string");
    }
    let offset2 = 0;
    for (const fd of this.fields) {
      if (fd.property === property) {
        return offset2;
      }
      if (0 > fd.span) {
        offset2 = -1;
      } else if (0 <= offset2) {
        offset2 += fd.span;
      }
    }
  }
}

class UnionDiscriminator {
  constructor(property) {
    this.property = property;
  }
  decode() {
    throw new Error("UnionDiscriminator is abstract");
  }
  encode() {
    throw new Error("UnionDiscriminator is abstract");
  }
}

class UnionLayoutDiscriminator extends UnionDiscriminator {
  constructor(layout, property) {
    if (!(layout instanceof ExternalLayout && layout.isCount())) {
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    }
    super(property || layout.property || "variant");
    this.layout = layout;
  }
  decode(b22, offset2) {
    return this.layout.decode(b22, offset2);
  }
  encode(src, b22, offset2) {
    return this.layout.encode(src, b22, offset2);
  }
}

class Union extends Layout {
  constructor(discr, defaultLayout, property) {
    const upv = discr instanceof UInt || discr instanceof UIntBE;
    if (upv) {
      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
    } else if (discr instanceof ExternalLayout && discr.isCount()) {
      discr = new UnionLayoutDiscriminator(discr);
    } else if (!(discr instanceof UnionDiscriminator)) {
      throw new TypeError("discr must be a UnionDiscriminator " + "or an unsigned integer layout");
    }
    if (defaultLayout === undefined) {
      defaultLayout = null;
    }
    if (!(defaultLayout === null || defaultLayout instanceof Layout)) {
      throw new TypeError("defaultLayout must be null or a Layout");
    }
    if (defaultLayout !== null) {
      if (0 > defaultLayout.span) {
        throw new Error("defaultLayout must have constant span");
      }
      if (defaultLayout.property === undefined) {
        defaultLayout = defaultLayout.replicate("content");
      }
    }
    let span = -1;
    if (defaultLayout) {
      span = defaultLayout.span;
      if (0 <= span && upv) {
        span += discr.layout.span;
      }
    }
    super(span, property);
    this.discriminator = discr;
    this.usesPrefixDiscriminator = upv;
    this.defaultLayout = defaultLayout;
    this.registry = {};
    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(src) {
      return boundGetSourceVariant(src);
    };
    this.configGetSourceVariant = function(gsv) {
      boundGetSourceVariant = gsv.bind(this);
    };
  }
  getSpan(b22, offset2) {
    if (0 <= this.span) {
      return this.span;
    }
    if (offset2 === undefined) {
      offset2 = 0;
    }
    const vlo = this.getVariant(b22, offset2);
    if (!vlo) {
      throw new Error("unable to determine span for unrecognized variant");
    }
    return vlo.getSpan(b22, offset2);
  }
  defaultGetSourceVariant(src) {
    if (src.hasOwnProperty(this.discriminator.property)) {
      if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
        return;
      }
      const vlo = this.registry[src[this.discriminator.property]];
      if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
        return vlo;
      }
    } else {
      for (const tag2 in this.registry) {
        const vlo = this.registry[tag2];
        if (src.hasOwnProperty(vlo.property)) {
          return vlo;
        }
      }
    }
    throw new Error("unable to infer src variant");
  }
  decode(b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    let dest;
    const dlo = this.discriminator;
    const discr = dlo.decode(b22, offset2);
    let clo = this.registry[discr];
    if (clo === undefined) {
      let contentOffset = 0;
      clo = this.defaultLayout;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dest = this.makeDestinationObject();
      dest[dlo.property] = discr;
      dest[clo.property] = this.defaultLayout.decode(b22, offset2 + contentOffset);
    } else {
      dest = clo.decode(b22, offset2);
    }
    return dest;
  }
  encode(src, b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    const vlo = this.getSourceVariant(src);
    if (vlo === undefined) {
      const dlo = this.discriminator;
      const clo = this.defaultLayout;
      let contentOffset = 0;
      if (this.usesPrefixDiscriminator) {
        contentOffset = dlo.layout.span;
      }
      dlo.encode(src[dlo.property], b22, offset2);
      return contentOffset + clo.encode(src[clo.property], b22, offset2 + contentOffset);
    }
    return vlo.encode(src, b22, offset2);
  }
  addVariant(variant, layout, property) {
    const rv = new VariantLayout(this, variant, layout, property);
    this.registry[variant] = rv;
    return rv;
  }
  getVariant(vb, offset2) {
    let variant = vb;
    if (Buffer.isBuffer(vb)) {
      if (offset2 === undefined) {
        offset2 = 0;
      }
      variant = this.discriminator.decode(vb, offset2);
    }
    return this.registry[variant];
  }
}

class VariantLayout extends Layout {
  constructor(union22, variant, layout, property) {
    if (!(union22 instanceof Union)) {
      throw new TypeError("union must be a Union");
    }
    if (!Number.isInteger(variant) || 0 > variant) {
      throw new TypeError("variant must be a (non-negative) integer");
    }
    if (typeof layout === "string" && property === undefined) {
      property = layout;
      layout = null;
    }
    if (layout) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (union22.defaultLayout !== null && 0 <= layout.span && layout.span > union22.defaultLayout.span) {
        throw new Error("variant span exceeds span of containing union");
      }
      if (typeof property !== "string") {
        throw new TypeError("variant must have a String property");
      }
    }
    let span = union22.span;
    if (0 > union22.span) {
      span = layout ? layout.span : 0;
      if (0 <= span && union22.usesPrefixDiscriminator) {
        span += union22.discriminator.layout.span;
      }
    }
    super(span, property);
    this.union = union22;
    this.variant = variant;
    this.layout = layout || null;
  }
  getSpan(b22, offset2) {
    if (0 <= this.span) {
      return this.span;
    }
    if (offset2 === undefined) {
      offset2 = 0;
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    return contentOffset + this.layout.getSpan(b22, offset2 + contentOffset);
  }
  decode(b22, offset2) {
    const dest = this.makeDestinationObject();
    if (offset2 === undefined) {
      offset2 = 0;
    }
    if (this !== this.union.getVariant(b22, offset2)) {
      throw new Error("variant mismatch");
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout) {
      dest[this.property] = this.layout.decode(b22, offset2 + contentOffset);
    } else if (this.property) {
      dest[this.property] = true;
    } else if (this.union.usesPrefixDiscriminator) {
      dest[this.union.discriminator.property] = this.variant;
    }
    return dest;
  }
  encode(src, b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    let contentOffset = 0;
    if (this.union.usesPrefixDiscriminator) {
      contentOffset = this.union.discriminator.layout.span;
    }
    if (this.layout && !src.hasOwnProperty(this.property)) {
      throw new TypeError("variant lacks property " + this.property);
    }
    this.union.discriminator.encode(this.variant, b22, offset2);
    let span = contentOffset;
    if (this.layout) {
      this.layout.encode(src[this.property], b22, offset2 + contentOffset);
      span += this.layout.getSpan(b22, offset2 + contentOffset);
      if (0 <= this.union.span && span > this.union.span) {
        throw new Error("encoded variant overruns containing union");
      }
    }
    return span;
  }
  fromArray(values) {
    if (this.layout) {
      return this.layout.fromArray(values);
    }
  }
}

class Blob$1 extends Layout {
  constructor(length, property) {
    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
      throw new TypeError("length must be positive integer " + "or an unsigned integer ExternalLayout");
    }
    let span = -1;
    if (!(length instanceof ExternalLayout)) {
      span = length;
    }
    super(span, property);
    this.length = length;
  }
  getSpan(b22, offset2) {
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b22, offset2);
    }
    return span;
  }
  decode(b22, offset2) {
    if (offset2 === undefined) {
      offset2 = 0;
    }
    let span = this.span;
    if (0 > span) {
      span = this.length.decode(b22, offset2);
    }
    return b22.slice(offset2, offset2 + span);
  }
  encode(src, b22, offset2) {
    let span = this.length;
    if (this.length instanceof ExternalLayout) {
      span = src.length;
    }
    if (!(Buffer.isBuffer(src) && span === src.length)) {
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
    }
    if (offset2 + span > b22.length) {
      throw new RangeError("encoding overruns Buffer");
    }
    b22.write(src.toString("hex"), offset2, span, "hex");
    if (this.length instanceof ExternalLayout) {
      this.length.encode(span, b22, offset2);
    }
    return span;
  }
}
var offset2 = (layout, offset3, property) => new OffsetLayout(layout, offset3, property);
var u83 = (property) => new UInt(1, property);
var u3242 = (property) => new UInt(4, property);
var nu642 = (property) => new NearUInt64(property);
var ns642 = (property) => new NearInt64(property);
var struct3 = (fields2, property, decodePrefixes) => new Structure(fields2, property, decodePrefixes);
var union22 = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
var blob3 = (length, property) => new Blob$1(length, property);

class RustStringLayout extends Layout_2 {
  constructor(property) {
    super(-1, property);
    this.property = property;
    this.layout = struct3([
      u3242("length"),
      u3242("lengthPadding"),
      blob3(offset2(u3242(), -8), "chars")
    ], this.property);
  }
  encode(src, b22, offset3 = 0) {
    if (src === null || src === undefined) {
      return this.layout.span;
    }
    const data = {
      chars: Buffer.from(src, "utf8")
    };
    return this.layout.encode(data, b22, offset3);
  }
  decode(b22, offset3 = 0) {
    const data = this.layout.decode(b22, offset3);
    return data["chars"].toString();
  }
  getSpan(b22, offset3 = 0) {
    return u3242().span + u3242().span + new import_bn22.default(new Uint8Array(b22).slice(offset3, offset3 + 4), 10, "le").toNumber();
  }
}
function rustStringLayout(property) {
  return new RustStringLayout(property);
}
function publicKey$2(property) {
  return blob3(32, property);
}
var LAYOUT = union22(u3242("instruction"));
LAYOUT.addVariant(0, struct3([
  ns642("lamports"),
  ns642("space"),
  publicKey$2("owner")
]), "createAccount");
LAYOUT.addVariant(1, struct3([publicKey$2("owner")]), "assign");
LAYOUT.addVariant(2, struct3([ns642("lamports")]), "transfer");
LAYOUT.addVariant(3, struct3([
  publicKey$2("base"),
  rustStringLayout("seed"),
  ns642("lamports"),
  ns642("space"),
  publicKey$2("owner")
]), "createAccountWithSeed");
LAYOUT.addVariant(4, struct3([publicKey$2("authorized")]), "advanceNonceAccount");
LAYOUT.addVariant(5, struct3([ns642("lamports")]), "withdrawNonceAccount");
LAYOUT.addVariant(6, struct3([publicKey$2("authorized")]), "initializeNonceAccount");
LAYOUT.addVariant(7, struct3([publicKey$2("authorized")]), "authorizeNonceAccount");
LAYOUT.addVariant(8, struct3([ns642("space")]), "allocate");
LAYOUT.addVariant(9, struct3([
  publicKey$2("base"),
  rustStringLayout("seed"),
  ns642("space"),
  publicKey$2("owner")
]), "allocateWithSeed");
LAYOUT.addVariant(10, struct3([
  publicKey$2("base"),
  rustStringLayout("seed"),
  publicKey$2("owner")
]), "assignWithSeed");
LAYOUT.addVariant(11, struct3([
  ns642("lamports"),
  rustStringLayout("seed"),
  publicKey$2("owner")
]), "transferWithSeed");
var instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r) => r.span));

class WrappedLayout$1 extends Layout_2 {
  constructor(layout, decoder, encoder, property) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder;
  }
  decode(b22, offset3) {
    return this.decoder(this.layout.decode(b22, offset3));
  }
  encode(src, b22, offset3) {
    return this.layout.encode(this.encoder(src), b22, offset3);
  }
  getSpan(b22, offset3) {
    return this.layout.getSpan(b22, offset3);
  }
}
function publicKey$1(property) {
  return new WrappedLayout$1(blob3(32), (b22) => new PublicKey2(b22), (key) => key.toBuffer(), property);
}
var NONCE_ACCOUNT_LAYOUT = struct3([
  u3242("version"),
  u3242("state"),
  publicKey$1("authorizedPubkey"),
  publicKey$1("nonce"),
  struct3([nu642("lamportsPerSignature")], "feeCalculator")
]);
var TOKEN_PROGRAM_ID = new PublicKey2("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var ASSOCIATED_PROGRAM_ID = new PublicKey2("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var browserPonyfill = { exports: {} };
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F.prototype = global2;
    return new F;
  }();
  (function(self2) {
    (function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob;
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === undefined, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers2(headers) {
        this.map = {};
        if (headers instanceof Headers2) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers2.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers2.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers2.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers2.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers2.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob4) {
        var reader = new FileReader;
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob4);
        return promise;
      }
      function readBlobAsText(blob4) {
        var reader = new FileReader;
        var promise = fileReaderReady(reader);
        reader.readAsText(blob4);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i22 = 0;i22 < view.length; i22++) {
          chars[i22] = String.fromCharCode(view[i22]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode3);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode3(body) {
        var form = new FormData;
        body.trim().split("&").forEach(function(bytes2) {
          if (bytes2) {
            var split22 = bytes2.split("=");
            var name = split22.shift().replace(/\+/g, " ");
            var value = split22.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers2;
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response2(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === undefined ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response2.prototype);
      Response2.prototype.clone = function() {
        return new Response2(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response2.error = function() {
        var response = new Response2(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response2.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response2(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException;
      } catch (err2) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch3(input, init2) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init2);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest;
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response2(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch3.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch3;
        self2.Headers = Headers2;
        self2.Request = Request;
        self2.Response = Response2;
      }
      exports2.Headers = Headers2;
      exports2.Request = Request;
      exports2.Response = Response2;
      exports2.fetch = fetch3;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfill.exports);
var fetch3 = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfill.exports);
var UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum([
  borsh.struct([], "uninitialized"),
  borsh.struct([borsh.option(borsh.publicKey(), "authorityAddress")], "buffer"),
  borsh.struct([borsh.publicKey("programdataAddress")], "program"),
  borsh.struct([
    borsh.u64("slot"),
    borsh.option(borsh.publicKey(), "upgradeAuthorityAddress")
  ], "programData")
], undefined, borsh.u32());
var PROGRAM_LOG = "Program log: ";
var PROGRAM_DATA = "Program data: ";
var PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;
var PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;

class EventManager {
  constructor(programId, provider, coder) {
    this._programId = programId;
    this._provider = provider;
    this._eventParser = new EventParser(programId, coder);
    this._eventCallbacks = new Map;
    this._eventListeners = new Map;
    this._listenerIdCount = 0;
  }
  addEventListener(eventName, callback, commitment) {
    var _a;
    let listener = this._listenerIdCount;
    this._listenerIdCount += 1;
    if (!this._eventListeners.has(eventName)) {
      this._eventListeners.set(eventName, []);
    }
    this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== undefined ? _a : []).concat(listener));
    this._eventCallbacks.set(listener, [eventName, callback]);
    if (this._onLogsSubscriptionId !== undefined) {
      return listener;
    }
    this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {
      if (logs.err) {
        return;
      }
      for (const event of this._eventParser.parseLogs(logs.logs)) {
        const allListeners = this._eventListeners.get(event.name);
        if (allListeners) {
          allListeners.forEach((listener2) => {
            const listenerCb = this._eventCallbacks.get(listener2);
            if (listenerCb) {
              const [, callback2] = listenerCb;
              callback2(event.data, ctx.slot, logs.signature);
            }
          });
        }
      }
    }, commitment);
    return listener;
  }
  async removeEventListener(listener) {
    const callback = this._eventCallbacks.get(listener);
    if (!callback) {
      throw new Error(`Event listener ${listener} doesn't exist!`);
    }
    const [eventName] = callback;
    let listeners = this._eventListeners.get(eventName);
    if (!listeners) {
      throw new Error(`Event listeners don't exist for ${eventName}!`);
    }
    this._eventCallbacks.delete(listener);
    listeners = listeners.filter((l) => l !== listener);
    this._eventListeners.set(eventName, listeners);
    if (listeners.length === 0) {
      this._eventListeners.delete(eventName);
    }
    if (this._eventCallbacks.size === 0) {
      if (this._eventListeners.size !== 0) {
        throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);
      }
      if (this._onLogsSubscriptionId !== undefined) {
        await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);
        this._onLogsSubscriptionId = undefined;
      }
    }
  }
}

class EventParser {
  constructor(programId, coder) {
    this.coder = coder;
    this.programId = programId;
  }
  *parseLogs(logs, errorOnDecodeFailure = false) {
    const logScanner = new LogScanner(logs);
    const execution = new ExecutionContext;
    let log3 = logScanner.next();
    while (log3 !== null) {
      let [event, newProgram, didPop] = this.handleLog(execution, log3, errorOnDecodeFailure);
      if (event) {
        yield event;
      }
      if (newProgram) {
        execution.push(newProgram);
      }
      if (didPop) {
        execution.pop();
      }
      log3 = logScanner.next();
    }
  }
  handleLog(execution, log3, errorOnDecodeFailure) {
    if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {
      return this.handleProgramLog(log3, errorOnDecodeFailure);
    } else {
      return [null, ...this.handleSystemLog(log3)];
    }
  }
  handleProgramLog(log3, errorOnDecodeFailure) {
    if (log3.startsWith(PROGRAM_LOG) || log3.startsWith(PROGRAM_DATA)) {
      const logStr = log3.startsWith(PROGRAM_LOG) ? log3.slice(PROGRAM_LOG_START_INDEX) : log3.slice(PROGRAM_DATA_START_INDEX);
      const event = this.coder.events.decode(logStr);
      if (errorOnDecodeFailure && event === null) {
        throw new Error(`Unable to decode event ${logStr}`);
      }
      return [event, null, false];
    } else {
      return [null, ...this.handleSystemLog(log3)];
    }
  }
  handleSystemLog(log3) {
    const logStart = log3.split(":")[0];
    if (logStart.match(/^Program (.*) success/g) !== null) {
      return [null, true];
    } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {
      return [this.programId.toString(), false];
    } else if (logStart.includes("invoke")) {
      return ["cpi", false];
    } else {
      return [null, false];
    }
  }
}

class ExecutionContext {
  constructor() {
    this.stack = [];
  }
  program() {
    if (!this.stack.length) {
      throw new Error("Expected the stack to have elements");
    }
    return this.stack[this.stack.length - 1];
  }
  push(newProgram) {
    this.stack.push(newProgram);
  }
  pop() {
    if (!this.stack.length) {
      throw new Error("Expected the stack to have elements");
    }
    this.stack.pop();
  }
}

class LogScanner {
  constructor(logs) {
    this.logs = logs;
  }
  next() {
    if (this.logs.length === 0) {
      return null;
    }
    let l = this.logs[0];
    this.logs = this.logs.slice(1);
    return l;
  }
}
function splitArgsAndCtx(idlIx, args) {
  var _a, _b;
  let options = {};
  const inputLen = idlIx.args ? idlIx.args.length : 0;
  if (args.length > inputLen) {
    if (args.length !== inputLen + 1) {
      throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === undefined ? undefined : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === undefined ? undefined : _a.map((a) => a.name)) !== null && _b !== undefined ? _b : []}`);
    }
    options = args.pop();
  }
  return [args, options];
}

class InstructionNamespaceFactory {
  static build(idlIx, encodeFn, programId) {
    if (idlIx.name === "_inner") {
      throw new IdlError("the _inner name is reserved");
    }
    const ix = (...args) => {
      const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);
      validateAccounts(idlIx.accounts, ctx.accounts);
      validateInstruction(idlIx, ...args);
      const keys = ix.accounts(ctx.accounts);
      if (ctx.remainingAccounts !== undefined) {
        keys.push(...ctx.remainingAccounts);
      }
      if (isSet("debug-logs")) {
        console.log("Outgoing account metas:", keys);
      }
      return new TransactionInstruction2({
        keys,
        programId,
        data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))
      });
    };
    ix["accounts"] = (accs) => {
      return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);
    };
    return ix;
  }
  static accountsArray(ctx, accounts, programId, ixName) {
    if (!ctx) {
      return [];
    }
    return accounts.map((acc) => {
      if (isCompositeAccounts(acc)) {
        const rpcAccs = ctx[acc.name];
        return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();
      }
      let pubkey;
      try {
        pubkey = translateAddress(ctx[acc.name]);
      } catch (err2) {
        throw new Error(`Wrong input type for account "${acc.name}" in the instruction accounts object${ixName !== undefined ? ' for instruction "' + ixName + '"' : ""}. Expected PublicKey or string.`);
      }
      const isOptional = acc.optional && pubkey.equals(programId);
      const isWritable = Boolean(acc.writable && !isOptional);
      const isSigner = Boolean(acc.signer && !isOptional);
      return {
        pubkey,
        isWritable,
        isSigner
      };
    }).flat();
  }
}
function validateInstruction(ix, ...args) {}

class TransactionFactory {
  static build(idlIx, ixFn) {
    const txFn = (...args) => {
      var _a, _b, _c;
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      const tx = new Transaction3;
      if (ctx.preInstructions && ctx.instructions) {
        throw new Error("instructions is deprecated, use preInstructions");
      }
      (_a = ctx.preInstructions) === null || _a === undefined || _a.forEach((ix) => tx.add(ix));
      (_b = ctx.instructions) === null || _b === undefined || _b.forEach((ix) => tx.add(ix));
      tx.add(ixFn(...args));
      (_c = ctx.postInstructions) === null || _c === undefined || _c.forEach((ix) => tx.add(ix));
      return tx;
    };
    return txFn;
  }
}

class RpcFactory {
  static build(idlIx, txFn, idlErrors, provider) {
    const rpc = async (...args) => {
      var _a;
      const tx = txFn(...args);
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      if (provider.sendAndConfirm === undefined) {
        throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
      }
      try {
        return await provider.sendAndConfirm(tx, (_a = ctx.signers) !== null && _a !== undefined ? _a : [], ctx.options);
      } catch (err2) {
        throw translateError(err2, idlErrors);
      }
    };
    return rpc;
  }
}

class AccountFactory {
  static build(idl, coder, programId, provider) {
    var _a;
    return ((_a = idl.accounts) !== null && _a !== undefined ? _a : []).reduce((accountFns, acc) => {
      accountFns[acc.name] = new AccountClient(idl, acc, programId, provider, coder);
      return accountFns;
    }, {});
  }
}

class AccountClient {
  get size() {
    return this._size;
  }
  get programId() {
    return this._programId;
  }
  get provider() {
    return this._provider;
  }
  get coder() {
    return this._coder;
  }
  constructor(idl, idlAccount, programId, provider, coder) {
    this._idlAccount = idlAccount;
    this._programId = programId;
    this._provider = provider !== null && provider !== undefined ? provider : getProvider2();
    this._coder = coder !== null && coder !== undefined ? coder : new BorshCoder(idl);
    this._size = this._coder.accounts.size(idlAccount.name);
  }
  async fetchNullable(address, commitment) {
    const { data } = await this.fetchNullableAndContext(address, commitment);
    return data;
  }
  async fetchNullableAndContext(address, commitment) {
    const accountInfo = await this.getAccountInfoAndContext(address, commitment);
    const { value, context } = accountInfo;
    return {
      data: value && value.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, value.data) : null,
      context
    };
  }
  async fetch(address, commitment) {
    const { data } = await this.fetchNullableAndContext(address, commitment);
    if (data === null) {
      throw new Error(`Account does not exist or has no data ${address.toString()}`);
    }
    return data;
  }
  async fetchAndContext(address, commitment) {
    const { data, context } = await this.fetchNullableAndContext(address, commitment);
    if (data === null) {
      throw new Error(`Account does not exist ${address.toString()}`);
    }
    return { data, context };
  }
  async fetchMultiple(addresses, commitment) {
    const accounts = await this.fetchMultipleAndContext(addresses, commitment);
    return accounts.map((account) => account ? account.data : null);
  }
  async fetchMultipleAndContext(addresses, commitment) {
    const accounts = await getMultipleAccountsAndContext(this._provider.connection, addresses.map((address) => translateAddress(address)), commitment);
    return accounts.map((result) => {
      if (result == null) {
        return null;
      }
      const { account, context } = result;
      return {
        data: this._coder.accounts.decode(this._idlAccount.name, account.data),
        context
      };
    });
  }
  async all(filters) {
    const filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : undefined);
    const coderFilters = [];
    if ((filter === null || filter === undefined ? undefined : filter.offset) != null && (filter === null || filter === undefined ? undefined : filter.bytes) != null) {
      coderFilters.push({
        memcmp: { offset: filter.offset, bytes: filter.bytes }
      });
    }
    if ((filter === null || filter === undefined ? undefined : filter.dataSize) != null) {
      coderFilters.push({ dataSize: filter.dataSize });
    }
    let resp = await this._provider.connection.getProgramAccounts(this._programId, {
      commitment: this._provider.connection.commitment,
      filters: [...coderFilters, ...Array.isArray(filters) ? filters : []]
    });
    return resp.map(({ pubkey, account }) => {
      return {
        publicKey: pubkey,
        account: this._coder.accounts.decode(this._idlAccount.name, account.data)
      };
    });
  }
  subscribe(address, commitment) {
    const sub2 = subscriptions.get(address.toString());
    if (sub2) {
      return sub2.ee;
    }
    const ee = new import_eventemitter32.default;
    address = translateAddress(address);
    const listener = this._provider.connection.onAccountChange(address, (acc) => {
      const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);
      ee.emit("change", account);
    }, commitment);
    subscriptions.set(address.toString(), {
      ee,
      listener
    });
    return ee;
  }
  async unsubscribe(address) {
    let sub2 = subscriptions.get(address.toString());
    if (!sub2) {
      console.warn("Address is not subscribed");
      return;
    }
    if (subscriptions) {
      await this._provider.connection.removeAccountChangeListener(sub2.listener).then(() => {
        subscriptions.delete(address.toString());
      }).catch(console.error);
    }
  }
  async createInstruction(signer, sizeOverride) {
    const size = this.size;
    if (this._provider.publicKey === undefined) {
      throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
    }
    return SystemProgram2.createAccount({
      fromPubkey: this._provider.publicKey,
      newAccountPubkey: signer.publicKey,
      space: sizeOverride !== null && sizeOverride !== undefined ? sizeOverride : size,
      lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== undefined ? sizeOverride : size),
      programId: this._programId
    });
  }
  async getAccountInfo(address, commitment) {
    return await this._provider.connection.getAccountInfo(translateAddress(address), commitment);
  }
  async getAccountInfoAndContext(address, commitment) {
    return await this._provider.connection.getAccountInfoAndContext(translateAddress(address), commitment);
  }
}
var subscriptions = new Map;

class SimulateFactory {
  static build(idlIx, txFn, idlErrors, provider, coder, programId, idl) {
    const simulate = async (...args) => {
      var _a;
      const tx = txFn(...args);
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      let resp = undefined;
      if (provider.simulate === undefined) {
        throw new Error("This function requires 'Provider.simulate' to be implemented.");
      }
      try {
        resp = await provider.simulate(tx, ctx.signers, (_a = ctx.options) === null || _a === undefined ? undefined : _a.commitment);
      } catch (err2) {
        throw translateError(err2, idlErrors);
      }
      if (resp === undefined) {
        throw new Error("Unable to simulate transaction");
      }
      const logs = resp.logs;
      if (!logs) {
        throw new Error("Simulated logs not found");
      }
      const events = [];
      if (idl.events) {
        let parser = new EventParser(programId, coder);
        for (const event of parser.parseLogs(logs)) {
          events.push(event);
        }
      }
      return { events, raw: logs };
    };
    return simulate;
  }
}
function uint64(property) {
  return new WrappedLayout(blob3(8), (b22) => u6432.fromBuffer(b22), (n2) => n2.toBuffer(), property);
}
function publicKey3(property) {
  return new WrappedLayout(blob3(32), (b22) => new PublicKey2(b22), (key) => key.toBuffer(), property);
}
function coption(layout, property) {
  return new COptionLayout(layout, property);
}

class WrappedLayout extends Layout_2 {
  constructor(layout, decoder, encoder, property) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder;
  }
  decode(b22, offset3) {
    return this.decoder(this.layout.decode(b22, offset3));
  }
  encode(src, b22, offset3) {
    return this.layout.encode(this.encoder(src), b22, offset3);
  }
  getSpan(b22, offset3) {
    return this.layout.getSpan(b22, offset3);
  }
}

class COptionLayout extends Layout_2 {
  constructor(layout, property) {
    super(-1, property);
    this.layout = layout;
    this.discriminator = u3242();
  }
  encode(src, b22, offset3 = 0) {
    if (src === null || src === undefined) {
      return this.layout.span + this.discriminator.encode(0, b22, offset3);
    }
    this.discriminator.encode(1, b22, offset3);
    return this.layout.encode(src, b22, offset3 + 4) + 4;
  }
  decode(b22, offset3 = 0) {
    const discriminator = this.discriminator.decode(b22, offset3);
    if (discriminator === 0) {
      return null;
    } else if (discriminator === 1) {
      return this.layout.decode(b22, offset3 + 4);
    }
    throw new Error("Invalid coption " + this.layout.property);
  }
  getSpan(b22, offset3 = 0) {
    return this.layout.getSpan(b22, offset3 + 4) + 4;
  }
}

class u6432 extends import_bn22.default {
  toBuffer() {
    const a = super.toArray().reverse();
    const b22 = Buffer.from(a);
    if (b22.length === 8) {
      return b22;
    }
    if (b22.length >= 8) {
      throw new Error("u64 too large");
    }
    const zeroPad2 = Buffer.alloc(8);
    b22.copy(zeroPad2);
    return zeroPad2;
  }
  static fromBuffer(buffer) {
    if (buffer.length !== 8) {
      throw new Error(`Invalid buffer length: ${buffer.length}`);
    }
    return new u6432([...buffer].reverse().map((i22) => `00${i22.toString(16)}`.slice(-2)).join(""), 16);
  }
}
var TOKEN_ACCOUNT_LAYOUT = struct3([
  publicKey3("mint"),
  publicKey3("owner"),
  uint64("amount"),
  coption(publicKey3(), "delegate"),
  ((p) => {
    const U = union22(u83("discriminator"), null, p);
    U.addVariant(0, struct3([]), "uninitialized");
    U.addVariant(1, struct3([]), "initialized");
    U.addVariant(2, struct3([]), "frozen");
    return U;
  })("state"),
  coption(uint64(), "isNative"),
  uint64("delegatedAmount"),
  coption(publicKey3(), "closeAuthority")
]);
function decodeTokenAccount(b22) {
  return TOKEN_ACCOUNT_LAYOUT.decode(b22);
}

class AccountsResolver {
  constructor(_args, _accounts, _provider2, _programId, _idlIx, accountNamespace, _idlTypes, _customResolver) {
    this._args = _args;
    this._accounts = _accounts;
    this._provider = _provider2;
    this._programId = _programId;
    this._idlIx = _idlIx;
    this._idlTypes = _idlTypes;
    this._customResolver = _customResolver;
    this._accountStore = new AccountStore(_provider2, accountNamespace, _programId);
  }
  args(args) {
    this._args = args;
  }
  async resolve() {
    this.resolveEventCpi(this._idlIx.accounts);
    this.resolveConst(this._idlIx.accounts);
    let depth = 0;
    while (await this.resolvePdasAndRelations(this._idlIx.accounts) + await this.resolveCustom() > 0) {
      depth++;
      if (depth === 16) {
        const isResolvable = (acc) => {
          if (!isCompositeAccounts(acc)) {
            return !!(acc.address || acc.pda || acc.relations);
          }
          return acc.accounts.some(isResolvable);
        };
        const getPaths = (accs, path = [], paths = []) => {
          for (const acc of accs) {
            if (isCompositeAccounts(acc)) {
              paths.push(...getPaths(acc.accounts, [...path, acc.name]));
            } else {
              paths.push([...path, acc.name]);
            }
          }
          return paths;
        };
        const resolvableAccs = this._idlIx.accounts.filter(isResolvable);
        const unresolvedAccs = getPaths(resolvableAccs).filter((path) => !this.get(path)).map((path) => path.reduce((acc, p) => acc + "." + p)).map((acc) => `\`${acc}\``).join(", ");
        throw new Error([
          `Reached maximum depth for account resolution.`,
          `Unresolved accounts: ${unresolvedAccs}`
        ].join(" "));
      }
    }
  }
  resolveOptionals(accounts) {
    Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));
  }
  get(path) {
    const ret = path.reduce((acc, subPath) => acc && acc[subPath], this._accounts);
    if (ret && ret.toBase58) {
      return ret;
    }
  }
  set(path, value) {
    let cur = this._accounts;
    path.forEach((p, i22) => {
      var _a;
      const isLast = i22 === path.length - 1;
      if (isLast) {
        cur[p] = value;
      }
      cur[p] = (_a = cur[p]) !== null && _a !== undefined ? _a : {};
      cur = cur[p];
    });
  }
  resolveOptionalsHelper(partialAccounts, accounts) {
    const nestedAccountsGeneric = {};
    for (const accountItem of accounts) {
      const accountName = accountItem.name;
      const partialAccount = partialAccounts[accountName];
      if (partialAccount === undefined)
        continue;
      if (isPartialAccounts(partialAccount)) {
        if (isCompositeAccounts(accountItem)) {
          nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem["accounts"]);
        } else {
          nestedAccountsGeneric[accountName] = flattenPartialAccounts(partialAccount, true);
        }
      } else {
        if (partialAccount !== null) {
          nestedAccountsGeneric[accountName] = translateAddress(partialAccount);
        } else if (accountItem["optional"]) {
          nestedAccountsGeneric[accountName] = this._programId;
        }
      }
    }
    return nestedAccountsGeneric;
  }
  async resolveCustom() {
    if (this._customResolver) {
      const { accounts, resolved } = await this._customResolver({
        args: this._args,
        accounts: this._accounts,
        provider: this._provider,
        programId: this._programId,
        idlIx: this._idlIx
      });
      this._accounts = accounts;
      return resolved;
    }
    return 0;
  }
  resolveEventCpi(accounts, path = []) {
    for (const i22 in accounts) {
      const accountOrAccounts = accounts[i22];
      if (isCompositeAccounts(accountOrAccounts)) {
        this.resolveEventCpi(accountOrAccounts.accounts, [
          ...path,
          accountOrAccounts.name
        ]);
      }
      const nextIndex = +i22 + 1;
      if (nextIndex === accounts.length)
        return;
      const currentName = accounts[i22].name;
      const nextName = accounts[nextIndex].name;
      if (currentName === "eventAuthority" && nextName === "program") {
        const currentPath = [...path, currentName];
        const nextPath = [...path, nextName];
        if (!this.get(currentPath)) {
          this.set(currentPath, PublicKey2.findProgramAddressSync([Buffer.from("__event_authority")], this._programId)[0]);
        }
        if (!this.get(nextPath)) {
          this.set(nextPath, this._programId);
        }
        return;
      }
    }
  }
  resolveConst(accounts, path = []) {
    for (const accountOrAccounts of accounts) {
      const name = accountOrAccounts.name;
      if (isCompositeAccounts(accountOrAccounts)) {
        this.resolveConst(accountOrAccounts.accounts, [...path, name]);
      } else {
        const account = accountOrAccounts;
        if ((account.signer || account.address) && !this.get([...path, name])) {
          if (account.signer) {
            if (!this._provider.publicKey) {
              throw new Error("This function requires the `Provider` interface implementor to have a `publicKey` field.");
            }
            this.set([...path, name], this._provider.publicKey);
          }
          if (account.address) {
            this.set([...path, name], translateAddress(account.address));
          }
        }
      }
    }
  }
  async resolvePdasAndRelations(accounts, path = []) {
    let found = 0;
    for (const accountOrAccounts of accounts) {
      const name = accountOrAccounts.name;
      if (isCompositeAccounts(accountOrAccounts)) {
        found += await this.resolvePdasAndRelations(accountOrAccounts.accounts, [...path, name]);
      } else {
        const account = accountOrAccounts;
        if ((account.pda || account.relations) && !this.get([...path, name])) {
          found++;
          try {
            if (account.pda) {
              const seeds = await Promise.all(account.pda.seeds.map((seed2) => this.toBuffer(seed2, path)));
              if (seeds.some((seed2) => !seed2)) {
                continue;
              }
              const programId = await this.parseProgramId(account, path);
              const [pubkey] = PublicKey2.findProgramAddressSync(seeds, programId);
              this.set([...path, name], pubkey);
            }
          } catch {}
          try {
            if (account.relations) {
              const accountKey = this.get([...path, account.relations[0]]);
              if (accountKey) {
                const account2 = await this._accountStore.fetchAccount({
                  publicKey: accountKey
                });
                this.set([...path, name], account2[name]);
              }
            }
          } catch {}
        }
      }
    }
    return found;
  }
  async parseProgramId(account, path = []) {
    var _a;
    if (!((_a = account.pda) === null || _a === undefined ? undefined : _a.program)) {
      return this._programId;
    }
    const buf = await this.toBuffer(account.pda.program, path);
    if (!buf) {
      throw new Error(`Program seed not resolved: ${account.name}`);
    }
    return new PublicKey2(buf);
  }
  async toBuffer(seed2, path = []) {
    switch (seed2.kind) {
      case "const":
        return this.toBufferConst(seed2);
      case "arg":
        return await this.toBufferArg(seed2);
      case "account":
        return await this.toBufferAccount(seed2, path);
      default:
        throw new Error(`Unexpected seed: ${seed2}`);
    }
  }
  toBufferConst(seed2) {
    return this.toBufferValue("bytes", seed2.value);
  }
  async toBufferArg(seed2) {
    const [name, ...path] = seed2.path.split(".");
    const index = this._idlIx.args.findIndex((arg) => arg.name === name);
    if (index === -1) {
      throw new Error(`Unable to find argument for seed: ${name}`);
    }
    const value = path.reduce((acc, path2) => (acc !== null && acc !== undefined ? acc : {})[path2], this._args[index]);
    if (value === undefined) {
      return;
    }
    const type3 = this.getType(this._idlIx.args[index].type, path);
    return this.toBufferValue(type3, value);
  }
  async toBufferAccount(seed2, path = []) {
    const [name, ...paths] = seed2.path.split(".");
    const fieldPubkey = this.get([...path, name]);
    if (!fieldPubkey)
      return;
    if (!paths.length) {
      return this.toBufferValue("pubkey", fieldPubkey);
    }
    if (!seed2.account) {
      throw new Error(`Seed account is required in order to resolve type: ${seed2.path}`);
    }
    const account = await this._accountStore.fetchAccount({
      publicKey: fieldPubkey,
      name: seed2.account
    });
    let accountValue = account;
    let currentPaths = paths;
    while (currentPaths.length > 0) {
      accountValue = accountValue[currentPaths[0]];
      currentPaths = currentPaths.slice(1);
    }
    if (accountValue === undefined)
      return;
    const type3 = this.getType({ defined: { name: seed2.account } }, paths);
    return this.toBufferValue(type3, accountValue);
  }
  toBufferValue(type3, value) {
    switch (type3) {
      case "u8":
      case "i8":
        return Buffer.from([value]);
      case "u16":
      case "i16":
        return new import_bn22.default(value).toArrayLike(Buffer, "le", 2);
      case "u32":
      case "i32":
        return new import_bn22.default(value).toArrayLike(Buffer, "le", 4);
      case "u64":
      case "i64":
        return new import_bn22.default(value).toArrayLike(Buffer, "le", 8);
      case "u128":
      case "i128":
        return new import_bn22.default(value).toArrayLike(Buffer, "le", 16);
      case "u256":
      case "i256":
        return new import_bn22.default(value).toArrayLike(Buffer, "le", 32);
      case "string":
        return Buffer.from(value);
      case "pubkey":
        return value.toBuffer();
      case "bytes":
        return Buffer.from(value);
      default:
        if (type3 === null || type3 === undefined ? undefined : type3.array) {
          return Buffer.from(value);
        }
        throw new Error(`Unexpected seed type: ${type3}`);
    }
  }
  getType(type3, path = []) {
    var _a;
    const typeName = (_a = type3 === null || type3 === undefined ? undefined : type3.defined) === null || _a === undefined ? undefined : _a.name;
    if (typeName) {
      if (typeName === "tokenAccount") {
        switch (path.at(0)) {
          case "mint":
          case "owner":
            return "pubkey";
          case "amount":
          case "delagatedAmount":
            return "u64";
          default:
            throw new Error(`Unknown token account path: ${path}`);
        }
      }
      const definedType = this._idlTypes.find((t) => t.name === typeName);
      if (!definedType) {
        throw new Error(`Type not found: ${typeName}`);
      }
      const [fieldName, ...subPath] = path;
      const fields2 = definedType.type.fields;
      const field = fields2.find((field2) => field2.name === fieldName);
      if (!field) {
        throw new Error(`Field not found: ${fieldName}`);
      }
      return this.getType(field.type, subPath);
    }
    return type3;
  }
}

class AccountStore {
  constructor(_provider2, accounts, programId) {
    this._provider = _provider2;
    this._cache = new Map;
    this._idls = {};
    this._idls[programId.toBase58()] = accounts;
  }
  async fetchAccount({ publicKey: publicKey4, name }) {
    const address = publicKey4.toBase58();
    if (!this._cache.has(address)) {
      const accountInfo = await this._provider.connection.getAccountInfo(publicKey4);
      if (accountInfo === null) {
        throw new Error(`Account not found: ${address}`);
      }
      if (name === "tokenAccount") {
        const account = decodeTokenAccount(accountInfo.data);
        this._cache.set(address, account);
      } else {
        const accounts = await this.getAccountsNs(accountInfo.owner);
        if (accounts) {
          const accountNs = Object.values(accounts)[0];
          if (accountNs) {
            const account = accountNs.coder.accounts.decodeAny(accountInfo.data);
            this._cache.set(address, account);
          }
        }
      }
    }
    return this._cache.get(address);
  }
  async getAccountsNs(programId) {
    const programIdStr = programId.toBase58();
    if (!this._idls[programIdStr]) {
      const idl = await Program.fetchIdl(programId, this._provider);
      if (idl) {
        const program = new Program(idl, this._provider);
        this._idls[programIdStr] = program.account;
      }
    }
    return this._idls[programIdStr];
  }
}

class MethodsBuilderFactory {
  static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {
    return (...args) => new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);
  }
}
function isPartialAccounts(partialAccount) {
  return typeof partialAccount === "object" && partialAccount !== null && !("_bn" in partialAccount);
}
function flattenPartialAccounts(partialAccounts, throwOnNull) {
  const toReturn = {};
  for (const accountName in partialAccounts) {
    const account = partialAccounts[accountName];
    if (account === null) {
      if (throwOnNull)
        throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
      continue;
    }
    toReturn[accountName] = isPartialAccounts(account) ? flattenPartialAccounts(account, true) : translateAddress(account);
  }
  return toReturn;
}

class MethodsBuilder {
  constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver) {
    this._args = _args;
    this._ixFn = _ixFn;
    this._txFn = _txFn;
    this._rpcFn = _rpcFn;
    this._simulateFn = _simulateFn;
    this._viewFn = _viewFn;
    this._accounts = {};
    this._remainingAccounts = [];
    this._signers = [];
    this._preInstructions = [];
    this._postInstructions = [];
    this._resolveAccounts = true;
    this._accountsResolver = new AccountsResolver(_args, this._accounts, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);
  }
  args(args) {
    this._args = args;
    this._accountsResolver.args(args);
  }
  accounts(accounts) {
    return this.accountsPartial(accounts);
  }
  accountsPartial(accounts) {
    this._resolveAccounts = true;
    this._accountsResolver.resolveOptionals(accounts);
    return this;
  }
  accountsStrict(accounts) {
    this._resolveAccounts = false;
    this._accountsResolver.resolveOptionals(accounts);
    return this;
  }
  signers(signers) {
    this._signers = this._signers.concat(signers);
    return this;
  }
  remainingAccounts(accounts) {
    this._remainingAccounts = this._remainingAccounts.concat(accounts);
    return this;
  }
  preInstructions(ixs, prepend = false) {
    if (prepend) {
      this._preInstructions = ixs.concat(this._preInstructions);
    } else {
      this._preInstructions = this._preInstructions.concat(ixs);
    }
    return this;
  }
  postInstructions(ixs) {
    this._postInstructions = this._postInstructions.concat(ixs);
    return this;
  }
  async pubkeys() {
    if (this._resolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._accounts;
  }
  async instruction() {
    if (this._resolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._ixFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions
    });
  }
  async transaction() {
    if (this._resolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._txFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions
    });
  }
  async simulate(options) {
    if (this._resolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._simulateFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async view(options) {
    if (this._resolveAccounts) {
      await this._accountsResolver.resolve();
    }
    if (!this._viewFn) {
      throw new Error([
        "Method does not support views.",
        "The instruction should return a value, and its accounts must be read-only"
      ].join(" "));
    }
    return this._viewFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async rpc(options) {
    if (this._resolveAccounts) {
      await this._accountsResolver.resolve();
    }
    return this._rpcFn(...this._args, {
      accounts: this._accounts,
      signers: this._signers,
      remainingAccounts: this._remainingAccounts,
      preInstructions: this._preInstructions,
      postInstructions: this._postInstructions,
      options
    });
  }
  async rpcAndKeys(options) {
    return {
      signature: await this.rpc(options),
      pubkeys: await this.pubkeys()
    };
  }
  async prepare() {
    return {
      instruction: await this.instruction(),
      signers: this._signers,
      pubkeys: await this.pubkeys()
    };
  }
}

class ViewFactory {
  static build(programId, idlIx, simulateFn, idl) {
    const isWritable = idlIx.accounts.find((a) => a.writable);
    const hasReturn = !!idlIx.returns;
    if (isWritable || !hasReturn)
      return;
    const view = async (...args) => {
      let simulationResult = await simulateFn(...args);
      const returnPrefix = `Program return: ${programId} `;
      let returnLog = simulationResult.raw.find((l) => l.startsWith(returnPrefix));
      if (!returnLog) {
        throw new Error("View expected return log");
      }
      let returnData = decode22(returnLog.slice(returnPrefix.length));
      let returnType = idlIx.returns;
      if (!returnType) {
        throw new Error("View expected return type");
      }
      const coder = IdlCoder.fieldLayout({ type: returnType }, idl.types);
      return coder.decode(returnData);
    };
    return view;
  }
}

class NamespaceFactory {
  static build(idl, coder, programId, provider, getCustomResolver) {
    const rpc = {};
    const instruction = {};
    const transaction = {};
    const simulate = {};
    const methods = {};
    const view = {};
    const idlErrors = parseIdlErrors(idl);
    const account = idl.accounts ? AccountFactory.build(idl, coder, programId, provider) : {};
    idl.instructions.forEach((idlIx) => {
      const ixItem = InstructionNamespaceFactory.build(idlIx, (ixName, ix) => coder.instruction.encode(ixName, ix), programId);
      const txItem = TransactionFactory.build(idlIx, ixItem);
      const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);
      const simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder, programId, idl);
      const viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);
      const methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver === null || getCustomResolver === undefined ? undefined : getCustomResolver(idlIx));
      const name = idlIx.name;
      instruction[name] = ixItem;
      transaction[name] = txItem;
      rpc[name] = rpcItem;
      simulate[name] = simulateItem;
      methods[name] = methodItem;
      if (viewItem) {
        view[name] = viewItem;
      }
    });
    return [
      rpc,
      instruction,
      transaction,
      account,
      simulate,
      methods,
      view
    ];
  }
}

class Program {
  get programId() {
    return this._programId;
  }
  get idl() {
    return this._idl;
  }
  get rawIdl() {
    return this._rawIdl;
  }
  get coder() {
    return this._coder;
  }
  get provider() {
    return this._provider;
  }
  constructor(idl, provider = getProvider2(), coder, getCustomResolver) {
    this._idl = convertIdlToCamelCase(idl);
    this._rawIdl = idl;
    this._provider = provider;
    this._programId = translateAddress(idl.address);
    this._coder = coder !== null && coder !== undefined ? coder : new BorshCoder(this._idl);
    this._events = new EventManager(this._programId, provider, this._coder);
    const [rpc, instruction, transaction, account, simulate, methods, views] = NamespaceFactory.build(this._idl, this._coder, this._programId, provider, getCustomResolver);
    this.rpc = rpc;
    this.instruction = instruction;
    this.transaction = transaction;
    this.account = account;
    this.simulate = simulate;
    this.methods = methods;
    this.views = views;
  }
  static async at(address, provider) {
    const programId = translateAddress(address);
    const idl = await Program.fetchIdl(programId, provider);
    if (!idl) {
      throw new Error(`IDL not found for program: ${address.toString()}`);
    }
    return new Program(idl, provider);
  }
  static async fetchIdl(address, provider) {
    provider = provider !== null && provider !== undefined ? provider : getProvider2();
    const programId = translateAddress(address);
    const idlAddr = await idlAddress(programId);
    const accountInfo = await provider.connection.getAccountInfo(idlAddr);
    if (!accountInfo) {
      return null;
    }
    let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
    const inflatedIdl = inflate_1(idlAccount.data);
    return JSON.parse(decode$2(inflatedIdl));
  }
  addEventListener(eventName, callback, commitment) {
    return this._events.addEventListener(eventName, callback, commitment);
  }
  async removeEventListener(listener) {
    return await this._events.removeEventListener(listener);
  }
}
new PublicKey2("11111111111111111111111111111111");
var bridge_idl_default = {
  address: "",
  metadata: {
    name: "bridge",
    version: "1.0.0",
    spec: "0.1.0",
    description: "Super awesome n1 bridging and state settlement contract"
  },
  instructions: [
    {
      name: "allow_app_version",
      discriminator: [
        37,
        106,
        252,
        165,
        124,
        88,
        212,
        139
      ],
      accounts: [
        {
          name: "app",
          writable: true
        },
        {
          name: "app_owner",
          signer: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "app_version",
          type: {
            array: [
              "u8",
              32
            ]
          }
        },
        {
          name: "allow",
          type: "bool"
        }
      ]
    },
    {
      name: "app_create_approve",
      discriminator: [
        197,
        24,
        144,
        254,
        92,
        176,
        67,
        217
      ],
      accounts: [
        {
          name: "app_owner",
          docs: [
            "NOTE: Must check that the owner matches up."
          ],
          signer: true
        },
        {
          name: "app",
          docs: [
            "During initialization, we already set the space and rent to match",
            "up to `App`, but wrote in `AppConfig`.`"
          ],
          writable: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "app_create_cancel",
      discriminator: [
        210,
        14,
        220,
        132,
        186,
        152,
        50,
        21
      ],
      accounts: [
        {
          name: "global",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "global_owner",
          signer: true
        },
        {
          name: "app",
          writable: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "app_create_propose",
      discriminator: [
        140,
        171,
        221,
        171,
        114,
        250,
        235,
        111
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "global",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "global_owner",
          signer: true
        },
        {
          name: "app",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "config",
          type: {
            defined: {
              name: "AppConfig"
            }
          }
        }
      ]
    },
    {
      name: "challenge_block",
      discriminator: [
        44,
        184,
        95,
        207,
        222,
        9,
        34,
        224
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "app"
        },
        {
          name: "child_blocks",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  104,
                  105,
                  108,
                  100,
                  95,
                  98,
                  108,
                  111,
                  99,
                  107,
                  115
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "prev_state_facts_commitment"
              }
            ]
          }
        },
        {
          name: "validator",
          signer: true
        },
        {
          name: "validator_acl_entry",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  99,
                  108
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "validator"
              }
            ]
          }
        },
        {
          name: "challenge_nullifier",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  104,
                  97,
                  108,
                  108,
                  101,
                  110,
                  103,
                  101,
                  95,
                  110,
                  117,
                  108,
                  108,
                  105,
                  102,
                  105,
                  101,
                  114
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "prev_state_facts_commitment"
              },
              {
                kind: "arg",
                path: "block_id"
              },
              {
                kind: "account",
                path: "validator"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "prev_state_facts_cmtmt",
          type: {
            defined: {
              name: "Commitment"
            }
          }
        },
        {
          name: "block_id",
          type: "u64"
        }
      ]
    },
    {
      name: "deposit_create",
      discriminator: [
        136,
        0,
        132,
        178,
        254,
        101,
        187,
        71
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "app"
        },
        {
          name: "event",
          writable: true,
          signer: true
        },
        {
          name: "asset_config",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  115,
                  115,
                  101,
                  116,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "from_account.mint"
              }
            ]
          }
        },
        {
          name: "from_account",
          writable: true
        },
        {
          name: "token_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "token_authority"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "from_account.mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "token_program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "user",
          type: "pubkey"
        },
        {
          name: "amount",
          type: "u64"
        }
      ]
    },
    {
      name: "emit_crumb",
      discriminator: [
        96,
        96,
        18,
        122,
        83,
        60,
        102,
        37
      ],
      accounts: [
        {
          name: "app"
        },
        {
          name: "crumb_authority",
          docs: [
            "Need a PDA to ensure that only this contract is allowed to",
            "call this instruction; the contract storage account is",
            "chosen since pretty much every other ix uses it, so this",
            "avoids having to introduce a new account."
          ],
          signer: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        }
      ],
      args: []
    },
    {
      name: "event_queue",
      discriminator: [
        77,
        86,
        223,
        153,
        163,
        135,
        241,
        12
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "app",
          writable: true
        },
        {
          name: "unqueued_event",
          writable: true
        },
        {
          name: "queued_event",
          writable: true
        },
        {
          name: "prev_queued_event",
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  113,
                  117,
                  101,
                  117,
                  101,
                  100,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "app.last_event_index",
                account: "App"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "finalize_block",
      discriminator: [
        63,
        101,
        92,
        132,
        135,
        251,
        98,
        177
      ],
      accounts: [
        {
          name: "app",
          writable: true
        },
        {
          name: "child_blocks",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  104,
                  105,
                  108,
                  100,
                  95,
                  98,
                  108,
                  111,
                  99,
                  107,
                  115
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "app.fina_state_facts",
                account: "App"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "freeze",
      discriminator: [
        255,
        91,
        207,
        84,
        251,
        194,
        254,
        63
      ],
      accounts: [
        {
          name: "app",
          writable: true
        },
        {
          name: "authority",
          signer: true
        },
        {
          name: "acl_entry",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  99,
                  108
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "authority"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "freeze",
          type: "bool"
        }
      ]
    },
    {
      name: "initialize_global",
      discriminator: [
        47,
        225,
        15,
        112,
        86,
        51,
        190,
        231
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "program",
          docs: [
            "Marked as signer to avoid races. This key should be thrown away after initialization."
          ],
          signer: true
        },
        {
          name: "global",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "global_owner",
          type: "pubkey"
        }
      ]
    },
    {
      name: "propose_block",
      discriminator: [
        147,
        21,
        105,
        53,
        152,
        116,
        128,
        187
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "app",
          writable: true
        },
        {
          name: "operator",
          signer: true
        },
        {
          name: "child_blocks",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  104,
                  105,
                  108,
                  100,
                  95,
                  98,
                  108,
                  111,
                  99,
                  107,
                  115
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "facts.prev_state_facts"
              }
            ]
          }
        },
        {
          name: "last_queued_event",
          optional: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  113,
                  117,
                  101,
                  117,
                  101,
                  100,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "facts.next_state_facts.last_event_index"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "facts",
          type: {
            defined: {
              name: "BlockFacts"
            }
          }
        }
      ]
    },
    {
      name: "prune_block",
      discriminator: [
        194,
        217,
        26,
        203,
        34,
        224,
        39,
        39
      ],
      accounts: [
        {
          name: "app"
        },
        {
          name: "child_blocks",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  104,
                  105,
                  108,
                  100,
                  95,
                  98,
                  108,
                  111,
                  99,
                  107,
                  115
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "prev_state_facts_cmtmt"
              }
            ]
          }
        },
        {
          name: "headr_refund_account",
          writable: true
        },
        {
          name: "block_refund_account",
          writable: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "prev_state_facts_cmtmt",
          type: {
            defined: {
              name: "Commitment"
            }
          }
        },
        {
          name: "block_id",
          type: "u64"
        }
      ]
    },
    {
      name: "prune_effect_nullifier",
      discriminator: [
        57,
        78,
        112,
        70,
        48,
        156,
        50,
        64
      ],
      accounts: [
        {
          name: "app"
        },
        {
          name: "child_blocks",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  104,
                  105,
                  108,
                  100,
                  95,
                  98,
                  108,
                  111,
                  99,
                  107,
                  115
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "prev_state_facts_cmtmt"
              }
            ]
          }
        },
        {
          name: "effect_nullifier",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  101,
                  102,
                  102,
                  101,
                  99,
                  116,
                  95,
                  110,
                  117,
                  108,
                  108,
                  105,
                  102,
                  105,
                  101,
                  114
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "prev_state_facts_cmtmt"
              },
              {
                kind: "arg",
                path: "block_id"
              },
              {
                kind: "arg",
                path: "leaf_index"
              }
            ]
          }
        },
        {
          name: "refund_account",
          writable: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "prev_state_facts_cmtmt",
          type: {
            defined: {
              name: "Commitment"
            }
          }
        },
        {
          name: "block_id",
          type: "u64"
        },
        {
          name: "leaf_index",
          type: "u64"
        }
      ]
    },
    {
      name: "set_block_lifetime",
      discriminator: [
        186,
        30,
        220,
        208,
        40,
        93,
        142,
        123
      ],
      accounts: [
        {
          name: "global",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "global_owner",
          signer: true
        },
        {
          name: "app",
          writable: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "block_lifetime",
          type: "u64"
        }
      ]
    },
    {
      name: "set_challenge_consensus_threshold",
      discriminator: [
        201,
        93,
        221,
        132,
        109,
        250,
        47,
        155
      ],
      accounts: [
        {
          name: "global",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "global_owner",
          signer: true
        },
        {
          name: "app",
          writable: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "challenge_consensus_threshold",
          type: "u16"
        }
      ]
    },
    {
      name: "set_challenge_period_slots",
      discriminator: [
        70,
        49,
        127,
        12,
        166,
        233,
        75,
        49
      ],
      accounts: [
        {
          name: "global",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "global_owner",
          signer: true
        },
        {
          name: "app",
          writable: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "challenge_period_slots",
          type: "u64"
        }
      ]
    },
    {
      name: "set_min_deposit",
      discriminator: [
        15,
        182,
        74,
        248,
        251,
        148,
        186,
        171
      ],
      accounts: [
        {
          name: "app"
        },
        {
          name: "app_owner",
          signer: true
        },
        {
          name: "asset_config",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  115,
                  115,
                  101,
                  116,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "mint"
              }
            ]
          }
        },
        {
          name: "mint"
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "min_deposit",
          type: "u64"
        }
      ]
    },
    {
      name: "set_operator",
      discriminator: [
        238,
        153,
        101,
        169,
        243,
        131,
        36,
        1
      ],
      accounts: [
        {
          name: "global",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "global_owner",
          signer: true
        },
        {
          name: "app",
          writable: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "operator",
          type: "pubkey"
        }
      ]
    },
    {
      name: "set_permission",
      discriminator: [
        70,
        126,
        41,
        194,
        245,
        189,
        128,
        8
      ],
      accounts: [
        {
          name: "global",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "global_owner",
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "app"
        },
        {
          name: "acl_entry",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  99,
                  108
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "addr"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "addr",
          type: "pubkey"
        },
        {
          name: "mask",
          type: {
            defined: {
              name: "PermissionSet"
            }
          }
        },
        {
          name: "value",
          type: {
            defined: {
              name: "PermissionSet"
            }
          }
        }
      ]
    },
    {
      name: "set_target_fina_state_facts",
      discriminator: [
        84,
        23,
        48,
        167,
        62,
        59,
        105,
        168
      ],
      accounts: [
        {
          name: "global",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  108,
                  111,
                  98,
                  97,
                  108
                ]
              }
            ]
          }
        },
        {
          name: "global_owner",
          signer: true
        },
        {
          name: "app",
          writable: true
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "target_fina_state_facts",
          type: {
            option: {
              defined: {
                name: "StateFacts"
              }
            }
          }
        }
      ]
    },
    {
      name: "set_withdrawal_rate_limit",
      discriminator: [
        223,
        228,
        217,
        48,
        144,
        211,
        153,
        146
      ],
      accounts: [
        {
          name: "app"
        },
        {
          name: "app_owner",
          signer: true
        },
        {
          name: "mint"
        },
        {
          name: "asset_config",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  115,
                  115,
                  101,
                  116,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "mint"
              }
            ]
          }
        },
        {
          name: "withdrawal_limiter",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  119,
                  105,
                  116,
                  104,
                  100,
                  114,
                  97,
                  119,
                  97,
                  108,
                  95,
                  108,
                  105,
                  109,
                  105,
                  116,
                  101,
                  114
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "mint"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "limiter_config",
          type: {
            defined: {
              name: "Config"
            }
          }
        }
      ]
    },
    {
      name: "whitelist_asset",
      discriminator: [
        113,
        64,
        172,
        191,
        33,
        33,
        57,
        18
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "app"
        },
        {
          name: "app_owner",
          signer: true
        },
        {
          name: "asset_config",
          docs: [
            "New asset config PDA account to be created",
            "This account is owned by the bridge program and stores the asset configuration"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  115,
                  115,
                  101,
                  116,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "mint"
              }
            ]
          }
        },
        {
          name: "withdrawal_limiter",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  119,
                  105,
                  116,
                  104,
                  100,
                  114,
                  97,
                  119,
                  97,
                  108,
                  95,
                  108,
                  105,
                  109,
                  105,
                  116,
                  101,
                  114
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "mint"
              }
            ]
          }
        },
        {
          name: "mint"
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "min_deposit",
          type: "u64"
        },
        {
          name: "limiter_config",
          type: {
            defined: {
              name: "Config"
            }
          }
        }
      ]
    },
    {
      name: "withdraw",
      discriminator: [
        183,
        18,
        70,
        156,
        148,
        109,
        161,
        34
      ],
      accounts: [
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "app"
        },
        {
          name: "child_blocks",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  104,
                  105,
                  108,
                  100,
                  95,
                  98,
                  108,
                  111,
                  99,
                  107,
                  115
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "claim.prev_state_facts_cmtmt"
              }
            ]
          }
        },
        {
          name: "effect_nullifier",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  101,
                  102,
                  102,
                  101,
                  99,
                  116,
                  95,
                  110,
                  117,
                  108,
                  108,
                  105,
                  102,
                  105,
                  101,
                  114
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "arg",
                path: "claim.prev_state_facts_cmtmt"
              },
              {
                kind: "arg",
                path: "claim.block_id"
              },
              {
                kind: "arg",
                path: "claim.leaf_index"
              }
            ]
          }
        },
        {
          name: "from_account",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "token_authority"
              },
              {
                kind: "account",
                path: "token_program"
              },
              {
                kind: "account",
                path: "to_account.mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "to_account",
          writable: true
        },
        {
          name: "withdrawal_limiter",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  119,
                  105,
                  116,
                  104,
                  100,
                  114,
                  97,
                  119,
                  97,
                  108,
                  95,
                  108,
                  105,
                  109,
                  105,
                  116,
                  101,
                  114
                ]
              },
              {
                kind: "account",
                path: "app"
              },
              {
                kind: "account",
                path: "to_account.mint"
              }
            ]
          }
        },
        {
          name: "token_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "crumb_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  117,
                  109,
                  98,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              },
              {
                kind: "account",
                path: "app"
              }
            ]
          }
        },
        {
          name: "program"
        },
        {
          name: "token_program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        }
      ],
      args: [
        {
          name: "claim",
          type: {
            defined: {
              name: "WithdrawalClaim"
            }
          }
        }
      ]
    }
  ],
  accounts: [
    {
      name: "App",
      discriminator: [
        67,
        135,
        84,
        79,
        153,
        49,
        239,
        169
      ]
    },
    {
      name: "AppConfig",
      discriminator: [
        35,
        142,
        177,
        102,
        131,
        31,
        162,
        52
      ]
    },
    {
      name: "AssetConfig",
      discriminator: [
        57,
        112,
        247,
        166,
        247,
        64,
        140,
        23
      ]
    },
    {
      name: "EffectNullifier",
      discriminator: [
        138,
        66,
        66,
        124,
        33,
        209,
        105,
        159
      ]
    },
    {
      name: "Global",
      discriminator: [
        167,
        232,
        232,
        177,
        200,
        108,
        114,
        127
      ]
    },
    {
      name: "PermissionSet",
      discriminator: [
        64,
        79,
        161,
        47,
        53,
        27,
        139,
        36
      ]
    },
    {
      name: "QueuedEvent",
      discriminator: [
        5,
        61,
        32,
        124,
        1,
        68,
        182,
        41
      ]
    },
    {
      name: "TokenBucket",
      discriminator: [
        64,
        212,
        194,
        121,
        213,
        38,
        100,
        53
      ]
    },
    {
      name: "UnqueuedEvent",
      discriminator: [
        198,
        208,
        170,
        230,
        58,
        90,
        225,
        167
      ]
    }
  ],
  errors: [
    {
      code: 6001,
      name: "AppConfigInvalid",
      msg: "app is invalid or already approved"
    },
    {
      code: 6002,
      name: "AppFrozen",
      msg: "app is frozen"
    },
    {
      code: 6003,
      name: "MinDepositInvalid",
      msg: "Min deposit must be greater than 0"
    },
    {
      code: 6101,
      name: "GlobalOwnerInvalid",
      msg: "provided global owner does not match configured global owner"
    },
    {
      code: 6102,
      name: "AppOwnerInvalid",
      msg: "app owner account does not match configured app's app_owner field"
    },
    {
      code: 6103,
      name: "OperatorInvalid",
      msg: "Operator account does not match configured app operator"
    },
    {
      code: 6104,
      name: "PermissionsInsufficient",
      msg: "signer does not have sufficient acl permissions"
    },
    {
      code: 6105,
      name: "NotAValidator",
      msg: "Ix was not signed with a registered validator account"
    },
    {
      code: 6201,
      name: "WithdrawalRateLimitExceeded",
      msg: "Total withdrawals in the last period exceeded the rate limit"
    },
    {
      code: 6202,
      name: "MerkleRootMismatch"
    },
    {
      code: 6203,
      name: "EffectAlreadyExecuted"
    },
    {
      code: 6301,
      name: "EventRootInvalid"
    },
    {
      code: 6302,
      name: "EventIndicesGoBackwards"
    },
    {
      code: 6303,
      name: "DepositTooSmall"
    },
    {
      code: 6401,
      name: "BlockEmpty",
      msg: "Block does not contain a state transition"
    },
    {
      code: 6403,
      name: "BlockNotFinalized",
      msg: "Block must be finalized before this operation"
    },
    {
      code: 6404,
      name: "BlockAlreadyFinalized",
      msg: "Block already finalized"
    },
    {
      code: 6405,
      name: "BlockAlreadyChallenged",
      msg: "Block already challenged by this validator"
    },
    {
      code: 6406,
      name: "BlockDoesNotExist"
    },
    {
      code: 6407,
      name: "BlockIsFinaTip",
      msg: "Cannot prune current finalized block tip"
    },
    {
      code: 6408,
      name: "BlockTooRecent",
      msg: "Block is not old enough to be pruned"
    },
    {
      code: 6409,
      name: "BlockHasUnexecutedEffects",
      msg: "Blocks effects have not all been executed"
    },
    {
      code: 6410,
      name: "RefundAccountInvalid",
      msg: "Refund account does not match the one stored in the block."
    },
    {
      code: 6411,
      name: "BlockNotPruned",
      msg: "Block hasn't yet been pruned"
    },
    {
      code: 6412,
      name: "ChildBlocksInvalid",
      msg: "ChildBlocks account does not exist or is invalid"
    },
    {
      code: 6413,
      name: "ChildBlocksNoFinaCandidates",
      msg: "ChildBlocks account contains no finalizable candidates"
    },
    {
      code: 6414,
      name: "ActionsGoBackwards"
    },
    {
      code: 6415,
      name: "ChallengePeriodExpired"
    },
    {
      code: 6501,
      name: "AppVersionNotAllowed",
      msg: "App version of block is not whitelisted for proposals or finalizations"
    },
    {
      code: 6502,
      name: "AppVersionsTooMany",
      msg: "App already at max allowed app versions capacity"
    }
  ],
  types: [
    {
      name: "App",
      docs: [
        "The central state of an app instance.",
        "",
        "# Multitenancy",
        "The bridge contract is multitenant. There may be multiple independent",
        "[`App`] instances owned by a single bridge program.",
        "",
        'Accounts owned by an app *instance* are PDAs "namespaced"  by including',
        "the [`App`] address in their seeds."
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "frozen",
            docs: [
              "Freeze all non-owner operations on this app"
            ],
            type: "bool"
          },
          {
            name: "operator",
            docs: [
              "Authority allowed to make proposals."
            ],
            type: "pubkey"
          },
          {
            name: "challenge_consensus_threshold",
            docs: [
              "Number of challenges required to disqualify a block from finalization.",
              "For consensus fraud proof on proposed blocks.",
              "",
              "Value of 0 means every block becomes unfinalizable, halting withdrawals",
              "indefinitely.",
              "",
              "Value greater than validator set size means *any* block can be finalized",
              "immediately even if challenged, defeating the fraud-proof mechanism."
            ],
            type: "u16"
          },
          {
            name: "challenge_period_slots",
            docs: [
              "Initial number of slots during which a block can be challenged",
              "",
              "Value of 0 means challenge window closes in the same slot; honest",
              "validators cannot react, enabling malicious block finalization.",
              "",
              'Value very large means blocks remain "Proposed" for years, preventing',
              "finalization and liquidity exit (economic DoS)."
            ],
            type: "u64"
          },
          {
            name: "last_block_id",
            docs: [
              "Last block id that was proposed. Highest valid block id.",
              "Blocks created and this counter bumped exclusively on proposal.",
              "",
              "NOTE: this *could* be instead a separate counter per ChildBlocks account but",
              "this global counter makes it a little easier to track the timeline of",
              "when blocks where proposed."
            ],
            type: "u64"
          },
          {
            name: "last_event_index",
            docs: [
              "Last event index that was made. Highest valid event index.",
              "Deposits created and this counter bumped exclusively on deposit."
            ],
            type: "u64"
          },
          {
            name: "fina_state_facts_prev_cmtmt",
            docs: [
              "`prev_state_facts.hash()` of the latest finalized block.",
              "Used to find the ChildBlocks layer holding the latest finalized block."
            ],
            type: {
              defined: {
                name: "Commitment"
              }
            }
          },
          {
            name: "fina_state_facts",
            docs: [
              "Recent-most finalized state facts.",
              "This corresponds to the next_state_facts of the last finalized block."
            ],
            type: {
              defined: {
                name: "StateFacts"
              }
            }
          },
          {
            name: "target_fina_state_facts",
            docs: [
              "If set, only blocks working towards these state facts will be",
              "finalizable. Once the target reached, this is unset.",
              "",
              'If set to a statefacts in the past or impossible to "work towards",',
              "the app will not accept any finalizations.",
              "",
              "Can be manually set to None by the owner to remove the restriction."
            ],
            type: {
              option: {
                defined: {
                  name: "StateFacts"
                }
              }
            }
          },
          {
            name: "block_lifetime",
            docs: [
              "Block retention policy.",
              "Blocks where slot_proposed + block_lifetime < slot_current  are prunable."
            ],
            type: "u64"
          },
          {
            name: "allowed_app_versions",
            docs: [
              "Allowed app versions for new proposals and finalizations.",
              "",
              "We only need to allow up to 2 versions concurrently in a typical upgrade",
              "scenario: one for the state translation and one for the new app version.",
              "",
              "We allow up to ALLOWED_APP_VERSIONS_LEN_MAX > 2 for some extra",
              "maneuverability in case it is needed."
            ],
            type: {
              vec: {
                defined: {
                  name: "Commitment"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "AppConfig",
      type: {
        kind: "struct",
        fields: [
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "operator",
            type: "pubkey"
          },
          {
            name: "challenge_consensus_threshold",
            type: "u16"
          },
          {
            name: "challenge_period_slots",
            type: "u64"
          },
          {
            name: "initial_app_state_commitment",
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "block_lifetime",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "AssetConfig",
      type: {
        kind: "struct",
        fields: [
          {
            name: "min_deposit",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BlockFacts",
      docs: [
        "State transition block facts."
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "app_version",
            type: {
              defined: {
                name: "Commitment"
              }
            }
          },
          {
            name: "prev_state_facts",
            type: {
              defined: {
                name: "StateFacts"
              }
            }
          },
          {
            name: "next_state_facts",
            type: {
              defined: {
                name: "StateFacts"
              }
            }
          },
          {
            name: "da_commitment",
            type: {
              defined: {
                name: "Commitment"
              }
            }
          },
          {
            name: "effects_root",
            type: {
              defined: {
                name: "Commitment"
              }
            }
          },
          {
            name: "effects_count",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Commitment",
      repr: {
        kind: "transparent"
      },
      type: {
        kind: "struct",
        fields: [
          {
            array: [
              "u8",
              32
            ]
          }
        ]
      }
    },
    {
      name: "Config",
      type: {
        kind: "struct",
        fields: [
          {
            name: "max_burst",
            type: "u64"
          },
          {
            name: "rate_per_slot",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EffectNullifier",
      type: {
        kind: "struct",
        fields: [
          {
            name: "refund_account",
            docs: [
              "Who to refund the rent of this nullifier to."
            ],
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "Event",
      repr: {
        kind: "rust"
      },
      type: {
        kind: "enum",
        variants: [
          {
            name: "Deposit",
            fields: [
              {
                name: "transfer",
                type: {
                  defined: {
                    name: "TransferParams"
                  }
                }
              }
            ]
          }
        ]
      }
    },
    {
      name: "Global",
      type: {
        kind: "struct",
        fields: [
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "PermissionSet",
      type: {
        kind: "struct",
        fields: [
          "u16"
        ]
      }
    },
    {
      name: "QueuedEvent",
      type: {
        kind: "struct",
        fields: [
          {
            name: "event",
            type: {
              defined: {
                name: "Event"
              }
            }
          },
          {
            name: "prev_event_root",
            type: {
              defined: {
                name: "Commitment"
              }
            }
          }
        ]
      }
    },
    {
      name: "StateFacts",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "app_state_commitment",
            type: {
              defined: {
                name: "Commitment"
              }
            }
          },
          {
            name: "event_root",
            type: {
              defined: {
                name: "Commitment"
              }
            }
          },
          {
            name: "last_event_index",
            type: "u64"
          },
          {
            name: "last_action_id",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TokenBucket",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cfg",
            type: {
              defined: {
                name: "Config"
              }
            }
          },
          {
            name: "tokens",
            type: "u64"
          },
          {
            name: "last_update",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TransferParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "authority",
            type: "pubkey"
          },
          {
            name: "mint",
            type: "pubkey"
          },
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "UnqueuedEvent",
      type: {
        kind: "struct",
        fields: [
          {
            name: "event",
            type: {
              defined: {
                name: "Event"
              }
            }
          }
        ]
      }
    },
    {
      name: "WithdrawalClaim",
      type: {
        kind: "struct",
        fields: [
          {
            name: "user",
            type: "pubkey"
          },
          {
            name: "amount",
            type: "u64"
          },
          {
            name: "prev_state_facts_cmtmt",
            type: {
              defined: {
                name: "Commitment"
              }
            }
          },
          {
            name: "block_id",
            type: "u64"
          },
          {
            name: "proof",
            type: {
              vec: {
                defined: {
                  name: "Commitment"
                }
              }
            }
          },
          {
            name: "leaf_index",
            type: "u64"
          },
          {
            name: "leaves_count",
            type: "u64"
          }
        ]
      }
    }
  ]
};
var TOKEN_PROGRAM_ID2 = new PublicKey2("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var TOKEN_2022_PROGRAM_ID = new PublicKey2("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey2("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT = new PublicKey2("So11111111111111111111111111111111111111112");
var NATIVE_MINT_2022 = new PublicKey2("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
var encodeDecode = (layout) => {
  const decode3 = layout.decode.bind(layout);
  const encode2 = layout.encode.bind(layout);
  return { decode: decode3, encode: encode2 };
};
var import_buffer_layout22 = __toESM2(require_Layout2(), 1);
var import_bigint_buffer = __toESM2(require_browser22(), 1);
var bigInt = (length) => (property) => {
  const layout = import_buffer_layout22.blob(length, property);
  const { encode: encode2, decode: decode3 } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset3) => {
    const src = decode3(buffer, offset3);
    return import_bigint_buffer.toBigIntLE(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset3) => {
    const src = import_bigint_buffer.toBufferLE(bigInt2, length);
    return encode2(src, buffer, offset3);
  };
  return bigIntLayout;
};
var bigIntBE = (length) => (property) => {
  const layout = import_buffer_layout22.blob(length, property);
  const { encode: encode2, decode: decode3 } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset3) => {
    const src = decode3(buffer, offset3);
    return import_bigint_buffer.toBigIntBE(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt2, buffer, offset3) => {
    const src = import_bigint_buffer.toBufferBE(bigInt2, length);
    return encode2(src, buffer, offset3);
  };
  return bigIntLayout;
};
var u644 = bigInt(8);
var u64be = bigIntBE(8);
var u1282 = bigInt(16);
var u128be = bigIntBE(16);
var u192 = bigInt(24);
var u192be = bigIntBE(24);
var u2562 = bigInt(32);
var u256be = bigIntBE(32);
var import_buffer_layout3 = __toESM2(require_Layout2(), 1);
var bool2 = (property) => {
  const layout = import_buffer_layout3.u8(property);
  const { encode: encode2, decode: decode3 } = encodeDecode(layout);
  const boolLayout = layout;
  boolLayout.decode = (buffer, offset3) => {
    const src = decode3(buffer, offset3);
    return !!src;
  };
  boolLayout.encode = (bool3, buffer, offset3) => {
    const src = Number(bool3);
    return encode2(src, buffer, offset3);
  };
  return boolLayout;
};
var import_buffer_layout5 = __toESM2(require_Layout2(), 1);
init_buffer2();
var import_bn4 = __toESM2(require_bn2(), 1);
var import_bs5832 = __toESM2(require_bs5822(), 1);
var import_borsh22 = __toESM2(require_lib2(), 1);
var BufferLayout22 = __toESM2(require_Layout2(), 1);
var import_buffer_layout4 = __toESM2(require_Layout2(), 1);

class StructError3 extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
}
function isIterable3(x2) {
  return isObject32(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject32(x2) {
  return typeof x2 === "object" && x2 != null;
}
function isNonArrayObject22(x2) {
  return isObject32(x2) && !Array.isArray(x2);
}
function print3(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator3(input) {
  const { done, value } = input.next();
  return done ? undefined : value;
}
function toFailure3(result, context, struct4, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type3 } = struct4;
  const { refinement, message = `Expected a value of type \`${type3}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print3(value)}\`` } = result;
  return {
    value,
    type: type3,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures3(result, context, struct4, value) {
  if (!isIterable3(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure3(r, context, struct4, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run3(value, struct4, options = {}) {
  const { path = [], branch = [value], coerce: coerce3 = false, mask: mask32 = false } = options;
  const ctx = { path, branch, mask: mask32 };
  if (coerce3) {
    value = struct4.coercer(value, ctx);
  }
  let status = "valid";
  for (const failure of struct4.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, undefined];
  }
  for (let [k, v, s] of struct4.entries(value, ctx)) {
    const ts = run3(v, s, {
      path: k === undefined ? path : [...path, k],
      branch: k === undefined ? branch : [...branch, v],
      coerce: coerce3,
      mask: mask32,
      message: options.message
    });
    for (const t of ts) {
      if (t[0]) {
        status = t[0].refinement != null ? "not_refined" : "not_valid";
        yield [t[0], undefined];
      } else if (coerce3) {
        v = t[1];
        if (k === undefined) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject32(value)) {
          if (v !== undefined || k in value)
            value[k] = v;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct4.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, undefined];
    }
  }
  if (status === "valid") {
    yield [undefined, value];
  }
}

class Struct4 {
  constructor(props) {
    const { type: type3, schema, validator, refiner, coercer = (value) => value, entries = function* () {} } = props;
    this.type = type3;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures3(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures3(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  assert(value, message) {
    return assert42(value, this, message);
  }
  create(value, message) {
    return create32(value, this, message);
  }
  is(value) {
    return is3(value, this);
  }
  mask(value, message) {
    return mask32(value, this, message);
  }
  validate(value, options = {}) {
    return validate4(value, this, options);
  }
}
function assert42(value, struct4, message) {
  const result = validate4(value, struct4, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create32(value, struct4, message) {
  const result = validate4(value, struct4, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask32(value, struct4, message) {
  const result = validate4(value, struct4, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is3(value, struct4) {
  const result = validate4(value, struct4);
  return !result[0];
}
function validate4(value, struct4, options = {}) {
  const tuples = run3(value, struct4, options);
  const tuple22 = shiftIterator3(tuples);
  if (tuple22[0]) {
    const error = new StructError3(tuple22[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, undefined];
  } else {
    const v = tuple22[1];
    return [undefined, v];
  }
}
function define4(name, validator) {
  return new Struct4({ type: name, schema: null, validator });
}
function any3() {
  return define4("any", () => true);
}
function array4(Element) {
  return new Struct4({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i22, v] of value.entries()) {
          yield [i22, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print3(value)}`;
    }
  });
}
function boolean3() {
  return define4("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance22(Class) {
  return define4("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print3(value)}`;
  });
}
function literal3(constant) {
  const description = print3(constant);
  const t = typeof constant;
  return new Struct4({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print3(value)}`;
    }
  });
}
function never22() {
  return define4("never", () => false);
}
function nullable3(struct4) {
  return new Struct4({
    ...struct4,
    validator: (value, ctx) => value === null || struct4.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct4.refiner(value, ctx)
  });
}
function number32() {
  return define4("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print3(value)}`;
  });
}
function optional3(struct4) {
  return new Struct4({
    ...struct4,
    validator: (value, ctx) => value === undefined || struct4.validator(value, ctx),
    refiner: (value, ctx) => value === undefined || struct4.refiner(value, ctx)
  });
}
function record22(Key, Value) {
  return new Struct4({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject32(value)) {
        for (const k in value) {
          const v = value[k];
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },
    validator(value) {
      return isNonArrayObject22(value) || `Expected an object, but received: ${print3(value)}`;
    },
    coercer(value) {
      return isNonArrayObject22(value) ? { ...value } : value;
    }
  });
}
function string3() {
  return define4("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print3(value)}`;
  });
}
function tuple22(Structs) {
  const Never = never22();
  return new Struct4({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Structs.length, value.length);
        for (let i22 = 0;i22 < length; i22++) {
          yield [i22, value[i22], Structs[i22] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print3(value)}`;
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    }
  });
}
function type3(schema) {
  const keys = Object.keys(schema);
  return new Struct4({
    type: "type",
    schema,
    *entries(value) {
      if (isObject32(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isNonArrayObject22(value) || `Expected an object, but received: ${print3(value)}`;
    },
    coercer(value) {
      return isNonArrayObject22(value) ? { ...value } : value;
    }
  });
}
function union3(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct4({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      for (const S2 of Structs) {
        const [error, coerced] = S2.validate(value, {
          coerce: true,
          mask: ctx.mask
        });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run3(value, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print3(value)}`,
        ...failures
      ];
    }
  });
}
function unknown3() {
  return define4("unknown", () => true);
}
function coerce3(struct4, condition, coercer) {
  return new Struct4({
    ...struct4,
    coercer: (value, ctx) => {
      return is3(value, condition) ? struct4.coercer(coercer(value, ctx), ctx) : struct4.coercer(value, ctx);
    }
  });
}
var import_browser22 = __toESM2(require_browser4(), 1);
var generatePrivateKey22 = ed255192.utils.randomPrivateKey;
var generateKeypair22 = () => {
  const privateScalar = ed255192.utils.randomPrivateKey();
  const publicKey4 = getPublicKey22(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey4, 32);
  return {
    publicKey: publicKey4,
    secretKey
  };
};
var getPublicKey22 = ed255192.getPublicKey;
function isOnCurve22(publicKey4) {
  try {
    ed255192.ExtendedPoint.fromHex(publicKey4);
    return true;
  } catch {
    return false;
  }
}
var sign22 = (message, secretKey) => ed255192.sign(message, secretKey.slice(0, 32));
var verify22 = ed255192.verify;
var toBuffer22 = (arr) => {
  if (export_Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return export_Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return export_Buffer.from(arr);
  }
};

class Struct5 {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return export_Buffer.from(import_borsh22.serialize(SOLANA_SCHEMA22, this));
  }
  static decode(data) {
    return import_borsh22.deserialize(SOLANA_SCHEMA22, this, data);
  }
  static decodeUnchecked(data) {
    return import_borsh22.deserializeUnchecked(SOLANA_SCHEMA22, this, data);
  }
}
var SOLANA_SCHEMA22 = new Map;
var _PublicKey22;
var MAX_SEED_LENGTH22 = 32;
var PUBLIC_KEY_LENGTH22 = 32;
function isPublicKeyData22(value) {
  return value._bn !== undefined;
}
var uniquePublicKeyCounter22 = 1;

class PublicKey22 extends Struct5 {
  constructor(value) {
    super({});
    this._bn = undefined;
    if (isPublicKeyData22(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs5832.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH22) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn4.default(decoded);
      } else {
        this._bn = new import_bn4.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH22) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  static unique() {
    const key = new PublicKey22(uniquePublicKeyCounter22);
    uniquePublicKeyCounter22 += 1;
    return new PublicKey22(key.toBuffer());
  }
  equals(publicKey4) {
    return this._bn.eq(publicKey4._bn);
  }
  toBase58() {
    return import_bs5832.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  toBuffer() {
    const b22 = this._bn.toArrayLike(export_Buffer);
    if (b22.length === PUBLIC_KEY_LENGTH22) {
      return b22;
    }
    const zeroPad2 = export_Buffer.alloc(32);
    b22.copy(zeroPad2, 32 - b22.length);
    return zeroPad2;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(fromPublicKey, seed2, programId) {
    const buffer = export_Buffer.concat([fromPublicKey.toBuffer(), export_Buffer.from(seed2), programId.toBuffer()]);
    const publicKeyBytes = sha25622(buffer);
    return new PublicKey22(publicKeyBytes);
  }
  static createProgramAddressSync(seeds, programId) {
    let buffer = export_Buffer.alloc(0);
    seeds.forEach(function(seed2) {
      if (seed2.length > MAX_SEED_LENGTH22) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = export_Buffer.concat([buffer, toBuffer22(seed2)]);
    });
    buffer = export_Buffer.concat([buffer, programId.toBuffer(), export_Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha25622(buffer);
    if (isOnCurve22(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey22(publicKeyBytes);
  }
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(export_Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err2) {
        if (err2 instanceof TypeError) {
          throw err2;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey22(pubkeyData);
    return isOnCurve22(pubkey.toBytes());
  }
}
_PublicKey22 = PublicKey22;
PublicKey22.default = new _PublicKey22("11111111111111111111111111111111");
SOLANA_SCHEMA22.set(PublicKey22, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID22 = new PublicKey22("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE22 = 1280 - 40 - 8;
var VERSION_PREFIX_MASK22 = 127;
var SIGNATURE_LENGTH_IN_BYTES22 = 64;

class TransactionExpiredBlockheightExceededError22 extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError22.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});

class TransactionExpiredTimeoutError22 extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + "unknown if it succeeded or failed. Check signature " + `${signature} using the Solana Explorer or CLI tools.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError22.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});

class TransactionExpiredNonceInvalidError22 extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError22.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});

class MessageAccountKeys22 {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = undefined;
    this.accountKeysFromLookups = undefined;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = new Map;
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === undefined)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}
var publicKey4 = (property = "publicKey") => {
  return BufferLayout22.blob(32, property);
};
var rustString22 = (property = "string") => {
  const rsl = BufferLayout22.struct([BufferLayout22.u32("length"), BufferLayout22.u32("lengthPadding"), BufferLayout22.blob(BufferLayout22.offset(BufferLayout22.u32(), -8), "chars")], property);
  const _decode2 = rsl.decode.bind(rsl);
  const _encode2 = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b22, offset4) => {
    const data = _decode2(b22, offset4);
    return data["chars"].toString();
  };
  rslShim.encode = (str2, b22, offset4) => {
    const data = {
      chars: export_Buffer.from(str2, "utf8")
    };
    return _encode2(data, b22, offset4);
  };
  rslShim.alloc = (str2) => {
    return BufferLayout22.u32().span + BufferLayout22.u32().span + export_Buffer.from(str2, "utf8").length;
  };
  return rslShim;
};
var authorized22 = (property = "authorized") => {
  return BufferLayout22.struct([publicKey4("staker"), publicKey4("withdrawer")], property);
};
var lockup22 = (property = "lockup") => {
  return BufferLayout22.struct([BufferLayout22.ns64("unixTimestamp"), BufferLayout22.ns64("epoch"), publicKey4("custodian")], property);
};
var voteInit22 = (property = "voteInit") => {
  return BufferLayout22.struct([publicKey4("nodePubkey"), publicKey4("authorizedVoter"), publicKey4("authorizedWithdrawer"), BufferLayout22.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs22 = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout22.struct([BufferLayout22.u32("voteAuthorizationType"), publicKey4("currentAuthorityDerivedKeyOwnerPubkey"), rustString22("currentAuthorityDerivedKeySeed"), publicKey4("newAuthorized")], property);
};
function getAlloc22(type4, fields2) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields2[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields2[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc22({
        layout: item
      }, fields2[item.property]);
    }
    return 0;
  };
  let alloc2 = 0;
  type4.layout.fields.forEach((item) => {
    alloc2 += getItemAlloc(item);
  });
  return alloc2;
}
function decodeLength22(bytes2) {
  let len2 = 0;
  let size = 0;
  for (;; ) {
    let elem = bytes2.shift();
    len2 |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len2;
}
function encodeLength22(bytes2, len2) {
  let rem_len = len2;
  for (;; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem);
      break;
    } else {
      elem |= 128;
      bytes2.push(elem);
    }
  }
}
function assert52(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

class CompiledKeys22 {
  constructor(payer, keyMetaMap) {
    this.payer = undefined;
    this.keyMetaMap = undefined;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = new Map;
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === undefined) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner ||= accountMeta.isSigner;
        keyMeta.isWritable ||= accountMeta.isWritable;
      }
    }
    return new CompiledKeys22(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert52(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert52(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert52(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey22(address)), ...readonlySigners.map(([address]) => new PublicKey22(address)), ...writableNonSigners.map(([address]) => new PublicKey22(address)), ...readonlyNonSigners.map(([address]) => new PublicKey22(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array;
    const drainedKeys = new Array;
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey22(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert52(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}
var END_OF_BUFFER_ERROR_MESSAGE22 = "Reached end of buffer unexpectedly";
function guardedShift22(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE22);
  }
  return byteArray.shift();
}
function guardedSplice22(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE22);
  }
  return byteArray.splice(...args);
}

class Message22 {
  constructor(args) {
    this.header = undefined;
    this.accountKeys = undefined;
    this.recentBlockhash = undefined;
    this.instructions = undefined;
    this.indexToProgramIds = new Map;
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey22(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs5832.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys22(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys22.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys22(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs5832.default.encode(ix.data)
    }));
    return new Message22({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength22(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs5832.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength22(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength22(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: export_Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: export_Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength22(instructionCount, instructions.length);
    let instructionBuffer = export_Buffer.alloc(PACKET_DATA_SIZE22);
    export_Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout22.struct([BufferLayout22.u8("programIdIndex"), BufferLayout22.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout22.seq(BufferLayout22.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout22.blob(instruction.dataLength.length, "dataLength"), BufferLayout22.seq(BufferLayout22.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout22.struct([BufferLayout22.blob(1, "numRequiredSignatures"), BufferLayout22.blob(1, "numReadonlySignedAccounts"), BufferLayout22.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout22.blob(keyCount.length, "keyCount"), BufferLayout22.seq(publicKey4("key"), numKeys, "keys"), publicKey4("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: export_Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: export_Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: export_Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: export_Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer22(key.toBytes())),
      recentBlockhash: import_bs5832.default.decode(this.recentBlockhash)
    };
    let signData = export_Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift22(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK22)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift22(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift22(byteArray);
    const accountCount = decodeLength22(byteArray);
    let accountKeys = [];
    for (let i22 = 0;i22 < accountCount; i22++) {
      const account = guardedSplice22(byteArray, 0, PUBLIC_KEY_LENGTH22);
      accountKeys.push(new PublicKey22(export_Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice22(byteArray, 0, PUBLIC_KEY_LENGTH22);
    const instructionCount = decodeLength22(byteArray);
    let instructions = [];
    for (let i22 = 0;i22 < instructionCount; i22++) {
      const programIdIndex = guardedShift22(byteArray);
      const accountCount2 = decodeLength22(byteArray);
      const accounts = guardedSplice22(byteArray, 0, accountCount2);
      const dataLength2 = decodeLength22(byteArray);
      const dataSlice2 = guardedSplice22(byteArray, 0, dataLength2);
      const data = import_bs5832.default.encode(export_Buffer.from(dataSlice2));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs5832.default.encode(export_Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message22(messageArgs);
  }
}
var DEFAULT_SIGNATURE22 = export_Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES22).fill(0);

class TransactionInstruction22 {
  constructor(opts) {
    this.keys = undefined;
    this.programId = undefined;
    this.data = export_Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}

class Transaction22 {
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  constructor(opts) {
    this.signatures = [];
    this.feePayer = undefined;
    this.instructions = [];
    this.recentBlockhash = undefined;
    this.lastValidBlockHeight = undefined;
    this.nonceInfo = undefined;
    this.minNonceContextSlot = undefined;
    this._message = undefined;
    this._json = undefined;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey5
      }) => {
        return publicKey5.toJSON();
      })
    };
  }
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction22(item));
      }
    });
    return this;
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i22 = 0;i22 < instructions.length; i22++) {
      if (instructions[i22].programId === undefined) {
        throw new Error(`Transaction instruction index ${i22} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey22(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x2, y) {
      if (x2.isSigner !== y.isSigner) {
        return x2.isSigner ? -1 : 1;
      }
      if (x2.isWritable !== y.isWritable) {
        return x2.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x2.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x2) => {
      return x2.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.equals(signature.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, " + "only the fee payer and instruction signer accounts should sign a transaction. " + "This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs5832.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert52(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert52(keyIndex >= 0));
    });
    return new Message22({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid)
        return message;
    }
    this.signatures = signedKeys.map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
    return message;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    this.signatures = signers.filter((publicKey5) => {
      const key = publicKey5.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey5) => ({
      signature: null,
      publicKey: publicKey5
    }));
  }
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature = sign22(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer22(signature));
    });
  }
  addSignature(pubkey, signature) {
    this._compile();
    this._addSignature(pubkey, signature);
  }
  _addSignature(pubkey, signature) {
    assert52(signature.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = export_Buffer.from(signature);
  }
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature,
      publicKey: publicKey5
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          (errors.missing ||= []).push(publicKey5);
        }
      } else {
        if (!verify22(signature, message, publicKey5.toBytes())) {
          (errors.invalid ||= []).push(publicKey5);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : undefined;
  }
  serialize(config2) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config2);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength22(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = export_Buffer.alloc(transactionLength);
    assert52(signatures.length < 256);
    export_Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert52(signature.length === 64, `signature has invalid length`);
        export_Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert52(wireTransaction.length <= PACKET_DATA_SIZE22, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE22}`);
    return wireTransaction;
  }
  get keys() {
    assert52(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  get programId() {
    assert52(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  get data() {
    assert52(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength22(byteArray);
    let signatures = [];
    for (let i22 = 0;i22 < signatureCount; i22++) {
      const signature = guardedSplice22(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES22);
      signatures.push(import_bs5832.default.encode(export_Buffer.from(signature)));
    }
    return Transaction22.populate(Message22.from(byteArray), signatures);
  }
  static populate(message, signatures = []) {
    const transaction = new Transaction22;
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == import_bs5832.default.encode(DEFAULT_SIGNATURE22) ? null : import_bs5832.default.decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction22({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs5832.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
}
var NUM_TICKS_PER_SECOND22 = 160;
var DEFAULT_TICKS_PER_SLOT22 = 64;
var NUM_SLOTS_PER_SECOND22 = NUM_TICKS_PER_SECOND22 / DEFAULT_TICKS_PER_SLOT22;
var MS_PER_SLOT22 = 1000 / NUM_SLOTS_PER_SECOND22;
var SYSVAR_CLOCK_PUBKEY22 = new PublicKey22("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY22 = new PublicKey22("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY22 = new PublicKey22("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY22 = new PublicKey22("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY22 = new PublicKey22("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY22 = new PublicKey22("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY22 = new PublicKey22("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY22 = new PublicKey22("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY22 = new PublicKey22("SysvarStakeHistory1111111111111111111111111");

class SendTransactionError22 extends Error {
  constructor({
    action,
    signature,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature} resulted in an error. 
` + `${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${((a) => a)(action)}'`;
      }
    }
    super(message);
    this.signature = undefined;
    this.transactionMessage = undefined;
    this.transactionLogs = undefined;
    this.signature = signature;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : undefined;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined
    };
  }
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
}
async function sendAndConfirmTransaction22(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was " + "supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` " + "or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature != null) {
      throw new SendTransactionError22({
        action: "send",
        signature,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
function sleep22(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function encodeData22(type4, fields2) {
  const allocLength = type4.layout.span >= 0 ? type4.layout.span : getAlloc22(type4, fields2);
  const data = export_Buffer.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type4.index
  }, fields2);
  type4.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout22 = BufferLayout22.nu64("lamportsPerSignature");
var NonceAccountLayout22 = BufferLayout22.struct([BufferLayout22.u32("version"), BufferLayout22.u32("state"), publicKey4("authorizedPubkey"), publicKey4("nonce"), BufferLayout22.struct([FeeCalculatorLayout22], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH22 = NonceAccountLayout22.span;
function u645(property) {
  const layout = import_buffer_layout4.blob(8, property);
  const decode3 = layout.decode.bind(layout);
  const encode2 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec2();
  bigIntLayout.decode = (buffer, offset4) => {
    const src = decode3(buffer, offset4);
    return codec.decode(src);
  };
  bigIntLayout.encode = (bigInt2, buffer, offset4) => {
    const src = codec.encode(bigInt2);
    return encode2(src, buffer, offset4);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS22 = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), BufferLayout22.ns64("lamports"), BufferLayout22.ns64("space"), publicKey4("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), u645("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("base"), rustString22("seed"), BufferLayout22.ns64("lamports"), BufferLayout22.ns64("space"), publicKey4("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), BufferLayout22.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), BufferLayout22.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("base"), rustString22("seed"), BufferLayout22.ns64("space"), publicKey4("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("base"), rustString22("seed"), publicKey4("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), u645("lamports"), rustString22("seed"), publicKey4("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  }
});

class SystemProgram22 {
  constructor() {}
  static createAccount(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.Create;
    const data = encodeData22(type4, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer22(params.programId.toBuffer())
    });
    return new TransactionInstruction22({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.TransferWithSeed;
      data = encodeData22(type4, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer22(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.Transfer;
      data = encodeData22(type4, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction22({
      keys,
      programId: this.programId,
      data
    });
  }
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.AssignWithSeed;
      data = encodeData22(type4, {
        base: toBuffer22(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer22(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.Assign;
      data = encodeData22(type4, {
        programId: toBuffer22(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction22({
      keys,
      programId: this.programId,
      data
    });
  }
  static createAccountWithSeed(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.CreateWithSeed;
    const data = encodeData22(type4, {
      base: toBuffer22(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer22(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction22({
      keys,
      programId: this.programId,
      data
    });
  }
  static createNonceAccount(params) {
    const transaction = new Transaction22;
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(SystemProgram22.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH22,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram22.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH22,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  static nonceInitialize(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.InitializeNonceAccount;
    const data = encodeData22(type4, {
      authorized: toBuffer22(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY22,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction22(instructionData);
  }
  static nonceAdvance(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.AdvanceNonceAccount;
    const data = encodeData22(type4);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction22(instructionData);
  }
  static nonceWithdraw(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.WithdrawNonceAccount;
    const data = encodeData22(type4, {
      lamports: params.lamports
    });
    return new TransactionInstruction22({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static nonceAuthorize(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.AuthorizeNonceAccount;
    const data = encodeData22(type4, {
      authorized: toBuffer22(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction22({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.AllocateWithSeed;
      data = encodeData22(type4, {
        base: toBuffer22(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer22(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS22.Allocate;
      data = encodeData22(type4, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction22({
      keys,
      programId: this.programId,
      data
    });
  }
}
SystemProgram22.programId = new PublicKey22("11111111111111111111111111111111");
var CHUNK_SIZE22 = PACKET_DATA_SIZE22 - 300;

class Loader22 {
  constructor() {}
  static getMinNumSignatures(dataLength2) {
    return 2 * (Math.ceil(dataLength2 / Loader22.chunkSize) + 1 + 1);
  }
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction22;
          transaction.add(SystemProgram22.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction22;
          transaction.add(SystemProgram22.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction22;
          transaction.add(SystemProgram22.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction22().add(SystemProgram22.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction22(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout22.struct([BufferLayout22.u32("instruction"), BufferLayout22.u32("offset"), BufferLayout22.u32("bytesLength"), BufferLayout22.u32("bytesLengthPadding"), BufferLayout22.seq(BufferLayout22.u8("byte"), BufferLayout22.offset(BufferLayout22.u32(), -8), "bytes")]);
    const chunkSize = Loader22.chunkSize;
    let offset4 = 0;
    let array5 = data;
    let transactions = [];
    while (array5.length > 0) {
      const bytes2 = array5.slice(0, chunkSize);
      const data2 = export_Buffer.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        offset: offset4,
        bytes: bytes2,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction22().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction22(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep22(1000 / REQUESTS_PER_SECOND);
      }
      offset4 += chunkSize;
      array5 = array5.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout22.struct([BufferLayout22.u32("instruction")]);
      const data2 = export_Buffer.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
      }, data2);
      const transaction = new Transaction22().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY22,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {}
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT22 / 2)));
      }
    }
    return true;
  }
}
Loader22.chunkSize = CHUNK_SIZE22;
var BPF_LOADER_PROGRAM_ID22 = new PublicKey22("BPFLoader2111111111111111111111111111111111");
var fetchImpl22 = globalThis.fetch;
var LookupTableMetaLayout22 = {
  index: 1,
  layout: BufferLayout22.struct([
    BufferLayout22.u32("typeIndex"),
    u645("deactivationSlot"),
    BufferLayout22.nu64("lastExtendedSlot"),
    BufferLayout22.u8("lastExtendedStartIndex"),
    BufferLayout22.u8(),
    BufferLayout22.seq(publicKey4(), BufferLayout22.offset(BufferLayout22.u8(), -1), "authority")
  ])
};
var PublicKeyFromString22 = coerce3(instance22(PublicKey22), string3(), (value) => new PublicKey22(value));
var RawAccountDataResult22 = tuple22([string3(), literal3("base64")]);
var BufferFromRawAccountData22 = coerce3(instance22(export_Buffer), RawAccountDataResult22, (value) => export_Buffer.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS22 = 30 * 1000;
function createRpcResult3(result) {
  return union3([type3({
    jsonrpc: literal3("2.0"),
    id: string3(),
    result
  }), type3({
    jsonrpc: literal3("2.0"),
    id: string3(),
    error: type3({
      code: unknown3(),
      message: string3(),
      data: optional3(any3())
    })
  })]);
}
var UnknownRpcResult3 = createRpcResult3(unknown3());
function jsonRpcResult3(schema) {
  return coerce3(createRpcResult3(schema), UnknownRpcResult3, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create32(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext3(value) {
  return jsonRpcResult3(type3({
    context: type3({
      slot: number32()
    }),
    value
  }));
}
function notificationResultAndContext22(value) {
  return type3({
    context: type3({
      slot: number32()
    }),
    value
  });
}
var GetInflationGovernorResult22 = type3({
  foundation: number32(),
  foundationTerm: number32(),
  initial: number32(),
  taper: number32(),
  terminal: number32()
});
var GetInflationRewardResult22 = jsonRpcResult3(array4(nullable3(type3({
  epoch: number32(),
  effectiveSlot: number32(),
  amount: number32(),
  postBalance: number32(),
  commission: optional3(nullable3(number32()))
}))));
var GetRecentPrioritizationFeesResult22 = array4(type3({
  slot: number32(),
  prioritizationFee: number32()
}));
var GetInflationRateResult22 = type3({
  total: number32(),
  validator: number32(),
  foundation: number32(),
  epoch: number32()
});
var GetEpochInfoResult22 = type3({
  epoch: number32(),
  slotIndex: number32(),
  slotsInEpoch: number32(),
  absoluteSlot: number32(),
  blockHeight: optional3(number32()),
  transactionCount: optional3(number32())
});
var GetEpochScheduleResult22 = type3({
  slotsPerEpoch: number32(),
  leaderScheduleSlotOffset: number32(),
  warmup: boolean3(),
  firstNormalEpoch: number32(),
  firstNormalSlot: number32()
});
var GetLeaderScheduleResult22 = record22(string3(), array4(number32()));
var TransactionErrorResult22 = nullable3(union3([type3({}), string3()]));
var SignatureStatusResult22 = type3({
  err: TransactionErrorResult22
});
var SignatureReceivedResult22 = literal3("receivedSignature");
var VersionResult22 = type3({
  "solana-core": string3(),
  "feature-set": optional3(number32())
});
var ParsedInstructionStruct22 = type3({
  program: string3(),
  programId: PublicKeyFromString22,
  parsed: unknown3()
});
var PartiallyDecodedInstructionStruct22 = type3({
  programId: PublicKeyFromString22,
  accounts: array4(PublicKeyFromString22),
  data: string3()
});
var SimulatedTransactionResponseStruct3 = jsonRpcResultAndContext3(type3({
  err: nullable3(union3([type3({}), string3()])),
  logs: nullable3(array4(string3())),
  accounts: optional3(nullable3(array4(nullable3(type3({
    executable: boolean3(),
    owner: string3(),
    lamports: number32(),
    data: array4(string3()),
    rentEpoch: optional3(number32())
  }))))),
  unitsConsumed: optional3(number32()),
  returnData: optional3(nullable3(type3({
    programId: string3(),
    data: tuple22([string3(), literal3("base64")])
  }))),
  innerInstructions: optional3(nullable3(array4(type3({
    index: number32(),
    instructions: array4(union3([ParsedInstructionStruct22, PartiallyDecodedInstructionStruct22]))
  }))))
}));
var BlockProductionResponseStruct22 = jsonRpcResultAndContext3(type3({
  byIdentity: record22(string3(), array4(number32())),
  range: type3({
    firstSlot: number32(),
    lastSlot: number32()
  })
}));
var GetInflationGovernorRpcResult22 = jsonRpcResult3(GetInflationGovernorResult22);
var GetInflationRateRpcResult22 = jsonRpcResult3(GetInflationRateResult22);
var GetRecentPrioritizationFeesRpcResult22 = jsonRpcResult3(GetRecentPrioritizationFeesResult22);
var GetEpochInfoRpcResult22 = jsonRpcResult3(GetEpochInfoResult22);
var GetEpochScheduleRpcResult22 = jsonRpcResult3(GetEpochScheduleResult22);
var GetLeaderScheduleRpcResult22 = jsonRpcResult3(GetLeaderScheduleResult22);
var SlotRpcResult22 = jsonRpcResult3(number32());
var GetSupplyRpcResult22 = jsonRpcResultAndContext3(type3({
  total: number32(),
  circulating: number32(),
  nonCirculating: number32(),
  nonCirculatingAccounts: array4(PublicKeyFromString22)
}));
var TokenAmountResult22 = type3({
  amount: string3(),
  uiAmount: nullable3(number32()),
  decimals: number32(),
  uiAmountString: optional3(string3())
});
var GetTokenLargestAccountsResult22 = jsonRpcResultAndContext3(array4(type3({
  address: PublicKeyFromString22,
  amount: string3(),
  uiAmount: nullable3(number32()),
  decimals: number32(),
  uiAmountString: optional3(string3())
})));
var GetTokenAccountsByOwner22 = jsonRpcResultAndContext3(array4(type3({
  pubkey: PublicKeyFromString22,
  account: type3({
    executable: boolean3(),
    owner: PublicKeyFromString22,
    lamports: number32(),
    data: BufferFromRawAccountData22,
    rentEpoch: number32()
  })
})));
var ParsedAccountDataResult22 = type3({
  program: string3(),
  parsed: unknown3(),
  space: number32()
});
var GetParsedTokenAccountsByOwner22 = jsonRpcResultAndContext3(array4(type3({
  pubkey: PublicKeyFromString22,
  account: type3({
    executable: boolean3(),
    owner: PublicKeyFromString22,
    lamports: number32(),
    data: ParsedAccountDataResult22,
    rentEpoch: number32()
  })
})));
var GetLargestAccountsRpcResult22 = jsonRpcResultAndContext3(array4(type3({
  lamports: number32(),
  address: PublicKeyFromString22
})));
var AccountInfoResult22 = type3({
  executable: boolean3(),
  owner: PublicKeyFromString22,
  lamports: number32(),
  data: BufferFromRawAccountData22,
  rentEpoch: number32()
});
var KeyedAccountInfoResult22 = type3({
  pubkey: PublicKeyFromString22,
  account: AccountInfoResult22
});
var ParsedOrRawAccountData22 = coerce3(union3([instance22(export_Buffer), ParsedAccountDataResult22]), union3([RawAccountDataResult22, ParsedAccountDataResult22]), (value) => {
  if (Array.isArray(value)) {
    return create32(value, BufferFromRawAccountData22);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult22 = type3({
  executable: boolean3(),
  owner: PublicKeyFromString22,
  lamports: number32(),
  data: ParsedOrRawAccountData22,
  rentEpoch: number32()
});
var KeyedParsedAccountInfoResult22 = type3({
  pubkey: PublicKeyFromString22,
  account: ParsedAccountInfoResult22
});
var StakeActivationResult22 = type3({
  state: union3([literal3("active"), literal3("inactive"), literal3("activating"), literal3("deactivating")]),
  active: number32(),
  inactive: number32()
});
var GetConfirmedSignaturesForAddress2RpcResult22 = jsonRpcResult3(array4(type3({
  signature: string3(),
  slot: number32(),
  err: TransactionErrorResult22,
  memo: nullable3(string3()),
  blockTime: optional3(nullable3(number32()))
})));
var GetSignaturesForAddressRpcResult22 = jsonRpcResult3(array4(type3({
  signature: string3(),
  slot: number32(),
  err: TransactionErrorResult22,
  memo: nullable3(string3()),
  blockTime: optional3(nullable3(number32()))
})));
var AccountNotificationResult22 = type3({
  subscription: number32(),
  result: notificationResultAndContext22(AccountInfoResult22)
});
var ProgramAccountInfoResult22 = type3({
  pubkey: PublicKeyFromString22,
  account: AccountInfoResult22
});
var ProgramAccountNotificationResult22 = type3({
  subscription: number32(),
  result: notificationResultAndContext22(ProgramAccountInfoResult22)
});
var SlotInfoResult22 = type3({
  parent: number32(),
  slot: number32(),
  root: number32()
});
var SlotNotificationResult22 = type3({
  subscription: number32(),
  result: SlotInfoResult22
});
var SlotUpdateResult22 = union3([type3({
  type: union3([literal3("firstShredReceived"), literal3("completed"), literal3("optimisticConfirmation"), literal3("root")]),
  slot: number32(),
  timestamp: number32()
}), type3({
  type: literal3("createdBank"),
  parent: number32(),
  slot: number32(),
  timestamp: number32()
}), type3({
  type: literal3("frozen"),
  slot: number32(),
  timestamp: number32(),
  stats: type3({
    numTransactionEntries: number32(),
    numSuccessfulTransactions: number32(),
    numFailedTransactions: number32(),
    maxTransactionsPerEntry: number32()
  })
}), type3({
  type: literal3("dead"),
  slot: number32(),
  timestamp: number32(),
  err: string3()
})]);
var SlotUpdateNotificationResult22 = type3({
  subscription: number32(),
  result: SlotUpdateResult22
});
var SignatureNotificationResult22 = type3({
  subscription: number32(),
  result: notificationResultAndContext22(union3([SignatureStatusResult22, SignatureReceivedResult22]))
});
var RootNotificationResult22 = type3({
  subscription: number32(),
  result: number32()
});
var ContactInfoResult22 = type3({
  pubkey: string3(),
  gossip: nullable3(string3()),
  tpu: nullable3(string3()),
  rpc: nullable3(string3()),
  version: nullable3(string3())
});
var VoteAccountInfoResult22 = type3({
  votePubkey: string3(),
  nodePubkey: string3(),
  activatedStake: number32(),
  epochVoteAccount: boolean3(),
  epochCredits: array4(tuple22([number32(), number32(), number32()])),
  commission: number32(),
  lastVote: number32(),
  rootSlot: nullable3(number32())
});
var GetVoteAccounts22 = jsonRpcResult3(type3({
  current: array4(VoteAccountInfoResult22),
  delinquent: array4(VoteAccountInfoResult22)
}));
var ConfirmationStatus22 = union3([literal3("processed"), literal3("confirmed"), literal3("finalized")]);
var SignatureStatusResponse22 = type3({
  slot: number32(),
  confirmations: nullable3(number32()),
  err: TransactionErrorResult22,
  confirmationStatus: optional3(ConfirmationStatus22)
});
var GetSignatureStatusesRpcResult22 = jsonRpcResultAndContext3(array4(nullable3(SignatureStatusResponse22)));
var GetMinimumBalanceForRentExemptionRpcResult22 = jsonRpcResult3(number32());
var AddressTableLookupStruct22 = type3({
  accountKey: PublicKeyFromString22,
  writableIndexes: array4(number32()),
  readonlyIndexes: array4(number32())
});
var ConfirmedTransactionResult22 = type3({
  signatures: array4(string3()),
  message: type3({
    accountKeys: array4(string3()),
    header: type3({
      numRequiredSignatures: number32(),
      numReadonlySignedAccounts: number32(),
      numReadonlyUnsignedAccounts: number32()
    }),
    instructions: array4(type3({
      accounts: array4(number32()),
      data: string3(),
      programIdIndex: number32()
    })),
    recentBlockhash: string3(),
    addressTableLookups: optional3(array4(AddressTableLookupStruct22))
  })
});
var AnnotatedAccountKey22 = type3({
  pubkey: PublicKeyFromString22,
  signer: boolean3(),
  writable: boolean3(),
  source: optional3(union3([literal3("transaction"), literal3("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult22 = type3({
  accountKeys: array4(AnnotatedAccountKey22),
  signatures: array4(string3())
});
var ParsedInstructionResult22 = type3({
  parsed: unknown3(),
  program: string3(),
  programId: PublicKeyFromString22
});
var RawInstructionResult22 = type3({
  accounts: array4(PublicKeyFromString22),
  data: string3(),
  programId: PublicKeyFromString22
});
var InstructionResult22 = union3([RawInstructionResult22, ParsedInstructionResult22]);
var UnknownInstructionResult22 = union3([type3({
  parsed: unknown3(),
  program: string3(),
  programId: string3()
}), type3({
  accounts: array4(string3()),
  data: string3(),
  programId: string3()
})]);
var ParsedOrRawInstruction22 = coerce3(InstructionResult22, UnknownInstructionResult22, (value) => {
  if ("accounts" in value) {
    return create32(value, RawInstructionResult22);
  } else {
    return create32(value, ParsedInstructionResult22);
  }
});
var ParsedConfirmedTransactionResult22 = type3({
  signatures: array4(string3()),
  message: type3({
    accountKeys: array4(AnnotatedAccountKey22),
    instructions: array4(ParsedOrRawInstruction22),
    recentBlockhash: string3(),
    addressTableLookups: optional3(nullable3(array4(AddressTableLookupStruct22)))
  })
});
var TokenBalanceResult22 = type3({
  accountIndex: number32(),
  mint: string3(),
  owner: optional3(string3()),
  programId: optional3(string3()),
  uiTokenAmount: TokenAmountResult22
});
var LoadedAddressesResult22 = type3({
  writable: array4(PublicKeyFromString22),
  readonly: array4(PublicKeyFromString22)
});
var ConfirmedTransactionMetaResult22 = type3({
  err: TransactionErrorResult22,
  fee: number32(),
  innerInstructions: optional3(nullable3(array4(type3({
    index: number32(),
    instructions: array4(type3({
      accounts: array4(number32()),
      data: string3(),
      programIdIndex: number32()
    }))
  })))),
  preBalances: array4(number32()),
  postBalances: array4(number32()),
  logMessages: optional3(nullable3(array4(string3()))),
  preTokenBalances: optional3(nullable3(array4(TokenBalanceResult22))),
  postTokenBalances: optional3(nullable3(array4(TokenBalanceResult22))),
  loadedAddresses: optional3(LoadedAddressesResult22),
  computeUnitsConsumed: optional3(number32())
});
var ParsedConfirmedTransactionMetaResult22 = type3({
  err: TransactionErrorResult22,
  fee: number32(),
  innerInstructions: optional3(nullable3(array4(type3({
    index: number32(),
    instructions: array4(ParsedOrRawInstruction22)
  })))),
  preBalances: array4(number32()),
  postBalances: array4(number32()),
  logMessages: optional3(nullable3(array4(string3()))),
  preTokenBalances: optional3(nullable3(array4(TokenBalanceResult22))),
  postTokenBalances: optional3(nullable3(array4(TokenBalanceResult22))),
  loadedAddresses: optional3(LoadedAddressesResult22),
  computeUnitsConsumed: optional3(number32())
});
var TransactionVersionStruct22 = union3([literal3(0), literal3("legacy")]);
var RewardsResult22 = type3({
  pubkey: string3(),
  lamports: number32(),
  postBalance: nullable3(number32()),
  rewardType: nullable3(string3()),
  commission: optional3(nullable3(number32()))
});
var GetBlockRpcResult22 = jsonRpcResult3(nullable3(type3({
  blockhash: string3(),
  previousBlockhash: string3(),
  parentSlot: number32(),
  transactions: array4(type3({
    transaction: ConfirmedTransactionResult22,
    meta: nullable3(ConfirmedTransactionMetaResult22),
    version: optional3(TransactionVersionStruct22)
  })),
  rewards: optional3(array4(RewardsResult22)),
  blockTime: nullable3(number32()),
  blockHeight: nullable3(number32())
})));
var GetNoneModeBlockRpcResult22 = jsonRpcResult3(nullable3(type3({
  blockhash: string3(),
  previousBlockhash: string3(),
  parentSlot: number32(),
  rewards: optional3(array4(RewardsResult22)),
  blockTime: nullable3(number32()),
  blockHeight: nullable3(number32())
})));
var GetAccountsModeBlockRpcResult22 = jsonRpcResult3(nullable3(type3({
  blockhash: string3(),
  previousBlockhash: string3(),
  parentSlot: number32(),
  transactions: array4(type3({
    transaction: ConfirmedTransactionAccountsModeResult22,
    meta: nullable3(ConfirmedTransactionMetaResult22),
    version: optional3(TransactionVersionStruct22)
  })),
  rewards: optional3(array4(RewardsResult22)),
  blockTime: nullable3(number32()),
  blockHeight: nullable3(number32())
})));
var GetParsedBlockRpcResult22 = jsonRpcResult3(nullable3(type3({
  blockhash: string3(),
  previousBlockhash: string3(),
  parentSlot: number32(),
  transactions: array4(type3({
    transaction: ParsedConfirmedTransactionResult22,
    meta: nullable3(ParsedConfirmedTransactionMetaResult22),
    version: optional3(TransactionVersionStruct22)
  })),
  rewards: optional3(array4(RewardsResult22)),
  blockTime: nullable3(number32()),
  blockHeight: nullable3(number32())
})));
var GetParsedAccountsModeBlockRpcResult22 = jsonRpcResult3(nullable3(type3({
  blockhash: string3(),
  previousBlockhash: string3(),
  parentSlot: number32(),
  transactions: array4(type3({
    transaction: ConfirmedTransactionAccountsModeResult22,
    meta: nullable3(ParsedConfirmedTransactionMetaResult22),
    version: optional3(TransactionVersionStruct22)
  })),
  rewards: optional3(array4(RewardsResult22)),
  blockTime: nullable3(number32()),
  blockHeight: nullable3(number32())
})));
var GetParsedNoneModeBlockRpcResult22 = jsonRpcResult3(nullable3(type3({
  blockhash: string3(),
  previousBlockhash: string3(),
  parentSlot: number32(),
  rewards: optional3(array4(RewardsResult22)),
  blockTime: nullable3(number32()),
  blockHeight: nullable3(number32())
})));
var GetConfirmedBlockRpcResult22 = jsonRpcResult3(nullable3(type3({
  blockhash: string3(),
  previousBlockhash: string3(),
  parentSlot: number32(),
  transactions: array4(type3({
    transaction: ConfirmedTransactionResult22,
    meta: nullable3(ConfirmedTransactionMetaResult22)
  })),
  rewards: optional3(array4(RewardsResult22)),
  blockTime: nullable3(number32())
})));
var GetBlockSignaturesRpcResult22 = jsonRpcResult3(nullable3(type3({
  blockhash: string3(),
  previousBlockhash: string3(),
  parentSlot: number32(),
  signatures: array4(string3()),
  blockTime: nullable3(number32())
})));
var GetTransactionRpcResult22 = jsonRpcResult3(nullable3(type3({
  slot: number32(),
  meta: nullable3(ConfirmedTransactionMetaResult22),
  blockTime: optional3(nullable3(number32())),
  transaction: ConfirmedTransactionResult22,
  version: optional3(TransactionVersionStruct22)
})));
var GetParsedTransactionRpcResult22 = jsonRpcResult3(nullable3(type3({
  slot: number32(),
  transaction: ParsedConfirmedTransactionResult22,
  meta: nullable3(ParsedConfirmedTransactionMetaResult22),
  blockTime: optional3(nullable3(number32())),
  version: optional3(TransactionVersionStruct22)
})));
var GetLatestBlockhashRpcResult22 = jsonRpcResultAndContext3(type3({
  blockhash: string3(),
  lastValidBlockHeight: number32()
}));
var IsBlockhashValidRpcResult22 = jsonRpcResultAndContext3(boolean3());
var PerfSampleResult22 = type3({
  slot: number32(),
  numTransactions: number32(),
  numSlots: number32(),
  samplePeriodSecs: number32()
});
var GetRecentPerformanceSamplesRpcResult22 = jsonRpcResult3(array4(PerfSampleResult22));
var GetFeeCalculatorRpcResult22 = jsonRpcResultAndContext3(nullable3(type3({
  feeCalculator: type3({
    lamportsPerSignature: number32()
  })
})));
var RequestAirdropRpcResult22 = jsonRpcResult3(string3());
var SendTransactionRpcResult22 = jsonRpcResult3(string3());
var LogsResult22 = type3({
  err: TransactionErrorResult22,
  logs: array4(string3()),
  signature: string3()
});
var LogsNotificationResult22 = type3({
  result: notificationResultAndContext22(LogsResult22),
  subscription: number32()
});

class Keypair22 {
  constructor(keypair) {
    this._keypair = undefined;
    this._keypair = keypair ?? generateKeypair22();
  }
  static generate() {
    return new Keypair22(generateKeypair22());
  }
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey5 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey22(privateScalar);
      for (let ii = 0;ii < 32; ii++) {
        if (publicKey5[ii] !== computedPublicKey[ii]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new Keypair22({
      publicKey: publicKey5,
      secretKey
    });
  }
  static fromSeed(seed2) {
    const publicKey5 = getPublicKey22(seed2);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed2);
    secretKey.set(publicKey5, 32);
    return new Keypair22({
      publicKey: publicKey5,
      secretKey
    });
  }
  get publicKey() {
    return new PublicKey22(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS22 = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), u645("recentSlot"), BufferLayout22.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), u645(), BufferLayout22.seq(publicKey4(), BufferLayout22.offset(BufferLayout22.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  }
});

class AddressLookupTableProgram22 {
  constructor() {}
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey22.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder2().encode(params.recentSlot)], this.programId);
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS22.CreateLookupTable;
    const data = encodeData22(type4, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram22.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction22({
      programId: this.programId,
      keys,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS22.FreezeLookupTable;
    const data = encodeData22(type4);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction22({
      programId: this.programId,
      keys,
      data
    });
  }
  static extendLookupTable(params) {
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS22.ExtendLookupTable;
    const data = encodeData22(type4, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram22.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction22({
      programId: this.programId,
      keys,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS22.DeactivateLookupTable;
    const data = encodeData22(type4);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction22({
      programId: this.programId,
      keys,
      data
    });
  }
  static closeLookupTable(params) {
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS22.CloseLookupTable;
    const data = encodeData22(type4);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction22({
      programId: this.programId,
      keys,
      data
    });
  }
}
AddressLookupTableProgram22.programId = new PublicKey22("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS22 = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout22.struct([BufferLayout22.u8("instruction"), BufferLayout22.u32("units"), BufferLayout22.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout22.struct([BufferLayout22.u8("instruction"), BufferLayout22.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout22.struct([BufferLayout22.u8("instruction"), BufferLayout22.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout22.struct([BufferLayout22.u8("instruction"), u645("microLamports")])
  }
});

class ComputeBudgetProgram22 {
  constructor() {}
  static requestUnits(params) {
    const type4 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS22.RequestUnits;
    const data = encodeData22(type4, params);
    return new TransactionInstruction22({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type4 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS22.RequestHeapFrame;
    const data = encodeData22(type4, params);
    return new TransactionInstruction22({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type4 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS22.SetComputeUnitLimit;
    const data = encodeData22(type4, params);
    return new TransactionInstruction22({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type4 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS22.SetComputeUnitPrice;
    const data = encodeData22(type4, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction22({
      keys: [],
      programId: this.programId,
      data
    });
  }
}
ComputeBudgetProgram22.programId = new PublicKey22("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$122 = 64;
var PUBLIC_KEY_BYTES$122 = 32;
var SIGNATURE_BYTES22 = 64;
var ED25519_INSTRUCTION_LAYOUT22 = BufferLayout22.struct([BufferLayout22.u8("numSignatures"), BufferLayout22.u8("padding"), BufferLayout22.u16("signatureOffset"), BufferLayout22.u16("signatureInstructionIndex"), BufferLayout22.u16("publicKeyOffset"), BufferLayout22.u16("publicKeyInstructionIndex"), BufferLayout22.u16("messageDataOffset"), BufferLayout22.u16("messageDataSize"), BufferLayout22.u16("messageInstructionIndex")]);

class Ed25519Program22 {
  constructor() {}
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature,
      instructionIndex
    } = params;
    assert52(publicKey5.length === PUBLIC_KEY_BYTES$122, `Public Key must be ${PUBLIC_KEY_BYTES$122} bytes but received ${publicKey5.length} bytes`);
    assert52(signature.length === SIGNATURE_BYTES22, `Signature must be ${SIGNATURE_BYTES22} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT22.span;
    const signatureOffset = publicKeyOffset + publicKey5.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = export_Buffer.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT22.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey5, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction22({
      keys: [],
      programId: Ed25519Program22.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert52(privateKey.length === PRIVATE_KEY_BYTES$122, `Private key must be ${PRIVATE_KEY_BYTES$122} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair22.fromSecretKey(privateKey);
      const publicKey5 = keypair.publicKey.toBytes();
      const signature = sign22(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Ed25519Program22.programId = new PublicKey22("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign22 = (msgHash, privKey) => {
  const signature = secp256k13.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
secp256k13.utils.isValidPrivateKey;
var publicKeyCreate22 = secp256k13.getPublicKey;
var PRIVATE_KEY_BYTES22 = 32;
var ETHEREUM_ADDRESS_BYTES22 = 20;
var PUBLIC_KEY_BYTES22 = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE22 = 11;
var SECP256K1_INSTRUCTION_LAYOUT22 = BufferLayout22.struct([BufferLayout22.u8("numSignatures"), BufferLayout22.u16("signatureOffset"), BufferLayout22.u8("signatureInstructionIndex"), BufferLayout22.u16("ethAddressOffset"), BufferLayout22.u8("ethAddressInstructionIndex"), BufferLayout22.u16("messageDataOffset"), BufferLayout22.u16("messageDataSize"), BufferLayout22.u8("messageInstructionIndex"), BufferLayout22.blob(20, "ethAddress"), BufferLayout22.blob(64, "signature"), BufferLayout22.u8("recoveryId")]);

class Secp256k1Program22 {
  constructor() {}
  static publicKeyToEthAddress(publicKey5) {
    assert52(publicKey5.length === PUBLIC_KEY_BYTES22, `Public key must be ${PUBLIC_KEY_BYTES22} bytes but received ${publicKey5.length} bytes`);
    try {
      return export_Buffer.from(keccak_2563(toBuffer22(publicKey5))).slice(-ETHEREUM_ADDRESS_BYTES22);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey5,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program22.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program22.publicKeyToEthAddress(publicKey5),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = export_Buffer.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = export_Buffer.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert52(ethAddress.length === ETHEREUM_ADDRESS_BYTES22, `Address must be ${ETHEREUM_ADDRESS_BYTES22} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE22;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = export_Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT22.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT22.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer22(signature),
      ethAddress: toBuffer22(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer22(message), SECP256K1_INSTRUCTION_LAYOUT22.span);
    return new TransactionInstruction22({
      keys: [],
      programId: Secp256k1Program22.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert52(pkey.length === PRIVATE_KEY_BYTES22, `Private key must be ${PRIVATE_KEY_BYTES22} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer22(pkey);
      const publicKey5 = publicKeyCreate22(privateKey, false).slice(1);
      const messageHash = export_Buffer.from(keccak_2563(toBuffer22(message)));
      const [signature, recoveryId] = ecdsaSign22(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey5,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Secp256k1Program22.programId = new PublicKey22("KeccakSecp256k11111111111111111111111111111");
var _Lockup22;
var STAKE_CONFIG_ID22 = new PublicKey22("StakeConfig11111111111111111111111111111111");

class Lockup22 {
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = undefined;
    this.epoch = undefined;
    this.custodian = undefined;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
}
_Lockup22 = Lockup22;
Lockup22.default = new _Lockup22(0, 0, PublicKey22.default);
var STAKE_INSTRUCTION_LAYOUTS22 = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), authorized22(), lockup22()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("newAuthorized"), BufferLayout22.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), BufferLayout22.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), BufferLayout22.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("newAuthorized"), BufferLayout22.u32("stakeAuthorizationType"), rustString22("authoritySeed"), publicKey4("authorityOwner")])
  }
});
var StakeAuthorizationLayout22 = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class StakeProgram22 {
  constructor() {}
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized3,
      lockup: maybeLockup
    } = params;
    const lockup3 = maybeLockup || Lockup22.default;
    const type4 = STAKE_INSTRUCTION_LAYOUTS22.Initialize;
    const data = encodeData22(type4, {
      authorized: {
        staker: toBuffer22(authorized3.staker.toBuffer()),
        withdrawer: toBuffer22(authorized3.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup3.unixTimestamp,
        epoch: lockup3.epoch,
        custodian: toBuffer22(lockup3.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY22,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction22(instructionData);
  }
  static createAccountWithSeed(params) {
    const transaction = new Transaction22;
    transaction.add(SystemProgram22.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized3,
      lockup: lockup3
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized3,
      lockup: lockup3
    }));
  }
  static createAccount(params) {
    const transaction = new Transaction22;
    transaction.add(SystemProgram22.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized3,
      lockup: lockup3
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized3,
      lockup: lockup3
    }));
  }
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS22.Delegate;
    const data = encodeData22(type4);
    return new Transaction22().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS22.Authorize;
    const data = encodeData22(type4, {
      newAuthorized: toBuffer22(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY22,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction22().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS22.AuthorizeWithSeed;
    const data = encodeData22(type4, {
      newAuthorized: toBuffer22(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer22(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY22,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction22().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS22.Split;
    const data = encodeData22(type4, {
      lamports
    });
    return new TransactionInstruction22({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static split(params, rentExemptReserve) {
    const transaction = new Transaction22;
    transaction.add(SystemProgram22.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed: seed2,
      lamports
    } = params;
    const transaction = new Transaction22;
    transaction.add(SystemProgram22.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed: seed2,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram22.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS22.Merge;
    const data = encodeData22(type4);
    return new Transaction22().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS22.Withdraw;
    const data = encodeData22(type4, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY22,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY22,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction22().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS22.Deactivate;
    const data = encodeData22(type4);
    return new Transaction22().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
}
StakeProgram22.programId = new PublicKey22("Stake11111111111111111111111111111111111111");
StakeProgram22.space = 200;
var VOTE_INSTRUCTION_LAYOUTS22 = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), voteInit22()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), publicKey4("newAuthorized"), BufferLayout22.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), BufferLayout22.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout22.struct([BufferLayout22.u32("instruction"), voteAuthorizeWithSeedArgs22()])
  }
});
var VoteAuthorizationLayout22 = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class VoteProgram22 {
  constructor() {}
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit3
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS22.InitializeAccount;
    const data = encodeData22(type4, {
      voteInit: {
        nodePubkey: toBuffer22(voteInit3.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer22(voteInit3.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer22(voteInit3.authorizedWithdrawer.toBuffer()),
        commission: voteInit3.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY22,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction22(instructionData);
  }
  static createAccount(params) {
    const transaction = new Transaction22;
    transaction.add(SystemProgram22.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS22.Authorize;
    const data = encodeData22(type4, {
      newAuthorized: toBuffer22(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY22,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction22().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS22.AuthorizeWithSeed;
    const data = encodeData22(type4, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer22(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer22(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY22,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction22().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS22.Withdraw;
    const data = encodeData22(type4, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction22().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return VoteProgram22.withdraw(params);
  }
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS22.UpdateValidatorIdentity;
    const data = encodeData22(type4);
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction22().add({
      keys,
      programId: this.programId,
      data
    });
  }
}
VoteProgram22.programId = new PublicKey22("Vote111111111111111111111111111111111111111");
VoteProgram22.space = 3762;
var VALIDATOR_INFO_KEY22 = new PublicKey22("Va1idator1nfo111111111111111111111111111111");
var InfoString22 = type3({
  name: string3(),
  website: optional3(string3()),
  details: optional3(string3()),
  iconUrl: optional3(string3()),
  keybaseUsername: optional3(string3())
});
var VOTE_PROGRAM_ID22 = new PublicKey22("Vote111111111111111111111111111111111111111");
var VoteAccountLayout22 = BufferLayout22.struct([
  publicKey4("nodePubkey"),
  publicKey4("authorizedWithdrawer"),
  BufferLayout22.u8("commission"),
  BufferLayout22.nu64(),
  BufferLayout22.seq(BufferLayout22.struct([BufferLayout22.nu64("slot"), BufferLayout22.u32("confirmationCount")]), BufferLayout22.offset(BufferLayout22.u32(), -8), "votes"),
  BufferLayout22.u8("rootSlotValid"),
  BufferLayout22.nu64("rootSlot"),
  BufferLayout22.nu64(),
  BufferLayout22.seq(BufferLayout22.struct([BufferLayout22.nu64("epoch"), publicKey4("authorizedVoter")]), BufferLayout22.offset(BufferLayout22.u32(), -8), "authorizedVoters"),
  BufferLayout22.struct([BufferLayout22.seq(BufferLayout22.struct([publicKey4("authorizedPubkey"), BufferLayout22.nu64("epochOfLastAuthorizedSwitch"), BufferLayout22.nu64("targetEpoch")]), 32, "buf"), BufferLayout22.nu64("idx"), BufferLayout22.u8("isEmpty")], "priorVoters"),
  BufferLayout22.nu64(),
  BufferLayout22.seq(BufferLayout22.struct([BufferLayout22.nu64("epoch"), BufferLayout22.nu64("credits"), BufferLayout22.nu64("prevCredits")]), BufferLayout22.offset(BufferLayout22.u32(), -8), "epochCredits"),
  BufferLayout22.struct([BufferLayout22.nu64("slot"), BufferLayout22.nu64("timestamp")], "lastTimestamp")
]);
var publicKey5 = (property) => {
  const layout = import_buffer_layout5.blob(32, property);
  const { encode: encode2, decode: decode3 } = encodeDecode(layout);
  const publicKeyLayout = layout;
  publicKeyLayout.decode = (buffer, offset4) => {
    const src = decode3(buffer, offset4);
    return new PublicKey22(src);
  };
  publicKeyLayout.encode = (publicKey6, buffer, offset4) => {
    const src = publicKey6.toBuffer();
    return encode2(src, buffer, offset4);
  };
  return publicKeyLayout;
};

class TokenError extends Error {
  constructor(message) {
    super(message);
  }
}

class TokenOwnerOffCurveError extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenOwnerOffCurveError";
  }
}
var import_buffer_layout6 = __toESM2(require_Layout2(), 1);
var MintLayout = import_buffer_layout6.struct([
  import_buffer_layout6.u32("mintAuthorityOption"),
  publicKey5("mintAuthority"),
  u644("supply"),
  import_buffer_layout6.u8("decimals"),
  bool2("isInitialized"),
  import_buffer_layout6.u32("freezeAuthorityOption"),
  publicKey5("freezeAuthority")
]);
var MINT_SIZE = MintLayout.span;
function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID2, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  if (!allowOwnerOffCurve && !PublicKey2.isOnCurve(owner.toBuffer()))
    throw new TokenOwnerOffCurveError;
  const [address] = PublicKey2.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
  return address;
}
function createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID2, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);
}
function createAssociatedTokenAccountIdempotentInstructionWithDerivation(payer, owner, mint, allowOwnerOffCurve = true, programId = TOKEN_PROGRAM_ID2, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve);
  return createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId, associatedTokenProgramId);
}
function buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = TOKEN_PROGRAM_ID2, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedToken, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: SystemProgram2.programId, isSigner: false, isWritable: false },
    { pubkey: programId, isSigner: false, isWritable: false }
  ];
  return new TransactionInstruction2({
    keys,
    programId: associatedTokenProgramId,
    data: instructionData
  });
}
function assert62(predicate, message) {
  if (!predicate) {
    throw new Error(`bug in @n1xyz/proton, please report! message: ${message}`);
  }
}
function assertHasOwn(x2, k) {
  assert62(Object.hasOwn(x2, k), `expected ${String(k)} to be defined on ${x2}`);
}
function assertInstanceOf(x2, cls) {
  assert62(x2 instanceof cls, `expected ${x2} to be an instance of ${cls.name}`);
}
var import_camelcase2 = __toESM2(require_camelcase(), 1);
init_buffer2();
var borsh2 = __toESM2(require_dist2(), 1);
var IDL_ACCOUNT_LAYOUT2 = borsh2.struct([
  borsh2.publicKey("authority"),
  borsh2.vecU8("data")
]);
function convertIdlToCamelCase2(idl) {
  const KEYS_TO_CONVERT = ["name", "path", "account", "relations", "generic"];
  const toCamelCase = (s) => s.split(".").map(import_camelcase2.default).join(".");
  const recursivelyConvertNamesToCamelCase = (obj) => {
    for (const key in obj) {
      const val = obj[key];
      if (KEYS_TO_CONVERT.includes(key)) {
        obj[key] = Array.isArray(val) ? val.map(toCamelCase) : toCamelCase(val);
      } else if (typeof val === "object") {
        recursivelyConvertNamesToCamelCase(val);
      }
    }
  };
  const camelCasedIdl = structuredClone(idl);
  recursivelyConvertNamesToCamelCase(camelCasedIdl);
  return camelCasedIdl;
}
init_buffer2();
var GLOBAL_SEED = export_Buffer.from("global");
var EVENT_SEED = export_Buffer.from("queued_event");
var CHILD_BLOCKS_STORAGE_SEED = export_Buffer.from("child_blocks");
var EFFECT_NULLIFIER_SEED = export_Buffer.from("effect_nullifier");
var CHALLENGE_NULLIFIER_SEED = export_Buffer.from("challenge_nullifier");
var ASSET_CONFIG_SEED = export_Buffer.from("asset_config");
var TOKEN_AUTHORITY_SEED = export_Buffer.from("token_authority");
var CRUMB_AUTHORITY_SEED = export_Buffer.from("crumb_authority");
var WITHDRAWAL_LIMITER_SEED = export_Buffer.from("withdrawal_limiter");
var ACL_SEED = export_Buffer.from("acl");
function createAnchorProgram(programId, provider) {
  return new Program({ ...bridge_idl_default, address: programId.toString() }, provider);
}
function discriminator(name) {
  const coder = new BorshAccountsCoder(convertIdlToCamelCase2(bridge_idl_default));
  const disc = coder.accountDiscriminator(name);
  assert62(disc.length === 8, `account discriminator ${disc.toHex} for ${name} is not 8 bytes`);
  return disc;
}
function decode3(name, data) {
  const program = createAnchorProgram(PublicKey2.default, {});
  const buffer = export_Buffer.from(data);
  return program.coder.accounts.decode(name, buffer);
}
async function depositIx({
  programId,
  app,
  quantAmount,
  recipient,
  payer,
  sourceTokenAccount,
  mint,
  tokenProgramId
}) {
  const buffer = Keypair2.generate();
  const [tokenAuthority] = PublicKey2.findProgramAddressSync([TOKEN_AUTHORITY_SEED, app.toBytes()], programId);
  const [assetConfig] = PublicKey2.findProgramAddressSync([ASSET_CONFIG_SEED, app.toBytes(), mint.toBytes()], programId);
  const tokenAccount = getAssociatedTokenAddressSync(mint, tokenAuthority, true, tokenProgramId);
  const ix = await createAnchorProgram(programId, {}).methods.depositCreate(recipient, new import_bn3.default(quantAmount.toString(16), 16)).accounts({
    payer,
    app,
    event: buffer.publicKey,
    fromAccount: sourceTokenAccount,
    program: programId,
    tokenProgram: tokenProgramId,
    ...{
      assetConfig,
      tokenAccount
    }
  }).instruction();
  return { ix, extraSigner: buffer };
}

class ProtonClient {
  programId;
  app;
  client;
  conn;
  anchor;
  mintInfo = new Map;
  constructor({
    client,
    config: config2,
    programVk,
    solConn: connection
  }) {
    this.client = client;
    this.app = new PublicKey2(config2.app);
    this.programId = programVk;
    this.conn = connection;
    this.anchor = createAnchorProgram(programVk, { connection });
  }
  static async init({
    protonUrl,
    app,
    solConn
  }) {
    const client = createClient({ baseUrl: protonUrl });
    let [config2, appAcc, genesisHash] = await Promise.all([
      client.GET("/proton/v0/config", {}),
      solConn.getAccountInfo(app, "finalized"),
      solConn.getGenesisHash()
    ]);
    if (!config2.data) {
      throw new Error(`failed to fetch indexer info: ${config2.error}`);
    }
    if (config2.data.app !== app.toString()) {
      throw new Error(`app mismatch: server reports ${config2.data.app}, but expected ${app.toString()}; check the url and app parameters`);
    }
    if (genesisHash !== config2.data.chainGenesis) {
      throw new Error(`genesis hash mismatch: server reports ${genesisHash.toString()}, but expected ${config2.data.chainGenesis.toString()}; check the chain for your rpc!`);
    }
    if (appAcc === null) {
      throw new Error(`app account ${app.toString()} not found; this is our fault, please report`);
    }
    try {
      decode3("app", appAcc.data);
    } catch (e) {
      throw new Error(`failed to decode app account at ${app}: ${e}; ensure your versions match up`);
    }
    const proton = new ProtonClient({
      config: config2.data,
      client,
      programVk: appAcc.owner,
      solConn
    });
    for (const mint of config2.data.mints) {
      proton.mintInfo.set(mint.mint, {
        minDeposit: BigInt(mint.minDeposit),
        tokenProgramId: new PublicKey2(mint.tokenProgram),
        withdrawalRateLimit: {
          ratePerSlot: BigInt(mint.withdrawalRateLimit.ratePerSlot),
          maxBurst: BigInt(mint.withdrawalRateLimit.maxBurst)
        }
      });
    }
    return proton;
  }
  async config() {
    const response = await this.client.GET("/proton/v0/config", {});
    return response.data;
  }
  async blocksByRange({ start, end }) {
    const response = await this.client.GET("/proton/v0/blocks/by-range", {
      params: {
        query: {
          start,
          end
        }
      }
    });
    return response.data;
  }
  async blocksByActionId(actionId) {
    const response = await this.client.GET("/proton/v0/blocks/by-action-id/{action_id}", {
      params: {
        path: {
          action_id: actionId
        }
      }
    });
    return response.data;
  }
  async withdrawalsForUser(pubkey, params) {
    const response = await this.client.GET("/proton/v0/withdrawals/by-user/{pubkey}", {
      params: {
        path: {
          pubkey: pubkey.toString()
        },
        query: {
          order: "desc",
          status: "all",
          ...params
        }
      }
    });
    return response.data;
  }
  async withdrawalForActionId(actionId) {
    const response = await this.client.GET("/proton/v0/withdrawals/by-action-id/{action_id}", {
      params: {
        path: {
          action_id: actionId
        }
      }
    });
    return response.data;
  }
  async depositsForRecipient(recipient, {
    startSlot,
    order
  }) {
    const response = await this.client.GET("/proton/v0/deposits/by-recipient/{pubkey}", {
      params: {
        path: {
          pubkey: recipient.toString()
        },
        query: {
          order,
          status: "all",
          slot: startSlot
        }
      }
    });
    return response.data;
  }
  async fetchApp() {
    const data = await this.anchor.account.app.fetchNullable(this.app);
    assert62(data !== null, `app account ${this.app} is null`);
    return data;
  }
  async fetchRateLimiterCapacity({
    mint
  }) {
    let mintInfo = this.mintInfo.get(mint.toString());
    if (mintInfo === undefined)
      return null;
    let addr = PublicKey2.findProgramAddressSync([WITHDRAWAL_LIMITER_SEED, this.app.toBytes(), mint.toBytes()], this.programId)[0];
    let {
      data,
      context: { slot }
    } = await this.anchor.account.tokenBucket.fetchNullableAndContext(addr);
    assert62(data !== null, `rate limiter for ${mint} at ${addr} is null`);
    const { cfg: _, lastUpdate, tokens } = data;
    const maxBurst = mintInfo.withdrawalRateLimit.maxBurst;
    const totalTokens = BigInt(tokens.toString()) + mintInfo.withdrawalRateLimit.ratePerSlot * (BigInt(slot) - BigInt(lastUpdate.toString()));
    return maxBurst < totalTokens ? maxBurst : totalTokens;
  }
  async buildDepositIx({
    quantAmount,
    sourceTokenAccount,
    recipient,
    payer,
    mint
  }) {
    const mintInfo = this.mintInfo.get(mint.toString());
    if (mintInfo === undefined) {
      throw new Error(`mint ${mint.toString()} not found; invalid mint`);
    }
    if (quantAmount < mintInfo.minDeposit) {
      throw new Error(`amount ${quantAmount} is less than the minimum deposit of ${mintInfo.minDeposit} for mint ${mint.toString()}`);
    }
    return await depositIx({
      programId: this.programId,
      app: this.app,
      payer,
      sourceTokenAccount,
      quantAmount,
      recipient,
      mint,
      tokenProgramId: mintInfo.tokenProgramId
    });
  }
}
var exports_owner = {};
__export2(exports_owner, {
  whitelistAssetIx: () => whitelistAssetIx,
  setWithdrawalRateLimitIx: () => setWithdrawalRateLimitIx,
  setMinDepositIx: () => setMinDepositIx,
  fetchApp: () => fetchApp,
  denyAppVersionIx: () => denyAppVersionIx,
  appCreateApproveIx: () => appCreateApproveIx,
  allowAppVersionIx: () => allowAppVersionIx
});
function commitmentToHex(x2) {
  assertInstanceOf(x2, Object);
  assertHasOwn(x2, "0");
  assertInstanceOf(x2["0"], Array);
  return Buffer.from(x2["0"]).toString("hex");
}
async function fetchApp({
  app,
  conn
}) {
  const accInfo = await conn.getAccountInfo(app);
  if (accInfo === null)
    return null;
  if (accInfo.data.length < 8)
    throw new Error("account data too small, no discriminator");
  const discriminator2 = accInfo.data.subarray(0, 8);
  if (exports_bridge.discriminator("appConfig").equals(discriminator2)) {
    const appConfig = exports_bridge.decode("appConfig", accInfo.data);
    assertHasOwn(appConfig, "initialAppStateCommitment");
    return {
      status: "unapproved",
      value: {
        ...appConfig,
        initialAppStateCommitment: commitmentToHex(appConfig.initialAppStateCommitment)
      }
    };
  }
  if (exports_bridge.discriminator("app").equals(discriminator2)) {
    const app2 = exports_bridge.decode("app", accInfo.data);
    assertHasOwn(app2, "allowedAppVersions");
    assertHasOwn(app2, "finaStateFactsPrevCmtmt");
    assertHasOwn(app2, "finaStateFacts");
    return {
      status: "approved",
      value: {
        ...app2,
        allowedAppVersions: app2.allowedAppVersions.map(commitmentToHex),
        finaStateFactsPrevCmtmt: commitmentToHex(app2.finaStateFactsPrevCmtmt)
      }
    };
  }
  throw new Error(`unknown account discriminator: ${discriminator2.toHex()}`);
}
async function appCreateApproveIx({
  programId,
  app,
  appOwner
}) {
  return createAnchorProgram(programId, {}).methods.appCreateApprove().accounts({
    app,
    appOwner,
    program: programId
  }).instruction();
}
async function whitelistAssetIx({
  programId,
  app,
  appOwner,
  payer,
  mint,
  quantMinDeposit,
  limiterConfig: { quantMaxBurst, quantRatePerSlot }
}) {
  const [tokenAuthority, _] = PublicKey2.findProgramAddressSync([exports_bridge.TOKEN_AUTHORITY_SEED, app.toBuffer()], programId);
  return [
    await createAnchorProgram(programId, {}).methods.whitelistAsset(new import_bn3.default(quantMinDeposit.toString(16), 16), {
      maxBurst: new import_bn3.default(quantMaxBurst.toString(16), 16),
      ratePerSlot: new import_bn3.default(quantRatePerSlot.toString(16), 16)
    }).accounts({
      payer,
      app,
      appOwner,
      mint,
      program: programId
    }).instruction(),
    createAssociatedTokenAccountIdempotentInstructionWithDerivation(appOwner, tokenAuthority, mint, true)
  ];
}
async function allowAppVersionIx(x2) {
  return await allowAppVersionIx_({ ...x2, allow: true });
}
async function denyAppVersionIx(x2) {
  return await allowAppVersionIx_({ ...x2, allow: false });
}
async function allowAppVersionIx_({
  programId,
  app,
  appOwner,
  appVersion,
  allow
}) {
  if (appVersion.length !== 32) {
    throw new RangeError(`appVersion must have exactly 32 bytes; received ${appVersion.length}`);
  }
  return createAnchorProgram(programId, {}).methods.allowAppVersion(Array.from(appVersion), allow).accounts({
    app,
    appOwner,
    program: programId
  }).instruction();
}
async function setMinDepositIx({
  programId,
  app,
  appOwner,
  mint,
  quantMinDeposit
}) {
  return createAnchorProgram(programId, {}).methods.setMinDeposit(new import_bn3.default(quantMinDeposit.toString(16), 16)).accounts({
    app,
    appOwner,
    mint,
    program: programId
  }).instruction();
}
async function setWithdrawalRateLimitIx({
  programId,
  app,
  appOwner,
  mint,
  limiterConfig: { quantMaxBurst, quantRatePerSlot }
}) {
  return createAnchorProgram(programId, {}).methods.setWithdrawalRateLimit({
    maxBurst: new import_bn3.default(quantMaxBurst.toString(16), 16),
    ratePerSlot: new import_bn3.default(quantRatePerSlot.toString(16), 16)
  }).accounts({
    app,
    appOwner,
    mint,
    program: programId
  }).instruction();
}
function floatToScaledBigIntLossy(amount, decimals) {
  if (!Number.isFinite(amount) || Number.isNaN(amount)) {
    throw new RangeError(`amount ${amount} is not a finite number`);
  }
  if (!Number.isInteger(decimals) || decimals < 0) {
    throw new RangeError(`decimals ${decimals} is not a positive integer`);
  }
  if (Number.isInteger(amount)) {
    return BigInt(amount) * 10n ** BigInt(decimals);
  }
  const sgn = amount >= 0 ? 1n : -1n;
  const amt = Math.abs(amount).toString();
  let [mant, exp_] = amt.split("e");
  assert62(mant !== undefined, `mantissa should be defined; inputs were (${amount}, ${decimals})`);
  let exp2 = exp_ ? parseInt(exp_) : 0;
  const dot = mant.indexOf(".");
  if (dot !== -1) {
    exp2 -= mant.length - dot - 1;
    mant = mant.replace(".", "");
  }
  exp2 += decimals;
  if (exp2 >= 0) {
    return sgn * BigInt(mant + "0".repeat(exp2));
  } else {
    if (mant.length <= -exp2) {
      return sgn * BigInt(0);
    } else {
      return sgn * BigInt(mant.slice(0, mant.length + exp2));
    }
  }
}

// node_modules/openapi-fetch/dist/index.mjs
var PATH_PARAM_RE2 = /\{[^{}]+\}/g;
var supportsRequestInitExt2 = () => {
  return typeof process === "object" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;
};
function randomID2() {
  return Math.random().toString(36).slice(2, 11);
}
function createClient2(clientOptions) {
  let {
    baseUrl = "",
    Request: CustomRequest = globalThis.Request,
    fetch: baseFetch = globalThis.fetch,
    querySerializer: globalQuerySerializer,
    bodySerializer: globalBodySerializer,
    headers: baseHeaders,
    requestInitExt = undefined,
    ...baseOptions
  } = { ...clientOptions };
  requestInitExt = supportsRequestInitExt2() ? requestInitExt : undefined;
  baseUrl = removeTrailingSlash2(baseUrl);
  const middlewares = [];
  async function coreFetch(schemaPath, fetchOptions) {
    const {
      baseUrl: localBaseUrl,
      fetch: fetch4 = baseFetch,
      Request = CustomRequest,
      headers,
      params = {},
      parseAs = "json",
      querySerializer: requestQuerySerializer,
      bodySerializer = globalBodySerializer ?? defaultBodySerializer2,
      body,
      ...init2
    } = fetchOptions || {};
    let finalBaseUrl = baseUrl;
    if (localBaseUrl) {
      finalBaseUrl = removeTrailingSlash2(localBaseUrl) ?? baseUrl;
    }
    let querySerializer = typeof globalQuerySerializer === "function" ? globalQuerySerializer : createQuerySerializer2(globalQuerySerializer);
    if (requestQuerySerializer) {
      querySerializer = typeof requestQuerySerializer === "function" ? requestQuerySerializer : createQuerySerializer2({
        ...typeof globalQuerySerializer === "object" ? globalQuerySerializer : {},
        ...requestQuerySerializer
      });
    }
    const serializedBody = body === undefined ? undefined : bodySerializer(body, mergeHeaders2(baseHeaders, headers, params.header));
    const finalHeaders = mergeHeaders2(serializedBody === undefined || serializedBody instanceof FormData ? {} : {
      "Content-Type": "application/json"
    }, baseHeaders, headers, params.header);
    const requestInit = {
      redirect: "follow",
      ...baseOptions,
      ...init2,
      body: serializedBody,
      headers: finalHeaders
    };
    let id2;
    let options;
    let request = new CustomRequest(createFinalURL2(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }), requestInit);
    let response;
    for (const key in init2) {
      if (!(key in request)) {
        request[key] = init2[key];
      }
    }
    if (middlewares.length) {
      id2 = randomID2();
      options = Object.freeze({
        baseUrl: finalBaseUrl,
        fetch: fetch4,
        parseAs,
        querySerializer,
        bodySerializer
      });
      for (const m of middlewares) {
        if (m && typeof m === "object" && typeof m.onRequest === "function") {
          const result = await m.onRequest({
            request,
            schemaPath,
            params,
            options,
            id: id2
          });
          if (result) {
            if (result instanceof CustomRequest) {
              request = result;
            } else if (result instanceof Response) {
              response = result;
              break;
            } else {
              throw new Error("onRequest: must return new Request() or Response() when modifying the request");
            }
          }
        }
      }
    }
    if (!response) {
      try {
        response = await fetch4(request, requestInitExt);
      } catch (error2) {
        let errorAfterMiddleware = error2;
        if (middlewares.length) {
          for (let i4 = middlewares.length - 1;i4 >= 0; i4--) {
            const m = middlewares[i4];
            if (m && typeof m === "object" && typeof m.onError === "function") {
              const result = await m.onError({
                request,
                error: errorAfterMiddleware,
                schemaPath,
                params,
                options,
                id: id2
              });
              if (result) {
                if (result instanceof Response) {
                  errorAfterMiddleware = undefined;
                  response = result;
                  break;
                }
                if (result instanceof Error) {
                  errorAfterMiddleware = result;
                  continue;
                }
                throw new Error("onError: must return new Response() or instance of Error");
              }
            }
          }
        }
        if (errorAfterMiddleware) {
          throw errorAfterMiddleware;
        }
      }
      if (middlewares.length) {
        for (let i4 = middlewares.length - 1;i4 >= 0; i4--) {
          const m = middlewares[i4];
          if (m && typeof m === "object" && typeof m.onResponse === "function") {
            const result = await m.onResponse({
              request,
              response,
              schemaPath,
              params,
              options,
              id: id2
            });
            if (result) {
              if (!(result instanceof Response)) {
                throw new Error("onResponse: must return new Response() when modifying the response");
              }
              response = result;
            }
          }
        }
      }
    }
    if (response.status === 204 || request.method === "HEAD" || response.headers.get("Content-Length") === "0") {
      return response.ok ? { data: undefined, response } : { error: undefined, response };
    }
    if (response.ok) {
      if (parseAs === "stream") {
        return { data: response.body, response };
      }
      return { data: await response[parseAs](), response };
    }
    let error = await response.text();
    try {
      error = JSON.parse(error);
    } catch {}
    return { error, response };
  }
  return {
    request(method, url, init2) {
      return coreFetch(url, { ...init2, method: method.toUpperCase() });
    },
    GET(url, init2) {
      return coreFetch(url, { ...init2, method: "GET" });
    },
    PUT(url, init2) {
      return coreFetch(url, { ...init2, method: "PUT" });
    },
    POST(url, init2) {
      return coreFetch(url, { ...init2, method: "POST" });
    },
    DELETE(url, init2) {
      return coreFetch(url, { ...init2, method: "DELETE" });
    },
    OPTIONS(url, init2) {
      return coreFetch(url, { ...init2, method: "OPTIONS" });
    },
    HEAD(url, init2) {
      return coreFetch(url, { ...init2, method: "HEAD" });
    },
    PATCH(url, init2) {
      return coreFetch(url, { ...init2, method: "PATCH" });
    },
    TRACE(url, init2) {
      return coreFetch(url, { ...init2, method: "TRACE" });
    },
    use(...middleware) {
      for (const m of middleware) {
        if (!m) {
          continue;
        }
        if (typeof m !== "object" || !(("onRequest" in m) || ("onResponse" in m) || ("onError" in m))) {
          throw new Error("Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`");
        }
        middlewares.push(m);
      }
    },
    eject(...middleware) {
      for (const m of middleware) {
        const i4 = middlewares.indexOf(m);
        if (i4 !== -1) {
          middlewares.splice(i4, 1);
        }
      }
    }
  };
}
function serializePrimitiveParam2(name, value, options) {
  if (value === undefined || value === null) {
    return "";
  }
  if (typeof value === "object") {
    throw new Error("Deeply-nested arrays/objects arent supported. Provide your own `querySerializer()` to handle these.");
  }
  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;
}
function serializeObjectParam2(name, value, options) {
  if (!value || typeof value !== "object") {
    return "";
  }
  const values = [];
  const joiner = {
    simple: ",",
    label: ".",
    matrix: ";"
  }[options.style] || "&";
  if (options.style !== "deepObject" && options.explode === false) {
    for (const k in value) {
      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));
    }
    const final2 = values.join(",");
    switch (options.style) {
      case "form": {
        return `${name}=${final2}`;
      }
      case "label": {
        return `.${final2}`;
      }
      case "matrix": {
        return `;${name}=${final2}`;
      }
      default: {
        return final2;
      }
    }
  }
  for (const k in value) {
    const finalName = options.style === "deepObject" ? `${name}[${k}]` : k;
    values.push(serializePrimitiveParam2(finalName, value[k], options));
  }
  const final = values.join(joiner);
  return options.style === "label" || options.style === "matrix" ? `${joiner}${final}` : final;
}
function serializeArrayParam2(name, value, options) {
  if (!Array.isArray(value)) {
    return "";
  }
  if (options.explode === false) {
    const joiner2 = { form: ",", spaceDelimited: "%20", pipeDelimited: "|" }[options.style] || ",";
    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner2);
    switch (options.style) {
      case "simple": {
        return final;
      }
      case "label": {
        return `.${final}`;
      }
      case "matrix": {
        return `;${name}=${final}`;
      }
      default: {
        return `${name}=${final}`;
      }
    }
  }
  const joiner = { simple: ",", label: ".", matrix: ";" }[options.style] || "&";
  const values = [];
  for (const v of value) {
    if (options.style === "simple" || options.style === "label") {
      values.push(options.allowReserved === true ? v : encodeURIComponent(v));
    } else {
      values.push(serializePrimitiveParam2(name, v, options));
    }
  }
  return options.style === "label" || options.style === "matrix" ? `${joiner}${values.join(joiner)}` : values.join(joiner);
}
function createQuerySerializer2(options) {
  return function querySerializer(queryParams) {
    const search = [];
    if (queryParams && typeof queryParams === "object") {
      for (const name in queryParams) {
        const value = queryParams[name];
        if (value === undefined || value === null) {
          continue;
        }
        if (Array.isArray(value)) {
          if (value.length === 0) {
            continue;
          }
          search.push(serializeArrayParam2(name, value, {
            style: "form",
            explode: true,
            ...options?.array,
            allowReserved: options?.allowReserved || false
          }));
          continue;
        }
        if (typeof value === "object") {
          search.push(serializeObjectParam2(name, value, {
            style: "deepObject",
            explode: true,
            ...options?.object,
            allowReserved: options?.allowReserved || false
          }));
          continue;
        }
        search.push(serializePrimitiveParam2(name, value, options));
      }
    }
    return search.join("&");
  };
}
function defaultPathSerializer2(pathname, pathParams) {
  let nextURL = pathname;
  for (const match of pathname.match(PATH_PARAM_RE2) ?? []) {
    let name = match.substring(1, match.length - 1);
    let explode = false;
    let style = "simple";
    if (name.endsWith("*")) {
      explode = true;
      name = name.substring(0, name.length - 1);
    }
    if (name.startsWith(".")) {
      style = "label";
      name = name.substring(1);
    } else if (name.startsWith(";")) {
      style = "matrix";
      name = name.substring(1);
    }
    if (!pathParams || pathParams[name] === undefined || pathParams[name] === null) {
      continue;
    }
    const value = pathParams[name];
    if (Array.isArray(value)) {
      nextURL = nextURL.replace(match, serializeArrayParam2(name, value, { style, explode }));
      continue;
    }
    if (typeof value === "object") {
      nextURL = nextURL.replace(match, serializeObjectParam2(name, value, { style, explode }));
      continue;
    }
    if (style === "matrix") {
      nextURL = nextURL.replace(match, `;${serializePrimitiveParam2(name, value)}`);
      continue;
    }
    nextURL = nextURL.replace(match, style === "label" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));
  }
  return nextURL;
}
function defaultBodySerializer2(body, headers) {
  if (body instanceof FormData) {
    return body;
  }
  if (headers) {
    const contentType = headers.get instanceof Function ? headers.get("Content-Type") ?? headers.get("content-type") : headers["Content-Type"] ?? headers["content-type"];
    if (contentType === "application/x-www-form-urlencoded") {
      return new URLSearchParams(body).toString();
    }
  }
  return JSON.stringify(body);
}
function createFinalURL2(pathname, options) {
  let finalURL = `${options.baseUrl}${pathname}`;
  if (options.params?.path) {
    finalURL = defaultPathSerializer2(finalURL, options.params.path);
  }
  let search = options.querySerializer(options.params.query ?? {});
  if (search.startsWith("?")) {
    search = search.substring(1);
  }
  if (search) {
    finalURL += `?${search}`;
  }
  return finalURL;
}
function mergeHeaders2(...allHeaders) {
  const finalHeaders = new Headers;
  for (const h of allHeaders) {
    if (!h || typeof h !== "object") {
      continue;
    }
    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);
    for (const [k, v] of iterator) {
      if (v === null) {
        finalHeaders.delete(k);
      } else if (Array.isArray(v)) {
        for (const v2 of v) {
          finalHeaders.append(k, v2);
        }
      } else if (v !== undefined) {
        finalHeaders.set(k, v);
      }
    }
  }
  return finalHeaders;
}
function removeTrailingSlash2(url) {
  if (url.endsWith("/")) {
    return url.substring(0, url.length - 1);
  }
  return url;
}

// src/client/Nord.ts
class Nord {
  webServerUrl;
  solanaConnection;
  markets = [];
  tokens = [];
  symbolToMarketId = new Map;
  protonClient;
  httpClient;
  constructor({
    solanaConnection,
    webServerUrl,
    protonClient
  }) {
    this.webServerUrl = webServerUrl;
    this.solanaConnection = solanaConnection;
    this.protonClient = protonClient;
    this.httpClient = createClient2({ baseUrl: webServerUrl });
  }
  createWebSocketClient({
    trades,
    deltas,
    accounts,
    candles
  }) {
    const subscriptions2 = [];
    if (trades && trades.length > 0) {
      trades.forEach((symbol2) => {
        subscriptions2.push(`trades@${symbol2}`);
      });
    }
    if (deltas && deltas.length > 0) {
      deltas.forEach((symbol2) => {
        subscriptions2.push(`deltas@${symbol2}`);
      });
    }
    if (accounts && accounts.length > 0) {
      accounts.forEach((accountId) => {
        if (isNaN(accountId) || accountId <= 0) {
          throw new NordError(`Invalid account ID: ${accountId}. Must be a positive number.`);
        }
        subscriptions2.push(`account@${accountId}`);
      });
    }
    if (candles && candles.length > 0) {
      candles.forEach(({ symbol: symbol2, resolution }) => {
        if (!symbol2 || typeof symbol2 !== "string") {
          throw new NordError("Invalid market symbol");
        }
        const allowedResolutions = [
          "1",
          "5",
          "15",
          "30",
          "60",
          "1D",
          "1W",
          "1M"
        ];
        if (!allowedResolutions.includes(resolution)) {
          throw new NordError("Invalid candle resolution");
        }
        subscriptions2.push(`candle@${symbol2}:${resolution}`);
      });
    }
    if (subscriptions2.length === 0) {
      throw new NordError("At least one subscription must be provided");
    }
    return initWebSocketClient(this.webServerUrl, subscriptions2);
  }
  async GET(path, options) {
    const r = await this.httpClient.GET(path, options);
    if (r.error) {
      throw new NordError(`failed to GET ${path}`, { cause: r.error });
    }
    if (r.data === undefined) {
      throw new NordError("internal assertion violation", { cause: r });
    }
    return r.data;
  }
  async getTimestamp() {
    return BigInt(await this.GET("/timestamp", {}));
  }
  async getActionNonce() {
    return await this.GET("/event/last-acked-nonce", {});
  }
  async getAdminList() {
    return await this.GET("/admin", {});
  }
  async getAccountVolume({
    accountId,
    since,
    until,
    marketId
  }) {
    return await this.GET("/account/volume", {
      params: {
        query: {
          accountId,
          since,
          until,
          marketId
        }
      }
    });
  }
  async fetchNordInfo() {
    try {
      const info = await this.GET("/info", {});
      this.markets = info.markets;
      this.tokens = info.tokens;
      this.symbolToMarketId.clear();
      info.markets.forEach((market) => {
        this.symbolToMarketId.set(market.symbol, market.marketId);
      });
    } catch (error) {
      throw new NordError("Failed to fetch Nord info", { cause: error });
    }
  }
  static async initNord(x2) {
    return await Nord.new(x2);
  }
  static async new({
    app,
    solanaConnection,
    webServerUrl,
    protonUrl
  }) {
    const protonClient = await ProtonClient.init({
      protonUrl: protonUrl ?? webServerUrl,
      app: new PublicKey(app),
      solConn: solanaConnection
    });
    const nord = new Nord({
      protonClient,
      solanaConnection,
      webServerUrl
    });
    await nord.init();
    return nord;
  }
  async init() {
    await this.fetchNordInfo();
  }
  async queryAction({
    actionId
  }) {
    return (await this.queryRecentActions({
      from: actionId,
      to: actionId
    }))[0] ?? null;
  }
  async queryRecentActions({
    from: from2,
    to
  }) {
    const xs = await this.GET("/action", {
      params: {
        query: { from: from2, to }
      }
    });
    return xs.map((x2) => ({
      actionId: x2.actionId,
      action: decodeLengthDelimited(Buffer.from(x2.payload, "base64"), ActionSchema),
      physicalExecTime: new Date(x2.physicalTime)
    }));
  }
  async getLastActionId() {
    return await this.GET("/action/last-executed-id", {});
  }
  subscribeOrderbook(symbol2) {
    if (!symbol2 || typeof symbol2 !== "string") {
      throw new NordError("Invalid market symbol");
    }
    const subscription = new EventEmitter2;
    const wsClient = this.createWebSocketClient({
      deltas: [symbol2]
    });
    const handleDelta = (update) => {
      if (update.market_symbol !== symbol2) {
        return;
      }
      subscription.emit("message", update);
    };
    wsClient.on("delta", handleDelta);
    subscription.close = () => {
      wsClient.removeListener("delta", handleDelta);
      subscription.removeAllListeners();
    };
    return subscription;
  }
  subscribeBars(symbol2, resolution) {
    if (!symbol2 || typeof symbol2 !== "string") {
      throw new NordError("Invalid market symbol");
    }
    const subscription = new EventEmitter2;
    const wsClient = this.createWebSocketClient({
      candles: [{ symbol: symbol2, resolution }]
    });
    const handleCandle = (update) => {
      subscription.emit("message", update);
    };
    wsClient.on("candle", handleCandle);
    subscription.close = () => {
      wsClient.removeListener("candle", handleCandle);
      subscription.removeAllListeners();
    };
    return subscription;
  }
  subscribeTrades(symbol2) {
    if (!symbol2 || typeof symbol2 !== "string") {
      throw new NordError("Invalid market symbol");
    }
    const subscription = new EventEmitter2;
    const wsClient = this.createWebSocketClient({
      trades: [symbol2]
    });
    const handleTrade = (update) => {
      if (update.market_symbol !== symbol2) {
        return;
      }
      subscription.emit("message", update);
    };
    wsClient.on("trades", handleTrade);
    subscription.close = () => {
      wsClient.removeListener("trades", handleTrade);
      subscription.removeAllListeners();
    };
    return subscription;
  }
  subscribeAccount(accountId) {
    if (isNaN(accountId) || accountId <= 0) {
      throw new NordError("Invalid account ID");
    }
    const subscription = new EventEmitter2;
    const wsClient = this.createWebSocketClient({
      accounts: [accountId]
    });
    const handleAccountUpdate = (update) => {
      if (update.account_id !== accountId) {
        return;
      }
      subscription.emit("message", update);
    };
    wsClient.on("account", handleAccountUpdate);
    subscription.close = () => {
      wsClient.removeListener("account", handleAccountUpdate);
      subscription.removeAllListeners();
    };
    return subscription;
  }
  async getTrades({
    marketId,
    takerId,
    makerId,
    takerSide,
    pageSize,
    since,
    until,
    startInclusive
  }) {
    if (since && !isRfc3339(since)) {
      throw new NordError(`Invalid RFC3339 timestamp: ${since}`);
    }
    if (until && !isRfc3339(until)) {
      throw new NordError(`Invalid RFC3339 timestamp: ${until}`);
    }
    return await this.GET("/trades", {
      params: {
        query: {
          takerId,
          makerId,
          marketId,
          pageSize,
          takerSide,
          since,
          until,
          startInclusive
        }
      }
    });
  }
  async getUser({
    pubkey
  }) {
    const r = await this.httpClient.GET("/user/{pubkey}", {
      params: {
        path: { pubkey: pubkey.toString() }
      }
    });
    if (r.response.status === 404) {
      return null;
    }
    return r.data;
  }
  async getOrderbook({
    symbol: symbol2,
    marketId
  }) {
    let _marketId;
    if (symbol2 && marketId === undefined) {
      if (this.symbolToMarketId.size === 0) {
        await this.fetchNordInfo();
      }
      const id2 = this.symbolToMarketId.get(symbol2);
      if (id2 === undefined) {
        throw new NordError(`Unknown market symbol: ${symbol2}`);
      }
      _marketId = id2;
    } else if (marketId !== undefined) {
      _marketId = marketId;
    } else {
      throw new NordError("Either symbol or market_id must be provided for orderbook query");
    }
    return await this.GET("/market/{market_id}/orderbook", {
      params: {
        path: { market_id: _marketId }
      }
    });
  }
  async getInfo() {
    return await this.GET("/info", {});
  }
  async getFeeBrackets() {
    return await this.GET("/fee/brackets/info", {});
  }
  async getAccountFeeTier(accountId) {
    return await this.GET("/account/{account_id}/fee/tier", {
      params: {
        path: { account_id: accountId }
      }
    });
  }
  async getAccount(accountId) {
    return await this.GET("/account/{account_id}", {
      params: {
        path: { account_id: accountId }
      }
    });
  }
  async getAccountPubkey(accountId) {
    return await this.GET("/account/{account_id}/pubkey", {
      params: {
        path: { account_id: accountId }
      }
    });
  }
  async getAccountWithdrawalFee(accountId) {
    return await this.GET("/account/{account_id}/fees/withdrawal", {
      params: {
        path: { account_id: accountId }
      }
    });
  }
  async getAccountOrders(accountId, {
    startInclusive,
    pageSize
  } = {}) {
    return await this.GET("/account/{account_id}/orders", {
      params: {
        path: { account_id: accountId },
        query: {
          startInclusive,
          pageSize
        }
      }
    });
  }
  async getAccountsFeeTiers({
    startInclusive,
    pageSize,
    tier
  } = {}) {
    return await this.GET("/accounts/fee-tiers", {
      params: {
        query: {
          startInclusive,
          pageSize,
          tier
        }
      }
    });
  }
  async getAccountPnl(accountId, {
    since,
    until,
    startInclusive,
    pageSize
  } = {}) {
    return await this.GET("/account/{account_id}/history/pnl", {
      params: {
        path: { account_id: accountId },
        query: {
          since,
          until,
          startInclusive,
          pageSize
        }
      }
    });
  }
  async getMarketStats({
    marketId
  }) {
    return await this.GET("/market/{market_id}/stats", {
      params: {
        path: { market_id: marketId }
      }
    });
  }
  async getMarketFee({
    marketId,
    feeKind,
    accountId
  }) {
    return await this.GET("/market/{market_id}/fees/{fee_kind}/{account_id}", {
      params: {
        path: {
          market_id: marketId,
          fee_kind: feeKind,
          account_id: accountId
        }
      }
    });
  }
  async getTokenStats(tokenId) {
    return await this.GET("/tokens/{token_id}/stats", {
      params: {
        path: { token_id: tokenId }
      }
    });
  }
  async getOrder(orderId) {
    return await this.GET("/order/{order_id}", {
      params: {
        path: { order_id: orderId }
      }
    });
  }
  async getOrderTrades(orderId, {
    startInclusive,
    pageSize
  } = {}) {
    return await this.GET("/order/{order_id}/trades", {
      params: {
        path: { order_id: orderId },
        query: {
          startInclusive,
          pageSize
        }
      }
    });
  }
  async accountExists(pubkey) {
    return !!await this.getUser({ pubkey });
  }
  async getAccountTriggers({
    accountId
  } = {}) {
    if (accountId == null) {
      throw new NordError("Account ID is undefined. Make sure to call updateAccountId() before requesting triggers.");
    }
    try {
      const triggers = await this.GET("/account/{account_id}/triggers", {
        params: {
          path: { account_id: accountId }
        }
      });
      return triggers ?? [];
    } catch (error) {
      throw new NordError("Failed to fetch account triggers", { cause: error });
    }
  }
  async getAccountTriggerHistory({
    accountId,
    since,
    until,
    pageSize,
    startInclusive
  }) {
    if (accountId == null) {
      throw new NordError("Account ID is undefined. Make sure to call updateAccountId() before requesting trigger history.");
    }
    try {
      return await this.GET("/account/{account_id}/triggers/history", {
        params: {
          path: { account_id: accountId },
          query: {
            since,
            until,
            pageSize,
            startInclusive
          }
        }
      });
    } catch (error) {
      throw new NordError("Failed to fetch account trigger history", {
        cause: error
      });
    }
  }
  async getAccountWithdrawalHistory({
    accountId,
    since,
    until,
    pageSize,
    startInclusive
  }) {
    if (accountId == null) {
      throw new NordError("Account ID is undefined. Make sure to call updateAccountId() before requesting withdrawal history.");
    }
    try {
      return await this.GET("/account/{account_id}/history/withdrawal", {
        params: {
          path: { account_id: accountId },
          query: {
            since,
            until,
            pageSize,
            startInclusive
          }
        }
      });
    } catch (error) {
      throw new NordError("Failed to fetch account withdrawal history", {
        cause: error
      });
    }
  }
}
// node_modules/@solana/spl-token/lib/esm/constants.js
var TOKEN_PROGRAM_ID3 = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var TOKEN_2022_PROGRAM_ID2 = new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var ASSOCIATED_TOKEN_PROGRAM_ID2 = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT2 = new PublicKey("So11111111111111111111111111111111111111112");
var NATIVE_MINT_20222 = new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");

// node_modules/@solana/buffer-layout-utils/lib/esm/base.mjs
var encodeDecode2 = (layout) => {
  const decode4 = layout.decode.bind(layout);
  const encode2 = layout.encode.bind(layout);
  return { decode: decode4, encode: encode2 };
};

// node_modules/@solana/buffer-layout-utils/lib/esm/bigint.mjs
var import_buffer_layout7 = __toESM(require_Layout(), 1);
var import_bigint_buffer2 = __toESM(require_browser5(), 1);
var bigInt2 = (length) => (property) => {
  const layout = import_buffer_layout7.blob(length, property);
  const { encode: encode2, decode: decode4 } = encodeDecode2(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset3) => {
    const src = decode4(buffer, offset3);
    return import_bigint_buffer2.toBigIntLE(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt3, buffer, offset3) => {
    const src = import_bigint_buffer2.toBufferLE(bigInt3, length);
    return encode2(src, buffer, offset3);
  };
  return bigIntLayout;
};
var bigIntBE2 = (length) => (property) => {
  const layout = import_buffer_layout7.blob(length, property);
  const { encode: encode2, decode: decode4 } = encodeDecode2(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset3) => {
    const src = decode4(buffer, offset3);
    return import_bigint_buffer2.toBigIntBE(Buffer.from(src));
  };
  bigIntLayout.encode = (bigInt3, buffer, offset3) => {
    const src = import_bigint_buffer2.toBufferBE(bigInt3, length);
    return encode2(src, buffer, offset3);
  };
  return bigIntLayout;
};
var u646 = bigInt2(8);
var u64be2 = bigIntBE2(8);
var u128 = bigInt2(16);
var u128be2 = bigIntBE2(16);
var u1922 = bigInt2(24);
var u192be2 = bigIntBE2(24);
var u256 = bigInt2(32);
var u256be2 = bigIntBE2(32);

// node_modules/@solana/buffer-layout-utils/lib/esm/native.mjs
var import_buffer_layout9 = __toESM(require_Layout(), 1);
var bool = (property) => {
  const layout = import_buffer_layout9.u8(property);
  const { encode: encode2, decode: decode4 } = encodeDecode2(layout);
  const boolLayout = layout;
  boolLayout.decode = (buffer, offset3) => {
    const src = decode4(buffer, offset3);
    return !!src;
  };
  boolLayout.encode = (bool3, buffer, offset3) => {
    const src = Number(bool3);
    return encode2(src, buffer, offset3);
  };
  return boolLayout;
};

// node_modules/@solana/buffer-layout-utils/lib/esm/web3.mjs
var import_buffer_layout11 = __toESM(require_Layout(), 1);

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/lib/index.browser.esm.js
init_buffer();

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n16 = /* @__PURE__ */ BigInt(0);
var _1n16 = /* @__PURE__ */ BigInt(1);
function abool3(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded4(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber4(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n16 : BigInt("0x" + hex);
}
function bytesToNumberBE4(bytes2) {
  return hexToNumber4(bytesToHex2(bytes2));
}
function bytesToNumberLE4(bytes2) {
  abytes(bytes2);
  return hexToNumber4(bytesToHex2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE4(n2, len2) {
  return hexToBytes2(n2.toString(16).padStart(len2 * 2, "0"));
}
function numberToBytesLE4(n2, len2) {
  return numberToBytesBE4(n2, len2).reverse();
}
function ensureBytes4(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len2 = res.length;
  if (typeof expectedLength === "number" && len2 !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len2);
  return res;
}
var isPosBig3 = (n2) => typeof n2 === "bigint" && _0n16 <= n2;
function inRange4(n2, min2, max2) {
  return isPosBig3(n2) && isPosBig3(min2) && isPosBig3(max2) && min2 <= n2 && n2 < max2;
}
function aInRange3(title, n2, min2, max2) {
  if (!inRange4(n2, min2, max2))
    throw new Error("expected valid " + title + ": " + min2 + " <= n < " + max2 + ", got " + n2);
}
function bitLen4(n2) {
  let len2;
  for (len2 = 0;n2 > _0n16; n2 >>= _1n16, len2 += 1)
    ;
  return len2;
}
var bitMask4 = (n2) => (_1n16 << BigInt(n2)) - _1n16;
function createHmacDrbg4(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n2 = (len2) => new Uint8Array(len2);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i4 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i4 = 0;
  };
  const h = (...b3) => hmacFn(k, v, ...b3);
  const reseed = (seed2 = u8n2(0)) => {
    k = h(u8of(0), seed2);
    v = h();
    if (seed2.length === 0)
      return;
    k = h(u8of(1), seed2);
    v = h();
  };
  const gen4 = () => {
    if (i4++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len2 = 0;
    const out = [];
    while (len2 < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len2 += v.length;
    }
    return concatBytes3(...out);
  };
  const genUntil = (seed2, pred) => {
    reset();
    reseed(seed2);
    let res = undefined;
    while (!(res = pred(gen4())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function _validateObject3(object2, fields2, optFields = {}) {
  if (!object2 || typeof object2 !== "object")
    throw new Error("expected valid options object");
  function checkField2(fieldName, expectedType, isOpt) {
    const val = object2[fieldName];
    if (isOpt && val === undefined)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields2).forEach(([k, v]) => checkField2(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField2(k, v, true));
}
function memoized3(fn) {
  const map = new WeakMap;
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== undefined)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n17 = BigInt(0);
var _1n17 = BigInt(1);
var _2n13 = /* @__PURE__ */ BigInt(2);
var _3n7 = /* @__PURE__ */ BigInt(3);
var _4n6 = /* @__PURE__ */ BigInt(4);
var _5n5 = /* @__PURE__ */ BigInt(5);
var _8n6 = /* @__PURE__ */ BigInt(8);
function mod5(a, b3) {
  const result = a % b3;
  return result >= _0n17 ? result : b3 + result;
}
function pow25(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n17) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert4(number4, modulo) {
  if (number4 === _0n17)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n17)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod5(number4, modulo);
  let b3 = modulo;
  let x2 = _0n17, y = _1n17, u = _1n17, v = _0n17;
  while (a !== _0n17) {
    const q = b3 / a;
    const r = b3 % a;
    const m = x2 - u * q;
    const n2 = y - v * q;
    b3 = a, a = r, x2 = u, y = v, u = m, v = n2;
  }
  const gcd = b3;
  if (gcd !== _1n17)
    throw new Error("invert: does not exist");
  return mod5(x2, modulo);
}
function sqrt3mod43(Fp4, n2) {
  const p1div4 = (Fp4.ORDER + _1n17) / _4n6;
  const root = Fp4.pow(n2, p1div4);
  if (!Fp4.eql(Fp4.sqr(root), n2))
    throw new Error("Cannot find square root");
  return root;
}
function sqrt5mod83(Fp4, n2) {
  const p5div8 = (Fp4.ORDER - _5n5) / _8n6;
  const n22 = Fp4.mul(n2, _2n13);
  const v = Fp4.pow(n22, p5div8);
  const nv = Fp4.mul(n2, v);
  const i4 = Fp4.mul(Fp4.mul(nv, _2n13), v);
  const root = Fp4.mul(nv, Fp4.sub(i4, Fp4.ONE));
  if (!Fp4.eql(Fp4.sqr(root), n2))
    throw new Error("Cannot find square root");
  return root;
}
function tonelliShanks4(P3) {
  if (P3 < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let Q = P3 - _1n17;
  let S2 = 0;
  while (Q % _2n13 === _0n17) {
    Q /= _2n13;
    S2++;
  }
  let Z2 = _2n13;
  const _Fp = Field4(P3);
  while (FpLegendre3(_Fp, Z2) === 1) {
    if (Z2++ > 1000)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S2 === 1)
    return sqrt3mod43;
  let cc = _Fp.pow(Z2, Q);
  const Q1div2 = (Q + _1n17) / _2n13;
  return function tonelliSlow(Fp4, n2) {
    if (Fp4.is0(n2))
      return n2;
    if (FpLegendre3(Fp4, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S2;
    let c = Fp4.mul(Fp4.ONE, cc);
    let t = Fp4.pow(n2, Q);
    let R = Fp4.pow(n2, Q1div2);
    while (!Fp4.eql(t, Fp4.ONE)) {
      if (Fp4.is0(t))
        return Fp4.ZERO;
      let i4 = 1;
      let t_tmp = Fp4.sqr(t);
      while (!Fp4.eql(t_tmp, Fp4.ONE)) {
        i4++;
        t_tmp = Fp4.sqr(t_tmp);
        if (i4 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n17 << BigInt(M - i4 - 1);
      const b3 = Fp4.pow(c, exponent);
      M = i4;
      c = Fp4.sqr(b3);
      t = Fp4.mul(t, c);
      R = Fp4.mul(R, b3);
    }
    return R;
  };
}
function FpSqrt4(P3) {
  if (P3 % _4n6 === _3n7)
    return sqrt3mod43;
  if (P3 % _8n6 === _5n5)
    return sqrt5mod83;
  return tonelliShanks4(P3);
}
var isNegativeLE3 = (num, modulo) => (mod5(num, modulo) & _1n17) === _1n17;
var FIELD_FIELDS4 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField4(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS4.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject3(field, opts);
  return field;
}
function FpPow4(Fp4, num, power) {
  if (power < _0n17)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n17)
    return Fp4.ONE;
  if (power === _1n17)
    return num;
  let p = Fp4.ONE;
  let d = num;
  while (power > _0n17) {
    if (power & _1n17)
      p = Fp4.mul(p, d);
    d = Fp4.sqr(d);
    power >>= _1n17;
  }
  return p;
}
function FpInvertBatch4(Fp4, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp4.ZERO : undefined);
  const multipliedAcc = nums.reduce((acc, num, i4) => {
    if (Fp4.is0(num))
      return acc;
    inverted[i4] = acc;
    return Fp4.mul(acc, num);
  }, Fp4.ONE);
  const invertedAcc = Fp4.inv(multipliedAcc);
  nums.reduceRight((acc, num, i4) => {
    if (Fp4.is0(num))
      return acc;
    inverted[i4] = Fp4.mul(acc, inverted[i4]);
    return Fp4.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre3(Fp4, n2) {
  const p1mod2 = (Fp4.ORDER - _1n17) / _2n13;
  const powered = Fp4.pow(n2, p1mod2);
  const yes = Fp4.eql(powered, Fp4.ONE);
  const zero2 = Fp4.eql(powered, Fp4.ZERO);
  const no = Fp4.eql(powered, Fp4.neg(Fp4.ONE));
  if (!yes && !zero2 && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero2 ? 0 : -1;
}
function nLength4(n2, nBitLength) {
  if (nBitLength !== undefined)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== undefined ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field4(ORDER, bitLenOrOpts, isLE4 = false, opts = {}) {
  if (ORDER <= _0n17)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = undefined;
  let _sqrt = undefined;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE4)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE4 = _opts.isLE;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength4(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f4 = Object.freeze({
    ORDER,
    isLE: isLE4,
    BITS,
    BYTES,
    MASK: bitMask4(BITS),
    ZERO: _0n17,
    ONE: _1n17,
    create: (num) => mod5(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n17 <= num && num < ORDER;
    },
    is0: (num) => num === _0n17,
    isValidNot0: (num) => !f4.is0(num) && f4.isValid(num),
    isOdd: (num) => (num & _1n17) === _1n17,
    neg: (num) => mod5(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod5(num * num, ORDER),
    add: (lhs, rhs) => mod5(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod5(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod5(lhs * rhs, ORDER),
    pow: (num, power) => FpPow4(f4, num, power),
    div: (lhs, rhs) => mod5(lhs * invert4(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert4(num, ORDER),
    sqrt: _sqrt || ((n2) => {
      if (!sqrtP)
        sqrtP = FpSqrt4(ORDER);
      return sqrtP(f4, n2);
    }),
    toBytes: (num) => isLE4 ? numberToBytesLE4(num, BYTES) : numberToBytesBE4(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE4 ? bytesToNumberLE4(bytes2) : bytesToNumberBE4(bytes2);
    },
    invertBatch: (lst) => FpInvertBatch4(f4, lst),
    cmov: (a, b3, c) => c ? b3 : a
  });
  return Object.freeze(f4);
}
function getFieldBytesLength4(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength4(fieldOrder) {
  const length = getFieldBytesLength4(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField4(key, fieldOrder, isLE4 = false) {
  const len2 = key.length;
  const fieldLen = getFieldBytesLength4(fieldOrder);
  const minLen = getMinHashLength4(fieldOrder);
  if (len2 < 16 || len2 < minLen || len2 > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len2);
  const num = isLE4 ? bytesToNumberLE4(key) : bytesToNumberBE4(key);
  const reduced = mod5(num, fieldOrder - _1n17) + _1n17;
  return isLE4 ? numberToBytesLE4(reduced, fieldLen) : numberToBytesBE4(reduced, fieldLen);
}

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n18 = BigInt(0);
var _1n18 = BigInt(1);
function negateCt3(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ3(c, property, points) {
  const getz = property === "pz" ? (p) => p.pz : (p) => p.ez;
  const toInv = FpInvertBatch4(c.Fp, points.map(getz));
  const affined = points.map((p, i4) => p.toAffine(toInv[i4]));
  return affined.map(c.fromAffine);
}
function validateW3(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts3(W, scalarBits) {
  validateW3(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask4 = bitMask4(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask: mask4, maxNumber, shiftBy };
}
function calcOffsets3(n2, window2, wOpts) {
  const { windowSize, mask: mask4, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask4);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n18;
  }
  const offsetStart = window2 * windowSize;
  const offset3 = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset: offset3, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints3(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i4) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i4);
  });
}
function validateMSMScalars3(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i4) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i4);
  });
}
var pointPrecomputes3 = new WeakMap;
var pointWindowSizes3 = new WeakMap;
function getW3(P3) {
  return pointWindowSizes3.get(P3) || 1;
}
function assert03(n2) {
  if (n2 !== _0n18)
    throw new Error("invalid wNAF");
}
function wNAF4(c, bits) {
  return {
    constTimeNegate: negateCt3,
    hasPrecomputes(elm) {
      return getW3(elm) !== 1;
    },
    unsafeLadder(elm, n2, p = c.ZERO) {
      let d = elm;
      while (n2 > _0n18) {
        if (n2 & _1n18)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n18;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts3(W, bits);
      const points = [];
      let p = elm;
      let base2 = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base2 = p;
        points.push(base2);
        for (let i4 = 1;i4 < windowSize; i4++) {
          base2 = base2.add(p);
          points.push(base2);
        }
        p = base2.double();
      }
      return points;
    },
    wNAF(W, precomputes, n2) {
      let p = c.ZERO;
      let f4 = c.BASE;
      const wo = calcWOpts3(W, bits);
      for (let window2 = 0;window2 < wo.windows; window2++) {
        const { nextN, offset: offset3, isZero, isNeg, isNegF, offsetF } = calcOffsets3(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          f4 = f4.add(negateCt3(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt3(isNeg, precomputes[offset3]));
        }
      }
      assert03(n2);
      return { p, f: f4 };
    },
    wNAFUnsafe(W, precomputes, n2, acc = c.ZERO) {
      const wo = calcWOpts3(W, bits);
      for (let window2 = 0;window2 < wo.windows; window2++) {
        if (n2 === _0n18)
          break;
        const { nextN, offset: offset3, isZero, isNeg } = calcOffsets3(n2, window2, wo);
        n2 = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset3];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert03(n2);
      return acc;
    },
    getPrecomputes(W, P3, transform) {
      let comp = pointPrecomputes3.get(P3);
      if (!comp) {
        comp = this.precomputeWindow(P3, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes3.set(P3, comp);
        }
      }
      return comp;
    },
    wNAFCached(P3, n2, transform) {
      const W = getW3(P3);
      return this.wNAF(W, this.getPrecomputes(W, P3, transform), n2);
    },
    wNAFCachedUnsafe(P3, n2, transform, prev) {
      const W = getW3(P3);
      if (W === 1)
        return this.unsafeLadder(P3, n2, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P3, transform), n2, prev);
    },
    setWindowSize(P3, W) {
      validateW3(W, bits);
      pointWindowSizes3.set(P3, W);
      pointPrecomputes3.delete(P3);
    }
  };
}
function mulEndoUnsafe3(c, point, k1, k2) {
  let acc = point;
  let p1 = c.ZERO;
  let p2 = c.ZERO;
  while (k1 > _0n18 || k2 > _0n18) {
    if (k1 & _1n18)
      p1 = p1.add(acc);
    if (k2 & _1n18)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n18;
    k2 >>= _1n18;
  }
  return { p1, p2 };
}
function pippenger3(c, fieldN, points, scalars) {
  validateMSMPoints3(points, c);
  validateMSMScalars3(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero2 = c.ZERO;
  const wbits = bitLen4(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask4(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero2);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum2 = zero2;
  for (let i4 = lastBits;i4 >= 0; i4 -= windowSize) {
    buckets.fill(zero2);
    for (let j = 0;j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i4) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero2;
    for (let j = buckets.length - 1, sumI = zero2;j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum2 = sum2.add(resI);
    if (i4 !== 0)
      for (let j = 0;j < windowSize; j++)
        sum2 = sum2.double();
  }
  return sum2;
}
function createField3(order, field) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField4(field);
    return field;
  } else {
    return Field4(order);
  }
}
function _createCurveFields3(type4, CURVE, curveOpts = {}) {
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type4} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n18))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp4 = createField3(CURVE.p, curveOpts.Fp);
  const Fn = createField3(CURVE.n, curveOpts.Fn);
  const _b = type4 === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp4.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  return { Fp: Fp4, Fn };
}

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n19 = BigInt(0);
var _1n19 = BigInt(1);
var _2n14 = BigInt(2);
var _8n7 = BigInt(8);
var VERIFY_DEFAULT3 = { zip215: true };
function isEdValidXY3(Fp4, CURVE, x2, y) {
  const x22 = Fp4.sqr(x2);
  const y2 = Fp4.sqr(y);
  const left = Fp4.add(Fp4.mul(CURVE.a, x22), y2);
  const right = Fp4.add(Fp4.ONE, Fp4.mul(CURVE.d, Fp4.mul(x22, y2)));
  return Fp4.eql(left, right);
}
function edwards3(CURVE, curveOpts = {}) {
  const { Fp: Fp4, Fn } = _createCurveFields3("edwards", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject3(curveOpts, {}, { uvRatio: "function" });
  const MASK = _2n14 << BigInt(Fn.BYTES * 8) - _1n19;
  const modP = (n2) => Fp4.create(n2);
  const uvRatio3 = curveOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp4.sqrt(Fp4.div(u, v)) };
    } catch (e) {
      return { isValid: false, value: _0n19 };
    }
  });
  if (!isEdValidXY3(Fp4, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min2 = banZero ? _1n19 : _0n19;
    aInRange3("coordinate " + title, n2, min2, MASK);
    return n2;
  }
  function aextpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized3((p, iz) => {
    const { ex: x2, ey: y, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n7 : Fp4.inv(z);
    const ax = modP(x2 * iz);
    const ay = modP(y * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n19, y: _1n19 };
    if (zz !== _1n19)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized3((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z2, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z22 = modP(Z2 * Z2);
    const Z4 = modP(Z22 * Z22);
    const aX2 = modP(X2 * a);
    const left = modP(Z22 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z2 * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });

  class Point2 {
    constructor(ex, ey, ez, et2) {
      this.ex = acoord("x", ex);
      this.ey = acoord("y", ey);
      this.ez = acoord("z", ez, true);
      this.et = acoord("t", et2);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point2)
        throw new Error("extended point not allowed");
      const { x: x2, y } = p || {};
      acoord("x", x2);
      acoord("y", y);
      return new Point2(x2, y, _1n19, modP(x2 * y));
    }
    static normalizeZ(points) {
      return normalizeZ3(Point2, "ez", points);
    }
    static msm(points, scalars) {
      return pippenger3(Point2, Fn, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_2n14);
      return this;
    }
    assertValidity() {
      assertValidMemo(this);
    }
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n14 * modP(Z1 * Z1));
      const D2 = modP(a * A);
      const x1y1 = X1 + Y1;
      const E2 = modP(modP(x1y1 * x1y1) - A - B);
      const G = D2 + B;
      const F = G - C;
      const H = D2 - B;
      const X3 = modP(E2 * F);
      const Y3 = modP(G * H);
      const T32 = modP(E2 * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T32);
    }
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T13 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T22 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T13 * d * T22);
      const D2 = modP(Z1 * Z2);
      const E2 = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D2 - C;
      const G = D2 + C;
      const H = modP(B - a * A);
      const X3 = modP(E2 * F);
      const Y3 = modP(G * H);
      const T32 = modP(E2 * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      const n2 = scalar;
      aInRange3("scalar", n2, _1n19, CURVE_ORDER);
      const { p, f: f4 } = wnaf.wNAFCached(this, n2, Point2.normalizeZ);
      return Point2.normalizeZ([p, f4])[0];
    }
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      const n2 = scalar;
      aInRange3("scalar", n2, _0n19, CURVE_ORDER);
      if (n2 === _0n19)
        return Point2.ZERO;
      if (this.is0() || n2 === _1n19)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n2, Point2.normalizeZ, acc);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    isTorsionFree() {
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n19)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    static fromBytes(bytes2, zip215 = false) {
      abytes(bytes2);
      return this.fromHex(bytes2, zip215);
    }
    static fromHex(hex, zip215 = false) {
      const { d, a } = CURVE;
      const len2 = Fp4.BYTES;
      hex = ensureBytes4("pointHex", hex, len2);
      abool3("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len2 - 1];
      normed[len2 - 1] = lastByte & ~128;
      const y = bytesToNumberLE4(normed);
      const max2 = zip215 ? MASK : Fp4.ORDER;
      aInRange3("pointHex.y", y, _0n19, max2);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n19);
      const v = modP(d * y2 - a);
      let { isValid, value: x2 } = uvRatio3(u, v);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x2 & _1n19) === _1n19;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x2 === _0n19 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x2 = modP(-x2);
      return Point2.fromAffine({ x: x2, y });
    }
    static fromPrivateScalar(scalar) {
      return Point2.BASE.multiply(scalar);
    }
    toBytes() {
      const { x: x2, y } = this.toAffine();
      const bytes2 = numberToBytesLE4(y, Fp4.BYTES);
      bytes2[bytes2.length - 1] |= x2 & _1n19 ? 128 : 0;
      return bytes2;
    }
    toRawBytes() {
      return this.toBytes();
    }
    toHex() {
      return bytesToHex2(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n19, modP(CURVE.Gx * CURVE.Gy));
  Point2.ZERO = new Point2(_0n19, _1n19, _1n19, _0n19);
  Point2.Fp = Fp4;
  Point2.Fn = Fn;
  const wnaf = wNAF4(Point2, Fn.BYTES * 8);
  return Point2;
}
function eddsa3(Point2, eddsaOpts) {
  _validateObject3(eddsaOpts, {
    hash: "function"
  }, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash, hash: cHash } = eddsaOpts;
  const { BASE: G, Fp: Fp4, Fn } = Point2;
  const CURVE_ORDER = Fn.ORDER;
  const randomBytes_ = eddsaOpts.randomBytes || randomBytes4;
  const adjustScalarBytes3 = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool3("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN(a) {
    return Fn.create(a);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE4(hash2));
  }
  function getPrivateScalar(key) {
    const len2 = Fp4.BYTES;
    key = ensureBytes4("private key", key, len2);
    const hashed = ensureBytes4("hashed private key", cHash(key), 2 * len2);
    const head = adjustScalarBytes3(hashed.slice(0, len2));
    const prefix = hashed.slice(len2, 2 * len2);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head, prefix, scalar } = getPrivateScalar(key);
    const point = G.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey3(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes3(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes4("context", context), !!prehash)));
  }
  function sign4(msg, privKey, options = {}) {
    msg = ensureBytes4("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G.multiply(r).toBytes();
    const k = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k * scalar);
    aInRange3("signature.s", s, _0n19, CURVE_ORDER);
    const L = Fp4.BYTES;
    const res = concatBytes3(R, numberToBytesLE4(s, L));
    return ensureBytes4("result", res, L * 2);
  }
  const verifyOpts = VERIFY_DEFAULT3;
  function verify3(sig, msg, publicKey6, options = verifyOpts) {
    const { context, zip215 } = options;
    const len2 = Fp4.BYTES;
    sig = ensureBytes4("signature", sig, 2 * len2);
    msg = ensureBytes4("message", msg);
    publicKey6 = ensureBytes4("publicKey", publicKey6, len2);
    if (zip215 !== undefined)
      abool3("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE4(sig.slice(len2, 2 * len2));
    let A, R, SB;
    try {
      A = Point2.fromHex(publicKey6, zip215);
      R = Point2.fromHex(sig.slice(0, len2), zip215);
      SB = G.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  G.precompute(8);
  const utils = {
    getExtendedPublicKey,
    randomPrivateKey: () => randomBytes_(Fp4.BYTES),
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return { getPublicKey: getPublicKey3, sign: sign4, verify: verify3, utils, Point: Point2 };
}
function _eddsa_legacy_opts_to_new3(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp4 = c.Fp;
  const Fn = Field4(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp: Fp4, Fn, uvRatio: c.uvRatio };
  const eddsaOpts = {
    hash: c.hash,
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, eddsaOpts };
}
function _eddsa_new_output_to_legacy3(c, eddsa4) {
  const legacy = Object.assign({}, eddsa4, { ExtendedPoint: eddsa4.Point, CURVE: c });
  return legacy;
}
function twistedEdwards3(c) {
  const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new3(c);
  const Point2 = edwards3(CURVE, curveOpts);
  const EDDSA = eddsa3(Point2, eddsaOpts);
  return _eddsa_new_output_to_legacy3(c, EDDSA);
}

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n20 = BigInt(0);
var _1n20 = BigInt(1);
var _2n15 = BigInt(2);
var _3n8 = BigInt(3);
var _5n6 = BigInt(5);
var _8n8 = BigInt(8);
var ed25519_CURVE3 = {
  p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n8,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function ed25519_pow_2_252_33(x2) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P3 = ed25519_CURVE3.p;
  const x22 = x2 * x2 % P3;
  const b22 = x22 * x2 % P3;
  const b4 = pow25(b22, _2n15, P3) * b22 % P3;
  const b5 = pow25(b4, _1n20, P3) * x2 % P3;
  const b10 = pow25(b5, _5n6, P3) * b5 % P3;
  const b20 = pow25(b10, _10n, P3) * b10 % P3;
  const b40 = pow25(b20, _20n, P3) * b20 % P3;
  const b80 = pow25(b40, _40n, P3) * b40 % P3;
  const b160 = pow25(b80, _80n, P3) * b80 % P3;
  const b240 = pow25(b160, _80n, P3) * b80 % P3;
  const b250 = pow25(b240, _10n, P3) * b10 % P3;
  const pow_p_5_8 = pow25(b250, _2n15, P3) * x2 % P3;
  return { pow_p_5_8, b2: b22 };
}
function adjustScalarBytes3(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
var ED25519_SQRT_M13 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio3(u, v) {
  const P3 = ed25519_CURVE3.p;
  const v33 = mod5(v * v * v, P3);
  const v7 = mod5(v33 * v33 * v, P3);
  const pow3 = ed25519_pow_2_252_33(u * v7).pow_p_5_8;
  let x2 = mod5(u * v33 * pow3, P3);
  const vx2 = mod5(v * x2 * x2, P3);
  const root1 = x2;
  const root2 = mod5(x2 * ED25519_SQRT_M13, P3);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod5(-u, P3);
  const noRoot = vx2 === mod5(-u * ED25519_SQRT_M13, P3);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (isNegativeLE3(x2, P3))
    x2 = mod5(-x2, P3);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
var Fp4 = /* @__PURE__ */ (() => Field4(ed25519_CURVE3.p, undefined, true))();
var ed25519Defaults3 = /* @__PURE__ */ (() => ({
  ...ed25519_CURVE3,
  Fp: Fp4,
  hash: sha5123,
  adjustScalarBytes: adjustScalarBytes3,
  uvRatio: uvRatio3
}))();
var ed255193 = /* @__PURE__ */ (() => twistedEdwards3(ed25519Defaults3))();

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/lib/index.browser.esm.js
var import_bn5 = __toESM(require_bn(), 1);
var import_bs584 = __toESM(require_bs584(), 1);
var import_borsh3 = __toESM(require_lib(), 1);
var BufferLayout3 = __toESM(require_Layout(), 1);
var import_buffer_layout10 = __toESM(require_Layout(), 1);
var import_browser3 = __toESM(require_browser2(), 1);

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts3(opts) {
  if (opts.lowS !== undefined)
    abool3("lowS", opts.lowS);
  if (opts.prehash !== undefined)
    abool3("prehash", opts.prehash);
}

class DERErr4 extends Error {
  constructor(m = "") {
    super(m);
  }
}
var DER4 = {
  Err: DERErr4,
  _tlv: {
    encode: (tag2, data) => {
      const { Err: E2 } = DER4;
      if (tag2 < 0 || tag2 > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E2("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len2 = numberToHexUnpadded4(dataLen);
      if (len2.length / 2 & 128)
        throw new E2("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded4(len2.length / 2 | 128) : "";
      const t = numberToHexUnpadded4(tag2);
      return t + lenLen + len2 + data;
    },
    decode(tag2, data) {
      const { Err: E2 } = DER4;
      let pos = 0;
      if (tag2 < 0 || tag2 > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag2)
        throw new E2("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E2("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E2("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E2("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E2("tlv.decode(long): zero leftmost byte");
        for (const b3 of lengthBytes)
          length = length << 8 | b3;
        pos += lenLen;
        if (length < 128)
          throw new E2("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length);
      if (v.length !== length)
        throw new E2("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length) };
    }
  },
  _int: {
    encode(num) {
      const { Err: E2 } = DER4;
      if (num < _0n21)
        throw new E2("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded4(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E2("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E2 } = DER4;
      if (data[0] & 128)
        throw new E2("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E2("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE4(data);
    }
  },
  toSig(hex) {
    const { Err: E2, _int: int, _tlv: tlv } = DER4;
    const data = ensureBytes4("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER4;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq2 = rs + ss;
    return tlv.encode(48, seq2);
  }
};
var _0n21 = BigInt(0);
var _1n21 = BigInt(1);
var _2n16 = BigInt(2);
var _3n9 = BigInt(3);
var _4n7 = BigInt(4);
function _legacyHelperEquat3(Fp5, a, b3) {
  function weierstrassEquation(x2) {
    const x22 = Fp5.sqr(x2);
    const x3 = Fp5.mul(x22, x2);
    return Fp5.add(Fp5.add(x3, Fp5.mul(x2, a)), b3);
  }
  return weierstrassEquation;
}
function _legacyHelperNormPriv3(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
  const { BYTES: expected } = Fn;
  function normPrivateKeyToScalar(key) {
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else {
      let bytes2 = ensureBytes4("private key", key);
      if (allowedPrivateKeyLengths) {
        if (!allowedPrivateKeyLengths.includes(bytes2.length * 2))
          throw new Error("invalid private key");
        const padded = new Uint8Array(expected);
        padded.set(bytes2, padded.length - bytes2.length);
        bytes2 = padded;
      }
      try {
        num = Fn.fromBytes(bytes2);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (wrapPrivateKey)
      num = Fn.create(num);
    if (!Fn.isValidNot0(num))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num;
  }
  return normPrivateKeyToScalar;
}
function weierstrassN3(CURVE, curveOpts = {}) {
  const { Fp: Fp5, Fn } = _createCurveFields3("weierstrass", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject3(curveOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = curveOpts;
  if (endo) {
    if (!Fp5.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
  }
  function assertCompressionIsSupported() {
    if (!Fp5.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes(_c, point, isCompressed) {
    const { x: x2, y } = point.toAffine();
    const bx = Fp5.toBytes(x2);
    abool3("isCompressed", isCompressed);
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp5.isOdd(y);
      return concatBytes3(pprefix3(hasEvenY), bx);
    } else {
      return concatBytes3(Uint8Array.of(4), bx, Fp5.toBytes(y));
    }
  }
  function pointFromBytes(bytes2) {
    abytes(bytes2);
    const L = Fp5.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    const length = bytes2.length;
    const head = bytes2[0];
    const tail = bytes2.subarray(1);
    if (length === LC && (head === 2 || head === 3)) {
      const x2 = Fp5.fromBytes(tail);
      if (!Fp5.isValid(x2))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x2);
      let y;
      try {
        y = Fp5.sqrt(y2);
      } catch (sqrtError) {
        const err2 = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err2);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp5.isOdd(y);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp5.neg(y);
      return { x: x2, y };
    } else if (length === LU && head === 4) {
      const x2 = Fp5.fromBytes(tail.subarray(L * 0, L * 1));
      const y = Fp5.fromBytes(tail.subarray(L * 1, L * 2));
      if (!isValidXY(x2, y))
        throw new Error("bad point: is not on curve");
      return { x: x2, y };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`);
    }
  }
  const toBytes4 = curveOpts.toBytes || pointToBytes;
  const fromBytes = curveOpts.fromBytes || pointFromBytes;
  const weierstrassEquation = _legacyHelperEquat3(Fp5, CURVE.a, CURVE.b);
  function isValidXY(x2, y) {
    const left = Fp5.sqr(y);
    const right = weierstrassEquation(x2);
    return Fp5.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp5.mul(Fp5.pow(CURVE.a, _3n9), _4n7);
  const _27b2 = Fp5.mul(Fp5.sqr(CURVE.b), BigInt(27));
  if (Fp5.is0(Fp5.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp5.isValid(n2) || banZero && Fp5.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized3((p, iz) => {
    const { px: x2, py: y, pz: z } = p;
    if (Fp5.eql(z, Fp5.ONE))
      return { x: x2, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp5.ONE : Fp5.inv(z);
    const ax = Fp5.mul(x2, iz);
    const ay = Fp5.mul(y, iz);
    const zz = Fp5.mul(z, iz);
    if (is0)
      return { x: Fp5.ZERO, y: Fp5.ZERO };
    if (!Fp5.eql(zz, Fp5.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized3((p) => {
    if (p.is0()) {
      if (curveOpts.allowInfinityPoint && !Fp5.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y } = p.toAffine();
    if (!Fp5.isValid(x2) || !Fp5.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x2, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp5.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
    k1p = negateCt3(k1neg, k1p);
    k2p = negateCt3(k2neg, k2p);
    return k1p.add(k2p);
  }

  class Point2 {
    constructor(px, py, pz) {
      this.px = acoord("x", px);
      this.py = acoord("y", py, true);
      this.pz = acoord("z", pz);
      Object.freeze(this);
    }
    static fromAffine(p) {
      const { x: x2, y } = p || {};
      if (!p || !Fp5.isValid(x2) || !Fp5.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp5.is0(x2) && Fp5.is0(y))
        return Point2.ZERO;
      return new Point2(x2, y, Fp5.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      return normalizeZ3(Point2, "pz", points);
    }
    static fromBytes(bytes2) {
      abytes(bytes2);
      return Point2.fromHex(bytes2);
    }
    static fromHex(hex) {
      const P3 = Point2.fromAffine(fromBytes(ensureBytes4("pointHex", hex)));
      P3.assertValidity();
      return P3;
    }
    static fromPrivateKey(privateKey) {
      const normPrivateKeyToScalar = _legacyHelperNormPriv3(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    static msm(points, scalars) {
      return pippenger3(Point2, Fn, points, scalars);
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_3n9);
      return this;
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp5.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp5.isOdd(y);
    }
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp5.eql(Fp5.mul(X1, Z2), Fp5.mul(X2, Z1));
      const U22 = Fp5.eql(Fp5.mul(Y1, Z2), Fp5.mul(Y2, Z1));
      return U12 && U22;
    }
    negate() {
      return new Point2(this.px, Fp5.neg(this.py), this.pz);
    }
    double() {
      const { a, b: b3 } = CURVE;
      const b32 = Fp5.mul(b3, _3n9);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp5;
      let t0 = Fp5.mul(X1, X1);
      let t1 = Fp5.mul(Y1, Y1);
      let t2 = Fp5.mul(Z1, Z1);
      let t3 = Fp5.mul(X1, Y1);
      t3 = Fp5.add(t3, t3);
      Z3 = Fp5.mul(X1, Z1);
      Z3 = Fp5.add(Z3, Z3);
      X3 = Fp5.mul(a, Z3);
      Y3 = Fp5.mul(b32, t2);
      Y3 = Fp5.add(X3, Y3);
      X3 = Fp5.sub(t1, Y3);
      Y3 = Fp5.add(t1, Y3);
      Y3 = Fp5.mul(X3, Y3);
      X3 = Fp5.mul(t3, X3);
      Z3 = Fp5.mul(b32, Z3);
      t2 = Fp5.mul(a, t2);
      t3 = Fp5.sub(t0, t2);
      t3 = Fp5.mul(a, t3);
      t3 = Fp5.add(t3, Z3);
      Z3 = Fp5.add(t0, t0);
      t0 = Fp5.add(Z3, t0);
      t0 = Fp5.add(t0, t2);
      t0 = Fp5.mul(t0, t3);
      Y3 = Fp5.add(Y3, t0);
      t2 = Fp5.mul(Y1, Z1);
      t2 = Fp5.add(t2, t2);
      t0 = Fp5.mul(t2, t3);
      X3 = Fp5.sub(X3, t0);
      Z3 = Fp5.mul(t2, t1);
      Z3 = Fp5.add(Z3, Z3);
      Z3 = Fp5.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp5;
      const a = CURVE.a;
      const b3 = Fp5.mul(CURVE.b, _3n9);
      let t0 = Fp5.mul(X1, X2);
      let t1 = Fp5.mul(Y1, Y2);
      let t2 = Fp5.mul(Z1, Z2);
      let t3 = Fp5.add(X1, Y1);
      let t4 = Fp5.add(X2, Y2);
      t3 = Fp5.mul(t3, t4);
      t4 = Fp5.add(t0, t1);
      t3 = Fp5.sub(t3, t4);
      t4 = Fp5.add(X1, Z1);
      let t5 = Fp5.add(X2, Z2);
      t4 = Fp5.mul(t4, t5);
      t5 = Fp5.add(t0, t2);
      t4 = Fp5.sub(t4, t5);
      t5 = Fp5.add(Y1, Z1);
      X3 = Fp5.add(Y2, Z2);
      t5 = Fp5.mul(t5, X3);
      X3 = Fp5.add(t1, t2);
      t5 = Fp5.sub(t5, X3);
      Z3 = Fp5.mul(a, t4);
      X3 = Fp5.mul(b3, t2);
      Z3 = Fp5.add(X3, Z3);
      X3 = Fp5.sub(t1, Z3);
      Z3 = Fp5.add(t1, Z3);
      Y3 = Fp5.mul(X3, Z3);
      t1 = Fp5.add(t0, t0);
      t1 = Fp5.add(t1, t0);
      t2 = Fp5.mul(a, t2);
      t4 = Fp5.mul(b3, t4);
      t1 = Fp5.add(t1, t2);
      t2 = Fp5.sub(t0, t2);
      t2 = Fp5.mul(a, t2);
      t4 = Fp5.add(t4, t2);
      t0 = Fp5.mul(t1, t4);
      Y3 = Fp5.add(Y3, t0);
      t0 = Fp5.mul(t5, t4);
      X3 = Fp5.mul(t3, X3);
      X3 = Fp5.sub(X3, t0);
      t0 = Fp5.mul(t3, t1);
      Z3 = Fp5.mul(t5, Z3);
      Z3 = Fp5.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    multiply(scalar) {
      const { endo: endo2 } = curveOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul2 = (n2) => wnaf.wNAFCached(this, n2, Point2.normalizeZ);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
        const { p: k1p, f: k1f } = mul2(k1);
        const { p: k2p, f: k2f } = mul2(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f: f4 } = mul2(scalar);
        point = p;
        fake = f4;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    multiplyUnsafe(sc) {
      const { endo: endo2 } = curveOpts;
      const p = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n21 || p.is0())
        return Point2.ZERO;
      if (sc === _1n21)
        return p;
      if (wnaf.hasPrecomputes(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
        const { p1, p2 } = mulEndoUnsafe3(Point2, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.wNAFCachedUnsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b3) {
      const sum2 = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b3));
      return sum2.is0() ? undefined : sum2;
    }
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    isTorsionFree() {
      const { isTorsionFree } = curveOpts;
      if (cofactor === _1n21)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = curveOpts;
      if (cofactor === _1n21)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    toBytes(isCompressed = true) {
      abool3("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes4(Point2, this, isCompressed);
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp5.ONE);
  Point2.ZERO = new Point2(Fp5.ZERO, Fp5.ONE, Fp5.ZERO);
  Point2.Fp = Fp5;
  Point2.Fn = Fn;
  const bits = Fn.BITS;
  const wnaf = wNAF4(Point2, curveOpts.endo ? Math.ceil(bits / 2) : bits);
  return Point2;
}
function pprefix3(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function ecdsa3(Point2, ecdsaOpts, curveOpts = {}) {
  _validateObject3(ecdsaOpts, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes4;
  const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac2(ecdsaOpts.hash, key, concatBytes3(...msgs)));
  const { Fp: Fp5, Fn } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  function isBiggerThanHalfOrder(number4) {
    const HALF = CURVE_ORDER >> _1n21;
    return number4 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
  }
  function aValidRS(title, num) {
    if (!Fn.isValidNot0(num))
      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
  }

  class Signature2 {
    constructor(r, s, recovery) {
      aValidRS("r", r);
      aValidRS("s", s);
      this.r = r;
      this.s = s;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromCompact(hex) {
      const L = Fn.BYTES;
      const b3 = ensureBytes4("compactSignature", hex, L * 2);
      return new Signature2(Fn.fromBytes(b3.subarray(0, L)), Fn.fromBytes(b3.subarray(L, L * 2)));
    }
    static fromDER(hex) {
      const { r, s } = DER4.toSig(ensureBytes4("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {}
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const FIELD_ORDER = Fp5.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n16 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp5.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x2 = Fp5.toBytes(radj);
      const R = Point2.fromHex(concatBytes3(pprefix3((rec & 1) === 0), x2));
      const ir = Fn.inv(radj);
      const h = bits2int_modN(ensureBytes4("msgHash", msgHash));
      const u1 = Fn.create(-h * ir);
      const u2 = Fn.create(s * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, Fn.neg(this.s), this.recovery) : this;
    }
    toBytes(format) {
      if (format === "compact")
        return concatBytes3(Fn.toBytes(this.r), Fn.toBytes(this.s));
      if (format === "der")
        return hexToBytes2(DER4.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex2(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex2(this.toBytes("compact"));
    }
  }
  const normPrivateKeyToScalar = _legacyHelperNormPriv3(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const n2 = CURVE_ORDER;
      return mapHashToField4(randomBytes_(getMinHashLength4(n2)), n2);
    },
    precompute(windowSize = 8, point = Point2.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function getPublicKey3(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point2)
      return true;
    const arr = ensureBytes4("key", item);
    const length = arr.length;
    const L = Fp5.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
      return;
    } else {
      return length === LC || length === LU;
    }
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicB) === false)
      throw new Error("second arg must be public key");
    const b3 = Point2.fromHex(publicB);
    return b3.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
  }
  const bits2int = ecdsaOpts.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE4(bytes2);
    const delta = bytes2.length * 8 - fnBits;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes2) {
    return Fn.create(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask4(fnBits);
  function int2octets(num) {
    aInRange3("num < 2^" + fnBits, num, _0n21, ORDER_MASK);
    return Fn.toBytes(num);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2 } = ecdsaOpts;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes4("msgHash", msgHash);
    validateSigVerOpts3(opts);
    if (prehash)
      msgHash = ensureBytes4("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes_(Fp5.BYTES) : ent;
      seedArgs.push(ensureBytes4("extraEntropy", e));
    }
    const seed2 = concatBytes3(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = Fn.create(q.x);
      if (r === _0n21)
        return;
      const s = Fn.create(ik * Fn.create(m + r * d));
      if (s === _0n21)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n21);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed: seed2, k2sig };
  }
  const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  function sign4(msgHash, privKey, opts = defaultSigOpts) {
    const { seed: seed2, k2sig } = prepSig(msgHash, privKey, opts);
    const drbg = createHmacDrbg4(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
    return drbg(seed2, k2sig);
  }
  Point2.BASE.precompute(8);
  function verify3(signature, msgHash, publicKey6, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes4("msgHash", msgHash);
    publicKey6 = ensureBytes4("publicKey", publicKey6);
    validateSigVerOpts3(opts);
    const { lowS, prehash, format } = opts;
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== undefined && !["compact", "der", "js"].includes(format))
      throw new Error('format must be "compact", "der" or "js"');
    const isHex2 = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex2 && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex2 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = undefined;
    let P3;
    try {
      if (isObj) {
        if (format === undefined || format === "js") {
          _sig = new Signature2(sg.r, sg.s);
        } else {
          throw new Error("invalid format");
        }
      }
      if (isHex2) {
        try {
          if (format !== "compact")
            _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER4.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature2.fromCompact(sg);
      }
      P3 = Point2.fromHex(publicKey6);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = ecdsaOpts.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is4 = Fn.inv(s);
    const u1 = Fn.create(h * is4);
    const u2 = Fn.create(r * is4);
    const R = Point2.BASE.multiplyUnsafe(u1).add(P3.multiplyUnsafe(u2));
    if (R.is0())
      return false;
    const v = Fn.create(R.x);
    return v === r;
  }
  return Object.freeze({
    getPublicKey: getPublicKey3,
    getSharedSecret,
    sign: sign4,
    verify: verify3,
    utils,
    Point: Point2,
    Signature: Signature2
  });
}
function _weierstrass_legacy_opts_to_new3(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp5 = c.Fp;
  const Fn = Field4(CURVE.n, c.nBitLength);
  const curveOpts = {
    Fp: Fp5,
    Fn,
    allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    wrapPrivateKey: c.wrapPrivateKey,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new3(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new3(c);
  const ecdsaOpts = {
    hash: c.hash,
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy3(c, ecdsa4) {
  return Object.assign({}, ecdsa4, {
    ProjectivePoint: ecdsa4.Point,
    CURVE: c
  });
}
function weierstrass4(c) {
  const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new3(c);
  const Point2 = weierstrassN3(CURVE, curveOpts);
  const signs = ecdsa3(Point2, ecdsaOpts, curveOpts);
  return _ecdsa_new_output_to_legacy3(c, signs);
}

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function createCurve4(curveDef, defHash) {
  const create5 = (hash2) => weierstrass4({ ...curveDef, hash: hash2 });
  return { ...create5(defHash), create: create5 };
}

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var secp256k1_CURVE3 = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var _0n23 = BigInt(0);
var _1n23 = BigInt(1);
var _2n17 = BigInt(2);
var divNearest4 = (a, b3) => (a + b3 / _2n17) / b3;
function sqrtMod4(y) {
  const P3 = secp256k1_CURVE3.p;
  const _3n10 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y * y * y % P3;
  const b3 = b22 * b22 * y % P3;
  const b6 = pow25(b3, _3n10, P3) * b3 % P3;
  const b9 = pow25(b6, _3n10, P3) * b3 % P3;
  const b11 = pow25(b9, _2n17, P3) * b22 % P3;
  const b222 = pow25(b11, _11n, P3) * b11 % P3;
  const b44 = pow25(b222, _22n, P3) * b222 % P3;
  const b88 = pow25(b44, _44n, P3) * b44 % P3;
  const b176 = pow25(b88, _88n, P3) * b88 % P3;
  const b220 = pow25(b176, _44n, P3) * b44 % P3;
  const b223 = pow25(b220, _3n10, P3) * b3 % P3;
  const t1 = pow25(b223, _23n, P3) * b222 % P3;
  const t2 = pow25(t1, _6n, P3) * b22 % P3;
  const root = pow25(t2, _2n17, P3);
  if (!Fpk13.eql(Fpk13.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk13 = Field4(secp256k1_CURVE3.p, undefined, undefined, { sqrt: sqrtMod4 });
var secp256k14 = createCurve4({
  ...secp256k1_CURVE3,
  Fp: Fpk13,
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n2 = secp256k1_CURVE3.n;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n23 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest4(b22 * k, n2);
      const c2 = divNearest4(-b1 * k, n2);
      let k1 = mod5(k - c1 * a1 - c2 * a2, n2);
      let k2 = mod5(-c1 * b1 - c2 * b22, n2);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n2 - k1;
      if (k2neg)
        k2 = n2 - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2563);

// node_modules/@solana/buffer-layout-utils/node_modules/@solana/web3.js/lib/index.browser.esm.js
var generatePrivateKey3 = ed255193.utils.randomPrivateKey;
var generateKeypair3 = () => {
  const privateScalar = ed255193.utils.randomPrivateKey();
  const publicKey6 = getPublicKey3(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey6, 32);
  return {
    publicKey: publicKey6,
    secretKey
  };
};
var getPublicKey3 = ed255193.getPublicKey;
function isOnCurve3(publicKey6) {
  try {
    ed255193.ExtendedPoint.fromHex(publicKey6);
    return true;
  } catch {
    return false;
  }
}
var sign4 = (message, secretKey) => ed255193.sign(message, secretKey.slice(0, 32));
var verify3 = ed255193.verify;
var toBuffer3 = (arr) => {
  if (Buffer2.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return Buffer2.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return Buffer2.from(arr);
  }
};

class Struct6 {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return Buffer2.from(import_borsh3.serialize(SOLANA_SCHEMA3, this));
  }
  static decode(data) {
    return import_borsh3.deserialize(SOLANA_SCHEMA3, this, data);
  }
  static decodeUnchecked(data) {
    return import_borsh3.deserializeUnchecked(SOLANA_SCHEMA3, this, data);
  }
}
var SOLANA_SCHEMA3 = new Map;
var _PublicKey3;
var MAX_SEED_LENGTH3 = 32;
var PUBLIC_KEY_LENGTH3 = 32;
function isPublicKeyData3(value) {
  return value._bn !== undefined;
}
var uniquePublicKeyCounter3 = 1;

class PublicKey3 extends Struct6 {
  constructor(value) {
    super({});
    this._bn = undefined;
    if (isPublicKeyData3(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs584.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH3) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn5.default(decoded);
      } else {
        this._bn = new import_bn5.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH3) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  static unique() {
    const key = new PublicKey3(uniquePublicKeyCounter3);
    uniquePublicKeyCounter3 += 1;
    return new PublicKey3(key.toBuffer());
  }
  equals(publicKey6) {
    return this._bn.eq(publicKey6._bn);
  }
  toBase58() {
    return import_bs584.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  toBuffer() {
    const b3 = this._bn.toArrayLike(Buffer2);
    if (b3.length === PUBLIC_KEY_LENGTH3) {
      return b3;
    }
    const zeroPad2 = Buffer2.alloc(32);
    b3.copy(zeroPad2, 32 - b3.length);
    return zeroPad2;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  toString() {
    return this.toBase58();
  }
  static async createWithSeed(fromPublicKey, seed2, programId) {
    const buffer = Buffer2.concat([fromPublicKey.toBuffer(), Buffer2.from(seed2), programId.toBuffer()]);
    const publicKeyBytes = sha2564(buffer);
    return new PublicKey3(publicKeyBytes);
  }
  static createProgramAddressSync(seeds, programId) {
    let buffer = Buffer2.alloc(0);
    seeds.forEach(function(seed2) {
      if (seed2.length > MAX_SEED_LENGTH3) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = Buffer2.concat([buffer, toBuffer3(seed2)]);
    });
    buffer = Buffer2.concat([buffer, programId.toBuffer(), Buffer2.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha2564(buffer);
    if (isOnCurve3(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey3(publicKeyBytes);
  }
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(Buffer2.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err2) {
        if (err2 instanceof TypeError) {
          throw err2;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey3(pubkeyData);
    return isOnCurve3(pubkey.toBytes());
  }
}
_PublicKey3 = PublicKey3;
PublicKey3.default = new _PublicKey3("11111111111111111111111111111111");
SOLANA_SCHEMA3.set(PublicKey3, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var BPF_LOADER_DEPRECATED_PROGRAM_ID3 = new PublicKey3("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE3 = 1280 - 40 - 8;
var VERSION_PREFIX_MASK3 = 127;
var SIGNATURE_LENGTH_IN_BYTES3 = 64;

class TransactionExpiredBlockheightExceededError3 extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: block height exceeded.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError3.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});

class TransactionExpiredTimeoutError3 extends Error {
  constructor(signature, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + "unknown if it succeeded or failed. Check signature " + `${signature} using the Solana Explorer or CLI tools.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError3.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});

class TransactionExpiredNonceInvalidError3 extends Error {
  constructor(signature) {
    super(`Signature ${signature} has expired: the nonce is no longer valid.`);
    this.signature = undefined;
    this.signature = signature;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError3.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});

class MessageAccountKeys3 {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = undefined;
    this.accountKeysFromLookups = undefined;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = new Map;
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === undefined)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}
var publicKey6 = (property = "publicKey") => {
  return BufferLayout3.blob(32, property);
};
var rustString3 = (property = "string") => {
  const rsl = BufferLayout3.struct([BufferLayout3.u32("length"), BufferLayout3.u32("lengthPadding"), BufferLayout3.blob(BufferLayout3.offset(BufferLayout3.u32(), -8), "chars")], property);
  const _decode2 = rsl.decode.bind(rsl);
  const _encode2 = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b3, offset4) => {
    const data = _decode2(b3, offset4);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b3, offset4) => {
    const data = {
      chars: Buffer2.from(str, "utf8")
    };
    return _encode2(data, b3, offset4);
  };
  rslShim.alloc = (str) => {
    return BufferLayout3.u32().span + BufferLayout3.u32().span + Buffer2.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized3 = (property = "authorized") => {
  return BufferLayout3.struct([publicKey6("staker"), publicKey6("withdrawer")], property);
};
var lockup3 = (property = "lockup") => {
  return BufferLayout3.struct([BufferLayout3.ns64("unixTimestamp"), BufferLayout3.ns64("epoch"), publicKey6("custodian")], property);
};
var voteInit3 = (property = "voteInit") => {
  return BufferLayout3.struct([publicKey6("nodePubkey"), publicKey6("authorizedVoter"), publicKey6("authorizedWithdrawer"), BufferLayout3.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs3 = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout3.struct([BufferLayout3.u32("voteAuthorizationType"), publicKey6("currentAuthorityDerivedKeyOwnerPubkey"), rustString3("currentAuthorityDerivedKeySeed"), publicKey6("newAuthorized")], property);
};
function getAlloc3(type4, fields2) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields2[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields2[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc3({
        layout: item
      }, fields2[item.property]);
    }
    return 0;
  };
  let alloc2 = 0;
  type4.layout.fields.forEach((item) => {
    alloc2 += getItemAlloc(item);
  });
  return alloc2;
}
function decodeLength3(bytes2) {
  let len2 = 0;
  let size = 0;
  for (;; ) {
    let elem = bytes2.shift();
    len2 |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len2;
}
function encodeLength3(bytes2, len2) {
  let rem_len = len2;
  for (;; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem);
      break;
    } else {
      elem |= 128;
      bytes2.push(elem);
    }
  }
}
function assert7(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

class CompiledKeys3 {
  constructor(payer, keyMetaMap) {
    this.payer = undefined;
    this.keyMetaMap = undefined;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = new Map;
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === undefined) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner ||= accountMeta.isSigner;
        keyMeta.isWritable ||= accountMeta.isWritable;
      }
    }
    return new CompiledKeys3(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert7(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert7(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert7(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey3(address)), ...readonlySigners.map(([address]) => new PublicKey3(address)), ...writableNonSigners.map(([address]) => new PublicKey3(address)), ...readonlyNonSigners.map(([address]) => new PublicKey3(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array;
    const drainedKeys = new Array;
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey3(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert7(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}
var END_OF_BUFFER_ERROR_MESSAGE3 = "Reached end of buffer unexpectedly";
function guardedShift3(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE3);
  }
  return byteArray.shift();
}
function guardedSplice3(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE3);
  }
  return byteArray.splice(...args);
}

class Message3 {
  constructor(args) {
    this.header = undefined;
    this.accountKeys = undefined;
    this.recentBlockhash = undefined;
    this.instructions = undefined;
    this.indexToProgramIds = new Map;
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey3(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs584.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys3(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys3.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys3(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs584.default.encode(ix.data)
    }));
    return new Message3({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength3(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs584.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength3(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength3(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: Buffer2.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: Buffer2.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength3(instructionCount, instructions.length);
    let instructionBuffer = Buffer2.alloc(PACKET_DATA_SIZE3);
    Buffer2.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout3.struct([BufferLayout3.u8("programIdIndex"), BufferLayout3.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout3.seq(BufferLayout3.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout3.blob(instruction.dataLength.length, "dataLength"), BufferLayout3.seq(BufferLayout3.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout3.struct([BufferLayout3.blob(1, "numRequiredSignatures"), BufferLayout3.blob(1, "numReadonlySignedAccounts"), BufferLayout3.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout3.blob(keyCount.length, "keyCount"), BufferLayout3.seq(publicKey6("key"), numKeys, "keys"), publicKey6("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: Buffer2.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: Buffer2.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: Buffer2.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: Buffer2.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer3(key.toBytes())),
      recentBlockhash: import_bs584.default.decode(this.recentBlockhash)
    };
    let signData = Buffer2.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = guardedShift3(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK3)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift3(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift3(byteArray);
    const accountCount = decodeLength3(byteArray);
    let accountKeys = [];
    for (let i4 = 0;i4 < accountCount; i4++) {
      const account = guardedSplice3(byteArray, 0, PUBLIC_KEY_LENGTH3);
      accountKeys.push(new PublicKey3(Buffer2.from(account)));
    }
    const recentBlockhash = guardedSplice3(byteArray, 0, PUBLIC_KEY_LENGTH3);
    const instructionCount = decodeLength3(byteArray);
    let instructions = [];
    for (let i4 = 0;i4 < instructionCount; i4++) {
      const programIdIndex = guardedShift3(byteArray);
      const accountCount2 = decodeLength3(byteArray);
      const accounts = guardedSplice3(byteArray, 0, accountCount2);
      const dataLength2 = decodeLength3(byteArray);
      const dataSlice2 = guardedSplice3(byteArray, 0, dataLength2);
      const data = import_bs584.default.encode(Buffer2.from(dataSlice2));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs584.default.encode(Buffer2.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message3(messageArgs);
  }
}
var DEFAULT_SIGNATURE3 = Buffer2.alloc(SIGNATURE_LENGTH_IN_BYTES3).fill(0);

class TransactionInstruction3 {
  constructor(opts) {
    this.keys = undefined;
    this.programId = undefined;
    this.data = Buffer2.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}

class Transaction4 {
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  constructor(opts) {
    this.signatures = [];
    this.feePayer = undefined;
    this.instructions = [];
    this.recentBlockhash = undefined;
    this.lastValidBlockHeight = undefined;
    this.nonceInfo = undefined;
    this.minNonceContextSlot = undefined;
    this._message = undefined;
    this._json = undefined;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey7
      }) => {
        return publicKey7.toJSON();
      })
    };
  }
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction3(item));
      }
    });
    return this;
  }
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i4 = 0;i4 < instructions.length; i4++) {
      if (instructions[i4].programId === undefined) {
        throw new Error(`Transaction instruction index ${i4} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey3(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x2, y) {
      if (x2.isSigner !== y.isSigner) {
        return x2.isSigner ? -1 : 1;
      }
      if (x2.isWritable !== y.isWritable) {
        return x2.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x2.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x2) => {
      return x2.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.equals(signature.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, " + "only the fee payer and instruction signer accounts should sign a transaction. " + "This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs584.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert7(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert7(keyIndex >= 0));
    });
    return new Message3({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid)
        return message;
    }
    this.signatures = signedKeys.map((publicKey7) => ({
      signature: null,
      publicKey: publicKey7
    }));
    return message;
  }
  serializeMessage() {
    return this._compile().serialize();
  }
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    this.signatures = signers.filter((publicKey7) => {
      const key = publicKey7.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey7) => ({
      signature: null,
      publicKey: publicKey7
    }));
  }
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = new Set;
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature = sign4(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer3(signature));
    });
  }
  addSignature(pubkey, signature) {
    this._compile();
    this._addSignature(pubkey, signature);
  }
  _addSignature(pubkey, signature) {
    assert7(signature.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = Buffer2.from(signature);
  }
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature,
      publicKey: publicKey7
    } of this.signatures) {
      if (signature === null) {
        if (requireAllSignatures) {
          (errors.missing ||= []).push(publicKey7);
        }
      } else {
        if (!verify3(signature, message, publicKey7.toBytes())) {
          (errors.invalid ||= []).push(publicKey7);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : undefined;
  }
  serialize(config2) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config2);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength3(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = Buffer2.alloc(transactionLength);
    assert7(signatures.length < 256);
    Buffer2.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature
    }, index) => {
      if (signature !== null) {
        assert7(signature.length === 64, `signature has invalid length`);
        Buffer2.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert7(wireTransaction.length <= PACKET_DATA_SIZE3, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE3}`);
    return wireTransaction;
  }
  get keys() {
    assert7(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  get programId() {
    assert7(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  get data() {
    assert7(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength3(byteArray);
    let signatures = [];
    for (let i4 = 0;i4 < signatureCount; i4++) {
      const signature = guardedSplice3(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES3);
      signatures.push(import_bs584.default.encode(Buffer2.from(signature)));
    }
    return Transaction4.populate(Message3.from(byteArray), signatures);
  }
  static populate(message, signatures = []) {
    const transaction = new Transaction4;
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature, index) => {
      const sigPubkeyPair = {
        signature: signature == import_bs584.default.encode(DEFAULT_SIGNATURE3) ? null : import_bs584.default.decode(signature),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction3({
        keys,
        programId: message.accountKeys[instruction.programIdIndex],
        data: import_bs584.default.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
}
var NUM_TICKS_PER_SECOND3 = 160;
var DEFAULT_TICKS_PER_SLOT3 = 64;
var NUM_SLOTS_PER_SECOND3 = NUM_TICKS_PER_SECOND3 / DEFAULT_TICKS_PER_SLOT3;
var MS_PER_SLOT3 = 1000 / NUM_SLOTS_PER_SECOND3;
var SYSVAR_CLOCK_PUBKEY3 = new PublicKey3("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY3 = new PublicKey3("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY3 = new PublicKey3("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY3 = new PublicKey3("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY3 = new PublicKey3("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY3 = new PublicKey3("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY3 = new PublicKey3("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY3 = new PublicKey3("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY3 = new PublicKey3("SysvarStakeHistory1111111111111111111111111");

class SendTransactionError3 extends Error {
  constructor({
    action,
    signature,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature} resulted in an error. 
` + `${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${((a) => a)(action)}'`;
      }
    }
    super(message);
    this.signature = undefined;
    this.transactionMessage = undefined;
    this.transactionLogs = undefined;
    this.signature = signature;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : undefined;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined
    };
  }
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
}
async function sendAndConfirmTransaction3(connection, transaction, signers, options) {
  const sendOptions = options && {
    skipPreflight: options.skipPreflight,
    preflightCommitment: options.preflightCommitment || options.commitment,
    maxRetries: options.maxRetries,
    minContextSlot: options.minContextSlot
  };
  const signature = await connection.sendTransaction(transaction, signers, sendOptions);
  let status;
  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      signature,
      blockhash: transaction.recentBlockhash,
      lastValidBlockHeight: transaction.lastValidBlockHeight
    }, options && options.commitment)).value;
  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
    const {
      nonceInstruction
    } = transaction.nonceInfo;
    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
    status = (await connection.confirmTransaction({
      abortSignal: options?.abortSignal,
      minContextSlot: transaction.minNonceContextSlot,
      nonceAccountPubkey,
      nonceValue: transaction.nonceInfo.nonce,
      signature
    }, options && options.commitment)).value;
  } else {
    if (options?.abortSignal != null) {
      console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was " + "supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` " + "or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
    }
    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
  }
  if (status.err) {
    if (signature != null) {
      throw new SendTransactionError3({
        action: "send",
        signature,
        transactionMessage: `Status: (${JSON.stringify(status)})`
      });
    }
    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
  }
  return signature;
}
function sleep3(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function encodeData3(type4, fields2) {
  const allocLength = type4.layout.span >= 0 ? type4.layout.span : getAlloc3(type4, fields2);
  const data = Buffer2.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type4.index
  }, fields2);
  type4.layout.encode(layoutFields, data);
  return data;
}
var FeeCalculatorLayout3 = BufferLayout3.nu64("lamportsPerSignature");
var NonceAccountLayout3 = BufferLayout3.struct([BufferLayout3.u32("version"), BufferLayout3.u32("state"), publicKey6("authorizedPubkey"), publicKey6("nonce"), BufferLayout3.struct([FeeCalculatorLayout3], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH3 = NonceAccountLayout3.span;
function u648(property) {
  const layout = import_buffer_layout10.blob(8, property);
  const decode4 = layout.decode.bind(layout);
  const encode2 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec();
  bigIntLayout.decode = (buffer, offset4) => {
    const src = decode4(buffer, offset4);
    return codec.decode(src);
  };
  bigIntLayout.encode = (bigInt3, buffer, offset4) => {
    const src = codec.encode(bigInt3);
    return encode2(src, buffer, offset4);
  };
  return bigIntLayout;
}
var SYSTEM_INSTRUCTION_LAYOUTS3 = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports"), BufferLayout3.ns64("space"), publicKey6("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), u648("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("base"), rustString3("seed"), BufferLayout3.ns64("lamports"), BufferLayout3.ns64("space"), publicKey6("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("base"), rustString3("seed"), BufferLayout3.ns64("space"), publicKey6("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("base"), rustString3("seed"), publicKey6("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), u648("lamports"), rustString3("seed"), publicKey6("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  }
});

class SystemProgram3 {
  constructor() {}
  static createAccount(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.Create;
    const data = encodeData3(type4, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer3(params.programId.toBuffer())
    });
    return new TransactionInstruction3({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.TransferWithSeed;
      data = encodeData3(type4, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer3(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.Transfer;
      data = encodeData3(type4, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction3({
      keys,
      programId: this.programId,
      data
    });
  }
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.AssignWithSeed;
      data = encodeData3(type4, {
        base: toBuffer3(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer3(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.Assign;
      data = encodeData3(type4, {
        programId: toBuffer3(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction3({
      keys,
      programId: this.programId,
      data
    });
  }
  static createAccountWithSeed(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.CreateWithSeed;
    const data = encodeData3(type4, {
      base: toBuffer3(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer3(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (!params.basePubkey.equals(params.fromPubkey)) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction3({
      keys,
      programId: this.programId,
      data
    });
  }
  static createNonceAccount(params) {
    const transaction = new Transaction4;
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(SystemProgram3.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH3,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram3.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH3,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  static nonceInitialize(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.InitializeNonceAccount;
    const data = encodeData3(type4, {
      authorized: toBuffer3(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY3,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction3(instructionData);
  }
  static nonceAdvance(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.AdvanceNonceAccount;
    const data = encodeData3(type4);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction3(instructionData);
  }
  static nonceWithdraw(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.WithdrawNonceAccount;
    const data = encodeData3(type4, {
      lamports: params.lamports
    });
    return new TransactionInstruction3({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static nonceAuthorize(params) {
    const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.AuthorizeNonceAccount;
    const data = encodeData3(type4, {
      authorized: toBuffer3(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction3({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.AllocateWithSeed;
      data = encodeData3(type4, {
        base: toBuffer3(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer3(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type4 = SYSTEM_INSTRUCTION_LAYOUTS3.Allocate;
      data = encodeData3(type4, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction3({
      keys,
      programId: this.programId,
      data
    });
  }
}
SystemProgram3.programId = new PublicKey3("11111111111111111111111111111111");
var CHUNK_SIZE3 = PACKET_DATA_SIZE3 - 300;

class Loader3 {
  constructor() {}
  static getMinNumSignatures(dataLength2) {
    return 2 * (Math.ceil(dataLength2 / Loader3.chunkSize) + 1 + 1);
  }
  static async load(connection, payer, program, programId, data) {
    {
      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
      const programInfo = await connection.getAccountInfo(program.publicKey, "confirmed");
      let transaction = null;
      if (programInfo !== null) {
        if (programInfo.executable) {
          console.error("Program load failed, account is already executable");
          return false;
        }
        if (programInfo.data.length !== data.length) {
          transaction = transaction || new Transaction4;
          transaction.add(SystemProgram3.allocate({
            accountPubkey: program.publicKey,
            space: data.length
          }));
        }
        if (!programInfo.owner.equals(programId)) {
          transaction = transaction || new Transaction4;
          transaction.add(SystemProgram3.assign({
            accountPubkey: program.publicKey,
            programId
          }));
        }
        if (programInfo.lamports < balanceNeeded) {
          transaction = transaction || new Transaction4;
          transaction.add(SystemProgram3.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: program.publicKey,
            lamports: balanceNeeded - programInfo.lamports
          }));
        }
      } else {
        transaction = new Transaction4().add(SystemProgram3.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: program.publicKey,
          lamports: balanceNeeded > 0 ? balanceNeeded : 1,
          space: data.length,
          programId
        }));
      }
      if (transaction !== null) {
        await sendAndConfirmTransaction3(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
    }
    const dataLayout = BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.u32("offset"), BufferLayout3.u32("bytesLength"), BufferLayout3.u32("bytesLengthPadding"), BufferLayout3.seq(BufferLayout3.u8("byte"), BufferLayout3.offset(BufferLayout3.u32(), -8), "bytes")]);
    const chunkSize = Loader3.chunkSize;
    let offset4 = 0;
    let array5 = data;
    let transactions = [];
    while (array5.length > 0) {
      const bytes2 = array5.slice(0, chunkSize);
      const data2 = Buffer2.alloc(chunkSize + 16);
      dataLayout.encode({
        instruction: 0,
        offset: offset4,
        bytes: bytes2,
        bytesLength: 0,
        bytesLengthPadding: 0
      }, data2);
      const transaction = new Transaction4().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }],
        programId,
        data: data2
      });
      transactions.push(sendAndConfirmTransaction3(connection, transaction, [payer, program], {
        commitment: "confirmed"
      }));
      if (connection._rpcEndpoint.includes("solana.com")) {
        const REQUESTS_PER_SECOND = 4;
        await sleep3(1000 / REQUESTS_PER_SECOND);
      }
      offset4 += chunkSize;
      array5 = array5.slice(chunkSize);
    }
    await Promise.all(transactions);
    {
      const dataLayout2 = BufferLayout3.struct([BufferLayout3.u32("instruction")]);
      const data2 = Buffer2.alloc(dataLayout2.span);
      dataLayout2.encode({
        instruction: 1
      }, data2);
      const transaction = new Transaction4().add({
        keys: [{
          pubkey: program.publicKey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SYSVAR_RENT_PUBKEY3,
          isSigner: false,
          isWritable: false
        }],
        programId,
        data: data2
      });
      const deployCommitment = "processed";
      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {
        preflightCommitment: deployCommitment
      });
      const {
        context,
        value
      } = await connection.confirmTransaction({
        signature: finalizeSignature,
        lastValidBlockHeight: transaction.lastValidBlockHeight,
        blockhash: transaction.recentBlockhash
      }, deployCommitment);
      if (value.err) {
        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
      }
      while (true) {
        try {
          const currentSlot = await connection.getSlot({
            commitment: deployCommitment
          });
          if (currentSlot > context.slot) {
            break;
          }
        } catch {}
        await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT3 / 2)));
      }
    }
    return true;
  }
}
Loader3.chunkSize = CHUNK_SIZE3;
var BPF_LOADER_PROGRAM_ID3 = new PublicKey3("BPFLoader2111111111111111111111111111111111");
var fetchImpl3 = globalThis.fetch;
var LookupTableMetaLayout3 = {
  index: 1,
  layout: BufferLayout3.struct([
    BufferLayout3.u32("typeIndex"),
    u648("deactivationSlot"),
    BufferLayout3.nu64("lastExtendedSlot"),
    BufferLayout3.u8("lastExtendedStartIndex"),
    BufferLayout3.u8(),
    BufferLayout3.seq(publicKey6(), BufferLayout3.offset(BufferLayout3.u8(), -1), "authority")
  ])
};
var PublicKeyFromString3 = coerce(instance(PublicKey3), string(), (value) => new PublicKey3(value));
var RawAccountDataResult3 = tuple([string(), literal("base64")]);
var BufferFromRawAccountData3 = coerce(instance(Buffer2), RawAccountDataResult3, (value) => Buffer2.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS3 = 30 * 1000;
function createRpcResult4(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult4 = createRpcResult4(unknown());
function jsonRpcResult4(schema) {
  return coerce(createRpcResult4(schema), UnknownRpcResult4, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create3(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext4(value) {
  return jsonRpcResult4(type({
    context: type({
      slot: number2()
    }),
    value
  }));
}
function notificationResultAndContext3(value) {
  return type({
    context: type({
      slot: number2()
    }),
    value
  });
}
var GetInflationGovernorResult3 = type({
  foundation: number2(),
  foundationTerm: number2(),
  initial: number2(),
  taper: number2(),
  terminal: number2()
});
var GetInflationRewardResult3 = jsonRpcResult4(array(nullable(type({
  epoch: number2(),
  effectiveSlot: number2(),
  amount: number2(),
  postBalance: number2(),
  commission: optional(nullable(number2()))
}))));
var GetRecentPrioritizationFeesResult3 = array(type({
  slot: number2(),
  prioritizationFee: number2()
}));
var GetInflationRateResult3 = type({
  total: number2(),
  validator: number2(),
  foundation: number2(),
  epoch: number2()
});
var GetEpochInfoResult3 = type({
  epoch: number2(),
  slotIndex: number2(),
  slotsInEpoch: number2(),
  absoluteSlot: number2(),
  blockHeight: optional(number2()),
  transactionCount: optional(number2())
});
var GetEpochScheduleResult3 = type({
  slotsPerEpoch: number2(),
  leaderScheduleSlotOffset: number2(),
  warmup: boolean(),
  firstNormalEpoch: number2(),
  firstNormalSlot: number2()
});
var GetLeaderScheduleResult3 = record(string(), array(number2()));
var TransactionErrorResult3 = nullable(union([type({}), string()]));
var SignatureStatusResult3 = type({
  err: TransactionErrorResult3
});
var SignatureReceivedResult3 = literal("receivedSignature");
var VersionResult3 = type({
  "solana-core": string(),
  "feature-set": optional(number2())
});
var ParsedInstructionStruct3 = type({
  program: string(),
  programId: PublicKeyFromString3,
  parsed: unknown()
});
var PartiallyDecodedInstructionStruct3 = type({
  programId: PublicKeyFromString3,
  accounts: array(PublicKeyFromString3),
  data: string()
});
var SimulatedTransactionResponseStruct4 = jsonRpcResultAndContext4(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number2(),
    data: array(string()),
    rentEpoch: optional(number2())
  }))))),
  unitsConsumed: optional(number2()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number2(),
    instructions: array(union([ParsedInstructionStruct3, PartiallyDecodedInstructionStruct3]))
  }))))
}));
var BlockProductionResponseStruct3 = jsonRpcResultAndContext4(type({
  byIdentity: record(string(), array(number2())),
  range: type({
    firstSlot: number2(),
    lastSlot: number2()
  })
}));
var GetInflationGovernorRpcResult3 = jsonRpcResult4(GetInflationGovernorResult3);
var GetInflationRateRpcResult3 = jsonRpcResult4(GetInflationRateResult3);
var GetRecentPrioritizationFeesRpcResult3 = jsonRpcResult4(GetRecentPrioritizationFeesResult3);
var GetEpochInfoRpcResult3 = jsonRpcResult4(GetEpochInfoResult3);
var GetEpochScheduleRpcResult3 = jsonRpcResult4(GetEpochScheduleResult3);
var GetLeaderScheduleRpcResult3 = jsonRpcResult4(GetLeaderScheduleResult3);
var SlotRpcResult3 = jsonRpcResult4(number2());
var GetSupplyRpcResult3 = jsonRpcResultAndContext4(type({
  total: number2(),
  circulating: number2(),
  nonCirculating: number2(),
  nonCirculatingAccounts: array(PublicKeyFromString3)
}));
var TokenAmountResult3 = type({
  amount: string(),
  uiAmount: nullable(number2()),
  decimals: number2(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult3 = jsonRpcResultAndContext4(array(type({
  address: PublicKeyFromString3,
  amount: string(),
  uiAmount: nullable(number2()),
  decimals: number2(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner3 = jsonRpcResultAndContext4(array(type({
  pubkey: PublicKeyFromString3,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString3,
    lamports: number2(),
    data: BufferFromRawAccountData3,
    rentEpoch: number2()
  })
})));
var ParsedAccountDataResult3 = type({
  program: string(),
  parsed: unknown(),
  space: number2()
});
var GetParsedTokenAccountsByOwner3 = jsonRpcResultAndContext4(array(type({
  pubkey: PublicKeyFromString3,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString3,
    lamports: number2(),
    data: ParsedAccountDataResult3,
    rentEpoch: number2()
  })
})));
var GetLargestAccountsRpcResult3 = jsonRpcResultAndContext4(array(type({
  lamports: number2(),
  address: PublicKeyFromString3
})));
var AccountInfoResult3 = type({
  executable: boolean(),
  owner: PublicKeyFromString3,
  lamports: number2(),
  data: BufferFromRawAccountData3,
  rentEpoch: number2()
});
var KeyedAccountInfoResult3 = type({
  pubkey: PublicKeyFromString3,
  account: AccountInfoResult3
});
var ParsedOrRawAccountData3 = coerce(union([instance(Buffer2), ParsedAccountDataResult3]), union([RawAccountDataResult3, ParsedAccountDataResult3]), (value) => {
  if (Array.isArray(value)) {
    return create3(value, BufferFromRawAccountData3);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult3 = type({
  executable: boolean(),
  owner: PublicKeyFromString3,
  lamports: number2(),
  data: ParsedOrRawAccountData3,
  rentEpoch: number2()
});
var KeyedParsedAccountInfoResult3 = type({
  pubkey: PublicKeyFromString3,
  account: ParsedAccountInfoResult3
});
var StakeActivationResult3 = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number2(),
  inactive: number2()
});
var GetConfirmedSignaturesForAddress2RpcResult3 = jsonRpcResult4(array(type({
  signature: string(),
  slot: number2(),
  err: TransactionErrorResult3,
  memo: nullable(string()),
  blockTime: optional(nullable(number2()))
})));
var GetSignaturesForAddressRpcResult3 = jsonRpcResult4(array(type({
  signature: string(),
  slot: number2(),
  err: TransactionErrorResult3,
  memo: nullable(string()),
  blockTime: optional(nullable(number2()))
})));
var AccountNotificationResult3 = type({
  subscription: number2(),
  result: notificationResultAndContext3(AccountInfoResult3)
});
var ProgramAccountInfoResult3 = type({
  pubkey: PublicKeyFromString3,
  account: AccountInfoResult3
});
var ProgramAccountNotificationResult3 = type({
  subscription: number2(),
  result: notificationResultAndContext3(ProgramAccountInfoResult3)
});
var SlotInfoResult3 = type({
  parent: number2(),
  slot: number2(),
  root: number2()
});
var SlotNotificationResult3 = type({
  subscription: number2(),
  result: SlotInfoResult3
});
var SlotUpdateResult3 = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number2(),
  timestamp: number2()
}), type({
  type: literal("createdBank"),
  parent: number2(),
  slot: number2(),
  timestamp: number2()
}), type({
  type: literal("frozen"),
  slot: number2(),
  timestamp: number2(),
  stats: type({
    numTransactionEntries: number2(),
    numSuccessfulTransactions: number2(),
    numFailedTransactions: number2(),
    maxTransactionsPerEntry: number2()
  })
}), type({
  type: literal("dead"),
  slot: number2(),
  timestamp: number2(),
  err: string()
})]);
var SlotUpdateNotificationResult3 = type({
  subscription: number2(),
  result: SlotUpdateResult3
});
var SignatureNotificationResult3 = type({
  subscription: number2(),
  result: notificationResultAndContext3(union([SignatureStatusResult3, SignatureReceivedResult3]))
});
var RootNotificationResult3 = type({
  subscription: number2(),
  result: number2()
});
var ContactInfoResult3 = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult3 = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number2(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number2(), number2(), number2()])),
  commission: number2(),
  lastVote: number2(),
  rootSlot: nullable(number2())
});
var GetVoteAccounts3 = jsonRpcResult4(type({
  current: array(VoteAccountInfoResult3),
  delinquent: array(VoteAccountInfoResult3)
}));
var ConfirmationStatus3 = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse3 = type({
  slot: number2(),
  confirmations: nullable(number2()),
  err: TransactionErrorResult3,
  confirmationStatus: optional(ConfirmationStatus3)
});
var GetSignatureStatusesRpcResult3 = jsonRpcResultAndContext4(array(nullable(SignatureStatusResponse3)));
var GetMinimumBalanceForRentExemptionRpcResult3 = jsonRpcResult4(number2());
var AddressTableLookupStruct3 = type({
  accountKey: PublicKeyFromString3,
  writableIndexes: array(number2()),
  readonlyIndexes: array(number2())
});
var ConfirmedTransactionResult3 = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number2(),
      numReadonlySignedAccounts: number2(),
      numReadonlyUnsignedAccounts: number2()
    }),
    instructions: array(type({
      accounts: array(number2()),
      data: string(),
      programIdIndex: number2()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct3))
  })
});
var AnnotatedAccountKey3 = type({
  pubkey: PublicKeyFromString3,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult3 = type({
  accountKeys: array(AnnotatedAccountKey3),
  signatures: array(string())
});
var ParsedInstructionResult3 = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString3
});
var RawInstructionResult3 = type({
  accounts: array(PublicKeyFromString3),
  data: string(),
  programId: PublicKeyFromString3
});
var InstructionResult3 = union([RawInstructionResult3, ParsedInstructionResult3]);
var UnknownInstructionResult3 = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction3 = coerce(InstructionResult3, UnknownInstructionResult3, (value) => {
  if ("accounts" in value) {
    return create3(value, RawInstructionResult3);
  } else {
    return create3(value, ParsedInstructionResult3);
  }
});
var ParsedConfirmedTransactionResult3 = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey3),
    instructions: array(ParsedOrRawInstruction3),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct3)))
  })
});
var TokenBalanceResult3 = type({
  accountIndex: number2(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult3
});
var LoadedAddressesResult3 = type({
  writable: array(PublicKeyFromString3),
  readonly: array(PublicKeyFromString3)
});
var ConfirmedTransactionMetaResult3 = type({
  err: TransactionErrorResult3,
  fee: number2(),
  innerInstructions: optional(nullable(array(type({
    index: number2(),
    instructions: array(type({
      accounts: array(number2()),
      data: string(),
      programIdIndex: number2()
    }))
  })))),
  preBalances: array(number2()),
  postBalances: array(number2()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult3))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult3))),
  loadedAddresses: optional(LoadedAddressesResult3),
  computeUnitsConsumed: optional(number2())
});
var ParsedConfirmedTransactionMetaResult3 = type({
  err: TransactionErrorResult3,
  fee: number2(),
  innerInstructions: optional(nullable(array(type({
    index: number2(),
    instructions: array(ParsedOrRawInstruction3)
  })))),
  preBalances: array(number2()),
  postBalances: array(number2()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult3))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult3))),
  loadedAddresses: optional(LoadedAddressesResult3),
  computeUnitsConsumed: optional(number2())
});
var TransactionVersionStruct3 = union([literal(0), literal("legacy")]);
var RewardsResult3 = type({
  pubkey: string(),
  lamports: number2(),
  postBalance: nullable(number2()),
  rewardType: nullable(string()),
  commission: optional(nullable(number2()))
});
var GetBlockRpcResult3 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult3,
    meta: nullable(ConfirmedTransactionMetaResult3),
    version: optional(TransactionVersionStruct3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetNoneModeBlockRpcResult3 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetAccountsModeBlockRpcResult3 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult3,
    meta: nullable(ConfirmedTransactionMetaResult3),
    version: optional(TransactionVersionStruct3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedBlockRpcResult3 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult3,
    meta: nullable(ParsedConfirmedTransactionMetaResult3),
    version: optional(TransactionVersionStruct3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedAccountsModeBlockRpcResult3 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult3,
    meta: nullable(ParsedConfirmedTransactionMetaResult3),
    version: optional(TransactionVersionStruct3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedNoneModeBlockRpcResult3 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetConfirmedBlockRpcResult3 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult3,
    meta: nullable(ConfirmedTransactionMetaResult3)
  })),
  rewards: optional(array(RewardsResult3)),
  blockTime: nullable(number2())
})));
var GetBlockSignaturesRpcResult3 = jsonRpcResult4(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  signatures: array(string()),
  blockTime: nullable(number2())
})));
var GetTransactionRpcResult3 = jsonRpcResult4(nullable(type({
  slot: number2(),
  meta: nullable(ConfirmedTransactionMetaResult3),
  blockTime: optional(nullable(number2())),
  transaction: ConfirmedTransactionResult3,
  version: optional(TransactionVersionStruct3)
})));
var GetParsedTransactionRpcResult3 = jsonRpcResult4(nullable(type({
  slot: number2(),
  transaction: ParsedConfirmedTransactionResult3,
  meta: nullable(ParsedConfirmedTransactionMetaResult3),
  blockTime: optional(nullable(number2())),
  version: optional(TransactionVersionStruct3)
})));
var GetLatestBlockhashRpcResult3 = jsonRpcResultAndContext4(type({
  blockhash: string(),
  lastValidBlockHeight: number2()
}));
var IsBlockhashValidRpcResult3 = jsonRpcResultAndContext4(boolean());
var PerfSampleResult3 = type({
  slot: number2(),
  numTransactions: number2(),
  numSlots: number2(),
  samplePeriodSecs: number2()
});
var GetRecentPerformanceSamplesRpcResult3 = jsonRpcResult4(array(PerfSampleResult3));
var GetFeeCalculatorRpcResult3 = jsonRpcResultAndContext4(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number2()
  })
})));
var RequestAirdropRpcResult3 = jsonRpcResult4(string());
var SendTransactionRpcResult3 = jsonRpcResult4(string());
var LogsResult3 = type({
  err: TransactionErrorResult3,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult3 = type({
  result: notificationResultAndContext3(LogsResult3),
  subscription: number2()
});
class Keypair3 {
  constructor(keypair) {
    this._keypair = undefined;
    this._keypair = keypair ?? generateKeypair3();
  }
  static generate() {
    return new Keypair3(generateKeypair3());
  }
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey7 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey3(privateScalar);
      for (let ii = 0;ii < 32; ii++) {
        if (publicKey7[ii] !== computedPublicKey[ii]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new Keypair3({
      publicKey: publicKey7,
      secretKey
    });
  }
  static fromSeed(seed2) {
    const publicKey7 = getPublicKey3(seed2);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed2);
    secretKey.set(publicKey7, 32);
    return new Keypair3({
      publicKey: publicKey7,
      secretKey
    });
  }
  get publicKey() {
    return new PublicKey3(this._keypair.publicKey);
  }
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS3 = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), u648("recentSlot"), BufferLayout3.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), u648(), BufferLayout3.seq(publicKey6(), BufferLayout3.offset(BufferLayout3.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  }
});
class AddressLookupTableProgram3 {
  constructor() {}
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey3.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder().encode(params.recentSlot)], this.programId);
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.CreateLookupTable;
    const data = encodeData3(type4, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram3.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction3({
      programId: this.programId,
      keys,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.FreezeLookupTable;
    const data = encodeData3(type4);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction3({
      programId: this.programId,
      keys,
      data
    });
  }
  static extendLookupTable(params) {
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.ExtendLookupTable;
    const data = encodeData3(type4, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram3.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction3({
      programId: this.programId,
      keys,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.DeactivateLookupTable;
    const data = encodeData3(type4);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction3({
      programId: this.programId,
      keys,
      data
    });
  }
  static closeLookupTable(params) {
    const type4 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS3.CloseLookupTable;
    const data = encodeData3(type4);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction3({
      programId: this.programId,
      keys,
      data
    });
  }
}
AddressLookupTableProgram3.programId = new PublicKey3("AddressLookupTab1e1111111111111111111111111");
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3 = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u8("instruction"), BufferLayout3.u32("units"), BufferLayout3.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u8("instruction"), BufferLayout3.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout3.struct([BufferLayout3.u8("instruction"), BufferLayout3.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u8("instruction"), u648("microLamports")])
  }
});

class ComputeBudgetProgram3 {
  constructor() {}
  static requestUnits(params) {
    const type4 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3.RequestUnits;
    const data = encodeData3(type4, params);
    return new TransactionInstruction3({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type4 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3.RequestHeapFrame;
    const data = encodeData3(type4, params);
    return new TransactionInstruction3({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type4 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3.SetComputeUnitLimit;
    const data = encodeData3(type4, params);
    return new TransactionInstruction3({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type4 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS3.SetComputeUnitPrice;
    const data = encodeData3(type4, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction3({
      keys: [],
      programId: this.programId,
      data
    });
  }
}
ComputeBudgetProgram3.programId = new PublicKey3("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$13 = 64;
var PUBLIC_KEY_BYTES$13 = 32;
var SIGNATURE_BYTES3 = 64;
var ED25519_INSTRUCTION_LAYOUT3 = BufferLayout3.struct([BufferLayout3.u8("numSignatures"), BufferLayout3.u8("padding"), BufferLayout3.u16("signatureOffset"), BufferLayout3.u16("signatureInstructionIndex"), BufferLayout3.u16("publicKeyOffset"), BufferLayout3.u16("publicKeyInstructionIndex"), BufferLayout3.u16("messageDataOffset"), BufferLayout3.u16("messageDataSize"), BufferLayout3.u16("messageInstructionIndex")]);

class Ed25519Program3 {
  constructor() {}
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey7,
      message,
      signature,
      instructionIndex
    } = params;
    assert7(publicKey7.length === PUBLIC_KEY_BYTES$13, `Public Key must be ${PUBLIC_KEY_BYTES$13} bytes but received ${publicKey7.length} bytes`);
    assert7(signature.length === SIGNATURE_BYTES3, `Signature must be ${SIGNATURE_BYTES3} bytes but received ${signature.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT3.span;
    const signatureOffset = publicKeyOffset + publicKey7.length;
    const messageDataOffset = signatureOffset + signature.length;
    const numSignatures = 1;
    const instructionData = Buffer2.alloc(messageDataOffset + message.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT3.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey7, publicKeyOffset);
    instructionData.fill(signature, signatureOffset);
    instructionData.fill(message, messageDataOffset);
    return new TransactionInstruction3({
      keys: [],
      programId: Ed25519Program3.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message,
      instructionIndex
    } = params;
    assert7(privateKey.length === PRIVATE_KEY_BYTES$13, `Private key must be ${PRIVATE_KEY_BYTES$13} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair3.fromSecretKey(privateKey);
      const publicKey7 = keypair.publicKey.toBytes();
      const signature = sign4(message, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey7,
        message,
        signature,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Ed25519Program3.programId = new PublicKey3("Ed25519SigVerify111111111111111111111111111");
var ecdsaSign3 = (msgHash, privKey) => {
  const signature = secp256k14.sign(msgHash, privKey);
  return [signature.toCompactRawBytes(), signature.recovery];
};
secp256k14.utils.isValidPrivateKey;
var publicKeyCreate3 = secp256k14.getPublicKey;
var PRIVATE_KEY_BYTES3 = 32;
var ETHEREUM_ADDRESS_BYTES3 = 20;
var PUBLIC_KEY_BYTES3 = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE3 = 11;
var SECP256K1_INSTRUCTION_LAYOUT3 = BufferLayout3.struct([BufferLayout3.u8("numSignatures"), BufferLayout3.u16("signatureOffset"), BufferLayout3.u8("signatureInstructionIndex"), BufferLayout3.u16("ethAddressOffset"), BufferLayout3.u8("ethAddressInstructionIndex"), BufferLayout3.u16("messageDataOffset"), BufferLayout3.u16("messageDataSize"), BufferLayout3.u8("messageInstructionIndex"), BufferLayout3.blob(20, "ethAddress"), BufferLayout3.blob(64, "signature"), BufferLayout3.u8("recoveryId")]);

class Secp256k1Program3 {
  constructor() {}
  static publicKeyToEthAddress(publicKey7) {
    assert7(publicKey7.length === PUBLIC_KEY_BYTES3, `Public key must be ${PUBLIC_KEY_BYTES3} bytes but received ${publicKey7.length} bytes`);
    try {
      return Buffer2.from(keccak_2562(toBuffer3(publicKey7))).slice(-ETHEREUM_ADDRESS_BYTES3);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey7,
      message,
      signature,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program3.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program3.publicKeyToEthAddress(publicKey7),
      message,
      signature,
      recoveryId,
      instructionIndex
    });
  }
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message,
      signature,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = Buffer2.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = Buffer2.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert7(ethAddress.length === ETHEREUM_ADDRESS_BYTES3, `Address must be ${ETHEREUM_ADDRESS_BYTES3} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE3;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature.length + 1;
    const numSignatures = 1;
    const instructionData = Buffer2.alloc(SECP256K1_INSTRUCTION_LAYOUT3.span + message.length);
    SECP256K1_INSTRUCTION_LAYOUT3.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer3(signature),
      ethAddress: toBuffer3(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer3(message), SECP256K1_INSTRUCTION_LAYOUT3.span);
    return new TransactionInstruction3({
      keys: [],
      programId: Secp256k1Program3.programId,
      data: instructionData
    });
  }
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message,
      instructionIndex
    } = params;
    assert7(pkey.length === PRIVATE_KEY_BYTES3, `Private key must be ${PRIVATE_KEY_BYTES3} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer3(pkey);
      const publicKey7 = publicKeyCreate3(privateKey, false).slice(1);
      const messageHash = Buffer2.from(keccak_2562(toBuffer3(message)));
      const [signature, recoveryId] = ecdsaSign3(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey7,
        message,
        signature,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
}
Secp256k1Program3.programId = new PublicKey3("KeccakSecp256k11111111111111111111111111111");
var _Lockup3;
var STAKE_CONFIG_ID3 = new PublicKey3("StakeConfig11111111111111111111111111111111");
class Lockup3 {
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = undefined;
    this.epoch = undefined;
    this.custodian = undefined;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
}
_Lockup3 = Lockup3;
Lockup3.default = new _Lockup3(0, 0, PublicKey3.default);
var STAKE_INSTRUCTION_LAYOUTS3 = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), authorized3(), lockup3()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("newAuthorized"), BufferLayout3.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("newAuthorized"), BufferLayout3.u32("stakeAuthorizationType"), rustString3("authoritySeed"), publicKey6("authorityOwner")])
  }
});
var StakeAuthorizationLayout3 = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class StakeProgram3 {
  constructor() {}
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized4,
      lockup: maybeLockup
    } = params;
    const lockup4 = maybeLockup || Lockup3.default;
    const type4 = STAKE_INSTRUCTION_LAYOUTS3.Initialize;
    const data = encodeData3(type4, {
      authorized: {
        staker: toBuffer3(authorized4.staker.toBuffer()),
        withdrawer: toBuffer3(authorized4.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup4.unixTimestamp,
        epoch: lockup4.epoch,
        custodian: toBuffer3(lockup4.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY3,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction3(instructionData);
  }
  static createAccountWithSeed(params) {
    const transaction = new Transaction4;
    transaction.add(SystemProgram3.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized4,
      lockup: lockup4
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized4,
      lockup: lockup4
    }));
  }
  static createAccount(params) {
    const transaction = new Transaction4;
    transaction.add(SystemProgram3.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized4,
      lockup: lockup4
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized4,
      lockup: lockup4
    }));
  }
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS3.Delegate;
    const data = encodeData3(type4);
    return new Transaction4().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS3.Authorize;
    const data = encodeData3(type4, {
      newAuthorized: toBuffer3(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction4().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS3.AuthorizeWithSeed;
    const data = encodeData3(type4, {
      newAuthorized: toBuffer3(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer3(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction4().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS3.Split;
    const data = encodeData3(type4, {
      lamports
    });
    return new TransactionInstruction3({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static split(params, rentExemptReserve) {
    const transaction = new Transaction4;
    transaction.add(SystemProgram3.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: rentExemptReserve,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  static splitWithSeed(params, rentExemptReserve) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed: seed2,
      lamports
    } = params;
    const transaction = new Transaction4;
    transaction.add(SystemProgram3.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed: seed2,
      space: this.space,
      programId: this.programId
    }));
    if (rentExemptReserve && rentExemptReserve > 0) {
      transaction.add(SystemProgram3.transfer({
        fromPubkey: params.authorizedPubkey,
        toPubkey: splitStakePubkey,
        lamports: rentExemptReserve
      }));
    }
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS3.Merge;
    const data = encodeData3(type4);
    return new Transaction4().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS3.Withdraw;
    const data = encodeData3(type4, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY3,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new Transaction4().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type4 = STAKE_INSTRUCTION_LAYOUTS3.Deactivate;
    const data = encodeData3(type4);
    return new Transaction4().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
}
StakeProgram3.programId = new PublicKey3("Stake11111111111111111111111111111111111111");
StakeProgram3.space = 200;
var VOTE_INSTRUCTION_LAYOUTS3 = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), voteInit3()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), publicKey6("newAuthorized"), BufferLayout3.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), BufferLayout3.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout3.struct([BufferLayout3.u32("instruction"), voteAuthorizeWithSeedArgs3()])
  }
});
var VoteAuthorizationLayout3 = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});

class VoteProgram3 {
  constructor() {}
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit4
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS3.InitializeAccount;
    const data = encodeData3(type4, {
      voteInit: {
        nodePubkey: toBuffer3(voteInit4.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer3(voteInit4.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer3(voteInit4.authorizedWithdrawer.toBuffer()),
        commission: voteInit4.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY3,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction3(instructionData);
  }
  static createAccount(params) {
    const transaction = new Transaction4;
    transaction.add(SystemProgram3.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS3.Authorize;
    const data = encodeData3(type4, {
      newAuthorized: toBuffer3(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction4().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS3.AuthorizeWithSeed;
    const data = encodeData3(type4, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer3(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer3(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY3,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction4().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS3.Withdraw;
    const data = encodeData3(type4, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction4().add({
      keys,
      programId: this.programId,
      data
    });
  }
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insufficient funds.");
    }
    return VoteProgram3.withdraw(params);
  }
  static updateValidatorIdentity(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      nodePubkey
    } = params;
    const type4 = VOTE_INSTRUCTION_LAYOUTS3.UpdateValidatorIdentity;
    const data = encodeData3(type4);
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: nodePubkey,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction4().add({
      keys,
      programId: this.programId,
      data
    });
  }
}
VoteProgram3.programId = new PublicKey3("Vote111111111111111111111111111111111111111");
VoteProgram3.space = 3762;
var VALIDATOR_INFO_KEY3 = new PublicKey3("Va1idator1nfo111111111111111111111111111111");
var InfoString3 = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
var VOTE_PROGRAM_ID3 = new PublicKey3("Vote111111111111111111111111111111111111111");
var VoteAccountLayout3 = BufferLayout3.struct([
  publicKey6("nodePubkey"),
  publicKey6("authorizedWithdrawer"),
  BufferLayout3.u8("commission"),
  BufferLayout3.nu64(),
  BufferLayout3.seq(BufferLayout3.struct([BufferLayout3.nu64("slot"), BufferLayout3.u32("confirmationCount")]), BufferLayout3.offset(BufferLayout3.u32(), -8), "votes"),
  BufferLayout3.u8("rootSlotValid"),
  BufferLayout3.nu64("rootSlot"),
  BufferLayout3.nu64(),
  BufferLayout3.seq(BufferLayout3.struct([BufferLayout3.nu64("epoch"), publicKey6("authorizedVoter")]), BufferLayout3.offset(BufferLayout3.u32(), -8), "authorizedVoters"),
  BufferLayout3.struct([BufferLayout3.seq(BufferLayout3.struct([publicKey6("authorizedPubkey"), BufferLayout3.nu64("epochOfLastAuthorizedSwitch"), BufferLayout3.nu64("targetEpoch")]), 32, "buf"), BufferLayout3.nu64("idx"), BufferLayout3.u8("isEmpty")], "priorVoters"),
  BufferLayout3.nu64(),
  BufferLayout3.seq(BufferLayout3.struct([BufferLayout3.nu64("epoch"), BufferLayout3.nu64("credits"), BufferLayout3.nu64("prevCredits")]), BufferLayout3.offset(BufferLayout3.u32(), -8), "epochCredits"),
  BufferLayout3.struct([BufferLayout3.nu64("slot"), BufferLayout3.nu64("timestamp")], "lastTimestamp")
]);

// node_modules/@solana/buffer-layout-utils/lib/esm/web3.mjs
var publicKey8 = (property) => {
  const layout = import_buffer_layout11.blob(32, property);
  const { encode: encode2, decode: decode4 } = encodeDecode2(layout);
  const publicKeyLayout = layout;
  publicKeyLayout.decode = (buffer, offset4) => {
    const src = decode4(buffer, offset4);
    return new PublicKey3(src);
  };
  publicKeyLayout.encode = (publicKey7, buffer, offset4) => {
    const src = publicKey7.toBuffer();
    return encode2(src, buffer, offset4);
  };
  return publicKeyLayout;
};

// node_modules/@solana/spl-token/lib/esm/errors.js
class TokenError2 extends Error {
  constructor(message) {
    super(message);
  }
}
class TokenOwnerOffCurveError2 extends TokenError2 {
  constructor() {
    super(...arguments);
    this.name = "TokenOwnerOffCurveError";
  }
}

// node_modules/@solana/spl-token/lib/esm/state/mint.js
var import_buffer_layout12 = __toESM(require_Layout(), 1);
var MintLayout2 = import_buffer_layout12.struct([
  import_buffer_layout12.u32("mintAuthorityOption"),
  publicKey8("mintAuthority"),
  u646("supply"),
  import_buffer_layout12.u8("decimals"),
  bool("isInitialized"),
  import_buffer_layout12.u32("freezeAuthorityOption"),
  publicKey8("freezeAuthority")
]);
var MINT_SIZE2 = MintLayout2.span;
async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID3, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID2) {
  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))
    throw new TokenOwnerOffCurveError2;
  const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
  return address;
}

// node_modules/@noble/ed25519/index.js
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
var ed25519_CURVE4 = {
  p: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,
  n: 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,
  h: 8n,
  a: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,
  d: 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,
  Gx: 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,
  Gy: 0x6666666666666666666666666666666666666666666666666666666666666658n
};
var { p: P3, n: N3, Gx, Gy, a: _a, d: _d } = ed25519_CURVE4;
var h = 8n;
var L = 32;
var L2 = 64;
var err2 = (m = "") => {
  throw new Error(m);
};
var isBig = (n2) => typeof n2 === "bigint";
var isStr = (s) => typeof s === "string";
var isBytes3 = (a) => a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
var abytes3 = (a, l) => !isBytes3(a) || typeof l === "number" && l > 0 && a.length !== l ? err2("Uint8Array expected") : a;
var u8n2 = (len2) => new Uint8Array(len2);
var u8fr2 = (buf) => Uint8Array.from(buf);
var padh = (n2, pad) => n2.toString(16).padStart(pad, "0");
var bytesToHex4 = (b3) => Array.from(abytes3(b3)).map((e) => padh(e, 2)).join("");
var C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
var _ch = (ch) => {
  if (ch >= C._0 && ch <= C._9)
    return ch - C._0;
  if (ch >= C.A && ch <= C.F)
    return ch - (C.A - 10);
  if (ch >= C.a && ch <= C.f)
    return ch - (C.a - 10);
  return;
};
var hexToBytes4 = (hex) => {
  const e = "hex invalid";
  if (!isStr(hex))
    return err2(e);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    return err2(e);
  const array5 = u8n2(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = _ch(hex.charCodeAt(hi));
    const n2 = _ch(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined)
      return err2(e);
    array5[ai] = n1 * 16 + n2;
  }
  return array5;
};
var toU8 = (a, len2) => abytes3(isStr(a) ? hexToBytes4(a) : u8fr2(abytes3(a)), len2);
var cr = () => globalThis?.crypto;
var subtle = () => cr()?.subtle ?? err2("crypto.subtle must be defined");
var concatBytes5 = (...arrs) => {
  const r = u8n2(arrs.reduce((sum2, a) => sum2 + abytes3(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r.set(a, pad);
    pad += a.length;
  });
  return r;
};
var randomBytes6 = (len2 = L) => {
  const c = cr();
  return c.getRandomValues(u8n2(len2));
};
var big = BigInt;
var arange = (n2, min2, max2, msg = "bad number: out of range") => isBig(n2) && min2 <= n2 && n2 < max2 ? n2 : err2(msg);
var M = (a, b3 = P3) => {
  const r = a % b3;
  return r >= 0n ? r : b3 + r;
};
var modN = (a) => M(a, N3);
var invert5 = (num, md) => {
  if (num === 0n || md <= 0n)
    err2("no inverse n=" + num + " mod=" + md);
  let a = M(num, md), b3 = md, x2 = 0n, y = 1n, u = 1n, v = 0n;
  while (a !== 0n) {
    const q = b3 / a, r = b3 % a;
    const m = x2 - u * q, n2 = y - v * q;
    b3 = a, a = r, x2 = u, y = v, u = m, v = n2;
  }
  return b3 === 1n ? M(x2, md) : err2("no inverse");
};
var apoint = (p) => p instanceof Point2 ? p : err2("Point expected");
var B256 = 2n ** 256n;

class Point2 {
  static BASE;
  static ZERO;
  ex;
  ey;
  ez;
  et;
  constructor(ex, ey, ez, et2) {
    const max2 = B256;
    this.ex = arange(ex, 0n, max2);
    this.ey = arange(ey, 0n, max2);
    this.ez = arange(ez, 1n, max2);
    this.et = arange(et2, 0n, max2);
    Object.freeze(this);
  }
  static fromAffine(p) {
    return new Point2(p.x, p.y, 1n, M(p.x * p.y));
  }
  static fromBytes(hex, zip215 = false) {
    const d = _d;
    const normed = u8fr2(abytes3(hex, L));
    const lastByte = hex[31];
    normed[31] = lastByte & ~128;
    const y = bytesToNumLE(normed);
    const max2 = zip215 ? B256 : P3;
    arange(y, 0n, max2);
    const y2 = M(y * y);
    const u = M(y2 - 1n);
    const v = M(d * y2 + 1n);
    let { isValid, value: x2 } = uvRatio4(u, v);
    if (!isValid)
      err2("bad point: y not sqrt");
    const isXOdd = (x2 & 1n) === 1n;
    const isLastByteOdd = (lastByte & 128) !== 0;
    if (!zip215 && x2 === 0n && isLastByteOdd)
      err2("bad point: x==0, isLastByteOdd");
    if (isLastByteOdd !== isXOdd)
      x2 = M(-x2);
    return new Point2(x2, y, 1n, M(x2 * y));
  }
  assertValidity() {
    const a = _a;
    const d = _d;
    const p = this;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z2, et: T } = p;
    const X2 = M(X * X);
    const Y2 = M(Y * Y);
    const Z22 = M(Z2 * Z2);
    const Z4 = M(Z22 * Z22);
    const aX2 = M(X2 * a);
    const left = M(Z22 * M(aX2 + Y2));
    const right = M(Z4 + M(d * M(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = M(X * Y);
    const ZT = M(Z2 * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return this;
  }
  equals(other) {
    const { ex: X1, ey: Y1, ez: Z1 } = this;
    const { ex: X2, ey: Y2, ez: Z2 } = apoint(other);
    const X1Z2 = M(X1 * Z2);
    const X2Z1 = M(X2 * Z1);
    const Y1Z2 = M(Y1 * Z2);
    const Y2Z1 = M(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  is0() {
    return this.equals(I);
  }
  negate() {
    return new Point2(M(-this.ex), this.ey, this.ez, M(-this.et));
  }
  double() {
    const { ex: X1, ey: Y1, ez: Z1 } = this;
    const a = _a;
    const A = M(X1 * X1);
    const B = M(Y1 * Y1);
    const C2 = M(2n * M(Z1 * Z1));
    const D2 = M(a * A);
    const x1y1 = X1 + Y1;
    const E2 = M(M(x1y1 * x1y1) - A - B);
    const G = D2 + B;
    const F = G - C2;
    const H = D2 - B;
    const X3 = M(E2 * F);
    const Y3 = M(G * H);
    const T32 = M(E2 * H);
    const Z3 = M(F * G);
    return new Point2(X3, Y3, Z3, T32);
  }
  add(other) {
    const { ex: X1, ey: Y1, ez: Z1, et: T13 } = this;
    const { ex: X2, ey: Y2, ez: Z2, et: T22 } = apoint(other);
    const a = _a;
    const d = _d;
    const A = M(X1 * X2);
    const B = M(Y1 * Y2);
    const C2 = M(T13 * d * T22);
    const D2 = M(Z1 * Z2);
    const E2 = M((X1 + Y1) * (X2 + Y2) - A - B);
    const F = M(D2 - C2);
    const G = M(D2 + C2);
    const H = M(B - a * A);
    const X3 = M(E2 * F);
    const Y3 = M(G * H);
    const T32 = M(E2 * H);
    const Z3 = M(F * G);
    return new Point2(X3, Y3, Z3, T32);
  }
  multiply(n2, safe = true) {
    if (!safe && (n2 === 0n || this.is0()))
      return I;
    arange(n2, 1n, N3);
    if (n2 === 1n)
      return this;
    if (this.equals(G))
      return wNAF5(n2).p;
    let p = I;
    let f4 = G;
    for (let d = this;n2 > 0n; d = d.double(), n2 >>= 1n) {
      if (n2 & 1n)
        p = p.add(d);
      else if (safe)
        f4 = f4.add(d);
    }
    return p;
  }
  toAffine() {
    const { ex: x2, ey: y, ez: z } = this;
    if (this.equals(I))
      return { x: 0n, y: 1n };
    const iz = invert5(z, P3);
    if (M(z * iz) !== 1n)
      err2("invalid inverse");
    return { x: M(x2 * iz), y: M(y * iz) };
  }
  toBytes() {
    const { x: x2, y } = this.assertValidity().toAffine();
    const b3 = numTo32bLE(y);
    b3[31] |= x2 & 1n ? 128 : 0;
    return b3;
  }
  toHex() {
    return bytesToHex4(this.toBytes());
  }
  clearCofactor() {
    return this.multiply(big(h), false);
  }
  isSmallOrder() {
    return this.clearCofactor().is0();
  }
  isTorsionFree() {
    let p = this.multiply(N3 / 2n, false).double();
    if (N3 % 2n)
      p = p.add(this);
    return p.is0();
  }
  static fromHex(hex, zip215) {
    return Point2.fromBytes(toU8(hex), zip215);
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  toRawBytes() {
    return this.toBytes();
  }
}
var G = new Point2(Gx, Gy, 1n, M(Gx * Gy));
var I = new Point2(0n, 1n, 1n, 0n);
Point2.BASE = G;
Point2.ZERO = I;
var numTo32bLE = (num) => hexToBytes4(padh(arange(num, 0n, B256), L2)).reverse();
var bytesToNumLE = (b3) => big("0x" + bytesToHex4(u8fr2(abytes3(b3)).reverse()));
var pow26 = (x2, power) => {
  let r = x2;
  while (power-- > 0n) {
    r *= r;
    r %= P3;
  }
  return r;
};
var pow_2_252_3 = (x2) => {
  const x22 = x2 * x2 % P3;
  const b22 = x22 * x2 % P3;
  const b4 = pow26(b22, 2n) * b22 % P3;
  const b5 = pow26(b4, 1n) * x2 % P3;
  const b10 = pow26(b5, 5n) * b5 % P3;
  const b20 = pow26(b10, 10n) * b10 % P3;
  const b40 = pow26(b20, 20n) * b20 % P3;
  const b80 = pow26(b40, 40n) * b40 % P3;
  const b160 = pow26(b80, 80n) * b80 % P3;
  const b240 = pow26(b160, 80n) * b80 % P3;
  const b250 = pow26(b240, 10n) * b10 % P3;
  const pow_p_5_8 = pow26(b250, 2n) * x2 % P3;
  return { pow_p_5_8, b2: b22 };
};
var RM1 = 0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n;
var uvRatio4 = (u, v) => {
  const v33 = M(v * v * v);
  const v7 = M(v33 * v33 * v);
  const pow3 = pow_2_252_3(u * v7).pow_p_5_8;
  let x2 = M(u * v33 * pow3);
  const vx2 = M(v * x2 * x2);
  const root1 = x2;
  const root2 = M(x2 * RM1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === M(-u);
  const noRoot = vx2 === M(-u * RM1);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if ((M(x2) & 1n) === 1n)
    x2 = M(-x2);
  return { isValid: useRoot1 || useRoot2, value: x2 };
};
var modL_LE = (hash2) => modN(bytesToNumLE(hash2));
var sha512a = (...m) => etc.sha512Async(...m);
var hash2extK = (hashed) => {
  const head = hashed.slice(0, L);
  head[0] &= 248;
  head[31] &= 127;
  head[31] |= 64;
  const prefix = hashed.slice(L, L2);
  const scalar = modL_LE(head);
  const point = G.multiply(scalar);
  const pointBytes = point.toBytes();
  return { head, prefix, scalar, point, pointBytes };
};
var getExtendedPublicKeyAsync = (priv) => sha512a(toU8(priv, L)).then(hash2extK);
var hashFinishA = (res) => sha512a(res.hashable).then(res.finish);
var _sign = (e, rBytes, msg) => {
  const { pointBytes: P4, scalar: s } = e;
  const r = modL_LE(rBytes);
  const R = G.multiply(r).toBytes();
  const hashable = concatBytes5(R, P4, msg);
  const finish = (hashed) => {
    const S2 = modN(r + modL_LE(hashed) * s);
    return abytes3(concatBytes5(R, numTo32bLE(S2)), L2);
  };
  return { hashable, finish };
};
var signAsync = async (msg, privKey) => {
  const m = toU8(msg);
  const e = await getExtendedPublicKeyAsync(privKey);
  const rBytes = await sha512a(e.prefix, m);
  return hashFinishA(_sign(e, rBytes, m));
};
var etc = {
  sha512Async: async (...messages2) => {
    const s = subtle();
    const m = concatBytes5(...messages2);
    return u8n2(await s.digest("SHA-512", m.buffer));
  },
  sha512Sync: undefined,
  bytesToHex: bytesToHex4,
  hexToBytes: hexToBytes4,
  concatBytes: concatBytes5,
  mod: M,
  invert: invert5,
  randomBytes: randomBytes6
};
var W = 8;
var scalarBits = 256;
var pwindows = Math.ceil(scalarBits / W) + 1;
var pwindowSize = 2 ** (W - 1);
var precompute = () => {
  const points = [];
  let p = G;
  let b3 = p;
  for (let w2 = 0;w2 < pwindows; w2++) {
    b3 = p;
    points.push(b3);
    for (let i4 = 1;i4 < pwindowSize; i4++) {
      b3 = b3.add(p);
      points.push(b3);
    }
    p = b3.double();
  }
  return points;
};
var Gpows = undefined;
var ctneg = (cnd, p) => {
  const n2 = p.negate();
  return cnd ? n2 : p;
};
var wNAF5 = (n2) => {
  const comp = Gpows || (Gpows = precompute());
  let p = I;
  let f4 = G;
  const pow_2_w = 2 ** W;
  const maxNum = pow_2_w;
  const mask4 = big(pow_2_w - 1);
  const shiftBy = big(W);
  for (let w2 = 0;w2 < pwindows; w2++) {
    let wbits = Number(n2 & mask4);
    n2 >>= shiftBy;
    if (wbits > pwindowSize) {
      wbits -= maxNum;
      n2 += 1n;
    }
    const off = w2 * pwindowSize;
    const offF = off;
    const offP = off + Math.abs(wbits) - 1;
    const isEven = w2 % 2 !== 0;
    const isNeg = wbits < 0;
    if (wbits === 0) {
      f4 = f4.add(ctneg(isEven, comp[offF]));
    } else {
      p = p.add(ctneg(isNeg, comp[offP]));
    }
  }
  return { p, f: f4 };
};

// src/actions.ts
function formatReceiptError(receipt) {
  if (receipt.kind?.case === "err") {
    const err3 = receipt.kind.value;
    return Error2[err3] ?? err3.toString();
  }
  return receipt.kind?.case ?? "unknown";
}
function expectReceiptKind(receipt, expected, action) {
  if (receipt.kind?.case !== expected) {
    const label = formatReceiptError(receipt);
    throw new NordError(`Failed to ${action}: ${label}`);
  }
}
async function sessionSign(signFn, message) {
  const signature = await signFn(message);
  return new Uint8Array([...message, ...signature]);
}
function createAction(currentTimestamp, nonce, kind) {
  return create(ActionSchema, {
    currentTimestamp,
    nonce,
    kind
  });
}
async function sendAction(client, makeSignedMessage, action) {
  const body = await prepareAction(action, makeSignedMessage);
  const response = await client.POST("/action", {
    params: {
      header: {
        "content-type": "application/octet-stream"
      }
    },
    body,
    bodySerializer: (body2) => body2,
    parseAs: "stream"
  });
  if (response.error) {
    throw new Error(`Failed to ${action.kind.case}, HTTP status ${JSON.stringify(response.error)}`);
  }
  const rawResp = new Uint8Array(await response.response.arrayBuffer());
  const resp = decodeLengthDelimited(rawResp, ReceiptSchema);
  if (resp.kind?.case === "err") {
    throw new Error(`Could not execute ${action.kind.case}, reason: ${Error2[resp.kind.value]}`);
  }
  return resp;
}
async function prepareAction(action, makeSignedMessage) {
  const encoded = sizeDelimitedEncode(ActionSchema, action);
  const MAX_ENCODED_ACTION_SIZE = 1024;
  if (encoded.byteLength > MAX_ENCODED_ACTION_SIZE) {
    console.warn("Encoded message:", encoded);
    throw new Error(`Encoded message size (${encoded.byteLength} bytes) is greater than max payload size (${MAX_ENCODED_ACTION_SIZE} bytes).`);
  }
  const body = await makeSignedMessage(encoded);
  if (body.byteLength > MAX_ENCODED_ACTION_SIZE) {
    console.warn("Encoded length:", encoded.byteLength);
    throw new Error(`Signed message size (${body.byteLength} bytes) is greater than max payload size (${MAX_ENCODED_ACTION_SIZE} bytes).`);
  }
  return body;
}
async function createSession(client, signMessage, currentTimestamp, nonce, params) {
  let expiry = 0n;
  if (params.expiryTimestamp !== undefined) {
    expiry = params.expiryTimestamp;
    assert5(expiry > currentTimestamp, "Cannot set expiry timestamp in the past");
  } else {
    expiry = currentTimestamp + SESSION_TTL;
  }
  let signatureFraming;
  let signPayload;
  if ((params.signatureFraming ?? "hex") === "hex") {
    signatureFraming = undefined;
    signPayload = (payload) => signHexEncodedPayload({ payload, signMessage });
  } else if (params.signatureFraming === "solanaTransaction") {
    signatureFraming = 1 /* SOLANA_TRANSACTION */;
    signPayload = (payload) => signSolanaTransactionFramedPayload({
      payload,
      signTransaction: params.signTransactionFn,
      user: params.userPubkey
    });
  } else {
    throw new Error(`invalid framing ${params.signatureFraming}`);
  }
  const action = createAction(currentTimestamp, nonce, {
    case: "createSession",
    value: create(Action_CreateSessionSchema, {
      userPubkey: params.userPubkey.toBytes(),
      sessionPubkey: params.sessionPubkey.toBytes(),
      expiryTimestamp: expiry,
      signatureFraming
    })
  });
  const resp = await sendAction(client, async (payload) => {
    return new Uint8Array([
      ...payload,
      ...await signPayload(payload)
    ]);
  }, action);
  if (resp.kind?.case === "createSessionResult") {
    return {
      actionId: resp.actionId,
      sessionId: resp.kind.value.sessionId
    };
  } else {
    throw new Error(`Unexpected receipt kind ${resp.kind?.case}`);
  }
}
async function revokeSession(client, signMessage, currentTimestamp, nonce, params) {
  const action = createAction(currentTimestamp, nonce, {
    case: "revokeSession",
    value: create(Action_RevokeSessionSchema, {
      sessionId: BigInt(params.sessionId)
    })
  });
  const resp = await sendAction(client, async (payload) => {
    return new Uint8Array([
      ...payload,
      ...await signHexEncodedPayload({
        payload,
        signMessage
      })
    ]);
  }, action);
  return { actionId: resp.actionId };
}
async function atomic(client, signFn, currentTimestamp, nonce, params) {
  assert5(params.actions.length > 0 && params.actions.length <= 4, "Atomic action must contain between 1 and 4 sub-actions");
  const subactions = params.actions.map((a) => {
    if (a.kind === "place") {
      const price = toScaledU64(a.price ?? 0, a.priceDecimals);
      const size = toScaledU64(a.size ?? 0, a.sizeDecimals);
      const scaledQuote = a.quoteSize ? a.quoteSize.toWire(a.priceDecimals, a.sizeDecimals) : undefined;
      assert5(price > 0n || size > 0n || scaledQuote !== undefined, "OrderLimit must include at least one of: size, price, or quoteSize");
      const tradeOrPlace = create(TradeOrPlaceSchema, {
        marketId: a.marketId,
        orderType: create(OrderTypeSchema, {
          side: a.side === "bid" /* Bid */ ? 1 /* BID */ : 0 /* ASK */,
          fillMode: fillModeToProtoFillMode(a.fillMode),
          isReduceOnly: a.isReduceOnly
        }),
        limit: create(OrderLimitSchema, {
          price,
          size,
          quoteSize: scaledQuote === undefined ? undefined : create(QuoteSizeSchema, {
            size: scaledQuote.size,
            price: scaledQuote.price
          })
        }),
        clientOrderId: a.clientOrderId === undefined ? undefined : BigInt(a.clientOrderId)
      });
      return create(AtomicSubactionKindSchema, {
        inner: { case: "tradeOrPlace", value: tradeOrPlace }
      });
    }
    return create(AtomicSubactionKindSchema, {
      inner: {
        case: "cancelOrder",
        value: create(CancelOrderSchema, { orderId: BigInt(a.orderId) })
      }
    });
  });
  const action = createAction(currentTimestamp, nonce, {
    case: "atomic",
    value: create(AtomicSchema, {
      sessionId: BigInt(params.sessionId),
      accountId: params.accountId,
      actions: subactions
    })
  });
  const resp = await sendAction(client, (m) => sessionSign(signFn, m), action);
  if (resp.kind?.case === "atomic") {
    return {
      actionId: resp.actionId,
      results: resp.kind.value.results
    };
  }
  throw new Error(`Unexpected receipt kind ${resp.kind?.case}`);
}

// src/client/NordUser.ts
class NordUser {
  signSessionMessage;
  signMessage;
  signTransaction;
  __use_solana_transaction_framing__ = false;
  nord;
  sessionId;
  sessionPubKey;
  publicKey;
  lastTs = 0;
  nonce = 0;
  balances = {};
  orders = {};
  positions = {};
  margins = {};
  accountIds;
  splTokenInfos = [];
  constructor({
    nord,
    walletPubkey,
    sessionPubkey,
    sessionId,
    signMessageFn,
    signTransactionFn,
    signSessionFn
  }) {
    this.nord = nord;
    this.signSessionMessage = signSessionFn;
    this.signMessage = signMessageFn;
    this.signTransaction = signTransactionFn;
    this.sessionId = sessionId;
    this.sessionPubKey = new PublicKey(sessionPubkey);
    this.publicKey = walletPubkey;
    if (this.nord.tokens && this.nord.tokens.length > 0) {
      this.splTokenInfos = this.nord.tokens.map((token) => ({
        mint: token.mintAddr,
        precision: token.decimals,
        tokenId: token.tokenId,
        name: token.symbol
      }));
    }
  }
  static async new({
    nord,
    walletPubkey,
    sessionPubkey,
    sessionId,
    signMessageFn,
    signTransactionFn,
    signSessionFn
  }) {
    return new NordUser({
      nord,
      walletPubkey,
      sessionPubkey,
      sessionId,
      signMessageFn,
      signTransactionFn,
      signSessionFn
    });
  }
  static fromPrivateKey(nord, privateKey) {
    try {
      const wallet = keypairFromPrivateKey(privateKey);
      const sessionKey = Keypair.generate();
      return new NordUser({
        nord,
        walletPubkey: wallet.publicKey,
        sessionPubkey: sessionKey.publicKey.toBytes(),
        signTransactionFn: async (tx) => {
          tx.sign(wallet);
          return tx;
        },
        signMessageFn: async (xs) => {
          return await signAsync(xs, wallet.secretKey.slice(0, 32));
        },
        signSessionFn: async (xs) => {
          return await signAsync(xs, sessionKey.secretKey.slice(0, 32));
        }
      });
    } catch (error) {
      throw new NordError("Failed to create NordUser from private key", {
        cause: error
      });
    }
  }
  async getAssociatedTokenAccount(mint) {
    try {
      const mintAccount = await this.nord.solanaConnection.getAccountInfo(mint);
      if (!mintAccount) {
        throw new NordError("Mint account not found");
      }
      const tokenProgramId = mintAccount.owner;
      if (!tokenProgramId.equals(TOKEN_PROGRAM_ID3) && !tokenProgramId.equals(TOKEN_2022_PROGRAM_ID2)) {
        throw new NordError("Mint Account is not owned by a supported SPL token program");
      }
      const associatedTokenAddress = await getAssociatedTokenAddress(mint, this.publicKey, false, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID2);
      return associatedTokenAddress;
    } catch (error) {
      throw new NordError("Failed to get associated token account", {
        cause: error
      });
    }
  }
  async depositSpl(amount, tokenId, recipient) {
    return this.deposit({ amount, tokenId, recipient }).then((x2) => x2.signature);
  }
  async deposit({
    amount,
    tokenId,
    recipient,
    sendOptions
  }) {
    try {
      const tokenInfo = this.splTokenInfos.find((t) => t.tokenId === tokenId);
      if (!tokenInfo) {
        throw new NordError(`Token with ID ${tokenId} not found`);
      }
      const mint = new PublicKey(tokenInfo.mint);
      const fromAccount = await this.getAssociatedTokenAccount(mint);
      const payer = this.publicKey;
      const { ix, extraSigner } = await this.nord.protonClient.buildDepositIx({
        payer,
        recipient: recipient ?? payer,
        quantAmount: floatToScaledBigIntLossy(amount, tokenInfo.precision),
        mint,
        sourceTokenAccount: fromAccount
      });
      const { blockhash } = await this.nord.solanaConnection.getLatestBlockhash();
      const tx = new Transaction2;
      tx.add(ix);
      tx.recentBlockhash = blockhash;
      tx.feePayer = payer;
      const signedTx = await this.signTransaction(tx);
      signedTx.partialSign(extraSigner);
      const signature = await this.nord.solanaConnection.sendRawTransaction(signedTx.serialize(), sendOptions);
      return {
        signature,
        buffer: extraSigner.publicKey
      };
    } catch (error) {
      throw new NordError(`Failed to deposit ${amount} of token ID ${tokenId}`, { cause: error });
    }
  }
  getNonce() {
    return ++this.nonce;
  }
  async submitSessionAction(kind) {
    return this.submitSignedAction(kind, async (message) => {
      const signature = await this.signSessionMessage(message);
      const signed2 = new Uint8Array(message.length + signature.length);
      signed2.set(message);
      signed2.set(signature, message.length);
      return signed2;
    });
  }
  async updateAccountId() {
    try {
      if (!this.publicKey) {
        throw new NordError("Public key is required to update account ID");
      }
      const resp = await this.nord.getUser({
        pubkey: this.publicKey.toBase58()
      });
      if (!resp) {
        throw new NordError(`User ${this.publicKey.toBase58()} not found`);
      }
      this.accountIds = resp.accountIds;
    } catch (error) {
      throw new NordError("Failed to update account ID", { cause: error });
    }
  }
  async fetchInfo() {
    if (this.accountIds !== undefined) {
      const accountsData = await Promise.all(this.accountIds.map(async (accountId) => {
        const accountData = await this.nord.getAccount(accountId);
        return {
          ...accountData,
          accountId
        };
      }));
      for (const accountData of accountsData) {
        this.orders[accountData.accountId] = accountData.orders.map((o) => ({
          orderId: o.orderId,
          marketId: o.marketId,
          side: o.side,
          size: o.size,
          price: o.price,
          originalOrderSize: o.originalOrderSize,
          clientOrderId: o.clientOrderId ?? null
        }));
        this.balances[accountData.accountId] = [];
        for (const balance of accountData.balances) {
          this.balances[accountData.accountId].push({
            accountId: accountData.accountId,
            balance: balance.amount,
            symbol: balance.token
          });
        }
        this.positions[accountData.accountId] = accountData.positions.map((p) => ({
          marketId: p.marketId,
          openOrders: p.openOrders,
          actionId: p.actionId,
          ...p.perp != null ? { perp: p.perp } : {}
        }));
        this.margins[accountData.accountId] = accountData.margins;
      }
    }
  }
  async refreshSession() {
    const result = await createSession(this.nord.httpClient, this.signMessage, await this.nord.getTimestamp(), this.getNonce(), {
      userPubkey: this.publicKey,
      sessionPubkey: this.sessionPubKey,
      signatureFraming: this.__use_solana_transaction_framing__ ? "solanaTransaction" : "hex",
      signTransactionFn: this.signTransaction
    });
    this.sessionId = result.sessionId;
  }
  async revokeSession(sessionId) {
    try {
      await revokeSession(this.nord.httpClient, this.signMessage, await this.nord.getTimestamp(), this.getNonce(), {
        sessionId
      });
    } catch (error) {
      throw new NordError(`Failed to revoke session ${sessionId}`, {
        cause: error
      });
    }
  }
  checkSessionValidity() {
    if (this.sessionId === undefined || this.sessionId === BigInt(0)) {
      throw new NordError("Invalid or empty session ID. Please create or refresh your session.");
    }
  }
  async withdraw({
    amount,
    tokenId,
    destPubkey
  }) {
    try {
      this.checkSessionValidity();
      const token = findToken(this.nord.tokens, tokenId);
      const scaledAmount = toScaledU64(amount, token.decimals);
      if (scaledAmount <= 0n) {
        throw new NordError("Withdraw amount must be positive");
      }
      const receipt = await this.submitSessionAction({
        case: "withdraw",
        value: create(Action_WithdrawSchema, {
          sessionId: BigInt(optExpect(this.sessionId, "No session")),
          tokenId,
          amount: scaledAmount,
          destPubkey: destPubkey ? esm_default2.decode(destPubkey) : undefined
        })
      });
      expectReceiptKind(receipt, "withdrawResult", "withdraw");
      return { actionId: receipt.actionId };
    } catch (error) {
      throw new NordError(`Failed to withdraw ${amount} of token ID ${tokenId}`, { cause: error });
    }
  }
  async placeOrder({
    marketId,
    side,
    fillMode,
    isReduceOnly,
    size,
    price,
    quoteSize,
    accountId,
    clientOrderId
  }) {
    try {
      this.checkSessionValidity();
      const market = findMarket(this.nord.markets, marketId);
      if (!market) {
        throw new NordError(`Market with ID ${marketId} not found`);
      }
      const sessionId = optExpect(this.sessionId, "No session");
      const scaledPrice = toScaledU64(price ?? 0, market.priceDecimals);
      const scaledSize = toScaledU64(size ?? 0, market.sizeDecimals);
      const scaledQuote = quoteSize ? quoteSize.toWire(market.priceDecimals, market.sizeDecimals) : undefined;
      assert5(scaledPrice > 0n || scaledSize > 0n || scaledQuote !== undefined, "OrderLimit must include at least one of: size, price, or quoteSize");
      const receipt = await this.submitSessionAction({
        case: "placeOrder",
        value: create(Action_PlaceOrderSchema, {
          sessionId: BigInt(sessionId),
          senderAccountId: accountId,
          marketId,
          side: side === "bid" /* Bid */ ? 1 /* BID */ : 0 /* ASK */,
          fillMode: fillModeToProtoFillMode(fillMode),
          isReduceOnly,
          price: scaledPrice,
          size: scaledSize,
          quoteSize: scaledQuote === undefined ? undefined : create(QuoteSizeSchema, {
            size: scaledQuote.size,
            price: scaledQuote.price
          }),
          clientOrderId: clientOrderId === undefined ? undefined : BigInt(clientOrderId)
        })
      });
      expectReceiptKind(receipt, "placeOrderResult", "place order");
      const result = receipt.kind.value;
      return {
        actionId: receipt.actionId,
        orderId: result.posted?.orderId,
        fills: result.fills
      };
    } catch (error) {
      throw new NordError("Failed to place order", { cause: error });
    }
  }
  async cancelOrder(orderId, accountId) {
    const senderAccountId = accountId != null ? accountId : this.accountIds?.[0];
    try {
      this.checkSessionValidity();
      const receipt = await this.submitSessionAction({
        case: "cancelOrderById",
        value: create(Action_CancelOrderByIdSchema, {
          orderId: BigInt(orderId),
          sessionId: BigInt(optExpect(this.sessionId, "No session")),
          senderAccountId
        })
      });
      expectReceiptKind(receipt, "cancelOrderResult", "cancel order");
      return {
        actionId: receipt.actionId,
        orderId: receipt.kind.value.orderId,
        accountId: receipt.kind.value.accountId
      };
    } catch (error) {
      throw new NordError(`Failed to cancel order ${orderId}`, {
        cause: error
      });
    }
  }
  async cancelOrderByClientId(clientOrderId, accountId) {
    const senderAccountId = accountId != null ? accountId : this.accountIds?.[0];
    try {
      this.checkSessionValidity();
      const receipt = await this.submitSessionAction({
        case: "cancelOrderByClientId",
        value: create(Action_CancelOrderByClientIdSchema, {
          clientOrderId: BigInt(clientOrderId),
          sessionId: BigInt(optExpect(this.sessionId, "No session")),
          senderAccountId
        })
      });
      expectReceiptKind(receipt, "cancelOrderResult", "cancel order by client id");
      return {
        actionId: receipt.actionId,
        orderId: receipt.kind.value.orderId,
        accountId: receipt.kind.value.accountId
      };
    } catch (error) {
      throw new NordError(`Failed to cancel order by client id ${clientOrderId}`, {
        cause: error
      });
    }
  }
  async addTrigger({
    marketId,
    side,
    kind,
    triggerPrice,
    limitPrice,
    accountId
  }) {
    try {
      this.checkSessionValidity();
      const market = findMarket(this.nord.markets, marketId);
      if (!market) {
        throw new NordError(`Market with ID ${marketId} not found`);
      }
      const scaledTriggerPrice = toScaledU64(triggerPrice, market.priceDecimals);
      assert5(scaledTriggerPrice > 0n, "Trigger price must be positive");
      const scaledLimitPrice = limitPrice === undefined ? undefined : toScaledU64(limitPrice, market.priceDecimals);
      if (scaledLimitPrice !== undefined) {
        assert5(scaledLimitPrice > 0n, "Limit price must be positive");
      }
      const key = create(TriggerKeySchema, {
        kind: kind === 0 /* StopLoss */ ? 0 /* STOP_LOSS */ : 1 /* TAKE_PROFIT */,
        side: side === "bid" /* Bid */ ? 1 /* BID */ : 0 /* ASK */
      });
      const prices = create(Action_TriggerPricesSchema, {
        triggerPrice: scaledTriggerPrice,
        limitPrice: scaledLimitPrice
      });
      const receipt = await this.submitSessionAction({
        case: "addTrigger",
        value: create(Action_AddTriggerSchema, {
          sessionId: BigInt(optExpect(this.sessionId, "No session")),
          marketId,
          key,
          prices,
          accountId
        })
      });
      expectReceiptKind(receipt, "triggerAdded", "add trigger");
      return { actionId: receipt.actionId };
    } catch (error) {
      throw new NordError("Failed to add trigger", { cause: error });
    }
  }
  async removeTrigger({
    marketId,
    side,
    kind,
    accountId
  }) {
    try {
      this.checkSessionValidity();
      const market = findMarket(this.nord.markets, marketId);
      if (!market) {
        throw new NordError(`Market with ID ${marketId} not found`);
      }
      const key = create(TriggerKeySchema, {
        kind: kind === 0 /* StopLoss */ ? 0 /* STOP_LOSS */ : 1 /* TAKE_PROFIT */,
        side: side === "bid" /* Bid */ ? 1 /* BID */ : 0 /* ASK */
      });
      const receipt = await this.submitSessionAction({
        case: "removeTrigger",
        value: create(Action_RemoveTriggerSchema, {
          sessionId: BigInt(optExpect(this.sessionId, "No session")),
          marketId,
          key,
          accountId
        })
      });
      expectReceiptKind(receipt, "triggerRemoved", "remove trigger");
      return { actionId: receipt.actionId };
    } catch (error) {
      throw new NordError("Failed to remove trigger", { cause: error });
    }
  }
  async transferToAccount({
    tokenId,
    amount,
    fromAccountId,
    toAccountId
  }) {
    try {
      this.checkSessionValidity();
      const token = findToken(this.nord.tokens, tokenId);
      const scaledAmount = toScaledU64(amount, token.decimals);
      if (scaledAmount <= 0n) {
        throw new NordError("Transfer amount must be positive");
      }
      const receipt = await this.submitSessionAction({
        case: "transfer",
        value: create(Action_TransferSchema, {
          sessionId: BigInt(optExpect(this.sessionId, "No session")),
          fromAccountId: optExpect(fromAccountId, "No source account"),
          toAccountId: optExpect(toAccountId, "No target account"),
          tokenId,
          amount: scaledAmount
        })
      });
      expectReceiptKind(receipt, "transferred", "transfer tokens");
      if (receipt.kind.value.accountCreated) {
        assert5(receipt.kind.value.toUserAccount !== undefined, `toAccount must be defined on new account on ${receipt.kind.value}`);
        return {
          actionId: receipt.actionId,
          newAccountId: receipt.kind.value.toUserAccount
        };
      } else {
        return { actionId: receipt.actionId };
      }
    } catch (error) {
      throw new NordError("Failed to transfer tokens", { cause: error });
    }
  }
  async atomic(userActions, providedAccountId) {
    try {
      this.checkSessionValidity();
      const accountId = providedAccountId != null ? providedAccountId : this.accountIds?.[0];
      if (accountId == null) {
        throw new NordError("Account ID is undefined. Make sure to call updateAccountId() before atomic operations.");
      }
      const apiActions = userActions.map((act) => {
        if (act.kind === "place") {
          const market = findMarket(this.nord.markets, act.marketId);
          if (!market) {
            throw new NordError(`Market ${act.marketId} not found`);
          }
          return {
            kind: "place",
            marketId: act.marketId,
            side: act.side,
            fillMode: act.fillMode,
            isReduceOnly: act.isReduceOnly,
            sizeDecimals: market.sizeDecimals,
            priceDecimals: market.priceDecimals,
            size: act.size,
            price: act.price,
            quoteSize: act.quoteSize,
            clientOrderId: act.clientOrderId
          };
        }
        return {
          kind: "cancel",
          orderId: act.orderId
        };
      });
      const result = await atomic(this.nord.httpClient, this.signSessionMessage, await this.nord.getTimestamp(), this.getNonce(), {
        sessionId: optExpect(this.sessionId, "No session"),
        accountId,
        actions: apiActions
      });
      return result;
    } catch (error) {
      throw new NordError("Atomic operation failed", { cause: error });
    }
  }
  async retryWithBackoff(fn, maxRetries = 3, initialDelay = 500) {
    let retries = 0;
    let delay = initialDelay;
    while (true) {
      try {
        return await fn();
      } catch (error) {
        if (retries >= maxRetries) {
          throw error;
        }
        const isRateLimitError = error instanceof Error && (error.message.includes("rate limit") || error.message.includes("429") || error.message.includes("too many requests"));
        if (!isRateLimitError) {
          throw error;
        }
        retries++;
        await new Promise((resolve) => setTimeout(resolve, delay));
        delay *= 2;
      }
    }
  }
  async getSolanaBalances(options = {}) {
    const {
      includeZeroBalances = true,
      includeTokenAccounts = false,
      maxConcurrent = 5,
      maxRetries = 3
    } = options;
    const balances = {};
    const tokenAccounts = {};
    try {
      const solBalance = await this.retryWithBackoff(() => this.nord.solanaConnection.getBalance(this.publicKey), maxRetries);
      balances["SOL"] = solBalance / 1e9;
      if (includeTokenAccounts) {
        tokenAccounts["SOL"] = this.publicKey.toString();
      }
      if (this.nord.tokens && this.nord.tokens.length > 0) {
        const tokens = this.nord.tokens.filter((token) => !!token.mintAddr);
        for (let i4 = 0;i4 < tokens.length; i4 += maxConcurrent) {
          const batch = tokens.slice(i4, i4 + maxConcurrent);
          const batchPromises = batch.map(async (token) => {
            try {
              const mint = new PublicKey(token.mintAddr);
              const associatedTokenAddress = await this.retryWithBackoff(() => getAssociatedTokenAddress(mint, this.publicKey), maxRetries);
              if (includeTokenAccounts) {
                tokenAccounts[token.symbol] = associatedTokenAddress.toString();
              }
              try {
                const tokenBalance = await this.retryWithBackoff(() => this.nord.solanaConnection.getTokenAccountBalance(associatedTokenAddress), maxRetries);
                const balance = Number(tokenBalance.value.uiAmount);
                if (balance > 0 || includeZeroBalances) {
                  balances[token.symbol] = balance;
                }
              } catch {
                if (includeZeroBalances) {
                  balances[token.symbol] = 0;
                }
              }
            } catch (error) {
              console.error(`Error getting balance for token ${token.symbol}:`, error);
              if (includeZeroBalances) {
                balances[token.symbol] = 0;
              }
            }
          });
          await Promise.all(batchPromises);
        }
      }
      return includeTokenAccounts ? { balances, tokenAccounts } : { balances };
    } catch (error) {
      throw new NordError("Failed to get Solana token balances", {
        cause: error
      });
    }
  }
  async submitSignedAction(kind, makeSignedMessage) {
    const nonce = this.getNonce();
    const currentTimestamp = await this.nord.getTimestamp();
    const action = createAction(currentTimestamp, nonce, kind);
    return sendAction(this.nord.httpClient, makeSignedMessage, action);
  }
}
// src/client/NordAdmin.ts
var AclRole;
((AclRole2) => {
  AclRole2[AclRole2["FEE_MANAGER"] = 1] = "FEE_MANAGER";
  AclRole2[AclRole2["MARKET_MANAGER"] = 2] = "MARKET_MANAGER";
  AclRole2[AclRole2["ADMIN"] = 2147483648] = "ADMIN";
})(AclRole ||= {});

class NordAdmin {
  nord;
  admin;
  signFn;
  constructor({
    nord,
    admin,
    signFn
  }) {
    this.nord = nord;
    this.admin = admin;
    this.signFn = signFn;
  }
  static async new({
    nord,
    admin,
    signFn
  }) {
    return new NordAdmin({
      nord,
      admin,
      signFn
    });
  }
  async submitAction(kind) {
    const timestamp = await this.nord.getTimestamp();
    const action = createAction(timestamp, 0, kind);
    return sendAction(this.nord.httpClient, async (xs) => {
      const signature = await signSolanaTransactionFramedPayload({
        payload: xs,
        user: this.admin,
        signTransaction: this.signFn
      });
      return Uint8Array.from([...xs, ...signature]);
    }, action);
  }
  async updateAcl({
    target,
    addRoles,
    removeRoles
  }) {
    const allRoles = addRoles.concat(removeRoles);
    if (allRoles.length !== new Set(allRoles).size) {
      throw new NordError("duplicate roles in acl update; must be unique");
    }
    let mask4 = 0;
    let values = 0;
    for (const role of allRoles)
      mask4 += role;
    for (const role of addRoles)
      values += role;
    const receipt = await this.submitAction({
      case: "updateAcl",
      value: create(Action_UpdateAclSchema, {
        aclPubkey: this.admin.toBytes(),
        targetPubkey: target.toBytes(),
        rolesValue: values,
        rolesMask: mask4
      })
    });
    expectReceiptKind(receipt, "aclUpdated", "update acl");
    return { ...receipt.kind.value, actionId: receipt.actionId };
  }
  async createToken({
    tokenDecimals,
    weightBps,
    viewSymbol,
    oracleSymbol,
    mintAddr
  }) {
    const receipt = await this.submitAction({
      case: "createToken",
      value: create(Action_CreateTokenSchema, {
        aclPubkey: this.admin.toBytes(),
        tokenDecimals,
        weightBps,
        viewSymbol,
        oracleSymbol,
        solAddr: mintAddr.toBytes()
      })
    });
    expectReceiptKind(receipt, "insertTokenResult", "create token");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async createMarket({
    sizeDecimals,
    priceDecimals,
    imfBps,
    cmfBps,
    mmfBps,
    marketType,
    viewSymbol,
    oracleSymbol,
    baseTokenId
  }) {
    const receipt = await this.submitAction({
      case: "createMarket",
      value: create(Action_CreateMarketSchema, {
        aclPubkey: this.admin.toBytes(),
        sizeDecimals,
        priceDecimals,
        imfBps,
        cmfBps,
        mmfBps,
        marketType,
        viewSymbol,
        oracleSymbol,
        baseTokenId
      })
    });
    expectReceiptKind(receipt, "insertMarketResult", "create market");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async pythSetWormholeGuardians({
    guardianSetIndex,
    addresses
  }) {
    const parsedAddresses = addresses.map((address) => {
      try {
        const decoded = decodeHex(address);
        if (decoded.length !== 20) {
          throw new Error("guardian address must be 20 bytes");
        }
        return decoded;
      } catch (e) {
        throw new NordError("invalid guardian address; must be a 20 byte hex address", { cause: e });
      }
    });
    const receipt = await this.submitAction({
      case: "pythSetWormholeGuardians",
      value: create(Action_PythSetWormholeGuardiansSchema, {
        aclPubkey: this.admin.toBytes(),
        guardianSetIndex,
        addresses: parsedAddresses
      })
    });
    expectReceiptKind(receipt, "updateGuardianSetResult", "update wormhole guardians");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async pythSetSymbolFeed({
    oracleSymbol,
    priceFeedId: priceFeedIdHex
  }) {
    let priceFeedId;
    try {
      priceFeedId = decodeHex(priceFeedIdHex);
      if (priceFeedId.length !== 32) {
        throw new Error("price feed id must be 32 bytes");
      }
    } catch (e) {
      throw new NordError("invalid price feed id; must be a 32 byte hex id", {
        cause: e
      });
    }
    const receipt = await this.submitAction({
      case: "pythSetSymbolFeed",
      value: create(Action_PythSetSymbolFeedSchema, {
        aclPubkey: this.admin.toBytes(),
        oracleSymbol,
        priceFeedId
      })
    });
    expectReceiptKind(receipt, "oracleSymbolFeedResult", "set symbol feed");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async pause() {
    const receipt = await this.submitAction({
      case: "pause",
      value: create(Action_PauseSchema, {
        aclPubkey: this.admin.toBytes()
      })
    });
    expectReceiptKind(receipt, "paused", "pause");
    return { actionId: receipt.actionId };
  }
  async unpause() {
    const receipt = await this.submitAction({
      case: "unpause",
      value: create(Action_UnpauseSchema, {
        aclPubkey: this.admin.toBytes()
      })
    });
    expectReceiptKind(receipt, "unpaused", "unpause");
    return { actionId: receipt.actionId };
  }
  async freezeMarket({
    marketId
  }) {
    const receipt = await this.submitAction({
      case: "freezeMarket",
      value: create(Action_FreezeMarketSchema, {
        marketId,
        aclPubkey: this.admin.toBytes()
      })
    });
    expectReceiptKind(receipt, "marketFreezeUpdated", "freeze market");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async unfreezeMarket({
    marketId
  }) {
    const receipt = await this.submitAction({
      case: "unfreezeMarket",
      value: create(Action_UnfreezeMarketSchema, {
        marketId,
        aclPubkey: this.admin.toBytes()
      })
    });
    expectReceiptKind(receipt, "marketFreezeUpdated", "unfreeze market");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async addFeeTier({
    config: config2
  }) {
    const receipt = await this.submitAction({
      case: "addFeeTier",
      value: create(Action_AddFeeTierSchema, {
        aclPubkey: this.admin.toBytes(),
        config: create(FeeTierConfigSchema, config2)
      })
    });
    expectReceiptKind(receipt, "feeTierAdded", "add fee tier");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async updateFeeTier({
    tierId,
    config: config2
  }) {
    const receipt = await this.submitAction({
      case: "updateFeeTier",
      value: create(Action_UpdateFeeTierSchema, {
        aclPubkey: this.admin.toBytes(),
        id: tierId,
        config: create(FeeTierConfigSchema, config2)
      })
    });
    expectReceiptKind(receipt, "feeTierUpdated", "update fee tier");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async updateAccountsTier(accounts, tierId) {
    const receipt = await this.submitAction({
      case: "updateAccountsTier",
      value: create(Action_UpdateAccountsTierSchema, {
        aclPubkey: this.admin.toBytes(),
        accounts,
        tierId
      })
    });
    expectReceiptKind(receipt, "accountsTierUpdated", "update accounts tier");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
  async feeVaultTransfer({
    recipient,
    tokenId,
    amount
  }) {
    const token = findToken(this.nord.tokens, tokenId);
    const scaledAmount = toScaledU64(amount, token.decimals);
    if (scaledAmount <= 0n) {
      throw new NordError("Transfer amount must be positive");
    }
    const receipt = await this.submitAction({
      case: "feeVaultTransfer",
      value: create(Action_FeeVaultTransferSchema, {
        aclPubkey: this.admin.toBytes(),
        recipient,
        tokenId,
        amount: scaledAmount
      })
    });
    expectReceiptKind(receipt, "feeVaultTransferred", "transfer from fee vault");
    return { actionId: receipt.actionId, ...receipt.kind.value };
  }
}
// src/gen/openapi.ts
var exports_openapi = {};
export {
  toScaledU64,
  toScaledU128,
  signSolanaTransactionFramedPayload,
  signHexEncodedPayload,
  exports_nord_pb as proto,
  panic,
  optExpect,
  exports_openapi as openapi,
  makeWalletSignFn,
  keypairFromPrivateKey,
  isRfc3339,
  initWebSocketClient,
  findToken,
  findMarket,
  fillModeToProtoFillMode,
  decodeLengthDelimited,
  decodeHex,
  checkedFetch,
  assert5 as assert,
  ZERO_DECIMAL,
  WebSocketMessageType,
  WEBSERVER_DEV_URL,
  TriggerStatus,
  TriggerKind2 as TriggerKind,
  Subscriber,
  Side2 as Side,
  SESSION_TTL,
  QuoteSize,
  NordWebSocketClient,
  NordUser,
  NordError,
  NordAdmin,
  Nord,
  MAX_BUFFER_LEN,
  FillMode2 as FillMode,
  DEV_URL,
  DEV_TOKEN_INFOS,
  DEFAULT_FUNDING_AMOUNTS,
  DEBUG_KEYS,
  AclRole
};
